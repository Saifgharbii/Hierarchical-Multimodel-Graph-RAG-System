{
    "document_name": "29573-i50.docx",
    "content": [
        {
            "title": "Foreword",
            "description": "This Technical Specification has been produced by the 3rd Generation Partnership Project (3GPP).\nThe contents of the present document are subject to continuing work within the TSG and may change following formal TSG approval. Should the TSG modify the contents of the present document, it will be re-released by the TSG with an identifying change of release date and an increase in version number as follows:\nVersion x.y.z\nwhere:\nx\tthe first digit:\n1\tpresented to TSG for information;\n2\tpresented to TSG for approval;\n3\tor greater indicates TSG approved document under change control.\ny\tthe second digit is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc.\nz\tthe third digit is incremented when editorial only changes have been incorporated in the document.\nIn the present document, modal verbs have the following meanings:\nshall\tindicates a mandatory requirement to do something\nshall not\tindicates an interdiction (prohibition) to do something\nThe constructions \"shall\" and \"shall not\" are confined to the context of normative provisions, and do not appear in Technical Reports.\nThe constructions \"must\" and \"must not\" are not used as substitutes for \"shall\" and \"shall not\". Their use is avoided insofar as possible, and they are not used in a normative context except in a direct citation from an external, referenced, non-3GPP document, or so as to maintain continuity of style when extending or modifying the provisions of such a referenced document.\nshould\tindicates a recommendation to do something\nshould not\tindicates a recommendation not to do something\nmay\tindicates permission to do something\nneed not\tindicates permission not to do something\nThe construction \"may not\" is ambiguous and is not used in normative elements. The unambiguous constructions \"might not\" or \"shall not\" are used instead, depending upon the meaning intended.\ncan\tindicates that something is possible\ncannot\tindicates that something is impossible\nThe constructions \"can\" and \"cannot\" are not substitutes for \"may\" and \"need not\".\nwill\tindicates that something is certain or expected to happen as a result of action taken by an agency the behaviour of which is outside the scope of the present document\nwill not\tindicates that something is certain or expected not to happen as a result of action taken by an agency the behaviour of which is outside the scope of the present document\nmight\tindicates a likelihood that something will happen as a result of action taken by some agency the behaviour of which is outside the scope of the present document\nmight not\tindicates a likelihood that something will not happen as a result of action taken by some agency the behaviour of which is outside the scope of the present document\nIn addition:\nis\t(or any other verb in the indicative mood) indicates a statement of fact\nis not\t(or any other negative verb in the indicative mood) indicates a statement of fact\nThe constructions \"is\" and \"is not\" do not indicate requirements.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "1\tScope",
            "description": "The present document specifies the stage 3 protocol and data model for the PLMN and/or SNPN interconnection Interface. It provides stage 3 protocol definitions and message flows, and specifies the APIs for the procedures on the PLMN interconnection interface (i.e N32).\nThe 5G System stage 2 architecture and procedures are specified in 3GPP TS 23.501 [2] and 3GPP TS 23.502 [3].\nThe Technical Realization of the Service Based Architecture and the Principles and Guidelines for Services Definition are specified in 3GPP TS 29.500 [4] and 3GPP TS 29.501 [5].\nThe stage 2 level N32 procedures are specified in 3GPP TS 33.501 [6].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "2\tReferences",
            "description": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non-specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\t3GPP TS 23.501: \"System Architecture for the 5G System; Stage 2\".\n[3]\t3GPP TS 23.502: \"Procedures for the 5G System; Stage 2\".\n[4]\t3GPP TS 29.500: \"5G System; Technical Realization of Service Based Architecture; Stage 3\".\n[5]\t3GPP TS 29.501: \"5G System; Principles and Guidelines for Services Definition; Stage 3\".\n[6]\t3GPP TS 33.501: \"Security architecture and procedures for 5G system\".\n[7]\tIETF RFC 9113: \"HTTP/2\".\n[8]\tIETF RFC 8259: \"The JavaScript Object Notation (JSON) Data Interchange Format\".\n[9]\tIETF RFC 9110: \"HTTP Semantics\".\n[10]\tVoid.\n[11]\tIETF RFC 793: \"Transmission Control Protocol\".\n[12]\t3GPP TS 29.571: \"5G System; Common Data Types for Service Based Interfaces Stage 3\".\n[13]\tIETF RFC 7518: \"JSON Web Algorithms (JWA)\".\n[14]\tIETF RFC 7516: \"JSON Web Encryption (JWE)\".\n[15]\tIETF RFC 4648: \"The Base16, Base32, and Base64 Data Encodings\".\n[16]\tIETF RFC 7515: \"JSON Web Signature (JWS)\".\n[17]\tIETF RFC 6901: \"JavaScript Object Notation (JSON) Pointer\".\n[18]\t3GPP TS 29.510: \"Network Function Repository Services; Stage 3\".\n[19]\t3GPP TS 23.003: \"Numbering, addressing and identification\".\n[20]\t3GPP TR 21.900: \"Technical Specification Group working methods\".\n[21]\tIETF RFC 7468: \"Textual Encodings of PKIX, PKCS, and CMS Structures\".\n[22]\tIETF RFC 9457: \"Problem Details for HTTP APIs\".\n[23]\tIETF RFC 1952: \"GZIP file format specification version 4.3\".\n[24]\tVoid\n[25]\t3GPP TS 29.518: \"5G System; Access and Mobility Management Service; Stage 3\".\n[26]\t3GPP TS 29.503: \"5G System; Unified Data Management Services; Stage 3\".\n[27]\tOpenAPI: \"OpenAPI Specification Version 3.0.0\", .\n[28]\t3GPP TS 22.261: \"Service requirements for the 5G system; Stage 1\".\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "3\tDefinitions and abbreviations",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "3.1\tDefinitions",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the terms and definitions given in 3GPP TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [1].\nc-SEPP: The SEPP that is present on the NF service consumer side is called the c-SEPP.\np-SEPP: The SEPP that is present on the NF service producer side is called the p-SEPP.\nNOTE:\tFor the purpose of N32-c procedures, the two interacting SEPPs are called \"initiating\" SEPP and \"responding\" SEPP. The c-SEPP and p-SEPP terminology is not used in this specification though it is used in 3GPP TS 33.501 [6].\nc-IPX: The IPX on the NF service consumer side.\np-IPX: The IPX of the NF service producer side.\nN32-c context: This context is set up at the SEPP after the Security Capability Exchange procedure is finalized. It defines the security capability that is mutually agreed and effective for both the cSEPP and the pSEPP.\nRoaming Intermediary: an entity that provides roaming related services (see clause 3.1 of 3GPP TS 33.501 [6]).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.2\tAbbreviations",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [1].\nGZIP\tGNU ZIP\nIPX\tIP Exchange Service\nJOSE\tJavascript Object Signing and Encryption\nJWE\tJSON Web Encryption\nJWS\tJSON Web Signature\nPRINS\tPRotocol for N32 INterconnect Security\nSEPP\tSecurity and Edge Protection Proxy\nTLS\tTransport Layer Security\nUPU\tUE Parameters Update\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "4\tGeneral Description",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "4.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "This clause provides a general description of the interconnect interfaces used between the PLMNs and/or SNPNs for transporting the service based interface message exchanges.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.2\tN32 Interface",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.2.1\tGeneral",
                            "text_content": "The N32 interface is used between SEPPs of different PLMNs for both roaming and PLMN interconnect scenarios.\nThe N32 interface may also be used between SEPPs from an SNPN and another SNPN or PLMN, for SNPN interconnect scenarios (e.g. for SNPN connectivity with a Credentials Holder network, see clause 5.30.2.9.3 of 3GPP TS 23.501 [2]). Unless specified otherwise, references to \"PLMN\" throughout this specification shall be substituted by \"SNPN\" for a SEPP that is deployed in an SNPN.\nThe SEPP that is on the NF service consumer side is called the c-SEPP and the SEPP that is on the NF service producer is called the p-SEPP. The NF service consumer or SCP may be configured with the c-SEPP or discover the c-SEPP by querying the NRF. The NF service producer or SCP may be configured with the p-SEPP or discover the p-SEPP by querying the NRF.\nThe N32 interface can be logically considered as 2 separate interfaces as given below.\n-\tN32-c, a control plane interface between the SEPPs for performing initial handshake and negotiating the parameters to be applied for the actual N32 message forwarding.\n-\tN32-f, a forwarding interface between the SEPPs which is used for forwarding the communication between the NF service consumer and the NF service producer after applying application level security protection or TLS security protection.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.2\tN32-c Interface",
                            "text_content": "The following figure shows the scope of the N32-c interface.\n\nThe figure depicts a 10Gbps N32-c interface, which is a crucial component in a 10Gbps network. It illustrates the physical structure of the interface, including the connectors, cables, and the network interface controller (NIC). The figure also highlights the importance of proper cable management and the use of cable trays to prevent cable clutter and ensure efficient network performance.\nFigure 4.2.2-1: N32-c Interface\nThe N32-c interface provides the following functionalities:\n-\tInitial handshake procedure between the SEPP in PLMN A (called the initiating SEPP) and the SEPP in PLMN B (called the responding SEPP), that involves capability negotiation and parameter exchange as specified in 3GPP TS 33.501 [6].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.3\tN32-f Interface",
                            "text_content": "The following figures shows the scope of the N32-f interface.\nThe figure depicts a 3GPP N32-f interface with TLS security, illustrating the encryption and authentication protocols used in 3GPP N32-f interfaces. The figure shows the interface with a 3GPP N32-f connector, a 3GPP N32-f cable, and a 3GPP N32-f connector with a 3GPP N32-f cable. The figure also includes a 3GPP N32-f connector with a 3GPP N32-f cable, a 3GPP N32-f connector with a 3GPP N32-f cable, and a 3GPP N32-f connector with a 3GPP N32-f cable. The figure also includes a 3GPP N32-f connector with a 3GPP N32-f cable, a 3GPP N32-f connector with a 3GPP N32-f cable, and a 3GPP N32-f connector with a 3GPP N32-f cable. The figure also includes a 3GPP N\nFigure 4.2.3-1a: N32-f Interface with TLS security\n\nThe figure depicts a 3-1 b interface with PRINS, which is a crucial component in the network. The interface is designed to support the transmission of data over a distance of 100 meters, ensuring reliable and efficient communication.\nFigure 4.2.3-1b: N32-f Interface with PRINS\nThe N32-f interface shall be used to forward the HTTP/2 messages of the NF service producers and the NF service consumers in different PLMN, through the SEPPs of the respective PLMN.\nIf TLS is the negotiated security policy between the SEPP, then the N32-f shall involve only the forwarding of the HTTP/2 messages of the NF service producers and the NF service consumers without any reformatting at the SEPPs and/or the IPXs (see figure 4.2.3-1a).\nThe application layer security protection functionality of the N32-f is used only if the PRotocol for N32 INterconnect Security (PRINS) is negotiated between the SEPPs using N32-c (see figure 4.2.3-1b).\nThe N32-f interface provides the following application layer security protection functionalities:\n-\tMessage protection of the information exchanged between the NF service consumer and the NF service producer across PLMNs by applying application layer security mechanisms as specified in 3GPP TS 33.501 [6].\n-\tForwarding of the application layer protected message from a SEPP in one PLMN to a SEPP in another PLMN. Such forwarding may involve IPX providers on path.\n-\tIf IPX providers are on the path from SEPP in PLMN A to SEPP in PLMN B, the forwarding on the N32-f interface may involve the insertion of content modification instructions which the receiving SEPP applies after verifying the integrity of such modification instructions.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.3\tProtocol Stack",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.3.1\tGeneral",
                            "text_content": "The protocol stack for the N32 interface is shown below in Figure 4.3.1-1.\nThe figure depicts a 3.1 protocol stack, which is a crucial component of the 3GPP 5G standard. It illustrates the various protocols and their respective roles in the 5G network, including the N32 protocol stack, which is responsible for managing the network's signaling and control. The figure also highlights the importance of network slicing and network slicing functions, which are essential for managing and distributing network resources efficiently.\nFigure 4.3.1-1: N32 Protocol Stack\nThe N32 interfaces (N32-c and N32-f) use HTTP/2 protocol (see clause 4.2.2 and 4.2.3, respectively) with JSON (see clause 4.2.4) as the application layer serialization protocol. For the security protection at the transport layer, the SEPPs shall support TLS as specified in clause 13.1.2 of 3GPP TS 33.501 [6].\nFor the N32-f interface, the application layer (i.e the JSON content) encapsulates the complete HTTP/2 message between the NF service consumer and the NF service producer, by transforming the HTTP/2 headers and the body into specific JSON attributes as specified in clause 6.2. For the scenarios when there are IPX entities between SEPPs, see clause 4.3.2 for TLS/PRINS usage.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.2\tHTTP/2 Protocol",
                            "text_content": "HTTP/2 as described in IETF RFC 9113 [7] shall be used for N32 interface.\nThe HTTP request standard headers and the HTTP response standard headers that shall be supported on the N32 interface are defined in Table 4.2.2.2-1 and in Table 4.2.2.2-2 respectively.\nTable 4.3.2.2-1: Mandatory to support HTTP request standard headers\n\nTable 4.3.2.2-2: Mandatory to support HTTP response standard headers\n\nThe HTTP custom headers specified in clause 5.2.3 of 3GPP TS 29.500 [4] shall be supported on the N32 interface.\nEach SEPP initiates HTTP/2 connections towards its peer SEPP for the following purposes\n-\tN32-c interface\n-\tN32-f interface\nThe scope of the HTTP/2 connection used for the N32-c interface is short-lived. Once the initial handshake is completed the connection is torn down as specified in 3GPP TS 33.501 [6]. The HTTP/2 connection used for N32-c is end to end between the SEPPs and does not involve an IPX to intercept the HTTP/2 connection, though an IPX may be involved for IP level routing.\nThe scope of the HTTP/2 connection used for the N32-f interface is long-lived. The N32-f HTTP/2 connection at a SEPP can be:\n-\tCase A: Towards a SEPP of another PLMN without involving any IPX intermediaries or involving IPX intermediaries where IPX does not require modification or observation of the information; or\n-\tCase B: Towards a SEPP of another PLMN via IPX where IPX requires modification or observation of the information. In this case, the HTTP/2 connection from a SEPP terminates at the next hop IPX with the IPX acting as a HTTP proxy.\nFor the N32-f interface the HTTP/2 connection management requirements specified in clause 5.2.6 of 3GPP TS 29.500 [4] shall be applicable. The URI scheme used for the N32-f JOSE protected message forwarding API shall be \"http\". If confidentiality protection of all IEs for the N32-f JOSE protected message forwarding procedure is required, then:\n-\tFor case A, the security between the SEPPs shall be ensured by means of an IPSec or TLS connection;\n-\tFor case B, hop-by-hop security between the SEPP and the IPXs should be established on N32-f. This hop-by-hop security shall be established using an IPSec or TLS connection.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 4.3.2.2-1: Mandatory to support HTTP request standard headers",
                                    "table number": 3,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 4.3.2.2-2: Mandatory to support HTTP response standard headers",
                                    "table number": 4,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "4.3.3\tTransport Protocol",
                            "text_content": "The Transmission Control Protocol as described in IETF RFC 793 [11] shall be used as transport protocol as required by HTTP/2 (see IETF RFC 9113 [7]).\nWhen there is no IPX between the SEPPs or IPX(s) are offering only IP routing service without modification or observation of the content, TLS shall be used for security protection (see clause 13.1.2 of 3GPP TS 33.501 [6]). When there is IPX between the SEPPs and IPX requires modification or observation of the content, TLS or NDS/IP should be used for security protection as specified in clause 13.1.2 of 3GPP TS 33.501 [6].\nNOTE:\tWhen using TCP as the transport protocol, an HTTP/2 connection is mapped to a TCP connection.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.4\tSerialization Protocol",
                            "text_content": "The JavaScript Object Notation (JSON) format as described in IETF RFC 8259 [8] shall be used as the serialization protocol.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "5\tN32 Procedures",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "5.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "The procedures on the N32 interface are split into two categories:\n-\tProcedures that happen end to end between the SEPPs on the N32-c interface;\n-\tProcedures that are used for the forwarding of messages on the service based interface between the NF service consumer and the NF service producer via the SEPP across the N32-f interface.\nTable 5.1-1 summarizes the corresponding APIs defined for this specification.\nTable 5.1-1: API Descriptions\n\n",
                    "tables": [
                        {
                            "description": "Table 5.1-1: API Descriptions",
                            "table number": 5,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "5.2\tN32 Handshake Procedures (N32-c)",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.2.1\tGeneral",
                            "text_content": "The N32 handshake procedure is used between the SEPPs in two PLMNs to mutually authenticate each other and negotiate the security mechanism to use over N32-f along with associated security configuration parameters.\nA HTTP/2 connection shall be established between the initiating SEPP and the responding SEPP end to end over TLS. The following N32 handshake procedures are specified in the clauses below.\n-\tSecurity Capability Negotiation Procedure\n-\tParameter Exchange Procedure\n-\tN32-f Context Termination Procedure\n-\tN32-f Error Reporting Procedure\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.2\tSecurity Capability Negotiation Procedure",
                            "text_content": "The initiating SEPP shall initiate a Security Capability Negotiation procedure towards the responding SEPP to agree on a security mechanism to use for protecting NF service related signalling over N32-f. An end to end TLS connection shall be setup between the SEPPs before the initiation of this procedure. This procedure may also be used to tear down the N32-f TLS connection if the remote SEPP indicated support of the feature NFTLST during the setup of the N32-c connection. The procedure is described in Figure 5.2.2-1 below.\n\nThe figure depicts a security capability negotiation procedure, illustrating the steps taken by the network to ensure secure communication. It includes the negotiation process, the negotiation process, and the negotiation process, with the negotiation process being the most important part. The negotiation process is crucial for ensuring that the network can securely communicate with other networks, as it involves the negotiation of security capabilities between the network and the other network. The negotiation process is a complex process that involves the negotiation of security capabilities, such as encryption, authentication, and authorization, to ensure that the network can securely communicate with other networks.\nFigure 5.2.2-1: Security Capability Negotiation Procedure\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"SecNegotiateReqData\" IE carrying the following information:\n-\tSupported security capabilities (i.e., PRINS and/or TLS);\n-\tWhether the 3gpp-Sbi-Target-apiRoot HTTP header is supported, if TLS security is supported;\n-\tSender PLMN ID(s) or SNPN ID(s);\n-\tTarget PLMN ID or SNPN ID;\n-\tPurpose of the intended usage of N32 connection.\n-\tThe senderN32fFqdn IE, if the initiating SEPP wishes the responding SEPP to establish the N32-f connection towards a specific FQDN (of the initiating SEPP).\n-\tThe senderN32fPortList IE, if the initiating SEPP wishes the responding SEPP to establish the N32-f connection using a specific port number. When present, the list shall contain one port number per supported security capability (i.e., PRINS and/or TLS).\nIf different PLMNs or SNPNs are represented by different PLMN IDs or SNPN IDs (respectively) supported by a SEPP, then the SEPP shall use separate N32-connections for each pair of local and remote PLMN or SNPN. Both SEPPs shall store the mapping between the N32 connections and their pair of PLMN IDs or SNPN IDs.\nNOTE 1:\tIf SEPPs support separate FQDN per PLMN or SNPN, then Target PLMN Id or Target SNPN Id is not required as target PLMN or SNPN can be selected by the FQDN.\nTo tear down the N32-f connection when negotiated security scheme is TLS, the \"SecNegotiateReqData\" IE shall contain:\n-\tSupported security capability set to \"NONE\"\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains \"SecNegotiateRspData\" IE carrying the following information:\n-\tSelected security capability (i.e., PRINS or TLS);\n-\tWhether the 3gpp-Sbi-Target-apiRoot HTTP header is supported, if TLS security is selected;\n-\tSender PLMN ID(s) or SNPN ID(s).\n-\tPurpose of the accepted usage of N32 connection.\n-\tThe senderN32fFqdn IE, if the responding SEPP wishes the initiating SEPP to establish the N32-f connection towards a specific FQDN (of the responding SEPP).\n-\tThe senderN32fPort IE, if the responding SEPP wishes the initiating SEPP to establish the N32-f connection using a specific port number.\nNOTE 2:\tSame SEPP endpoints can serve all accepted purposes over the same N32-f connection established as the result of request/response messages.\nThe responding SEPP compares the initiating SEPP's supported security capabilities to its own supported security capabilities and selects, based on its local policy, a security mechanism, which is supported by both the SEPPs. If the selected security capability indicates any other capability other than PRINS, then the HTTP/2 connection initiated between the two SEPPs for the N32 handshake procedures shall be terminated. The negotiated security capability shall be applicable on both the directions. If the selected security capability is PRINS, then the two SEPPs may decide to create (if not available) / maintain HTTP/2 connection(s) where each SEPP acts as a client towards the other (which acts as a server). This may be used for later signalling of N32-f error reporting procedure (see clause 5.2.5) and N32-f context termination procedure (see clause 5.2.4).\nIf different PLMNs or SNPNs are represented by different PLMN IDs or SNPN IDs (respectively) supported by a SEPP, then the SEPP shall use separate N32-connections for each pair of local and remote PLMN or SNPN. Both SEPPs shall store the mapping between the N32 connections and their pair of PLMN IDs or SNPN IDs.\nThe SEPP shall select the PLMN or SNPN from the list of supported PLMN(s) or SNPN(s) based on the received Target PLMN ID or SNPN ID, or based on PLMN or SNPN specific FQDN used in the request, and provide the selected PLMN's PLMN Id(s) in the plmnIdList or the selected SNPN's SNPN Id(s) in the snpnIdList.\nIn case no purposes are exchanged, the receiving SEPP shall assume by default that purposes are for Roaming and inter-PLMN mobility as described in clause 6.1.5.3.9.\nThe initiating SEPP and/or responding SEPP may enable the establishment of an N32 connection for the purpose of Disaster Roaming only during disaster conditions.\nWhen the request is for tearing down the existing N32-f TLS connection, the \"SecNegotiateRspData\" IE shall contain:\n-\tSupported security capability set to \"NONE\"\nand, subsequently, both SEPP shall terminate the N32-c and N32-f TLS connection.\nIf the initiating SEPP receives the senderN32fFqdn IE and/or the senderN32fPort IE from the responding SEPP, the initiating SEPP shall establish the N32-f connection towards the responding SEPP using the received N32-f FQDN and/or the senderN32fPort IE.\nIf the responding SEPP receives the senderN32fFqdn IE and/or the senderN32fPortList IE from the initiating SEPP, the responding SEPP shall establish the N32-f connection towards the initiating SEPP using the received N32-f FQDN and/or the N32-f port number received in the senderN32fPortList IE corresponding to the selected security capability (i.e., TLS or PRINS).\nIf the N32-f context exists between the peer SEPPs, and the N32 exchange capability request is not for tearing down the N32-f connections, the responding SEPP shall:\n-\tstop sending any further messages over the N32-f towards the initiating SEPP;\n-\tdelete the current N32-f context and terminate any N32-f connection with the initiating SEPP; and\n-\tprocess the received exchange capability request.\n2b.\tOn failure or redirection, the responding SEPP shall respond to the initiating SEPP with an appropriate status code as specified in clause 6.1.4.2.\nIf the responding SEPP has sent an outgoing Security Capability Negotiation request to the initiating SEPP, the responding SEPP shall compare the FQDN of the initiating SEPP that has been received in the incoming Security Capability Negotiation request message with the FQDN of the responding SEPP that has been sent in the outgoing Security Capability Negotiation request. If the responding SEPP's FQDN lexicographically precedes, it shall reject the incoming HTTP request message with the cause \"N32C_EXCHANGE_CAPABILITY_ONGOING\" and it shall continue with its initiated procedure and vice versa.\nEXAMPLE: assuming SEPP A's FQDN is \"sepp.5gc.mnc345.mcc012.3gppnetwork.org\" and SEPP B's FQDN is \"sepp.5gc.mnc346.mcc012.3gppnetwork.org\", then SEPP A's FQDN precedes SEPP B's FQDN and SEPP A proceeds with its exchange capability procedure.\nA SEPP may be configured to accept an HTTP request from a given PLMN and not to send an HTTP request for exchange capability towards that PLMN.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.3\tParameter Exchange Procedure",
                            "text_content": "The parameter exchange procedure shall be executed if the security capability negotiation procedure selected the security capability as PRINS. The parameter exchange procedure is performed to:\n-\tAgree on a cipher suite to use for protecting NF service related signalling over N32-f; and\n-\tOptionally, exchange the protection policies to use for protecting NF service related signalling over N32.\nThe parameter exchange procedure for cipher suite negotiation shall be performed after the security capability negotiation procedure if the selected security policy is PRINS. If there is a change in the cipher suite and the SEPP wants to renegotiate it, then the SEPP may reuse the parameter exchange procedure to override what was exchanged before.\nThe procedure is described in Figure 5.2.3.2-1 below.\n\n\nThe figure depicts a diagram illustrating the process of parameter exchange and procedure for cipher suite negotiation in a communication system. It shows the steps involved in exchanging cipher suites between the sender and receiver, including the negotiation process and the resulting cipher suite. The figure is a visual representation of the complex process, making it easier to understand and follow.\nFigure 5.2.3.2-1: Parameter Exchange Procedure for Cipher Suite Negotiation\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"SecParamExchReqData\" IE carrying the following information\n-\tSupported cipher suites;\nThe supported cipher suites shall be an ordered list with the cipher suites mandated by 3GPP TS 33.501 [6] appearing at the top of the list.\nThe initiating SEPP also provides a N32-f context identifier for the responding SEPP to use towards the initiating SEPP for subsequent JOSE Protected Message Forwarding procedures over N32-f (see clause 5.3.3) when the responding SEPP acts as the forwarding SEPP.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains the following information\n-\tSelected cipher suite\nThe responding SEPP compares the initiating SEPP's supported cipher suites to its own supported cipher suites and selects, based on its local policy, a cipher suite, which is supported by both the SEPPs. The responding SEPP's supported cipher suites shall be an ordered list with the cipher suites mandated by 3GPP TS 33.501 [6] appearing at the top of the list. The selected cipher suite is applicable for both the directions of communication between the SEPPs.\nThe responding SEPP also provides a N32-f context identifier for the initiating SEPP to use towards the responding SEPP for subsequent JOSE Protected Message Forwarding procedures over N32-f (see clause 5.3.3) when the initiating SEPP acts as the forwarding SEPP.\nIf the receiving SEPP already has a previously negotiated cipher suite, the SEPP shall overwrite it with the new one.\n2b.\tOn failure, the responding p-SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code as specified in clause 6.1.4.3. If the SEPP already has a previously negotiated cipher suite, the SEPP shall continue to use the same.\nNOTE :\tIf a SEPP already has a previously negotiated cipher suite and a new cipher suite is also received, the SEPP starts applying the new cipher suite immediately and also continues with the old cipher suite for a limited time period. This allows messages with old policies to be completed gracefully.\nIf the initiating SEPP receives a security parameter exchange request from the responding SEPP before receiving a response for its request (i.e security parameter exchange procedure collision), the initiating SEPP shall compare its FQDN that was sent in its request with the FQDN of the responding SEPP that is received in the security parameter exchange request message. If the initiating SEPP's FQDN lexicographically precedes, it shall reject the incoming HTTP request message with the cause \"SECURITY_PARAM_EXCHANGE_COLLISION\" and it shall continue with its initiated procedure and vice versa.\nEXAMPLE:\tAssuming SEPP A's FQDN is \"sepp.5gc.mnc345.mcc012.3gppnetwork.org\" and SEPP B's FQDN is \"sepp.5gc.mnc346.mcc012.3gppnetwork.org\", then SEPP A's FQDN precedes SEPP B's FQDN and SEPP A proceeds with its security parameter exchange procedure.\nThe parameter exchange procedure for protection policy exchange may be performed after the Parameter Exchange Procedure for Cipher Suite Negotiation (see clause 5.2.3.2). If a HTTP/2 connection does not exist towards the peer SEPP at the time of initiating this procedure, the HTTP/2 connection shall be established. If there is a change in the protection policy exchange and the SEPP wants to renegotiate it, then the SEPP may reuse the parameter exchange procedure for the protection policy exchange to override what was exchanged before. If the parameter exchange procedure for the protection policy exchange is not performed then the protection policies between the SEPP shall be exchanged out of bands.\nThe procedure is described in Figure 5.2.3.3-1 below.\n\n\nThe figure depicts a parameter exchange procedure for protection policy exchange in a network. It illustrates the steps involved in exchanging protection policies between network devices, ensuring the security and integrity of the network.\nFigure 5.2.3.3-1: Parameter Exchange Procedure for Protection Policy Exchange\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"SecParamExchReqData\" IE carrying the following information\n-\tProtection policy information\nThe protection policy information contains:\n-\tAPI to IE mapping containing the mapping information of list of leaf IEs for each:\n-\tRequest/response and Subscribe / Unsubscribe service operation, identified by the API URI and method; and/or\n-\tCallbacks (e.g Notification service operation), identified by the value of the 3GPP custom HTTP header \"3gpp-Sbi-Callback\" (see clause 5.2.3 of 3GPP TS 29.500 [4]).\n-\tList of IE types that are to be protected across N32-f (i.e the data type encryption policy as specified in clause 13.2.3.2 of 3GPP TS 33.501 [6]); and\n-\tModification policy: Against each leaf IE in the API to IE mapping information, a boolean flag indicating whether that IE is allowed to be modified by an IPX on the side of the SEPP sending the protection policy information.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains the following information\n-\tSelected protection policy information\nThe Selected protection policy information contains the IEs allowed to be modified by an IPX on the side of the responding SEPP. If the responding SEPP connects to several IPXs, an isModifiable IE may be included to indicate an IE is allowed to be modified by all IPX(s) or an map type of isModifiableByIpx IE may be included to indicate an IE is allowed to be modified by an IPX identified by the key of ipxProviderId IE if this IE is allowed to be modified by some of (but not all) the IPX(s), as specified in clause 13.2.3.4 of 3GPP TS 33.501 [6].\nThe initiating SEPP shall store the modification policy which are sent from responding SEPP in selected protection policy information and the responding SEPP shall store the modification policy which are sent from the initiating SEPP in the protection policy information. The SEPP receving the subsequent message transfers over N32-f shall check whether the modifications performed by the IPXs were permitted by the respective modification policy.\nThe SEPPs shall store the encryption policy in selected protection policy information and shall apply this policy for subsequent message transfers over N32-f. The encryption policy in selected protection policy is applicable for both the directions of communication between the SEPPs.\nIf the receiving SEPP already has a previously negotiated protection policy information, the SEPP shall overwrite it with the new one.\nThe HTTP/2 connection used for the N32 handshake procedures may be terminated after the completion of this procedure.\n2b.\tOn failure, the responding SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code as specified in clause 6.1.4.3. If the SEPP already has previously negotiated protection policy information, the SEPP shall continue to use the same.\nNOTE :\tIf a SEPP already has a previously negotiated cipher suite and a new cipher suite is also received, the SEPP starts applying the new cipher suite immediately and also continues with the old cipher suite for a limited time period. This allows messages with old policies to be completed gracefully.\n\nAn illustration of how the protection policy is stored and looked up in the SEPP is provided in figure 5.2.3.3-2\nThe figure depicts a protection policy storage and lookup system in SEPP, which is a key component of the SEPP architecture. The system is designed to ensure the integrity and availability of data in the network. It includes a storage area network (SAN) and a lookup table, which are essential for managing and retrieving data in the network. The figure shows the layout of the storage and lookup areas, as well as the connections between them. The system is designed to be fault-tolerant and to provide a high level of security, ensuring that data is protected and can be retrieved in the event of a failure.\nFigure 5.2.3.3-2: Protection Policy Storage and Lookup in SEPP\nDuring the N32-f message forwarding, the SEPP looks at a HTTP request or response it receives from an NF service consumer or NF service producer and then uses the above tables to decide which IEs and headers in the message it shall cipher and integrity protect and which IEs it shall allow the IPXes to modify.\nThe initiating SEPP shall initiate a Security Information list exchange procedure towards the responding SEPP to exchange the Security Information lists that contain information on IPX public keys or certificates that are needed to verify IPX modifications at the receiving SEPP as specified in clause 13.2.2.2 of 3GPP TS 33.501 [6]. If there is a change in the security information list and the SEPP wants to renegotiate it, then the SEPP may reuse the parameter exchange procedure for the security information list exchange to override what was exchanged before.\nThe procedure is described in Figure 5.2.3.4-1 below.\n\n\nThe figure depicts a procedure for exchanging security information lists in a network security architecture. It illustrates the steps involved in exchanging security information lists, including the exchange of parameters, the exchange of security information lists, and the exchange of security information lists.\nFigure 5.2.3.4-1: Parameter Exchange Procedure for Security Information List exchange\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"SecParamExchReqData\" IE carrying the following information:\n-\tIPX provider identifier connected to the initiating SEPP;\n-\tList of raw public keys or certificates for that IPX.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains the \"SecParamExchRspData\" IE carrying the following information:\n-\tIPX provider identifier connected to the responding SEPP;\n-\tList of raw public keys or certificates for that IPX.\nIf the receiving SEPP already has a previously negotiated security information list, the SEPP shall overwrite it with the new one.\n2b.\tOn failure, the responding SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code as specified in clause 6.1.4.3. If the SEPP already has previously negotiated security information list, the SEPP shall continue to use the same.\nNOTE :\tIf a SEPP already has a previously negotiated cipher suite and a new cipher suite is also received, the SEPP starts applying the new cipher suite immediately and also continues with the old cipher suite for a limited time period. This allows messages with old policies to be completed gracefully.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.4\tN32-f Context Termination Procedure",
                            "text_content": "After the completion of the security capability negotiation procedure and/or the parameter exchange procedures, an N32-f context is established between the two SEPPs. The \"n32fContextId\" of each SEPP is provided to the other SEPP. This context identifier shall be stored in each SEPP until the context is explicitly terminated by the N32-f context termination procedure. The SEPP that is initiating the N32-f context termination procedure shall use the HTTP method POST on the URI: {apiRoot}/n32c-handshake/<apiVersion>/n32f-terminate. If a HTTP/2 connection does not exist towards the receiving SEPP, a HTTP/2 connection shall be created before initiating this procedure. The procedure is shown below in Figure 5.2.4-1.\n\nThe figure depicts the context termination procedure for the N32f context in a 5G network. It illustrates the steps involved in terminating the context, including the use of context-aware routing, context-aware forwarding, and context-aware forwarding. The figure also highlights the importance of context-aware routing in ensuring efficient communication in a 5G network.\nFigure 5.2.4-1: N32f Context Termination Procedure\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the N32-f context id information that is to be terminated.\n2a.\tOn success, the responding SEPP, shall:\n-\tstop sending any further messages over the N32-f towards the initiating SEPP;\n-\tonce all the ongoing N32-f message exchanges with the initiating SEPP are completed or timed out, delete the N32-f context identified by the \"n32fContextId\" provided in the request.\nThe N32-f HTTP/2 connections from the responding SEPP shall not be deleted if they terminate at an IPX, since that HTTP/2 connection may carry traffic towards other PLMN SEPPs as well. The responding SEPP shall return the status code \"200 OK\" together with an N32ContextInfo content that carries the \"n32fContextId\" of the initiating SEPP that the responding SEPP has stored.\nThe initiating SEPP shall:\n-\tstop sending any further messages over the N32-f towards the responding SEPP;\n-\tonce all the ongoing N32-f message exchanges with the responding SEPP are completed or timed out, delete the local N32-f context identified by this \"n32fContextId\".\nIf the initiating SEPP receives a N32-f termination request from the responding SEPP before receiving a response for its request (i.e N32-f Context Termination Procedure collision), the initiating SEPP shall process the received N32-f termination request from the responding SEPP and shall return the status code \"200 OK\" together with an N32ContextInfo content that carries the \"n32fContextId\" of the responding SEPP that the initiating SEPP has stored. The initiating SEPP shall behave as specified above without waiting for a response from the responding SEPP for its N32-f Context Termination request.\n2b.\tOn failure, the responding SEPP shall return an appropriate 4xx/5xx status code together with the \"ProblemDetails\" JSON body.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.5\tN32-f Error Reporting Procedure",
                            "text_content": "When a SEPP is not able to process a message it received over the N32-f interface due to errors, the error information is conveyed to the sending SEPP by using the N32-f error reporting procedure over the N32-c interface. The SEPP that is initiating the N32-f error reporting procedure shall use the HTTP method POST on the URI: {apiRoot}/n32c-handshake/<apiVersion>/n32f-error. If a HTTP/2 connection does not exist towards the receiving SEPP, a HTTP/2 connection shall be created before initiating this procedure. The procedure is shown below in Figure 5.2.5-1.\n\nThe figure depicts a 5-1 N32f error reporting procedure, which is a crucial component of the 5G network. It illustrates the steps taken to identify and report errors in the network, ensuring that the network remains stable and reliable. The figure includes a flowchart, which outlines the sequence of actions to be taken when an error occurs. This helps in maintaining the quality of service and preventing disruptions to the network.\nFigure 5.2.5-1: N32f Error Reporting Procedure\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the N32-f error information that is to be reported.\n2a.\tOn success, the responding SEPP, shall:\n-\tlog that the N32-f request / response message identified by the \"n32fMessageId\" is not processed by the receiving SEPP;\nThe responding SEPP shall return the status code \"204 No Content\".\n2b.\tOn failure, the responding SEPP shall return an appropriate 4xx/5xx status code together with the \"ProblemDetails\" JSON body.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.3\tMessage Forwarding Procedure on N32 (N32-f)",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.3.1\tIntroduction",
                            "text_content": "The N32-f interface is used between two SEPPs for:\n-\tThe forwarding of JOSE protected HTTP/2 messages between the NF service consumer and the NF service producer across two PLMNs, when PRINS is the negotiated security policy. The message forwarding on N32-f shall be based on the negotiated security capability and the exchanged security parameters between the two SEPPs (see clause 5.2).\n-\tForwarding of the HTTP/2 messages between the NF service consumer and the NF service producer without any reformatting and application layer protection, when TLS is the negotiated security policy.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.2\tUse of Application Layer Security",
                            "text_content": "If the negotiated security capability between the two SEPPs is PRINS, one or more HTTP/2 connections between the two SEPPs for the forwarding of JOSE protected message shall be established, which may involve IPX providers on path. The forwarding of messages over the N32-f interface involves the following steps at the sending SEPP:\n1.\tIdentification of the protection policy applicable for the API being invoked (i.e either a request/response NF service API or a subscribe/unsubscribe service API or a notification API).\n2.\tMessage reformatting as per the identified protection policy.\n3.\tForwarding of the reformatted message over the N32 interface.\nThe processing of a message received over the N32-f interface at the receiving IPX provider involves the following steps:\n1.\tApply the modifications in the \"modificationsBlock\" appended by the sending IPX provider as JSON patches in the DataToIntegrityProtectBlock (from the decoded \"aad\" part), if the \"modificationsBlock\" is received in the message.\n2.\tDetermine further modifications required based on modification policy and insert the modification entries in \"modificationsBlock\".\n3.\tForwarding the received message with the above inserted modification entries in \"modificationsBlock\" over the N32 interface.\nThe processing of a message received over the N32-f interface at the receiving SEPP involves the following steps.\n1.\tIdentify the N32-f context using the N32-f context Id received in the message.\n2.\tVerify the integrity protection of the message using the keying material obtained from the TLS layer during the parameter exchange procedure for that N32-f context (see 3GPP TS 33.501 [6]). The TLS connection from which the keying material is obtained is the N32-c TLS connection used for the parameter exchange procedure.\n3.\tDecrypt the ciphertext part of the received JWE message. Decode the \"aad\" part of the JWE message using BASE64URL decoding.\n4.\tFor each entry in the \"modificationsBlock\" of the received message:\n-\tFirst verify the integity protection of that entry using the keying material applicable for the IPX that inserted that block (using the \"identity\" IE in the \"modificationsBlock\");\n-\tIdentify the modifications policy exchanged during the parameter exchange procedure with the sending SEPP if the IPX that inserted the modificationsBlock is from the sending SEPP side; else identify the modifications policy applicable for the IPX based on local configuration;\n-\tCheck if the inserted modifications are as per the identified modifications policy;\n-\tApply the modifications as a JSON patch in the DataToIntegrityProtectBlock (from the decoded \"aad\" part).\n5.\tForm the original JSON request / response body from the decrypted ciphertext and the decoded integrity verified \"aad\" block possibly modified as described in step 4.\n6.\tIf the reconstructed HTTP message has an \"Authorization\" header, then the SEPP shall check whether the service consumer's PLMN ID or SNPN ID is present in the Bearer token contained in the Authorization header (see 3GPP TS 29.510 [18], clause 6.3.5.2.4) and if it matches with the \"Remote PLMN ID\" or \"Remote SNPN ID\" of the N32-f context. If they do not match, the SEPP shall respond to the sending SEPP with \"403 Forbidden\" status code with the application specific cause set as \"PLMNID_MISMATCH\" or \"SNPNID_MISMATCH\".\nNOTE 1:\tIn this case, the N32-f Error Reporting procedure specified in clause 5.2.5 is not used since the processing of the complete N32-f message fails at the receiving SEPP.\nNOTE 2:\tIf the service consumer's PLMN ID or SNPN ID is present in the reconstructed HTTP message, then the receiving SEPP compares this with the sending SEPP's PLMN ID or SNPN ID, which is retrieved from N32f Context (see clause 5.9.3 in 3GPP TS 33.501 [6]). See the above step 6 for the receiving SEPP behaviour. If the service consumer's PLMN ID and SNPN ID are not present, the comparison is not done.\nSEPPs and IPX should support gzip coding (see IETF RFC 1952 [23]) in HTTP requests and responses and indicate so in the Accept-Encoding header, as described in clause 6.9 of 3GPP TS 29.500 [4] and clause 6.2.2.2.3.\nWhen a SEPP receives a HTTP/2 request or response message intended to be routed towards another PLMN, the sending SEPP shall identify the protection policy as given below\n1.\tIdentify the target PLMN from the \":aurthority\" part of the message using the format specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\n2.\tCheck if the incoming HTTP/2 message has the \"3gpp-Sbi-Callback\" header. When present, the SEPP shall select the data encryption and modification policy applicable for the specific notification type, identified by the value of the \"3gpp-Sbi-Callback\" header and the target PLMN, using the notification type list stored as specified in subclase 5.2.3.3.\n3.\tElse, if it is a HTTP/2 request message, then from the \":authority\" and \":path\" part of the received HTTP/2 request message, form the API URI. For the identified PLMN, check if a protection policy exists for the API URI using the table stored as specified in clause 5.2.3.3.\n4.\tElse, if it is a HTTP/2 response message, then based on the HTTP/2 stream ID on which the response is received, identify the corresponding request that was sent by the SEPP and the protection policy applicable for that request, as specified in step 3.\n5.\tIf an entry is not found, then it means that either the particular API has no protection policy exchanged.\nOnce a protection policy is identified, the SEPP shall apply the application layer security as per the identified protection policy.\nA SEPP on the sending side PLMN applies message reformatting in the following cases:\n-\tWhen it receives a HTTP/2 request message from an NF service consumer to a an NF service producer in another PLMN;\n-\tWhen it receives a response HTTP/2 response message from an NF service producer to an NF service consumer in another PLMN.\n-\tWhen it receives a HTTP/2 notification request message from an NF service producer to an NF service consumer in another PLMN;\n-\tWhen it receives a HTTP/2 notification response message from an NF service consumer to an NF service producer in another PLMN\nThe SEPP shall reformat the HTTP/2 message by encapsulating the whole message into the body of a new HTTP POST message. The body of the HTTP POST request / response message shall contain the reformatted original HTTP/2 request/response message respectively. The HTTP POST request/response body shall be encoded as the \"N32fReformattedReqMsg\"/\"N32fReformattedRspMsg\" JSON bodies respectively, as specified in clause 6.2.5.\nThe \"N32fReformattedReqMsg\"/\"N32fReformattedRspMsg\" are structured as given below:\nThe figure depicts a JSON representation of a reformatted HTTP message, illustrating the structure and content of the message.\nFigure 5.3.2.3-1 JSON representation of a reformatted HTTP message\n\nThe \"cipherText\" part of the reformatted message in FlatJweJson shall be prepared as given below\nThe figure depicts the transformation of HTTP headers and content into ciphertext, illustrating the encryption process.\nFigure 5.3.2.3-2 Transformation of HTTP Header and Content to Encrypt into CipherText\n1.\tBased on the protection policy exchanged between the SEPPs, the sending SEPP prepares an input for the JWE ciphering and integrity protection as an array of arbitrary types in the \"DataToIntegrityProtectAndCipher\" block with each entry containing either a HTTP header value or the value of a JSON payload IE of the API message being reformatted. The index value \"encBlockIdx\" in the contentpart of DataToIntegrityProtectBlock shall point to the index of a header value or IE value in this input array.\n2.\tThe input block is fed into an encryption function along with the other required inputs for JWE as specified in IETF RFC 7516 [14].\n3.\tThe encryption function outputs the cipher text information. This cipher text is then subjected to BASE64URL transformation as specified in IETF RFC 4648 [15] clause 5.\n4. The output of the BASE64URL transform is them encoded as the ciphertext part of FlatJweJson IE specified in clause 6.2.5.2.11.\nOnce a SEPP reformats the HTTP/2 message into the \"N32ReformattedReqMsg\"/\"N32ReformattedRspMsg\" JSON object as specified in clause 5.3.2, the SEPP forwards the message to the receiving SEPP by invoking a HTTP POST method as shown in figure 5.3.2.4-1 below.\n\nThe figure depicts a message forwarding mechanism between two SEPPs on the N32-f network. The message is forwarded from the source SEPP to the destination SEPP, with the destination SEPP being the one responsible for processing the message. The figure shows the routing path, including the source SEPP, the destination SEPP, and the intermediate SEPPs. The figure also includes the message header and the routing table, which provides information about the path and the destination of the message.\nFigure 5.3.2.4-1 Message Forwarding between SEPP on N32-f\n1.\tThe initiating SEPP issues a HTTP POST request towards the responding SEPP with the request body containing the \"N32ReformattedReqMsg\" IE carrying the reformatted HTTP/2 message. The request message shall contain the \"n32fContextId\" information provided by the responding SEPP to the initiating SEPP earlier during the parameter exchange procedure (see clause 5.2.3). The responding SEPP shall use the \"n32fContextId\" information to:\n-\tLocate the agreed cipher suite and protection policy;\n-\tLocate the n32ContextId to be used in the response.\nIf the HTTP request/response message to be forwarded over N32-f includes an 3gpp-Sbi-Message-Priority header, the initiating/responding SEPP should additionally insert a 3gpp-Sbi-Message-Priority header in the N32-f message with the same contents as the 3gpp-Sbi-Message-Priority header encoded within the \"N32ReformattedReqMsg\"/ N32ReformattedRspMsg IE respectively.\nNOTE 1:\tReplicating the information in a N32-f message header enables the receiving SEPP to determine the priority of the forwarded HTTP request/response without having to parse the N32-f message content.\nThe HTTP request content may be compressed hop by hop over N32-f, if the initiating SEPP or IPX and its next hop (IPX or SEPP) support gzip coding (see IETF RFC 1952 [23]).\n2a.\tOn successful processing of the request, the responding SEPP shall:\n-\tdecompress the N32-f HTTP request content, if it is compressed;\n-\treconstruct the HTTP/2 message towards the NF service producer;\n-\tcompress the reconstructed HTTP request if the reconstructed HTTP content contains a Content-Encoding header indicating gzip compression;\n-\tforward the reconstructed HTTP/2 message to the NF service producer;\n-\twait for the response from the NF service producer; and then\n-\tonce the response from the NF service producer is received, respond to the initiating SEPP with a \"200 OK\" status code and a POST response body that contains the \"N32ReformattedRspMsg\". The \"N32ReformattedRspMsg\" shall contain the reformatted HTTP response message from the responding PLMN. The response message shall contain the \"n32fContextId\" information provided by the initiating SEPP to the responding SEPP earlier during the parameter exchange procedure (see clause 5.2.3).\nNOTE 2:\tFor unsuccessful processing of the request with \"PLMNID_MISMATCH\", see clause 5.3.2.1.\nThe responding SEPP shall be able to map the response received from the NF service producer to the HTTP/2 stream ID for the corresponding response it needs to generate towards the initiating SEPP. The HTTP/2 stream ID and the HTTP/2 connection information on either side shall be used to derive this mapping.\nThe HTTP response content may be compressed hop by hop over N32-f, if the responding SEPP or IPX and its next hop (IPX or SEPP) support gzip coding (see IETF RFC 1952 [23]).\n2b.\tOn failure or unsuccessful processing of the request, the responding SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code, the message body shall contain a ProblemDetails structure with the \"cause\" attribute set to one of the application error as specified in clause 6.2.4.2. The \"cause\" attribute shall be set to \"UNSPECIFIED\", if the responding SEPP fails to process the reconstructed message, and the error is reported by N32f error reporting procedure as specified in clause 5.2.5.\nThe JOSE Protected Forwarding Options is used by the sending SEPP or IPX to discover the communication options supported by its next hop (IPX or SEPP) for N32-f message processing.\n\nThe figure depicts a procedure for the discovery of communication options supported by the next hop, illustrating the steps involved in selecting the most suitable communication method for a given communication scenario.\nFigure 5.3.2.5-1: Procedure for the discovery of communication options supported by the next hop\n1.\tThe sending SEPP or IPX shall send an OPTIONS request to discover the communication options supported by its next hop (IPX or SEPP) for N32-f message processing.\n2.\tIf the request is accepted, the next hop (IPX or SEPP) shall respond with the status code 204 No Content and include an Accept-Encoding header (as described in IETF RFC 9110 [24]).\nOn failure, the next hop shall return one of the HTTP status code listed in Table 6.2.4.3.2.1-3.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.3\tMessage Forwarding to Peer SEPP when TLS is used",
                            "text_content": "When the negotiated security policy between the SEPPs is TLS, then the procedures described in clause 5.3.2 shall not be applied. Messages shall be forwarded to the peer SEPP as specified in clause 6.1.4.3.4 of 3GPP TS 29.500 [4].\nOn failure or unsuccessful processing of the incoming N32-f request, the responding SEPP shall respond to the initiating SEPP with an appropriate 4xx/5xx status code including a ProblemDetails structure with the \"cause\" attribute set to one of the following application errors as specified in Table 5.3.3-1.\nTable 5.3.3-1: Protocol and application errors generated by SEPP\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.3.3-1: Protocol and application errors generated by SEPP",
                                    "table number": 6,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.3.4\tVoid",
                            "text_content": "\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.4\tNsepp_Telescopic_FQDN_Mapping Service",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.4.1\tGeneral",
                            "text_content": "The Nsepp_Telescopic_FQDN_Mapping service is used between any Network Function and the SEPPs in the same PLMN, if TLS protection between the Network Function and the SEPP relies on using telescopic FQDN. See clause 28.5.2 of 3GPP TS 23.003 [19] and clause 6.1.4.3 of 3GPP TS 29.500 [4]) for the definition and use of Telescopic FQDN.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.4.2\tForeign FQDN to Telescopic FQDN Mapping Procedure",
                            "text_content": "This procedure is initiated by an NF Service Consumer (typically an NRF or an NSSF) that needs to interact with a NF in a foreign PLMN (typically the corresponding NRF or NSSF), and to do so, it needs to build a telescopic FQDN of said NF (i.e. concatenation of the FQDN of the foreign FQDN, and the FQDN of the local SEPP), and then the resulting telescopic FQDN needs to be \"flattened\" (i.e. the FQDN of the NF in the foreign PLMN needs to be converted to a singel label). The procedure is described in Figure 5.4.2-1 below.\n\nThe figure depicts a step-by-step procedure for mapping foreign FQDNs to Telescopic FQDNs in a network. It illustrates the process of converting a foreign FQDN into a Telescopic FQDN, which is a more efficient method for network management. The figure includes a step-by-step guide, with arrows indicating the sequence of actions, and a legend to clarify the terminology used.\nFigure 5.4.2-1: Foreign FQDN to Telescopic FQDN Mapping Procedure\n1.\tThe NF Service Consumer issues an HTTP GET request towards the local SEPP with a query parameter \"foreign-fqdn\" containing the FQDN of the NF in the foreign PLMN, that needs to be transformed into a flattened telescopic FQDN.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the NF Service Consumer with a \"200 OK\" status code and a response body that contains a JSON object of type \"TelescopicMapping\", containing as attributes the label to be used as first label in the telescopic FQDN, and the domain of the local SEPP to be appended after such first label. The resulting FQDN shall be used by the NF Consumer to setup a TLS session terminated in the local SEPP, where the SEPP shall present a server certificate with a wildcard domain matching the returned telescopic FQDN.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.4.3\tTelescopic FQDN to Foreign FQDN Mapping Procedure",
                            "text_content": "This procedure is initiated by an NF Service Consumer (typically another SEPP) that has received a service request with an unknown first label of a telescopic FQDN. Typically, this SEPP may interact with other SEPPs in the same PLMN in order to determine if there is an existing mapping for a given label to an FQDN of a foreign FQDN; this procedure is only expected to be used when multiple SEPPs are deployed in a PLMN. The procedure is described in Figure 5.4.3-1 below.\n\nThe given telecommunication figure, labeled as \"Figure 5,\" depicts a step-by-step procedure for mapping foreign FQDNs to Telescopic FQDNs. The figure illustrates the process of converting a foreign FQDN into a Telescopic FQDN, which is a method used in network management to simplify the management of multiple network domains. The figure includes a step-by-step guide, with each step labeled and accompanied by a corresponding diagram, to ensure clarity and ease of understanding.\nFigure 5.4.3-1: Foreign FQDN to Telescopic FQDN Mapping Procedure\n1.\tThe NF Service Consumer issues an HTTP GET request towards another SEPP with a query parameter \"telescopic-label\" containing the first label of a given telescopic FQDN, whose mapping towards an FQDN of an NF in a foreign PLMN needs to be verified.\n2a.\tOn successful processing of the request, the responding SEPP shall respond to the NF Service Consumer with a \"200 OK\" status code and a response body that contains a JSON object of type \"TelescopicMapping\", containing as attribute \"foreignFqdn\", containing the FQDN of the NF in the foreign PLMN.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.5\tSupport of Roaming Intermediaries",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.5.1\tGeneral",
                            "text_content": "Roaming services providers provide the technical and commercial means to facilitate the deployment and operation of roaming services between a client operator and a set of selected connected operators (see clause 6.45 of 3GPP TS 22.261 [28]).\nThe communication between two SEPPs may go via up to two Roaming Intermediaries. The changes made by Roaming Intermediaries to messages originated by a SEPP, based on the originating PLMNs policy, shall be identifiable by the receiving SEPP.\nEditor’s notes: How to send error over N32-c in case the errors are relevant for the Roaming intermediaries and delivery over N32-f failed is FFS.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.5.2\tN32-c connection establishment via Roaming Intermediaries",
                            "text_content": "This clause specifies the requirements that apply in scenarios where a PLMN SEPP makes use of Roaming Intermediaries and support messages generated by Roaming Intermediaries as specified in clause 5.9.3.2a of 3GPP TS 33.501 [6].\nEditor's note: this clause will describe requirements regarding the establishment of the N32-c connection via one or two Roaming Intermediaries, using the HTTP CONNECT method.\nEditor's note: Details about the HTTP CONNECT procedures are FFS.\nEditor's note: It is FFS how a Roaming Intermediary identifies the source PLMN in the HTTP CONNECT request.\nThe Roaming Intermediary may reject an N32-c connection establishment request by rejecting the HTTP CONNECT request.\nThe following error scenarios are supported and further detailed in the following clauses.\n1)\tErrors determined upon receipt of the HTTP CONNECT request\nExamples: Roaming Intermediary rejecting an HTTP CONNECT request due to:\n-\tthe N32-c connection cannot be setup due to contractual reasons;\n-\tthe N32-c connection cannot be setup due to a connectivity issue.\nEditor's note: Details about error handling are FFS.\nFigure 5.5.2.2.2-1: N32-c connection establishment rejection by Roaming Intermediaries\n1.\tThe cSEPP shall use HTTP CONNECT to send the HTTP message to the pSEPP.\n2.\tThe Roaming Intermediary determines that an N32 connection shall not to be established e.g. due to contractual reasons. The Roaming Intermediary shall return an HTTP error response, e.g. \"403 forbidden\" response with the ProblemDetails providing details on the N32 related error for the c-SEPP.\nEditor's note: The details of related API definitions are FFS.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.5.3\tN32-f messages forwarding or origination via Roaming Intermediaries",
                            "text_content": "Error messages may be originated from either PLMN SEPPs or Roaming Hubs to adjacent Roaming Hubs or adjacent PLMN SEPPs, in an identifiable way. Furthermore, if allowed by the PLMN policy, the SEPP shall be able to send error messages on the N32 interface to a roaming hub via the N32-f. See clause 5.9.3.2 of 3GPP TS 33.501 [6]).\nThe following error scenarios are supported and further detailed in the following clauses.\n1)\tN32-f related error determined upon receipt of an N32-f request\nExamples: Roaming Intermediary rejecting an N32-f request due to:\n-\tthe N32-f connection cannot be setup due to contractual reasons;\n-\tthe N32-f connection cannot be setup due to a connectivity issue;\n-\tincompatible encryption/plain information in the request (e.g. an IE is encrypted while it was expected in clear);\n-\tN32-f request not delivered due contractual reasons.\n2)\tN32-f related error determined upon receipt of an N32-f response\nExample:\n-\tincompatible encryption/plain information in the N32-f response (e.g. an IE is encrypted while it was expected in clear).\n3)\tApplicative (i.e. SBI related) error determined upon receipt of an N32-f request\nExample:\n-\tRoaming Intermediary rejecting a UE Registration on behalf of the involved PLMNs based on roaming agreements.\n\nEditor’s Note: It is left FFS how to handle the applicative errors for termination of session and deregistration of the UE by the Roaming Intermediary based on roaming agreements.\nThe given telecommunication figure depicts a network error message originating from a roaming intermediary via N32-f. The figure shows a network topology with various components such as base stations (gNB), user equipment (UE), and scatterers. The diagram highlights the importance of error management and failover mechanisms in ensuring network reliability.\nFigure 5.5.3.2.1-1: Error message originated by Roaming Intermediary via N32-f\n1.\tThe cSEPP receives a service request (HTTP request) message from cNF.\n2.\tThe cSEPP sends an N32-f request using PRINS security (i.e. JOSE protected message) to forward the service request message to the pSEPP.\n3.\tThe Roaming Intermediary detects an N32-f related error and returns an N32-f error response, e.g. \"403 Forbidden\" response, with the ProblemDetails data providing details on the N32-f related error for the cSEPP. If the error is due to an encryption policy mismatch, the ProblemDetails may include the invalidParams attribute indicating which IEs were received ciphered when they were expected to be received in clear, and vice-versa. The N32-f error response may additionally contain a suggested status code (e.g. \"504 Gateway Timeout\") and a suggested application error (e.g. \"TARGET_PLMN_NOT_REACHABLE\") that the Roaming Intermediary suggests the cSEPP to forward in the error response to the cNF, if the cSEPP cannot or does not attempt to re-send the N32-f request taking into account the N32-f error information.\n4.\tIf the cSEPP cannot or does not attempt to re-send the N32-f request taking into account the N32-f error information, the cSEPP sends an error response to the cNF. The cSEPP may use the suggested status code and/or suggested application error for the error response sent to the cNF (e.g. the cSEPP may send a \"504 Gateway timeout\" response with the cause \"TARGET_PLMN_NOT_REACHABLE\" in the ProblemDetails).\n5. \tAlternatively, the cSEPP may re-send the N32-f request taking into account the N32-f error information that was received from the Roaming Intermediary. For instance, if the cSEPP receives an error message with the application error \"POLICY_MISMATCH\", the cSEPP may change the data type encryption policy to 'Parameter shall be encrypted' or 'Parameter shall not be encrypted', if this is allowed by local policies, and if necessary, re-negotiate the data type encryption policy with the peer SEPP. After that, the cSEPP may re-send the N32-f Request based on the updated data type encryption policy to the Roaming Intermediary.\n6-9.\tThe rest of procedures are processed accordingly.\nThe given telecommunication figure depicts a 5G network signal path, illustrating the multi-path signal propagation in a 5G network. The figure includes key components such as the base station (gNB), user equipment (UE), and scatterers. It highlights beamforming techniques to mitigate interference and shows the fiber-optic backbone architecture with core switches, optical line terminals (OLTs), and distributed nodes. The layered design aligns with SDN principles.\nFigure 5.5.3.2.2-1: Error message originated by pSEPP via N32-f (and optionally N32-c)\n1. \tThe cSEPP receives a service request (HTTP request) message from cNF.\n2.\tThe cSEPP sends an N32-f request using PRINS security (i.e. JOSE protected message) to forward the service request message to the pSEPP.\n3.\tThe pSEPP detects an N32-f related error and returns an N32-f error response, e.g. \"403 Forbidden\" response, with the ProblemDetails data providing details on the N32-f related error for the cSEPP. If the error is due to an encryption policy mismatch, the ProblemDetails may include the invalidParams attribute indicating which IEs were received ciphered when they were expected to be received in clear, and vice-versa. The N32-f error response may additionally contain a suggested status code (e.g. \"504 Gateway Timeout\") and a suggested application error (e.g. \"TARGET_PLMN_NOT_REACHABLE\") that the pSEPP suggests the cSEPP to forward in the error response to the cNF, if the cSEPP cannot or does not attempt to re-send the N32-f request taking into account the N32-f error information.\n4.\tThe pSEPP may also send an N32-c request (HTTP POST request) towards the cSEPP with the content containing the N32-f error information that is to be reported (see clause 5.2.5).\n5.\tThe cSEPP shall return the status code \"204 No Content\" as the response to the N32-f Error Reporting. (see clause 5.2.5)\n6.\tIf the cSEPP cannot or does not attempt to re-send the N32-f request taking into account the N32-f error information, the cSEPP sends an error response to the cNF. The cSEPP may use the suggested status code and/or suggested application error for the error response to the cNF (e.g. the cSEPP may send a\"504 Gateway timeout\" response with the cause \"TARGET_PLMN_NOT_REACHABLE\" in the ProblemDetails).\n7.\tAlternatively, the cSEPP may re-send the N32-f request taking into account the N32-f error information that was received from the pSEPP. For instance, if the cSEPP receives an error message with the application error \"POLICY_MISMATCH\", the cSEPP may change the data type encryption policy to 'Parameter shall be encrypted' or 'Parameter shall not be encrypted', if this is allowed by local policies, and if necessary, re-negotiate the data type encryption policy with the peer SEPP. After that, the cSEPP may re-send the N32-f Request based on the updated data type encryption policy to the Roaming Intermediary.\n8-11.\tThe rest of procedures are processed accordingly.\nThe procedure below describes the situation in which Roaming Intermediary B detects an error in the response.\nThe given telecommunication figure depicts a network error message originating from a roaming intermediary via N32 -f Response. The figure shows a network error message with a specific error code and a response from the roaming intermediary. The message indicates that the error occurred due to a network issue, and the response from the roaming intermediary provides a solution to the problem.\nFigure 5.5.3.3.1-1: Error message originated by Roaming Intermediary via N32-f Response\n1.\tThe cSEPP receives a service request (HTTP request) message from cNF.\n2.\tThe cSEPP sends an N32-f request using PRINS security (i.e. JOSE protected message) to forward the service request message to the pSEPP.\n3.\tThe pSEPP send the service request to the pNF (see clause 5.3.2.3)\n4.\tThe pNF returns the service response (e.g. 200 OK response) to the pSEPP.\n5.\tThe pSEPP encapsulates the service reponse in an N32-f response (i.e. JOSE protected message) and forwards the message to the cSEPP (see clause 5.3.2.3).\n6-8.\tAs the Roaming Intermediary B detects an N32-f related error (e.g. an IE is received ciphered while it should be in clear), depending on the Roaming Intermediary’s policy, the Roaming Intermdiary B may forward the response message (200 OK) encapsulating the service response to the cSEPP and the cSEPP sends the Service Response to the cNF.\nNOTE:\tIn case the Roaming Intermediary decides not to forward the response message to cSEPP, NF consumers and NF producers can end up with de-synchronized status in case of a non-safe/idempotent operation. Mechanisms specified for 5GC SBI can be used for handling such situation (e.g. to detect the re-transmitted request).\n9.\tThe Roaming Intermediary B sends a new N32-f request encapsulating an N32-c \"N32-f Error Reporting request\" towards pSEPP to report the error, as specified in clause 5.5.3.3.2.\n10.\tThe pSEPP returns \"204 No Content\" to the Roaming Intermediary B.\n11.\tThe pSEPP logs the error and, if possible and allowed by local policies, considers it for further N32-f messages the pSEPP sends towards the cSEPP (e.g. the pSEPP may send the reported IE in clear in further messages it forwards towards the cSEPP).\n12.\tThe cNF may repeat its service request in case no response is being received from the cSEPP.\n13.\tThe cSEPP forwards the (repeated) service request from the cNF, if any. Alternatively, the cSEPP may resend its N32-f request to the pSEPP due to no response being received from the pSEPP.\n14.\tThe pSEPP forwards the service request towards the pNF.\n15.\tThe pNF returns the service response (e.g. 200 OK response).\n16.\tThe cSEPP encapsulates the service reponse in an N32-f response (i.e. JOSE protected message) and forwards the message to the cSEPP, taking into account any error information earlier received from the cSEPP or Roaming Intermediary, if possible and allowed by local policies (so e.g. with the IE previously reported in error in clear).\n17.\tThe cSEPP send the service response to the cNF.\nThe procedure is identical if the Roaming Intermediary A detects an error.\nIf a Roaming Intermediary needs to generate an N32-f related error message upon receiving an N32-f response, the Roaming Intermediary shall construct a new N32-f request as defined in clause 5.3.2.3 for a SEPP with the following modifications:\n-\tthe DataToIntegrityProtectBlock (see Table 6.2.5.2.2-1) shall only contain the MetaData with the N32fContextId and messageId of the N32-f response message for which an error was detected.\n-\tthe patch instructions in the modificationBlock (see Table 6.2.5.2.2-1) shall be based on an  DataToIntegrityProtectBlock only containing the MetaData with the N32fContextId and messageId.\n-\tthe modifications in the \"modificationsBlock\" shall result in encoding a N32-c request for N32-f Error Reporting, i.e. it shall contain patch instructions:\n-\tadding the requestLine to form an HTTP POST request \"{n32c-apiRoot}/n32c-handshake/v1/n32f-error\";\n-\tadding headers, if applicable; and\n-\tadding the payload that shall be the content of the N32-f Error Reporting Request, i.e N32fErrorInfo.\nEditor's note: It is FFS how the Roaming Intermediary sets / knows the apiRoot of the N32-c Handshake API of the pSEPP.\n-\tthe modificationBlock shall contain the JWS signature of the Roaming Intermediary.\nEditor's note: The definition of the error message and related data types are FFS.\nThe Roaming Intermediary shall then send its N32-f request towards the pSEPP, possibly via another intermediate Roaming Intermediary.\nEditor's note: Further details on how to format the N32-f request for error reporting are FFS.\nFigure 5.5.3.4.1-1: Applicative (i.e. SBI related) error originated by Roaming Intermediary via N32-f\n1.\tThe c-SEPP receives a service request (HTTP request) message from cNF.\n2.\tThe c-SEPP sends an N32-f request using PRINS security (i.e. JOSE protected message) to forward the service request message to the p-SEPP.\n3.\tThe Roaming Intermediary detects an applicative error within the service request encapsulated in the N32-f request, e.g. the UE registration needs to be rejected on behalf of the involved PLMNs. The Roaming Intermediary responds back with a successful N32-f response encapsulating a service error response instead of forwarding the N32-f request to the p-SEPP, as defined in clause 5.5.3.2.\n4.\tThe c-SEPP forwards the service error response towards the cNF.\nIf a Roaming Intermediary needs to generate a service error message upon receiving an N32-f request, the Roaming Intermediary shall construct a service error response (to be sent within a successful N32-f response) as defined in clause 5.3.2.3 for a SEPP with the following modifications:\n-\tthe DataToIntegrityProtectBlock (see Table 6.2.5.2.2-1) shall only contain metadata with N32-f message ID and N32-f context ID;\n-\tthe patch instructions in the modificationBlock (see Table 6.2.5.2.2-1) shall be based on an intermediary originated DataToIntegrityProtectBlock.\n-\tthe modifications in the \"modificationsBlock\" shall result in encoding the service error response, i.e. it shall contain patch instructions;\n-\tadding the statusLine to form the desired service error response (e.g. 403 Forbidden response);\n-\tadding SBI headers, if applicable; and\n-\tadding the payload that shall be the content of the service error response (e.g. ProblemDetails with the reason why the registration request is rejected)\n-\tthe modificationBlock shall contain the JWS signature of the Roaming Intermediary.\nEditor's note: The definition of the error message and related data types are FFS.\nThe Roaming Intermediary shall then send its N32-f response towards the c-SEPP, possibly via another intermediate Roaming Intermediary, encapsulating the service error response.\nEditor's note: Further details on how to format the service error response are FFS.\nEditor's note: Roaming Intermediary originated error message e.g. to terminate a session is FFS.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "6\tAPI Definitions",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "6.1\tN32 Handshake API",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.1.1\tAPI URI",
                            "text_content": "The N32 Handshake Procedures shall use the N32 Handshake API.\nThe API URI of the N32 Handshake API shall be:\n{apiRoot}/<apiName>/<apiVersion>\nThe request URIs used in HTTP requests from the initiating SEPP towards the responding SEPP shall have the Resource URI structure defined in clause 4.4.1 of 3GPP TS 29.501 [5], i.e.:\n{apiRoot}/<apiName>/<apiVersion>/<apiSpecificResourceUriPart>\nwith the following components:\n-\tThe {apiRoot} shall be set as described in 3GPP TS 29.501 [5].\n-\tThe <apiName> shall be \"n32c-handshake\".\n-\tThe <apiVersion> shall be \"v1\".\n-\tThe <apiSpecificResourceUriPart> shall be set as described in clause 6.1.4.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.1.2\tUsage of HTTP",
                            "text_content": "HTTP/2, as defined in IETF RFC 9113 [7], shall be used as specified in clause 4.3.2.1.\nHTTP/2 shall be transported as specified in clause 4.3.3.\nHTTP messages and bodies for the N32 handshake API shall comply with the OpenAPI [27] specification contained in Annex A.\nThe HTTP standard headers as specified in clause 4.3.2.2 shall be supported for this API.\nThe following content types shall be supported:\n-\tthe JSON format (see IETF RFC 8259 [8]). The use of the JSON format shall be signalled by the content type \"application/json\". See also clause 5.3.4.\n-\tthe Problem Details JSON Object (see IETF RFC 9457 [22]). The use of the Problem Details JSON object in a HTTP response body shall be signalled by the content type \"application/problem+json\".\nIn this release of the specification, no specific custom headers are defined for the N32 handshake API.\nFor 3GPP specific HTTP custom headers used across all service based interfaces, see clause 4.3.2.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.1.3\tResources",
                            "text_content": "There are no resources in this version of the N32 handshake API. All the operations are realized as custom operations without resources.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.1.4\tCustom Operations without Associated Resources",
                            "text_content": "Table 6.1.4.1-1: Custom operations without associated resources\n\nThis custom operation is used between the SEPPs to negotiate their security capabilities or to tear down the N32-f connection when negotiated security scheme is TLS. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32c-handshake/<apiVersion>/exchange-capability\nThis operation shall support the resource URI variables defined in table 6.1.4.2.1-1.\nTable 6.1.4.2.1-1: Resource URI variables for this Operation\n\nThis operation shall support the request data structures and response codes specified in tables 6.2.4.2.2-1 and 6.2.4.2.2-2.\nTable 6.1.4.2.2-1: Data structures supported by the POST Request Body\n\nTable 6.1.4.2.2-2: Data structures supported by the POST Response Body on this resource\n\nTable 6.1.4.2.2-3: Headers supported by the 307 response code on this resource\n\nThis custom operation is used between the SEPPs to exchange the parameters for the N32-f connection. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32c-handshake/<apiVersion>/exchange-params\nThis operation shall support the resource URI variables defined in table 6.1.4.3.1-1.\nTable 6.1.4.3.1-1: Resource URI variables for this Operation\n\nThis operation shall support the request data structures and response codes specified in tables 6.1.4.3.2-1 and 6.1.4.3.2-2.\nTable 6.1.4.3.2-1: Data structures supported by the POST Request Body\n\nTable 6.1.4.3.2-2: Data structures supported by the POST Response Body on this resource\n\nThis custom operation is used between the SEPPs to terminate an N32-f context. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32c-handshake/<apiVersion>/n32f-terminate\nThis operation shall support the resource URI variables defined in table 6.1.4.3.1-1.\nTable 6.1.4.4.1-1: Resource URI variables for this Operation\n\nThis operation shall support the request data structures and response codes specified in tables 6.1.4.4.2-1 and 6.1.4.4.2-2.\nTable 6.1.4.4.2-1: Data structures supported by the POST Request Body\n\nTable 6.1.4.4.2-2: Data structures supported by the POST Response Body on this resource\n\nThis custom operation is used between the SEPPs to report errors identified while processing the messages received on N32-f. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32c-handshake/<apiVersion>/n32f-error\nThis operation shall support the resource URI variables defined in table 6.1.4.5.1-1.\nTable 6.1.4.5.1-1: Resource URI variables for this Operation\n\nThis operation shall support the request data structures and response codes specified in tables 6.1.4.5.2-1 and 6.1.4.5.2-2.\nTable 6.1.4.5.2-1: Data structures supported by the POST Request Body\n\nTable 6.1.4.5.2-2: Data structures supported by the POST Response Body on this resource\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.1.4.1-1: Custom operations without associated resources",
                                    "table number": 7,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.2.1-1: Resource URI variables for this Operation",
                                    "table number": 8,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.2.2-1: Data structures supported by the POST Request Body",
                                    "table number": 9,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.2.2-2: Data structures supported by the POST Response Body on this resource",
                                    "table number": 10,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.2.2-3: Headers supported by the 307 response code on this resource",
                                    "table number": 11,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.3.1-1: Resource URI variables for this Operation",
                                    "table number": 12,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.3.2-1: Data structures supported by the POST Request Body",
                                    "table number": 13,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.3.2-2: Data structures supported by the POST Response Body on this resource",
                                    "table number": 14,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.4.1-1: Resource URI variables for this Operation",
                                    "table number": 15,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.4.2-1: Data structures supported by the POST Request Body",
                                    "table number": 16,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.4.2-2: Data structures supported by the POST Response Body on this resource",
                                    "table number": 17,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.5.1-1: Resource URI variables for this Operation",
                                    "table number": 18,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.5.2-1: Data structures supported by the POST Request Body",
                                    "table number": 19,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.4.5.2-2: Data structures supported by the POST Response Body on this resource",
                                    "table number": 20,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "6.1.5\tData Model",
                            "text_content": "This clause specifies the application data model supported by the API.\nTable 6.1.5.1-1 specifies the data types defined for the N32 interface.\nTable 6.1.5.1-1: N32 specific Data Types\n\nTable 6.1.5.1-2 specifies data types re-used by the N32 interface protocol from other specifications, including a reference to their respective specifications and when needed, a short description of their use within the Namf service based interface.\nTable 6.1.5.1-2: N32 re-used Data Types\n\nThis clause defines the structures to be used in the N32 Handshake API.\nTable 6.1.5.2.2-1: Definition of type SecNegotiateReqData\n\nTable 6.1.5.2.3-1: Definition of type SecNegotiateRspData\n\nTable 6.1.5.2.4-1: Definition of type SecParamExchReqData\n\nTable 6.1.5.2.5-1: Definition of type SecParamExchRspData\n\nTable 6.1.5.2.6-1: Definition of type ProtectionPolicy\n\nTable 6.1.5.2.7-1: Definition of type ApiIeMapping\n\nTable 6.1.5.2.8-1: Definition of type IeInfo\n\nTable 6.1.5.2.9-1: Definition of type ApiSignature as a list of \"mutually exclusive alternatives\"\n\nTable 6.1.5.2.10-1: Definition of type N32fContextInfo\n\nTable 6.1.5.2.11-1: Definition of type N32fErrorInfo\n\nTable 6.1.5.2.12-1: Definition of type FailedModificationInfo\n\nTable 6.1.5.2.13-1: Definition of type N32fErrorDetail\n\nTable 6.1.5.2.14-1: Definition of type CallbackName\n\nTable 6.1.5.2.15-1: Definition of type IpxProviderSecInfo\n\nTable 6.1.5.2.16-1: Definition of type IntendedN32Purpose\n\nThis clause defines simple data types and enumerations that can be referenced from data structures defined in the previous clauses.\nThe simple data types defined in table 6.1.5.3.2-1 shall be supported.\nTable 6.1.5.3.2-1: Simple data types\n\nTable 6.1.5.3.3-1: Enumeration SecurityCapability\n\nTable 6.1.5.3.4-1: Enumeration HttpMethod\n\nTable 6.1.5.3.5-1: Enumeration IeType\n\nTable 6.1.5.3.6-1: Enumeration IeLocation\n\nTable 6.1.5.3.7-1: Enumeration N32fErrorType\n\nTable 6.1.5.3.8-1: Enumeration FailureReason\n\nTable 6.1.5.3.9-1: Enumeration N32Purpose\n\nThere are no multipart/binary part used on the N32-c API(s) in this release of this specification.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.1.5.1-1: N32 specific Data Types",
                                    "table number": 21,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.1-2: N32 re-used Data Types",
                                    "table number": 22,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.2-1: Definition of type SecNegotiateReqData",
                                    "table number": 23,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.3-1: Definition of type SecNegotiateRspData",
                                    "table number": 24,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.4-1: Definition of type SecParamExchReqData",
                                    "table number": 25,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.5-1: Definition of type SecParamExchRspData",
                                    "table number": 26,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.6-1: Definition of type ProtectionPolicy",
                                    "table number": 27,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.7-1: Definition of type ApiIeMapping",
                                    "table number": 28,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.8-1: Definition of type IeInfo",
                                    "table number": 29,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.9-1: Definition of type ApiSignature as a list of \"mutually exclusive alternatives\"",
                                    "table number": 30,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.10-1: Definition of type N32fContextInfo",
                                    "table number": 31,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.11-1: Definition of type N32fErrorInfo",
                                    "table number": 32,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.12-1: Definition of type FailedModificationInfo",
                                    "table number": 33,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.13-1: Definition of type N32fErrorDetail",
                                    "table number": 34,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.14-1: Definition of type CallbackName",
                                    "table number": 35,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.15-1: Definition of type IpxProviderSecInfo",
                                    "table number": 36,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.2.16-1: Definition of type IntendedN32Purpose",
                                    "table number": 37,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.3.2-1: Simple data types",
                                    "table number": 38,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.3.3-1: Enumeration SecurityCapability",
                                    "table number": 39,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.3.4-1: Enumeration HttpMethod",
                                    "table number": 40,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.3.5-1: Enumeration IeType",
                                    "table number": 41,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.3.6-1: Enumeration IeLocation",
                                    "table number": 42,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.3.7-1: Enumeration N32fErrorType",
                                    "table number": 43,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.3.8-1: Enumeration FailureReason",
                                    "table number": 44,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.1.5.3.9-1: Enumeration N32Purpose",
                                    "table number": 45,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "6.1.6\tError Handling",
                            "text_content": "HTTP error handling shall be supported as specified in clause 5.2.4 of 3GPP TS 29.500 [4].\nProtocol Error Handling shall be supported as specified in clause 5.2.7.2 of 3GPP TS 29.500 [4].\nThe common application errors defined in the Table 5.2.7.2-1 in 3GPP TS 29.500 [4] may also be used for the N32-c Handshake service. The following application errors listed in Table 6.1.6.3-1 are specific for the N32-c Handshake service.\nTable 6.1.6.3-1: Application errors\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.1.6.3-1: Application errors",
                                    "table number": 46,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "6.1.7\tFeature Negotiation",
                            "text_content": "The feature negotiation mechanism specified in clause 6.6 of 3GPP TS 29.500 [4] shall be used to negotiate the optional features applicable between the c-SEPP and the p-SEPP, for the N32 Handshake service, if any.\nThe c-SEPP shall indicate the optional features it supports for the N32 Handshake service, if any, by including the supportedFeatures attribute in the HTTP POST request message for following service operations:\n-\tSecurity Capability Negotiation procedure, as specified in clause 5.2.2 to negotiate the security capability;\nThe p-SEPP shall determine the supported features for the requested network as specified in clause 6.6 of 3GPP TS 29.500 [4] and shall indicate the supported features by including the supportedFeatures attribute in content of the HTTP response for the service operation.\nThe syntax of the supportedFeatures attribute is defined in clause 5.2.2 of 3GPP TS 29.571 [12].\nThe following features are defined for the N32 Handshake service.\nTable 6.1.7-1: Features of supportedFeatures attribute used by N32 Handshake service\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.1.7-1: Features of supportedFeatures attribute used by N32 Handshake service",
                                    "table number": 47,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "6.1.8\tHTTP redirection",
                            "text_content": "An N32 HTTP request may be redirected to a different SEPP service instance located within the same PLMN.\nIf e.g. a SEPP-A1 in PLMN-A receives a N32 HTTP request from another, e.g. SEPP-B that is in PLMN-B and redirects the request to another SEPP-A2 in PLMN-A, the SEPP-A1 shall send 307 Temporary Redirect response to the SEPP-B and may include a RedirectResponse data structure (see 3GPP TS 29.571 [12]) in the response, where the \"cause\" attribute shall not be set to \"SEPP_REDIRECTION\" and the \"targetSepp\" attribute shall be absent. The Location header shall contain the URI of the SEPP-A2.\nNOTE 1:\tA sender that receives a redirectResponse with the cause \"SEPP_REDIRECTION\" ignores the Location header as specified in clause 6.10.9.1 in 3GPP TS 29.500 [4], accordingly this cause is not used for redirecting N32 request for which the location header is used to convey the URI of the SEPP to which the request is redirected.\nNOTE 2:\tFor non N32 interfaces, if a SEPP receives a service request from a HTTP client e.g. an NF or an SCP, from the same PLMN and redirects the service request to a different SEPP in the same PLMN, the SEPP sends 307 Temporary Redirect or 308 Permanent Redirect response to the HTTP client including a RedirectResponse data structure (see 3GPP TS 29.571 [12]), where the \"cause\" attribute sets to \"SEPP_REDIRECTION\" and the \"targetSepp\" attribute contains the apiRoot of the SEPP towards which the request is redirected. The content of the Location header field is ignored by the receiver. See clause 6.10.9.1 in 3GPP TS 29.500 [4].\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.2\tJOSE Protected Message Forwarding API on N32",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.2.1\tAPI URI",
                            "text_content": "The JOSE Protected Message Forwarding Procedure on N32 shall use the JOSE Protected Message Forwarding API on N32-f API.\nThe API URI of the JOSE Protected Message Forwarding API on N32-f API shall be:\n{apiRoot}/<apiName>/<apiVersion>\nThe request URIs used in HTTP requests from the initiating SEPP towards the responding SEPP shall have the Resource URI structure defined in clause 4.4.1 of 3GPP TS 29.501 [5], i.e.:\n{apiRoot}/<apiName>/<apiVersion>/<apiSpecificResourceUriPart>\nwith the following components:\n-\tThe {apiRoot} shall be set as described in 3GPP TS 29.501 [5].\n-\tThe <apiName> shall be \"n32f-forward\".\n-\tThe <apiVersion> shall be \"v1\".\n-\tThe <apiSpecificResourceUriPart> shall be set as described in clause 6.2.4.\nThe apiRoot to use towards a SEPP of the target PLMN shall be configured at the SEPP. The URI scheme of the API shall be \"http\". The apiName part of the URI shall be as specified here for homogeneity of the API across PLMNs.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.2\tUsage of HTTP",
                            "text_content": "HTTP/2, as defined in IETF RFC 9113 [7], shall be used as specified in clause 4.3.2.1.\nHTTP/2 shall be transported as specified in clause 4.3.3.\nHTTP messages and bodies for the JOSE protected message forwarding API on N32-f shall comply with the OpenAPI [27] specification contained in Annex A.\nThe HTTP standard headers as specified in clause 4.3.2.2 shall be supported for this API.\nThe following content types shall be supported:\n-\tthe JSON format (see IETF RFC 8259 [8]). The use of the JSON format shall be signalled by the content type \"application/json\". See also clause 5.3.4.\n-\tthe Problem Details JSON Object (see IETF RFC 9457 [22]). The use of the Problem Details JSON object in a HTTP response body shall be signalled by the content type \"application/problem+json\".\nSEPPs and IPX should support gzip coding (see IETF RFC 1952 [23]) in HTTP requests and responses and indicate so in the Accept-Encoding header, as described in clause 5.3.2.1.\n\nIn this release of the specification, no specific custom headers are defined for the JOSE protected message forwarding API on N32.\nFor 3GPP specific HTTP custom headers used across all service based interfaces, see clause 4.3.2.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.3\tResources",
                            "text_content": "There are no resources in this version of this API. All the operations are realized as custom operations without resources.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.4\tCustom Operations without associated resources",
                            "text_content": "Table 6.2.4.1-1: Custom operations without associated resources\n\nThis custom operation is used between the SEPPs to forward the reformatted and JOSE protected HTTP/2 message on N32-f. The HTTP method POST shall be used on the following URI:\nURI: {apiRoot}/n32f-forward/<apiVersion>/n32f-process\nThis operation shall support the resource URI variables defined in table 6.1.4.2.1-1.\nTable 6.2.4.2.1-1: Resource URI variables for this Operation\n\nThis operation shall support the request data structures and response codes specified in tables 6.2.4.2.2-1 and 6.2.4.2.2-2.\nTable 6.2.4.2.2-1: Data structures supported by the POST Request Body on this resource\n\nTable 6.2.4.2.2-2: Data structures supported by the POST Response Body on this resource\n\nTable 6.2.4.2.2-3: Headers supported by the POST method on this resource\n\nTable 6.2.4.2.2-4: Headers supported by 200 Response Code on this endpoint\n\nThis service operation queries the communication options supported by the next hop (IPX or SEPP) for N32-f message processing (see clauses 5.3.2.4 and 5.3.4).\nThe HTTP method OPTIONS shall be used on the following URI:\nURI: {apiRoot}/n32f-forward/<apiVersion>/n32f-process\nThis operation shall support the resource URI variables defined in table 6.2.4.3.1-1.\nTable 6.2.4.3.1-1: Resource URI variables for this Operation\n\n6.2.4.3.2.1\tOPTIONS\nThis method shall support the URI query parameters specified in table 6.2.4.3.2.1-1.\nTable 6.2.4.3.2.1-1: URI query parameters supported by the OPTIONS method\n\nThis method shall support the request data structures specified in table 6.2.4.3.2.1-2 and the response data structures and response codes specified in table 6.2.4.3.2.1-3.\nTable 6.2.4.3.2.1-2: Data structures supported by the OPTIONS Request Body on this resource\n\nTable 6.2.4.3.2.1-3: Data structures supported by the OPTIONS Response Body on this resource\n\nTable 6.2.4.3.2.1-4: Headers supported by the 204 Response Code on this resource\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.2.4.1-1: Custom operations without associated resources",
                                    "table number": 48,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.2.1-1: Resource URI variables for this Operation",
                                    "table number": 49,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.2.2-1: Data structures supported by the POST Request Body on this resource",
                                    "table number": 50,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.2.2-2: Data structures supported by the POST Response Body on this resource",
                                    "table number": 51,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.2.2-3: Headers supported by the POST method on this resource",
                                    "table number": 52,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.2.2-4: Headers supported by 200 Response Code on this endpoint",
                                    "table number": 53,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.3.1-1: Resource URI variables for this Operation",
                                    "table number": 54,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.3.2.1-1: URI query parameters supported by the OPTIONS method",
                                    "table number": 55,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.3.2.1-2: Data structures supported by the OPTIONS Request Body on this resource",
                                    "table number": 56,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.3.2.1-3: Data structures supported by the OPTIONS Response Body on this resource",
                                    "table number": 57,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.4.3.2.1-4: Headers supported by the 204 Response Code on this resource",
                                    "table number": 58,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "6.2.5\tData Model",
                            "text_content": "This clause specifies the application data model supported by the API.\nTable 6.2.5.1-1 specifies the data types defined for the N32 interface.\nTable 6.2.5.1-1: N32 specific Data Types\n\nTable 6.2.5.1-2 specifies data types re-used by the N32 interface protocol from other specifications, including a reference to their respective specifications and when needed, a short description of their use within the Namf service based interface.\nTable 6.2.5.1-2: N32 re-used Data Types\n\nThis clause defines the structures to be used in the JOSE Protected Message Forwarding API on N32.\nTable 6.2.5.2.2-1: Definition of type N32fReformattedReqMsg\n\nTable 6.2.5.2.3-1: Definition of type N32fReformattedRspMsg\n\nTable 6.2.5.2.4-1: Definition of type DataToIntegrityProtectAndCipherBlock\n\nTable 6.2.5.2.5-1: Definition of type DataToIntegrityProtectBlock\n\nTable 6.2.5.2.6-1: Definition of type RequestLine\n\nTable 6.2.5.2.7-1: Definition of type HttpHeader\n\nTable 6.2.5.2.8-1: Definition of type HttpPayload\n\nTable 6.2.5.2.9-1: Definition of type MetaData\n\nTable 6.2.5.2.10-1: Definition of type Modifications\n\nTable 6.2.5.2.11-1: Definition of type FlatJweJson\n\nTable 6.2.5.2.12-1: Definition of type FlatJwsJson\n\nTable 6.2.5.2.13-1: Definition of type IndexToEncryptedHttpHeader\n\nTable 6.2.5.2.14-1: Definition of type EncodedHttpHeaderValue as a list of \"mutually exclusive alternatives\"\n\nTable 6.2.5.2.15-1: Definition of type ProblemDetailsMsgForwarding as a list of to be combined data types\n\nTable 6.2.5.2.16-1: Definition of type AdditionInfoMsgForwarding\n\nThis clause defines simple data types and enumerations that can be referenced from data structures defined in the previous clauses.\nThe simple data types defined in table 6.1.5.3.2-1 shall be supported.\nTable 6.2.5.3.2-1: Simple data types\n\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.2.5.1-1: N32 specific Data Types",
                                    "table number": 59,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.1-2: N32 re-used Data Types",
                                    "table number": 60,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.2-1: Definition of type N32fReformattedReqMsg",
                                    "table number": 61,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.3-1: Definition of type N32fReformattedRspMsg",
                                    "table number": 62,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.4-1: Definition of type DataToIntegrityProtectAndCipherBlock",
                                    "table number": 63,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.5-1: Definition of type DataToIntegrityProtectBlock",
                                    "table number": 64,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.6-1: Definition of type RequestLine",
                                    "table number": 65,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.7-1: Definition of type HttpHeader",
                                    "table number": 66,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.8-1: Definition of type HttpPayload",
                                    "table number": 67,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.9-1: Definition of type MetaData",
                                    "table number": 68,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.10-1: Definition of type Modifications",
                                    "table number": 69,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.11-1: Definition of type FlatJweJson",
                                    "table number": 70,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.12-1: Definition of type FlatJwsJson",
                                    "table number": 71,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.13-1: Definition of type IndexToEncryptedHttpHeader",
                                    "table number": 72,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.14-1: Definition of type EncodedHttpHeaderValue as a list of \"mutually exclusive alternatives\"",
                                    "table number": 73,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.15-1: Definition of type ProblemDetailsMsgForwarding as a list of to be combined data types",
                                    "table number": 74,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.2.16-1: Definition of type AdditionInfoMsgForwarding",
                                    "table number": 75,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.2.5.3.2-1: Simple data types",
                                    "table number": 76,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "6.2.6\tError Handling",
                            "text_content": "HTTP error handling shall be supported as specified in clause 5.2.4 of 3GPP TS 29.500 [4].\nProtocol Error Handling shall be supported as specified in clause 5.2.7.2 of 3GPP TS 29.500 [4].\nThe application errors defined for the JOSE protected message forwarding API on N32-f are listed in Table 6.2.6.3-1.\nTable 6.2.6.3-1: Application errors\n\nEditor's note: the list of application errors to be added for the support of roaming intermediaries is FFS.\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.2.6.3-1: Application errors",
                                    "table number": 77,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "6.3\tNsepp_Telescopic_FQDN_Mapping API",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.3.1\tAPI URI",
                            "text_content": "The Nsepp_Telescopic_FQDN_Mapping Service shall use the SEPP Telescopic FQDN Mapping API.\nThe API URI of the SEPP Telescopic FQDN Mapping API shall be:\n{apiRoot}/<apiName>/<apiVersion>\nThe request URIs used in HTTP requests from the NF service consumer towards the SEPP shall have the Resource URI structure defined in clause 4.4.1 of 3GPP TS 29.501 [5], i.e.:\n{apiRoot}/<apiName>/<apiVersion>/<apiSpecificResourceUriPart>\nwith the following components:\n-\tThe {apiRoot} shall be set as described in 3GPP TS 29.501 [5].\n-\tThe <apiName> shall be \"nsepp-telescopic\".\n-\tThe <apiVersion> shall be \"v1\".\n-\tThe <apiSpecificResourceUriPart> shall be set as described in clause 6.3.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.3.2\tUsage of HTTP",
                            "text_content": "HTTP/2, as defined in IETF RFC 9113 [7], shall be used as specified in clause 5 of 3GPP TS 29.500 [4].\nHTTP/2 shall be transported as specified in clause 5.3 of 3GPP TS 29.500 [4].\nHTTP messages and bodies for the Nsepp_Telescopic_FQDN_Mapping service shall comply with the OpenAPI [27] specification contained in Annex A.\nThe HTTP standard headers as specified in clause 4.3.2.2 shall be supported for this API.\nThe following content types shall be supported:\n-\tJSON, as defined in IETF RFC 8259 [9]. The use of the JSON format shall be signalled by the content type \"application/json\". See also clause 5.4 of 3GPP TS 29.500 [4].\n-\tThe Problem Details JSON Object (IETF RFC 9457 [22]. The use of the Problem Details JSON object in a HTTP response body shall be signalled by the content type \"application/problem+json\".\nIn this release of this specification, no custom headers specific to the Nsepp_Telescopic_FQDN_Mapping service are defined. For 3GPP specific HTTP custom headers used across all service-based interfaces, see clause 5.2.3 of 3GPP TS 29.500 [4].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.3.3\tResources",
                            "text_content": "The figure depicts the structure of the nsepp-telescopic API, which is a resource URI structure used in the nsepp-telescopic framework. The API is designed to facilitate communication between different components of the nsepp-telescopic system, allowing for efficient data exchange and integration. The figure provides a clear and concise representation of the API's structure, making it easier for developers to understand and use the API.\nFigure 6.3.3.1-1: Resource URI structure of the nsepp-telescopic API\nTable 6.3.3.1-1 provides an overview of the resources and applicable HTTP methods.\nTable 6.3.3.1-1: Resources and methods overview\n\nThis resource represents the mapping between the FQDN of an NF in a foreign PLMN and a telescopic FQDN.\nResource URI: {apiRoot}/nsepp-telescopic/<apiVersion>/mapping\nThis resource shall support the resource URI variables defined in table 6.3.3.2.2-1.\nTable 6.3.3.2.2-1: Resource URI variables for this resource\n\n6.3.3.2.3.1\tGET\nThis method shall support the URI query parameters specified in table 6.3.3.2.3.1-1.\nTable 6.3.3.2.3.1-1: URI query parameters supported by the GET method on this resource\n\nThis method shall support the request data structures specified in table 6.3.3.2.3.1-2 and the response data structures and response codes specified in table 6.3.3.2.3.1-3.\nTable 6.3.3.2.3.1-2: Data structures supported by the GET Request Body on this resource\n\nTable 6.3.3.2.3.1-3: Data structures supported by the GET Response Body on this resource\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.3.3.1-1: Resources and methods overview",
                                    "table number": 78,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.3.3.2.2-1: Resource URI variables for this resource",
                                    "table number": 79,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.3.3.2.3.1-1: URI query parameters supported by the GET method on this resource",
                                    "table number": 80,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.3.3.2.3.1-2: Data structures supported by the GET Request Body on this resource",
                                    "table number": 81,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.3.3.2.3.1-3: Data structures supported by the GET Response Body on this resource",
                                    "table number": 82,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "6.3.4\tData Model",
                            "text_content": "This clause specifies the application data model supported by the API.\nTable 6.3.4.1-1 specifies the data types defined for the Nsepp_Telescopic_FQDN_Mapping service-based interface protocol.\nTable 6.3.4.1-1: Nsepp_Telescopic_FQDN_Mapping specific Data Types\n\nTable 6.3.4.1-2 specifies data types re-used by the Nsepp_Telescopic_Mapping service-based interface protocol from other specifications.\nTable 6.3.4.1-2: Nsepp_Telescopic_FQDN_Mapping re-used Data Types\n\nThis clause defines the structures to be used in resource representations.\nTable 6.3.4.2.2-1: Definition of type TelescopicMapping\n\nThis clause defines simple data types and enumerations that can be referenced from data structures defined in the previous clauses.\nThe simple data types defined in table 6.3.4.3.2-1 shall be supported.\nTable 6.3.4.3.2-1: Simple data types\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.3.4.1-1: Nsepp_Telescopic_FQDN_Mapping specific Data Types",
                                    "table number": 83,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.3.4.1-2: Nsepp_Telescopic_FQDN_Mapping re-used Data Types",
                                    "table number": 84,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.3.4.2.2-1: Definition of type TelescopicMapping",
                                    "table number": 85,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 6.3.4.3.2-1: Simple data types",
                                    "table number": 86,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "6.3.5\tError Handling",
                            "text_content": "HTTP error handling shall be supported as specified in clause 5.2.4 of 3GPP TS 29.500 [4].\nProtocol Error Handling shall be supported as specified in clause 5.2.7 of 3GPP TS 29.500 [4].\nThe common application errors defined in the Table 5.2.7.2-1 in 3GPP TS 29.500 [4] may also be used for the Nsepp_Telescopic_Mapping service, and the following application errors listed in Table 6.3.5.3-1 are specific for the Nsepp_Telescopic_Mapping service.\nTable 6.3.5.3-1: Application errors\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.3.5.3-1: Application errors",
                                    "table number": 87,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "6.3.6\tFeature Negotiation",
                            "text_content": "This API does not currently specify any features.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.3.7\tSecurity",
                            "text_content": "This API shall be accessed only from NFs in the same PLMN as the SEPP; it shall not be exposed externally to NFs from another PLMN.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "A.1\tGeneral",
            "description": "This Annex specifies the formal definition of the N32 Handshake API(s) on the N32-c interface. It consists of OpenAPI 3.0.0 specifications, in YAML format.\nThis Annex takes precedence when being discrepant to other parts of the specification with respect to the encoding of information elements and methods within the API(s).\nNOTE:\tThe semantics and procedures, as well as conditions, e.g. for the applicability and allowed combinations of attributes or values, not expressed in the OpenAPI definitions but defined in other parts of the specification also apply.\nInformative copies of the OpenAPI specification files contained in this 3GPP Technical Specification are available on a Git-based repository that uses the GitLab software version control system (see 3GPP TS 29.501 [5] clause 5.3.1 and 3GPP TR 21.900 [7] clause 5B).\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "A.2\tN32 Handshake API",
            "description": "openapi: 3.0.0\n\ninfo:\nversion: '1.3.0-alpha.5'\ntitle: 'N32 Handshake API'\ndescription: |\nN32-c Handshake Service.\n© 2023, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).\nAll rights reserved.\nservers:\n- url: '{apiRoot}/n32c-handshake/v1'\nvariables:\napiRoot:\ndefault: https://example.com\ndescription:  apiRoot as defined in clause 4.4 of 3GPP TS 29.501.\nexternalDocs:\ndescription: 3GPP TS 29.573 V18.5.0; 5G System; Public Land Mobile Network (PLMN) Interconnection; Stage 3\nurl: https://www.3gpp.org/ftp/Specs/archive/29_series/29.573/\n\npaths:\n/exchange-capability:\npost:\nsummary:  Security Capability Negotiation\ntags:\n- Security Capability Negotiation\noperationId: PostExchangeCapability\nrequestBody:\ndescription: Custom operation for security capability negotiation\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/SecNegotiateReqData'\nresponses:\n'200':\ndescription: OK (Successful negitiation of security capabilities)\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/SecNegotiateRspData'\n'307':\n$ref: 'TS29571_CommonData.yaml#/components/responses/307'\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'409':\n$ref: 'TS29571_CommonData.yaml#/components/responses/409'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\n/exchange-params:\npost:\nsummary: Parameter Exchange\ntags:\n- Parameter Exchange\noperationId: PostExchangeParams\nrequestBody:\ndescription: Custom operation for parameter exchange\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/SecParamExchReqData'\nresponses:\n'200':\ndescription: OK (Successful exchange of parameters)\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/SecParamExchRspData'\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'409':\n$ref: 'TS29571_CommonData.yaml#/components/responses/409'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\n/n32f-terminate:\npost:\nsummary: N32-f Context Terminate\ntags:\n- N32-f Context Terminate\noperationId: PostN32fTerminate\nrequestBody:\ndescription: Custom operation for n32-f context termination\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fContextInfo'\nresponses:\n'200':\ndescription: OK (Successful exchange of parameters)\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fContextInfo'\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\n/n32f-error:\npost:\nsummary: N32-f Error Reporting Procedure\ntags:\n- N32-f Error Report\noperationId: PostN32fError\nrequestBody:\ndescription: Custom operation for n32-f error reporting procedure\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fErrorInfo'\nresponses:\n'204':\ndescription: successful error reporting\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\ncomponents:\nschemas:\nSecurityCapability:\ndescription: Enumeration of security capabilities\nanyOf:\n- type: string\nenum:\n- TLS\n- PRINS\n- NONE\n- type: string\nApiSignature:\ndescription: API URI of the service operation\noneOf:\n- $ref: 'TS29571_CommonData.yaml#/components/schemas/Uri'\n- $ref: '#/components/schemas/CallbackName'\nHttpMethod:\ndescription: Enumeration of HTTP methods\nanyOf:\n- type: string\nenum:\n- GET\n- PUT\n- POST\n- DELETE\n- PATCH\n- HEAD\n- OPTIONS\n- CONNECT\n- TRACE\n- type: string\n\nIeType:\ndescription: Enumeration of types of IEs (i.e kind of IE) to specify the protection policy\nanyOf:\n- type: string\nenum:\n- UEID\n- LOCATION\n- KEY_MATERIAL\n- AUTHENTICATION_MATERIAL\n- AUTHORIZATION_TOKEN\n- OTHER\n- NONSENSITIVE\n- type: string\n\nIeLocation:\ndescription: Location of the IE in a HTTP message\nanyOf:\n- type: string\nenum:\n- URI_PARAM\n- HEADER\n- BODY\n- MULTIPART_BINARY\n- type: string\n\nIeInfo:\ndescription: Protection and modification policy for the IE\ntype: object\nrequired:\n- ieLoc\n- ieType\nproperties:\nieLoc:\n$ref: '#/components/schemas/IeLocation'\nieType:\n$ref: '#/components/schemas/IeType'\nreqIe:\ntype: string\nrspIe:\ntype: string\nisModifiable:\ntype: boolean\nisModifiableByIpx:\ntype: object\nadditionalProperties:\ntype: boolean\nminProperties: 1\n\nApiIeMapping:\ndescription: API URI to IE mapping on which the protection policy needs to be applied\ntype: object\nrequired:\n- apiSignature\n- apiMethod\n- IeList\nproperties:\napiSignature:\n$ref: '#/components/schemas/ApiSignature'\napiMethod:\n$ref: '#/components/schemas/HttpMethod'\nIeList:\ntype: array\nitems:\n$ref: '#/components/schemas/IeInfo'\nminItems: 1\n# The attribute name does not follow the naming conventions specified in 3GPP TS 29.501. The attribute name is kept though as defined in the current specification for backward compatibility reason.\n\nProtectionPolicy:\ndescription: The protection policy to be negotiated between the SEPPs\ntype: object\nrequired:\n- apiIeMappingList\nproperties:\napiIeMappingList:\ntype: array\nitems:\n$ref: '#/components/schemas/ApiIeMapping'\nminItems: 1\ndataTypeEncPolicy:\ntype: array\nitems:\n$ref: '#/components/schemas/IeType'\nminItems: 1\n\nSecNegotiateReqData:\ndescription: Defines the security capabilities of a SEPP sent to a receiving SEPP\ntype: object\nrequired:\n- sender\n- supportedSecCapabilityList\nproperties:\nsender:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nsupportedSecCapabilityList:\ntype: array\nitems:\n$ref: '#/components/schemas/SecurityCapability'\nminItems: 1\n3GppSbiTargetApiRootSupported:\ntype: boolean\ndefault: false\n# The attribute name does not follow the naming conventions specified in 3GPP TS 29.501. The attribute name is kept though as defined in the current specification for backward compatibility reason.\nplmnIdList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnId'\nminItems: 1\nsnpnIdList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnIdNid'\nminItems: 1\ntargetPlmnId:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnId'\ntargetSnpnId:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnIdNid'\nintendedUsagePurpose:\ntype: array\nitems:\n$ref: '#/components/schemas/IntendedN32Purpose'\nminItems: 1\nsupportedFeatures:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/SupportedFeatures'\nsenderN32fFqdn:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nsenderN32fPort:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Uinteger'\n\nSecNegotiateRspData:\ndescription: Defines the selected security capabilities by a SEPP\ntype: object\nrequired:\n- sender\n- selectedSecCapability\nproperties:\nsender:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nselectedSecCapability:\n$ref: '#/components/schemas/SecurityCapability'\n3GppSbiTargetApiRootSupported:\ntype: boolean\ndefault: false\n# The attribute name does not follow the naming conventions specified in 3GPP TS 29.501. The attribute name is kept though as defined in the current specification for backward compatibility reason.\nplmnIdList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnId'\nminItems: 1\nsnpnIdList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PlmnIdNid'\nminItems: 1\nallowedUsagePurpose:\ntype: array\nitems:\n$ref: '#/components/schemas/IntendedN32Purpose'\nminItems: 1\nrejectedUsagePurpose:\ntype: array\nitems:\n$ref: '#/components/schemas/IntendedN32Purpose'\nminItems: 1\nsupportedFeatures:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/SupportedFeatures'\nsenderN32fFqdn:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nsenderN32fPortList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Uinteger'\nminItems: 1\n\nSecParamExchReqData:\ndescription: Request data structure for parameter exchange\ntype: object\nrequired:\n- n32fContextId\nproperties:\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\njweCipherSuiteList:\ntype: array\nitems:\ntype: string\nminItems: 1\njwsCipherSuiteList:\ntype: array\nitems:\ntype: string\nminItems: 1\nprotectionPolicyInfo:\n$ref: '#/components/schemas/ProtectionPolicy'\nipxProviderSecInfoList:\ntype: array\nitems:\n$ref: '#/components/schemas/IpxProviderSecInfo'\nminItems: 1\nsender:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\n\nSecParamExchRspData:\ndescription: Response data structure for parameter exchange\ntype: object\nrequired:\n- n32fContextId\nproperties:\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\nselectedJweCipherSuite:\ntype: string\nselectedJwsCipherSuite:\ntype: string\nselProtectionPolicyInfo:\n$ref: '#/components/schemas/ProtectionPolicy'\nipxProviderSecInfoList:\ntype: array\nitems:\n$ref: '#/components/schemas/IpxProviderSecInfo'\nminItems: 1\nsender:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\n\nN32fContextInfo:\ndescription: N32-f context information\ntype: object\nrequired:\n- n32fContextId\nproperties:\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\nCallbackName:\ndescription: Callback Name\ntype: object\nrequired:\n- callbackType\nproperties:\ncallbackType:\ntype: string\nN32fErrorInfo:\ndescription: N32-f error information\ntype: object\nrequired:\n- n32fMessageId\n- n32fErrorType\nproperties:\nn32fMessageId:\ntype: string\nn32fErrorType:\n$ref: '#/components/schemas/N32fErrorType'\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\nfailedModificationList:\ntype: array\nitems:\n$ref: '#/components/schemas/FailedModificationInfo'\nminItems: 1\nerrorDetailsList:\ntype: array\nitems:\n$ref: '#/components/schemas/N32fErrorDetail'\nminItems: 1\npolicyMismatchList:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/InvalidParam'\nminItems: 1\nFailedModificationInfo:\ndescription: Information on N32-f modifications block that failed to process\ntype: object\nrequired:\n- ipxId\n- n32fErrorType\nproperties:\nipxId:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nn32fErrorType:\n$ref: '#/components/schemas/N32fErrorType'\nN32fErrorDetail:\ndescription: Details about the N32f error\ntype: object\nrequired:\n- attribute\n- msgReconstructFailReason\nproperties:\nattribute:\ntype: string\nmsgReconstructFailReason:\n$ref: '#/components/schemas/FailureReason'\nIpxProviderSecInfo:\ndescription: Defines the security information list of an IPX\ntype: object\nrequired:\n- ipxProviderId\nproperties:\nipxProviderId:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nrawPublicKeyList:\ntype: array\nitems:\ntype: string\nminItems: 1\ncertificateList:\ntype: array\nitems:\ntype: string\nminItems: 1\n\nIntendedN32Purpose:\ndescription: Indicates the intended N32 establishment purpose\ntype: object\nrequired:\n- usagePurpose\nproperties:\nusagePurpose:\n$ref: '#/components/schemas/N32Purpose'\nadditionalInfo:\ntype: string\ncause:\ntype: string\n\nN32fErrorType:\ndescription: Type of error while processing N32-f message\nanyOf:\n- type: string\nenum:\n- INTEGRITY_CHECK_FAILED\n- INTEGRITY_CHECK_ON_MODIFICATIONS_FAILED\n- MODIFICATIONS_INSTRUCTIONS_FAILED\n- DECIPHERING_FAILED\n- MESSAGE_RECONSTRUCTION_FAILED\n- CONTEXT_NOT_FOUND\n- INTEGRITY_KEY_EXPIRED\n- ENCRYPTION_KEY_EXPIRED\n- POLICY_MISMATCH\n- type: string\nFailureReason:\ndescription: Reason for failure to reconstruct a HTTP/2 message from N32-f message\nanyOf:\n- type: string\nenum:\n- INVALID_JSON_POINTER\n- INVALID_INDEX_TO_ENCRYPTED_BLOCK\n- INVALID_HTTP_HEADER\n- type: string\n\nN32Purpose:\ndescription: Usage purpose of establishing N32 connectivity\nanyOf:\n- type: string\nenum:\n- ROAMING\n- INTER_PLMN_MOBILITY\n- SMS_INTERCONNECT\n- ROAMING_TEST\n- INTER_PLMN_MOBILITY_TEST\n- SMS_INTERCONNECT_TEST\n- SNPN_INTERCONNECT\n- SNPN_INTERCONNECT_TEST\n- DISASTER_ROAMING\n- DISASTER_ROAMING_TEST\n- type: string\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "A.3\tJOSE Protected Message Forwarding API on N32-f",
            "description": "openapi: 3.0.0\n\ninfo:\nversion: '1.3.0-alpha.2'\ntitle: 'JOSE Protected Message Forwarding API'\ndescription: |\nN32-f Message Forwarding Service.\n© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).\nAll rights reserved.\nservers:\n- url: '{apiRoot}/n32f-forward/v1'\nvariables:\napiRoot:\ndefault: https://example.com\ndescription:  apiRoot as defined in clause 4.4 of 3GPP TS 29.501.\nexternalDocs:\ndescription: 3GPP TS 29.573 V18.5.0; 5G System; Public Land Mobile Network (PLMN) Interconnection; Stage 3\nurl: https://www.3gpp.org/ftp/Specs/archive/29_series/29.573/\n\npaths:\n/n32f-process:\npost:\nsummary:  N32-f Message Forwarding\ntags:\n- N32-f Forward\noperationId: PostN32fProcess\nparameters:\n- name: Content-Encoding\nin: header\ndescription: Content-Encoding, described in IETF RFC 9110\nschema:\ntype: string\n- name: Accept-Encoding\nin: header\ndescription: Accept-Encoding, described in IETF RFC 9110\nschema:\ntype: string\n- name: 3gpp-Sbi-Message-Priority\nin: header\ndescription: 3gpp-Sbi-Message-Priority, defined in 3GPP TS 29.500\nschema:\ntype: string\nrequestBody:\ndescription: Custom operation N32-f Message Forwarding\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fReformattedReqMsg'\nresponses:\n'200':\ndescription: OK (Successful forwarding of reformatted message over N32-f)\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/N32fReformattedRspMsg'\nheaders:\nAccept-Encoding:\ndescription: Accept-Encoding, described in IETF RFC 9110\nschema:\ntype: string\nContent-Encoding:\ndescription: Content-Encoding, described in IETF RFC 9110\nschema:\ntype: string\n3gpp-Sbi-Message-Priority:\ndescription: 3gpp-Sbi-Message-Priority, defined in 3GPP TS 29.500\nschema:\ntype: string\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\ndescription: Forbidden\ncontent:\napplication/problem+json:\nschema:\n$ref: '#/components/schemas/ProblemDetailsMsgForwarding'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'411':\n$ref: 'TS29571_CommonData.yaml#/components/responses/411'\n'413':\n$ref: 'TS29571_CommonData.yaml#/components/responses/413'\n'415':\n$ref: 'TS29571_CommonData.yaml#/components/responses/415'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\ndescription: Unexpected error\n\noptions:\nsummary: Discover communication options supported by next hop (IPX or SEPP)\noperationId: N32fProcessOptions\ntags:\n- N32-f Forward\nresponses:\n'204':\ndescription: No Content\nheaders:\nAccept-Encoding:\ndescription: Accept-Encoding, described in IETF RFC 9110\nschema:\ntype: string\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'405':\n$ref: 'TS29571_CommonData.yaml#/components/responses/405'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'501':\n$ref: 'TS29571_CommonData.yaml#/components/responses/501'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\n$ref: 'TS29571_CommonData.yaml#/components/responses/default'\n\ncomponents:\nschemas:\nFlatJweJson:\ndescription: Contains the integrity protected reformatted block\ntype: object\nrequired:\n- ciphertext\nproperties:\nprotected:\ntype: string\nunprotected:\ntype: object\nheader:\ntype: object\nencrypted_key:\ntype: string\n# The attribute name does not follow the naming conventions specified in 3GPP TS 29.501. The attribute name is kept though as defined in the current specification for backward compatibility reason.\naad:\ntype: string\niv:\ntype: string\nciphertext:\ntype: string\ntag:\ntype: string\n\nFlatJwsJson:\ndescription: Contains the modification from IPXes on path\ntype: object\nrequired:\n- payload\n- signature\nproperties:\npayload:\ntype: string\nprotected:\ntype: string\nheader:\ntype: object\nsignature:\ntype: string\n\nN32fReformattedReqMsg:\ndescription: Contains the reformatted HTTP/2 request message\ntype: object\nrequired:\n- reformattedData\nproperties:\nreformattedData:\n$ref: '#/components/schemas/FlatJweJson'\nmodificationsBlock:\ntype: array\nitems:\n$ref: '#/components/schemas/FlatJwsJson'\nminItems: 1\n\nN32fReformattedRspMsg:\ndescription: Contains the reformatted HTTP/2 response message\ntype: object\nrequired:\n- reformattedData\nproperties:\nreformattedData:\n$ref: '#/components/schemas/FlatJweJson'\nmodificationsBlock:\ntype: array\nitems:\n$ref: '#/components/schemas/FlatJwsJson'\nminItems: 1\n\nDataToIntegrityProtectAndCipherBlock:\ndescription: HTTP header to be encrypted or the value of a JSON attribute to be encrypted\ntype: object\nrequired:\n- dataToEncrypt\nproperties:\ndataToEncrypt:\ntype: array\nitems: {}\nminItems: 1\nDataToIntegrityProtectBlock:\ndescription: Data to be integrity protected\ntype: object\nproperties:\nmetaData:\n$ref: '#/components/schemas/MetaData'\nrequestLine:\n$ref: '#/components/schemas/RequestLine'\nstatusLine:\ntype: string\nheaders:\ntype: array\nitems:\n$ref: '#/components/schemas/HttpHeader'\nminItems: 1\npayload:\ntype: array\nitems:\n$ref: '#/components/schemas/HttpPayload'\nminItems: 1\nRequestLine:\ndescription: Contains the request line of the HTTP API request being reformatted and forwarded over N32-f\ntype: object\nrequired:\n- method\n- scheme\n- authority\n- path\n- protocolVersion\nproperties:\nmethod:\n$ref: 'TS29573_N32_Handshake.yaml#/components/schemas/HttpMethod'\nscheme:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/UriScheme'\nauthority:\ntype: string\npath:\ntype: string\nprotocolVersion:\ntype: string\nqueryFragment:\ntype: string\nHttpHeader:\ndescription: Contains the encoding of HTTP headers in the API request / response\ntype: object\nrequired:\n- header\n- value\nproperties:\nheader:\ntype: string\nvalue:\n$ref: '#/components/schemas/EncodedHttpHeaderValue'\nHttpPayload:\ndescription: Contains the encoding of JSON content in the API request / response\ntype: object\nrequired:\n- iePath\n- ieValueLocation\n- value\nproperties:\niePath:\ntype: string\nieValueLocation:\n$ref: 'TS29573_N32_Handshake.yaml#/components/schemas/IeLocation'\nvalue:\ntype: object\nMetaData:\ndescription: Contains the meta data information needed for replay protection\ntype: object\nrequired:\n- n32fContextId\n- messageId\n- authorizedIpxId\nproperties:\nn32fContextId:\ntype: string\npattern: '^[A-Fa-f0-9]{16}$'\nmessageId:\ntype: string\nauthorizedIpxId:\ntype: string\nModifications:\ndescription: Information on inserting of the modifications entry\ntype: object\nrequired:\n- identity\nproperties:\nidentity:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\noperations:\ntype: array\nitems:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/PatchItem'\nminItems: 1\ntag:\ntype: string\nIndexToEncryptedValue:\ndescription: Index to the encrypted value\ntype: object\nrequired:\n- encBlockIndex\nproperties:\nencBlockIndex:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Uinteger'\nEncodedHttpHeaderValue:\ndescription: HTTP header value or index to the HTTP header value\noneOf:\n- type: string\n- $ref: '#/components/schemas/IndexToEncryptedValue'\n\nProblemDetailsMsgForwarding:\nallOf:\n- $ref: 'TS29571_CommonData.yaml#/components/schemas/ProblemDetails'\n- $ref: '#/components/schemas/AdditionInfoMsgForwarding'\n\nAdditionInfoMsgForwarding:\ndescription: Problem Details extensions for N32-f message forwarding\nproperties:\nsuggestedStatusCode:\ntype: integer\nsuggestedProblemDetails:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/ProblemDetails'\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "A.4\tSEPP Telescopic FQDN Mapping API",
            "description": "openapi: 3.0.0\n\ninfo:\nversion: '1.2.0-alpha.1'\ntitle: 'SEPP Telescopic FQDN Mapping API'\ndescription: |\nSEPP Telescopic FQDN Mapping Service.\n© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).\nAll rights reserved.\n\nservers:\n- url: '{apiRoot}/nsepp-telescopic/v1'\nvariables:\napiRoot:\ndefault: https://example.com\ndescription:  apiRoot as defined in clause 4.4 of 3GPP TS 29.501.\n\nexternalDocs:\ndescription: 3GPP TS 29.573 V18.1.0; 5G System; Public Land Mobile Network (PLMN) Interconnection; Stage 3\nurl: https://www.3gpp.org/ftp/Specs/archive/29_series/29.573/\n\npaths:\n/mapping:\nget:\nsummary: Maps an FQDN to/from a telescopic FQDN\noperationId: GetTelescopicMapping\ntags:\n- Telescopic Mapping (Document)\nparameters:\n- name: foreign-fqdn\nin: query\ndescription: FQDN of the NF in the foreign PLMN\nschema:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\n- name: telescopic-label\nin: query\ndescription: Telescopic Label\nschema:\ntype: string\nresponses:\n'200':\ndescription: Expected response to a valid request\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/TelescopicMapping'\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'401':\n$ref: 'TS29571_CommonData.yaml#/components/responses/401'\n'403':\n$ref: 'TS29571_CommonData.yaml#/components/responses/403'\n'404':\n$ref: 'TS29571_CommonData.yaml#/components/responses/404'\n'429':\n$ref: 'TS29571_CommonData.yaml#/components/responses/429'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\n'502':\n$ref: 'TS29571_CommonData.yaml#/components/responses/502'\n'503':\n$ref: 'TS29571_CommonData.yaml#/components/responses/503'\ndefault:\n$ref: 'TS29571_CommonData.yaml#/components/responses/default'\n\ncomponents:\nschemas:\nTelescopicMapping:\ndescription: Contains the Telescopic mapping data\ntype: object\nproperties:\ntelescopicLabel:\ntype: string\nseppDomain:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\nforeignFqdn:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Fqdn'\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.1\tGeneral",
            "description": "This Annex provides some example encodings of HTTP/2 request and response messages initiated by NF service consumer / producer when they are reformatted and sent over N32-f\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.2\tInput Message Containing No Binary Part",
            "description": "Consider the following example:\n-\tSome headers of the input HTTP/2 message need to be integrity protected and ciphered.\n-\tSome content part of the input HTTP/2 message need to be integrity protected and ciphered.\n-\tThe input HTTP/2 message has no multipart/related binary content.\n-\tThe headers and content that are not required to be integrity protected and ciphered in the input HTTP/2 message need to be only integrity protected.\n\nThe N32fReformattedReqMessage for this example looks like\n\"reformattedData\": {\n\"protected\": BASE64URL(UTF8(JWE Protected Header),\n\"unprotected\": <non integrity protected shared JOSE headers>,\n\"header\": <non integrity protected recipient specific JOSE headers>,\n\"encrypted_key\": BASE64URL(JWE Encrypted Key),\n\"aad\": BASE64URL(DataToIntegrityProtectBlock),\n\"iv\": BASE64URL(JWE Initialization Vector),\n\"ciphertext\": BASE64URL(JWE CipherText(DataToIntegrityProtectAndCipherBlock),\n\"tag\": BASE64URL(JWE Authentication Tag)\n}\nThe DataToIntegrityProtectBlock for this example looks like\n{\n\"metaData\":\n{\n\"n32fContextId\": <the n32fcontext Id of receiving SEPP>,\n\"messageId\": <Id of the message>,\n\"authorizedIpxId\": <FQDN of the IPX>\n},\n\"requestLine\":\n{\n\"method\": <http method of the NF service API>,\n\"scheme\": <http scheme of the NF service API>,\n\"authority\": <authority part of the NF service API URI>,\n\"path\": <path part of the NF service API URI>,\n\"protocolVersion\": <HTTP protocol version>,\n\"queryFragment\": <query fragment of the NF service API, if available>\n},\n\"headers\":\n[\n{\n\"header\": <name of HTTP header 1>,\n\"value\": {\"headerval\": <string carrying value of the header>}\n},\n{\n\"header\": <name of HTTP header 2>,\n\"value\": {\"encBlockIndex\": 1}\n}\n],\n\"payload\":\n[\n{\n\"iePath\": <JSON Pointer of IE 1>,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of IE>\n},\n{\n\"iePath\": <JSON Pointer of IE 2>,\n\"ieValueLocation\": \"BODY\",\n\"value\": {\"encBlockIndex\": 2}\n}\n]\n}\n\nThe DataToIntegrityProtectAndCipherBlock for this example looks like\n{\n\"dataToEncrypt\":\n[\n<value of HTTP header 2>,\n<value of payload 2>\n]\n}\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.3\tInput Message Containing Multipart Binary Part",
            "description": "Consider the following example:\n-\tSome headers of the input HTTP/2 message need to be integrity protected and ciphered.\n-\tSome content part of the input HTTP/2 message need to be integrity protected and ciphered.\n-\tThe input HTTP/2 message has two multipart/related binary content out of which one binary content needs to be integrity protected and ciphered while the other is only required to be integrity protected.\n-\tThe headers and content that are not required to be integrity protected and ciphered in the input HTTP/2 message need to be only integrity protected.\n\nThe N32fReformattedReqMessage for this example looks like\n\"reformattedData\": {\n\"protected\": BASE64URL(UTF8(JWE Protected Header),\n\"unprotected\": <non integrity protected shared JOSE headers>,\n\"header\": <non integrity protected recipient specific JOSE headers>,\n\"encrypted_key\": BASE64URL(JWE Encrypted Key),\n\"aad\": BASE64URL(DataToIntegrityProtectBlock),\n\"iv\": BASE64URL(JWE Initialization Vector),\n\"ciphertext\": BASE64URL(JWE CipherText(DataToIntegrityProtectAndCipherBlock),\n\"tag\": BASE64URL(JWE Authentication Tag)\n}\nThe DataToIntegrityProtectBlock for this example looks like\n{\n\"metaData\":\n{\n\"n32fContextId\": <the n32fcontext Id of receiving SEPP>,\n\"messageId\": <Id of the message>,\n\"authorizedIpxId\": <FQDN of the IPX>\n},\n\"requestLine\":\n{\n\"method\": <http method of the NF service API>,\n\"scheme\": <http scheme of the NF service API>,\n\"authority\": <authority part of the NF service API URI>,\n\"path\": <path part of the NF service API URI>,\n\"protocolVersion\": <HTTP protocol version>,\n\"queryFragment\": <query fragment of the NF service API, if available>\n},\n\"headers\":\n[\n{\n\"header\": <name of HTTP header 1>,\n\"value\": {\"headerval\": <string carrying value of the header>}\n},\n{\n\"header\": <name of HTTP header 2>,\n\"value\": {\"encBlockIndex\": 1}\n}\n],\n\"payload\":\n[\n{\n\"iePath\": <JSON Pointer of IE 1>,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of IE>\n},\n{\n\"iePath\": <JSON Pointer of IE 2 - which is an attribute defined with the RefToBinaryData type>/contentId,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of the Content ID>\n},\n{\n\"iePath\": <JSON Pointer of IE 2 - which is an attribute defined with the RefToBinaryData type>/contenttype,\n\"ieValueLocation\": \"MULTIPART_BINARY\",\n\"value\": <value of the Content Type>\n},\n{\n\"iePath\": <JSON Pointer of IE 2 - which is an attribute defined with the RefToBinaryData type>/data,\n\"ieValueLocation\": \"MULTIPART_BINARY\",\n\"value\": <BASE 64 encoded byte array of the binary part>\n}\n{\n\"iePath\": <JSON Pointer of IE 3 - which is an attribute defined with the RefToBinaryData type>/contentId,\n\"ieValueLocation\": \"BODY\",\n\"value\": <value of the Content ID>\n},\n{\n\"iePath\": <JSON Pointer of IE 3 - which is an attribute defined with the RefToBinaryData type>/contenttype,\n\"ieValueLocation\": \"MULTIPART_BINARY\",\n\"value\": <value of the Content Type>\n},\n{\n\"iePath\": <JSON Pointer of IE 3 - which is an attribute defined with the RefToBinaryData type>/data,\n\"ieValueLocation\": \"MULTIPART_BINARY\",\n\"value\": {\"encBlockIndex\": 2}\n}\n]\n}\n\nNOTE:\tThe \"iePath\" for Content Type or data is a virtual path, which actually refers to the \"Content-Type\" and \"data\" in multipart body.\nEXAMPLE:\tIf the input HTTP message contains multipart binary part, as:\n\nPOST /example.com/namf-comm/v1/ue-contexts/{ueContextId}/n1-n2-messages HTTP/2\nContent-Type: multipart/related; boundary=----Boundary\nContent-Length: xyz\n\n------Boundary\nContent-Type: application/json\n\n{\n    \"n2InfoContainer\": {\n      \"n2InformationClass\": \"SM\",\n      \"smInfo\": {\n        \"pduSessionId\": 5,\n        \"n2InfoContent\": {\n          \"ngapIeType\": \"PDU_RES_SETUP_REQ\",\n          \"ngapData\": {\n            \"contentId\": \"n2msg\"\n          }\n        }\n      }\n    },\n    \"pduSessionId\": 5\n}\n------Boundary\nContent-Type: application/vnd.3gpp.ngap\nContent-Id: n2msg\n\n{ … N2 Information binary data …}\n------Boundary\n\nthe binary content needs to be integrity protected will be formatted, as:\n\n\"payload\":\n  [\n    {\n      \"iePath\": \"/n2InfoContainer/smInfo/n2InfoContent/ngapData/contentId\",\n      \"ieValueLocation\": \"BODY\",\n      \"value\": \"n2msg\"\n    },\n    {\n      \"iePath\": \"/n2InfoContainer/smInfo/n2InfoContent/ngapData/contenttype\",\n      \"ieValueLocation\": \"MULTIPART_BINARY\",\n      \"value\": \"application/vnd.3gpp.ngap\"\n    },\n    {\n      \"iePath\": \"/n2InfoContainer/smInfo/n2InfoContent/ngapData/data\",\n      \"ieValueLocation\": \"MULTIPART_BINARY\",\n      \"value\": <BASE 64 encoded byte array of N2 Information binary data >\n    }\n  ]\n\nThe DataToIntegrityProtectAndCipherBlock for this example looks like\n{\n\"dataToEncrypt\":\n[\n<value of HTTP header 2>,\n<byte array containing BASE 64 encoding of the binary part>\n]\n}\n\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.1\tGeneral",
            "description": "This Annex provides an informative reference for how the end to end call flow works when the NF service consumer and the NF service producer are in different PLMNs and SEPP is involved on path.\nThe following clauses explain how the HTTP messages are forwarded between NF services in two PLMNs via the SEPP. In these clauses, the following aspects are not shown to avoid cluttering of the figures and procedure:\n-\tResolution of FQDN into an IP address using DNS. TCP / TLS connection for sending the HTTP/2 messages is initiated towards the IP address obtained from DNS resolution.\nWhen https URI scheme is used, TLS protection between the Network Function and the SEPP may rely on using telescopic FQDN or 3gpp-Sbi-Target-apiRoot header. See clause 6.1.4.3 of 3GPP TS 29.500 [4].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.2\tTLS security between SEPPs",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "C.2.1\tWhen http URI scheme is used",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "C.2.1.1\tGeneral",
                            "text_content": "The following figure shows the end to end call flow between an NF service consumer and a NF service producer in different PLMNs when:\n-\tthe SEPP in each PLMN acts as a security proxy;\n-\tthe negotiated security policy between the SEPPs is TLS;\n-\t\"http\" scheme URI is used between the NF service consumer and NF service producer; and\n-\t\"http\" scheme URI is used for accessing NRF's NF discovery service.\nNOTE:\tThere may be one or more IPX(s), offering only IP routing serving without content modification or observation of the information, in between the SEPPs.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "C.2.1.2\tWithout TLS protection between NF and SEPP and with TLS security without the 3gpp-Sbi-Target-apiRoot header used over N32f",
                            "text_content": "\n\nFigure C.2.1.2-1: End to end call flow when http scheme URI is used and TLS security without the 3gpp-Sbi-Target-apiRoot header used is used between SEPPs\n1.\tThe SEPP on the NF service consumer side (c-SEPP) and the SEPP on the NF service producer side (p-SEPP) negotiate the security capabilities using the procedure specified in clause 5.2.2. The SEPPs mutually negotiate to use TLS as the security policy.\n2.\tA TLS connection is setup between the c-SEPP and the p-SEPP for N32-f forwarding.\n3.\tBefore the NF service consumer starts using the API of the NF service producer it needs to discover the NF service profile of the producer by querying the NRF. The NF service consumer uses \"http\" scheme URI to access the Nnrf_NFDiscovery service.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF is configured to route all HTTP messages with inter PLMN FQDN as the \"authority\" part of the URI via the c-SEPP. The c-SEPP acts as a HTTP proxy.\n5.\tThe c-SEPP forwards the NF discovery request within the N32-f TLS tunnel established in step 2.\n6.\tThe p-SEPP forwards the NF discovery request to the p-NRF.\n7.\tThe p-NRF sends the NF discovery response. The NF service profile contains service URI with \"http\" scheme. The FQDN of the NF service is an inter PLMN FQDN.\n8.\tThe p-SEPP forwards the NF discovery response within TLS tunnel to the c-SEPP.\n9.\tThe c-SEPP forwards the NF discovery response to c-NRF.\n10.\tThe c-NRF sends the NF discovery response to NF service consumer.\n11.\tThe NF service profile received at the NF service consumer contains service URI with \"http\" scheme. The NF service consumer initiates a HTTP message (as supported by the NF service producer API) using \"http\" scheme URI. The NF service consumer is configured to route all HTTP messages with inter PLMN FQDN as the \"authority\" part of the URI via the c-SEPP. The c-SEPP acts as a HTTP proxy.\n12.\tThe c-SEPP forwards the HTTP service request within the N32-f TLS tunnel established in step 2.\n13.\tThe p-SEPP forwards the HTTP service request to the NF service producer.\n14.\tThe NF service producer sends the HTTP service response.\n15.\tThe p-SEPP forwards the HTTP service response within TLS tunnel to the c-SEPP.\n16.\tThe c-SEPP forwards the HTTP service response to the NF service consumer.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "C.2.1.3\tWithout TLS protection between NF and SEPP and with TLS security with the 3gpp-Sbi-Target-apiRoot header used over N32f",
                            "text_content": "\nFigure C.2.1.3-1: End to end call flow when http scheme URI is used and TLS security with the 3gpp-Sbi-Target-apiRoot header used is used between SEPPs\n1.\tSame as step 1 of Figure C.2.1.2-1.\n2.\tSame as step 3 of Figure C.2.1.2-1\n3.\tSame as step 4 of Figure C.2.1.2-1\n4.\tThe c-SEPP setups a TLS connection with the authoritative server for the p-SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the p-SEPP. The c-SEPP is configured with the p-SEPP FQDN.\n5.\tThe c-SEPP sets the apiRoot in the request URI with the apiRoot of the p-SEPP, inserts the 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NRF, and sends the request towards p-SEPP.\n6.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"http\", the p-SEPP forwards the NF discovery request to the p-NRF.\n7 to 11.\tSame as steps 7 to 11 of Figure C.2.1.2-1.\n12.\tThe c-SEPP sets the apiRoot of the p-SEPP FQDN in the request URI, inserts the 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NF, and sends the request towards p-SEPP.\n13.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NF received in the 3gpp-Sbi-Target-apiRoot header and then seeing that the URI scheme of the NF service producer is \"http\", the p-SEPP forwards the request to the p-NF.\n13 to 16. Same as steps 13 to 16 of Figure C.2.1.2-1.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "C.2.2\tWhen https URI scheme is used",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "C.2.2.1\tGeneral",
                            "text_content": "The following figures show the end to end call flow between an NF service consumer and a NF service producer in different PLMNs when:\n-\tthe SEPP in each PLMN acts as a security proxy;\n-\tthe negotiated security policy between the SEPPs is TLS;\n-\t\"https\" scheme URI is used between the NF service consumer and NF service producer;\n-\t\"https\" scheme URI is used for accessing NRF's NF discovery service; and\n-\tTLS protection between NF and SEPP relies on using telescopic FQDN or 3gpp-Sbi-Target-apiRoot header.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "C.2.2.2\tWith TLS protection between NF and SEPP relying on telescopic FQDN, and TLS security without the 3gpp-Sbi-Target-apiRoot header used over N32f",
                            "text_content": "\n\nFigure C.2.2.2-1: End to end call flow when https scheme URI is used, telescopic FQDNs are used between NF and SEPP and TLS security without the 3gpp-Sbi-Target-apiRoot header is used between SEPPs\n1.\tThe SEPP on the NF service consumer side (c-SEPP) and the SEPP on the NF service producer side (p-SEPP) negotiate the security capabilities using the procedure specified in clause 5.2.2. The SEPPs mutually negotiate to use TLS as the security policy.\n2.\tA TLS connection is setup between the c-SEPP and the p-SEPP for N32-f forwarding.\n3.\tBefore the NF service consumer starts using the API of the NF service producer it needs to discover the NF service profile of the producer by querying the NRF. The NF service consumer uses \"https\" scheme URI to access the Nnrf_NFDiscovery service. This implies that the NF service consumer sets up a TLS connection to the c-NRF and then sends the HTTP request over the TLS connection to the c-NRF.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. Since \"https\" requires setup of TLS connection with the p-NRF and it requires that c-NRF has to verify that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the p-NRF, a telescopic FQDN with wildcarded certificate scheme mechanism is specified in 3GPP TS 33.501 [6]. The c-NRF is configured with the telescopic FQDN of the p-NRF with the telescopic FQDN having the FQDN of the c-SEPP as the trailing part. The c-NRF sets up a TLS connection with the authoritative server for the telescopic FQDN (i.e. the c-SEPP).\n5.\tThe c-NRF forwards the NF discovery request in this TLS connection.\n6.\tThe c-SEPP extracts the NF discovery request from the TLS connection, replaces the telescopic FQDN in the request URI with the FQDN of the p-NRF and sends the request towards p-SEPP in the TLS tunnel setup in step 2. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF discovery service of the p-NRF is in the request URI \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8.\tThe p-SEPP forwards the NF discovery request to the p-NRF.\n9.\tThe p-NRF sends the NF discovery response within the TLS connection. The NF service profile contains service URI with \"https\" scheme. The FQDN of the NF service is an inter PLMN FQDN.\n10.\tThe p-SEPP forwards the NF discovery response within TLS tunnel setup in step 2 to the c-SEPP. The p-SEPP may replace the inter PLMN FQDN of the NF service producer's API endpoint with a label representing that FQDN. The p-SEPP re-maps the label with the NF service producer's API endpoint in step 17.\n11.\tThe c-SEPP upon receiving the HTTP response message for NF discovery response, within the TLS tunnel in step 2, replaces the trailing part of the inter PLMN FQDN of the NF service producer's API endpoint in the NF service profile with the FQDN of the c-SEPP, to form a telescopic FQDN as specified in clause 28.5.2 of 3GPP TS 23.003 [19]. The c-SEPP may replace the label part of the telescopic FQDN with a label of it's own significance. The p-SEPP re-maps the label in step 16.\n12.\tThe c-SEPP then forwards the NF discovery response to c-NRF, with the NF service profile containing the telescopic FQDN.\n13.\tThe c-NRF sends the NF discovery response to NF service consumer.\n14.\tThe NF service profile received at the NF service consumer contains service URI with \"https\" scheme. The NF service consumer sets up a TLS connection with the authoritative server for the telescopic FQDN (i.e. c-SEPP) received in step 13.\n15.\tThe NF service consumer sends the HTTP service request within the TLS connection to the c-SEPP.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the telescopic FQDN in the request URI the FQDN of the NF service producer and sends the request towards p-SEPP in the TLS tunnel setup in step 2. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF service producer in the request URI is \"https\", the p-SEPP sets up a TLS connection with the NF service producer. The p-SEPP also replaces callback URI and link relations within the extracted HTTP message with a telescopic FQDN containing the FQDN of the p-SEPP as the trailing part, as specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\n18.\tThe p-SEPP forwards the HTTP request to the NF service producer.\n19.\tThe NF service producer sends the HTTP response within the TLS connection.\n20.\tThe p-SEPP forwards the HTTP response within TLS tunnel setup in step 2 to the c-SEPP.\n21.\tThe c-SEPP upon receiving the HTTP response message within the TLS tunnel setup in step 2, forwards the response to the NF service consumer. The c-SEPP replaces callback URI and link relations within the extracted HTTP response message with a telescopic FQDN containing the FQDN of the c-SEPP as the trailing part, as specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "C.2.2.3\tWith TLS protection between NF and SEPP relying on 3gpp-Sbi-Target-apiRoot header, and TLS security without the 3gpp-Sbi-Target-apiRoot header used over N32f",
                            "text_content": "\nFigure C.2.2.3-1 End to end call flow when https scheme URI is used, 3gpp-Sbi-Target-apiRoot header is used between NF and SEPP and TLS security without the 3gpp-Sbi-Target-apiRoot header is used between SEPPs\n1.\tSame as step 1 of Figure C.2.2.2-1.\n2.\tSame as step 2 of Figure C.2.2.2-1.\n3.\tSame as step 3 of Figure C.2.2.2-1\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. The c-NRF setups a TLS connection with the authoritative server for the SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the c-SEPP. The c-NRF is configured with the c-SEPP FQDN, or the c-SEPP registered to the c-NRF (including c-SEPP FQDN in its profile).\n5.\tThe c-NRF forwards the NF discovery request in this TLS connection, including an 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NRF.\n6.\tThe c-SEPP extracts the NF discovery request from the TLS connection, replaces the apiRoot of the SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header and sends the request towards p-SEPP in the TLS tunnel setup in step 2. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8.\tSame as step 8 of Figure C.2.2.2-1\n9.\tSame as step 9 of Figure C.2.2.2-1\n10.\tSame as step 10 of Figure C.2.2.2-1\n11, 12.\tThe c-SEPP forwards the NF discovery response to c-NRF.\n13.\tSame as step 13 of Figure C.2.2.2-1\n14.\tThe NF service profile received at the NF service consumer contains service URI with \"https\" scheme. Since the URI of the p-NF contains an authority of a remote PLMN, the NF service consumer sets up a TLS connection with the authoritative server for the SEPP FQDN (i.e. c-SEPP). The c-NF is configured with the c-SEPP FQDN, or the c-NF discovers the c-SEPP FQDN by querying the c-NRF.\n15.\tThe NF service consumer sends the HTTP service request within the TLS connection to the c-SEPP, including a 3pp-Sbi-Target-apiRoot header set to the apiRoot of the p-NF.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the apiRoot of the SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header and sends the request towards p-SEPP in the TLS tunnel setup in step 2. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection and then seeing that the URI scheme of the NF service producer is \"https\", the p-SEPP sets up a TLS connection with the NF service producer.\n18.\tSame as step 18 of Figure C.2.2.2-1\n19.\tSame as step 19 of Figure C.2.2.2-1\n20.\tSame as step 20 of Figure C.2.2.2-1\n21.\tThe c-SEPP upon receiving the HTTP response message within the TLS tunnel setup in step 2, forwards the response to the NF service consumer.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "C.2.2.4\tWith TLS protection between NF and SEPP relying on telescopic FQDN, and TLS security with the 3gpp-Sbi-Target-apiRoot header used over N32f",
                            "text_content": "\n\nFigure C.2.2.4-1: End to end call flow when https scheme URI is used, telescopic FQDNs are used between NF and SEPP and TLS security with the 3gpp-Sbi-Target-apiRoot header is used between SEPPs\n1.\tSame as step 1 of Figure C.2.2.2-1.\n2.\tSame as step 3 of Figure C.2.2.2-1.\n3.\tSame as step 4 of Figure C.2.2.2-1.\n4. Same as step 5 of Figure C.2.2.2-1\n5.\tThe c-SEPP setups a TLS connection with the authoritative server for the p-SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the p-SEPP. The c-SEPP is configured with the p-SEPP FQDN.\n6.\tThe c-SEPP sets the apiRoot in the request URI with the apiRoot of the p-SEPP, inserts the 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NRF derived from the telescopic FQDN received in step 4, and sends the request towards p-SEPP.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8 to 15.\tSame as steps 8 to 15 of Figure C.2.2.3-1.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, sets the apiRoot of the p-SEPP FQDN in the request URI, inserts the 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NF derived from the telescopic FQDN received in step 15, and sends the request towards p-SEPP.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NF received in the 3gpp-Sbi-Target-apiRoot header and then seeing that the URI scheme of the NF service producer is \"https\", the p-SEPP sets up a TLS connection with the NF service producer.\n18 to 21.\tSame as steps 18 to 21 of Figure C.2.2.2-1\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "C.2.2.5\tWith TLS protection between NF and SEPP relying on 3gpp-Sbi-Target-apiRoot header, and TLS security with the 3gpp-Sbi-Target-apiRoot header used over N32f",
                            "text_content": "\nFigure C.2.2.5-1: End to end call flow when https scheme URI is used, 3gpp-Sbi-Target-apiRoot header is used between NF and SEPP and TLS security with the 3gpp-Sbi-Target-apiRoot header is used between SEPPs\n1.\tSame as step 1 of Figure C.2.2.3-1.\n2.\tSame as step 3 of Figure C.2.2.3-1\n3.\tSame as step 4 of Figure C.2.2.3-1\n4.\tSame as step 5 of Figure C.2.2.3-1.\n5.\tThe c-SEPP setups a TLS connection with the authoritative server for the p-SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the p-SEPP. The c-SEPP is configured with the p-SEPP FQDN.\n6.\tThe c-SEPP sets the apiRoot in the request URI with the apiRoot of the p-SEPP and sends the request towards p-SEPP including the 3gpp-Sbi-Target-apiRoot header received in step 4.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8 to 15.\tSame as steps 8 to 15 of Figure C.2.2.3-1.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the apiRoot of the c-SEPP FQDN in the request URI with the apiRoot of the p-SEPP, and sends the request towards p-SEPP including the 3gpp-Sbi-Target-apiRoot header received in step 15.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, replaces the apiRoot of the p-SEPP FQDN in the request URI with the apiRoot of the p-NF received in the 3gpp-Sbi-Target-apiRoot header and then seeing that the URI scheme of the NF service producer is \"https\", the p-SEPP sets up a TLS connection with the NF service producer.\n18 to 21.\tSame as steps 18 to 21 of Figure C.2.2.2-1\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "C.3\tApplication Layer Security between SEPPs",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "C.3.1\tWhen http URI scheme is used",
                    "description": "",
                    "summary": "",
                    "text_content": "The following figure shows the end to end call flow between an NF service consumer and a NF service producer in different PLMNs when:\n-\tthe SEPP in each PLMN acts as a security proxy;\n-\tthe negotiated security policy between the SEPPs is \"PRINS\";\n-\t\"http\" scheme URI is used between the NF service consumer and NF service producer; and\n-\t\"http\" scheme URI is used for accessing NRF's NF discovery service.\n\n\n\nFigure C.3.1-1 End to end call flow when http scheme URI is used and \"PRINS\" security is used between SEPPs\n1.\tThe SEPP on the NF service consumer side (c-SEPP) and the SEPP on the NF service producer side (p-SEPP) negotiate the security capabilities using the procedure specified in clause 5.2.2. The SEPPs mutually negotiate to use \"PRINS\" as the security policy.\n2.\tA TLS connection is setup between the c-SEPP and the p-SEPP for N32-f forwarding. If IPX-es are deployed between the c-SEPP and p-SEPP, the TLS connection is set up hop by hop with the authoritative server of the next hop.\n3.\tBefore the NF service consumer starts using the API of the NF service producer it needs to discover the NF service profile of the producer by querying the NRF. The NF service consumer uses \"http\" scheme URI to access the Nnrf_NFDiscovery service.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF is configured to route all HTTP messages with inter PLMN FQDN as the \"authority\" part of the URI via the c-SEPP. The c-SEPP acts as a HTTP proxy.\n5.\tThe c-SEPP forwards the NF discovery request within the N32-f TLS tunnel established in step 2 and using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header.\n6.\tThe p-SEPP forwards the NF discovery request to the p-NRF.\n7.\tThe p-NRF sends the NF discovery response. The NF service profile contains service URI with \"http\" scheme. The FQDN of the NF service is an inter PLMN FQDN.\n8.\tThe p-SEPP forwards the NF discovery response within TLS tunnel to the c-SEPP using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively.\n9.\tThe c-SEPP forwards the NF discovery response to c-NRF.\n10.\tThe c-NRF sends the NF discovery response to NF service consumer.\n11.\tThe NF service profile received at the NF service consumer contains service URI with \"http\" scheme. The NF service consumer initiates a HTTP message (as supported by the NF service producer API) using \"http\" scheme URI. The NF service consumer is configured to route all HTTP messages with inter PLMN FQDN as the \"authority\" part of the URI via the c-SEPP. The c-SEPP acts as a HTTP proxy.\n12.\tThe c-SEPP forwards the HTTP service request within the N32-f TLS tunnel established in step 2 and using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header.\n13.\tThe p-SEPP forwards the HTTP service request to the NF service producer.\n14.\tThe NF service producer sends the HTTP service response.\n15.\tThe p-SEPP forwards the HTTP service response within TLS tunnel to the c-SEPP using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively.\n16.\tThe c-SEPP forwards the HTTP service response to the NF service consumer.\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "C.3.2\tWhen https URI scheme is used",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "C.3.2.1\tGeneral",
                            "text_content": "The following figure shows the end to end call flow between an NF service consumer and a NF service producer in different PLMNs when:\n-\tthe SEPP in each PLMN acts as a security proxy;\n-\tthe negotiated security policy between the SEPPs is \"PRINS\";\n-\t\"https\" scheme URI is used between the NF service consumer and NF service producer; and\n-\t\"https\" scheme URI is used for accessing NRF's NF discovery service; and\n-\tTLS protection between NF and SEPP relies on using telescopic FQDN or 3gpp-Sbi-Target-apiRoot header.\nWhen https URI scheme is used, TLS protection between the Network Function and the SEPP may rely on using telescopic FQDN or 3gpp-Sbi-Target-apiRoot header. See clause 6.1.4.3 of 3GPP TS 29.500 [4].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "C.3.2.2\tWith TLS protection between NF and SEPP relying on telescopic FQDN",
                            "text_content": "\nFigure C.3.2.2-1 End to end call flow when https scheme URI is used, telescopic FQDNs are used between NF and SEPP and \"PRINS\" security is used between SEPPs\n1.\tThe SEPP on the NF service consumer side (c-SEPP) and the SEPP on the NF service producer side (p-SEPP) negotiate the security capabilities using the procedure specified in clause 5.2.2. The SEPPs mutually negotiate to use \"PRINS\" as the security policy.\n2.\tA TLS connection is setup between the c-SEPP and the p-SEPP for N32-f forwarding. If IPX-es are deployed between the c-SEPP and p-SEPP, the TLS connection is set up hop by hop with the authoritative server of the next hop.\n3.\tBefore the NF service consumer starts using the API of the NF service producer it needs to discover the NF service profile of the producer by querying the NRF. The NF service consumer uses \"https\" scheme URI to access the Nnrf_NFDiscovery service. This implies that the NF service consumer sets up a TLS connection to the c-NRF and then sends the HTTP request over the TLS connection to the c-NRF.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. Since \"https\" requires setup of TLS connection with the p-NRF and it requires that c-NRF has to verify that the certificate presented by the endpoint of the TLS connection belngs to the authoritative server of the p-NRF, a telescopic FQDN with wildcarded certificate scheme mechanism is specified in 3GPP TS 33.501 [6]. The c-NRF is configured with the telescopic FQDN of the p-NRF with the telescopic FQDN having the FQDN of the c-SEPP as the trailing part. The c-NRF sets up a TLS connection with the authoritative server for the telescopic FQDN (i.e. the c-SEPP).\n5.\tThe c-NRF forwards the NF discovery request in this TLS connection.\n6.\tThe c-SEPP extracts the NF discovery request from the TLS connection, replaces the telescopic FQDN in the request URI with the FQDN of the p-NRF and sends the request towards p-SEPP in the TLS tunnel setup in step 2 and using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF discovery service of the p-NRF in the request URI is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8.\tThe p-SEPP forwards the NF discovery request to the p-NRF.\n9.\tThe p-NRF sends the NF discovery response within the TLS connection. The NF service profile contains service URI with \"https\" scheme. The FQDN of the NF service is an inter PLMN FQDN.\n10.\tThe p-SEPP forwards the NF discovery response within TLS tunnel setup in step 2 using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively, to the c-SEPP. The p-SEPP may replace the inter PLMN FQDN of the NF service producer's API endpoint with a label representing that FQDN. The p-SEPP re-maps the label with the NF service producer's API endpoint in step 17.\n11.\tThe c-SEPP upon receiving the HTTP response message for NF discovery response, within the TLS tunnel in step 2, replaces the trailing part of the inter PLMN FQDN of the NF service producer's API endpoint in the NF service profile with the FQDN of the c-SEPP, to form a telescopic FQDN as specified in clause 28.5.2 of 3GPP TS 23.003 [19]. The c-SEPP may replace the label part of the telescopic FQDN with a label of it's own significance. The p-SEPP re-maps the label in step 16.\n12.\tThe c-SEPP then forwards the NF discovery response to c-NRF, with the NF service profile containing the telescopic FQDN.\n13.\tThe c-NRF sends the NF discovery response to NF service consumer.\n14.\tThe NF service profile received at the NF service consumer contains service URI with \"https\" scheme. The NF service consumer sets up a TLS connection with the authoritative server for the telescopic FQDN (i.e. the c-SEPP).\n15.\tThe NF service consumer sends the HTTP service request within the TLS connection to the c-SEPP.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the the telescopic FQDN in the request URI with the FQDN of the NF service producer and sends the request towards p-SEPP in the TLS tunnel setup in step 2 using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF service producer in the request URI is \"https\", the p-SEPP sets up a TLS connection with the NF service producer. The p-SEPP also replaces callback URI and link relations within the extracted HTTP message with a telescopic FQDN containing the FQDN of the p-SEPP as the trailing part, as specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\n18.\tThe p-SEPP forwards the HTTP request to the NF service producer.\n19.\tThe NF service producer sends the HTTP response within the TLS connection.\n20.\tThe p-SEPP forwards the HTTP response within TLS tunnel setup in step 2 to the c-SEPP using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively.\n21.\tThe c-SEPP upon receiving the HTTP response message within the TLS tunnel setup in step 2, forwards the response to the NF service consumer. The c-SEPP replaces callback URI and link relations within the extracted HTTP response message with a telescopic FQDN containing the FQDN of the c-SEPP as the trailing part, as specified in clause 6.1.4.3 of 3GPP TS 29.500 [4].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "C.3.2.3\tWith TLS protection between NF and SEPP relying on 3gpp-Sbi-Target-apiRoot header",
                            "text_content": "\n\nFigure C.3.2.3-1 End to end call flow when https scheme URI is used, 3gpp-Sbi-Target-apiRoot header is used between NF and SEPP and \"PRINS\" security is used between SEPPs\n1.\tSame as step 1 of Figure C.3.2.2-1.\n2.\tSame as step 2 of Figure C.3.2.2-1.\n3.\tSame as step 3 of Figure C.3.2.2-1.\n4. The NRF on the NF service consumer side (c-NRF) needs to further initiate a discovery request to the NRF on the NF service producer side (p-NRF). The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. The c-NRF uses \"https\" scheme URI to access the NF discovery service of the p-NRF. The c-NRF setups a TLS connection with the authoritative server for the SEPP FQDN (in the apiRoot of the Request URI) and verifies that the certificate presented by the endpoint of the TLS connection belongs to the authoritative server of the c-SEPP. The c-NRF is configured with the c-SEPP FQDN, or the c-SEPP registered to the c-NRF (including c-SEPP FQDN in its profile).\n5.\tThe c-NRF forwards the NF discovery request in this TLS connection, including an 3gpp-Sbi-Target-apiRoot header set to the apiRoot of the p-NRF.\n6.\tThe c-SEPP extracts the NF discovery request from the TLS connection, replaces the apiRoot of the SEPP FQDN in the request URI with the apiRoot of the p-NRF received in the 3gpp-Sbi-Target-apiRoot header and sends the request towards p-SEPP in the TLS tunnel setup in step 2 and using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case.\n7.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF discovery service of the p-NRF is \"https\", the p-SEPP sets up a TLS connection with the p-NRF.\n8.\tSame as step 8 of Figure C.3.2.2-1.\n9.\tSame as step 9 of Figure C.3.2.2-1.\n10.\tSame as step 10 of Figure C.3.2.2-1.\n11, 12.\tThe c-SEPP forwards the NF discovery response to c-NRF.\n13.\tSame as step 13 of Figure C.3.2.2-1.\n14.\tThe NF service profile received at the NF service consumer contains service URI with \"https\" scheme. Since the URI of the p-NF contains an authority of a remote PLMN, the NF service consumer sets up a TLS connection with the authoritative server for the SEPP FQDN (i.e. c-SEPP). The c-NF is configured with the c-SEPP FQDN, or the c-NF discovers the c-SEPP FQDN by querying the c-NRF.\n15.\tThe NF service consumer sends the HTTP service request within the TLS connection to the c-SEPP, including a 3pp-Sbi-Target-apiRoot header set to the apiRoot of the p-NF.\n16.\tThe c-SEPP extracts the HTTP request from the TLS connection, replaces the apiRoot of the SEPP FQDN in the request URI with the apiRoot of the p-NF received in the 3gpp-Sbi-Target-apiRoot header and sends the request towards p-SEPP in the TLS tunnel setup in step 2 using the JOSE protected message forwarding procedure and API specified in clauses 5.3 and 6.2 respectively. The c-SEPP and the p-SEPP act as a man in the middle proxy in this case. The apiRoot of the Request URI of the HTTP request shall contain the apiRoot of p-SEPP. The HTTP request shall not contain any 3gpp-Sbi-Target-apiRoot header.\n17.\tThe p-SEPP extracts the HTTP message received on the TLS connection, and then seeing that the URI scheme of the NF service producer is \"https\", the p-SEPP sets up a TLS connection with the NF service producer.\n18.\tSame as step 18 of Figure C.3.2.2-1.\n19.\tSame as step 19 of Figure C.3.2.2-1.\n20.\tSame as step 20 of Figure C.3.2.2-1.\n21.\tThe c-SEPP upon receiving the HTTP response message within the TLS tunnel setup in step 2, forwards the response to the NF service consumer.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "D.1\tGeneral",
            "description": "This Annex lists withdrawn API versions of the APIs defined in the present specification. 3GPP TS 29.501 [5] clause 4.3.1.6 describes the withdrawal of API versions.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "D.2\tN32 Handshake API",
            "description": "The API versions listed in table D.2-1 are withdrawn for the N32 Handshake API.\nTable D.2-1: Withdrawn API versions of the N32 Handshake API service\n\n\n\n",
            "summary": "",
            "tables": [
                {
                    "description": "Table D.2-1: Withdrawn API versions of the N32 Handshake API service",
                    "table number": 88,
                    "summary": "",
                    "name": ""
                },
                {
                    "description": "",
                    "table number": 89,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        }
    ]
}