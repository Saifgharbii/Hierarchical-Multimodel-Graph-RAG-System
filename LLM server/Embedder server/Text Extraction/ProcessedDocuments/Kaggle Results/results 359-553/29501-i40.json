{
    "document_name": "29501-i40.docx",
    "content": [
        {
            "title": "Foreword",
            "description": "This Technical Specification has been produced by the 3rd Generation Partnership Project (3GPP).\nThe contents of the present document are subject to continuing work within the TSG and may change following formal TSG approval. Should the TSG modify the contents of the present document, it will be re-released by the TSG with an identifying change of release date and an increase in version number as follows:\nVersion x.y.z\nwhere:\nx\tthe first digit:\n1\tpresented to TSG for information;\n2\tpresented to TSG for approval;\n3\tor greater indicates TSG approved document under change control.\ny\tthe second digit is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc.\nz\tthe third digit is incremented when editorial only changes have been incorporated in the document.\nIn the present document, modal verbs have the following meanings:\nshall\tindicates a mandatory requirement to do something\nshall not\tindicates an interdiction (prohibition) to do something\nThe constructions \"shall\" and \"shall not\" are confined to the context of normative provisions, and do not appear in Technical Reports.\nThe constructions \"must\" and \"must not\" are not used as substitutes for \"shall\" and \"shall not\". Their use is avoided insofar as possible, and they are not used in a normative context except in a direct citation from an external, referenced, non-3GPP document, or so as to maintain continuity of style when extending or modifying the provisions of such a referenced document.\nshould\tindicates a recommendation to do something\nshould not\tindicates a recommendation not to do something\nmay\tindicates permission to do something\nneed not\tindicates permission not to do something\nThe construction \"may not\" is ambiguous and is not used in normative elements. The unambiguous constructions \"might not\" or \"shall not\" are used instead, depending upon the meaning intended.\ncan\tindicates that something is possible\ncannot\tindicates that something is impossible\nThe constructions \"can\" and \"cannot\" are not substitutes for \"may\" and \"need not\".\nwill\tindicates that something is certain or expected to happen as a result of action taken by an agency the behaviour of which is outside the scope of the present document\nwill not\tindicates that something is certain or expected not to happen as a result of action taken by an agency the behaviour of which is outside the scope of the present document\nmight\tindicates a likelihood that something will happen as a result of action taken by some agency the behaviour of which is outside the scope of the present document\nmight not\tindicates a likelihood that something will not happen as a result of action taken by some agency the behaviour of which is outside the scope of the present document\nIn addition:\nis\t(or any other verb in the indicative mood) indicates a statement of fact\nis not\t(or any other negative verb in the indicative mood) indicates a statement of fact\nThe constructions \"is\" and \"is not\" do not indicate requirements.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "1\tScope",
            "description": "The present document defines design principles and documentation guidelines for 5GC SBI APIs. These principles and guidelines should be followed when drafting the 5G System SBI Stage 3 specifications.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "2\tReferences",
            "description": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non-specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\t3GPP TS 29.500: \"5G System; Technical Realization of Service Based Architecture; Stage 3\".\n[3]\tIETF RFC 8259: \"The JavaScript Object Notation (JSON) Data Interchange Format\".\n[4]\tOpenAPI: \"OpenAPI Specification Version 3.0.0\", .\n[5]\t3GPP TS 29.571: \"5G System; Common Data Types for Service Based Interfaces Stage 3\".\n[6]\tIETF RFC 7231: \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\".\n[7]\tIETF RFC 7396: \"JSON Merge Patch\".\n[8]\tIETF RFC 6902: \"JavaScript Object Notation (JSON) Patch\".\n[9]\tIETF RFC 3986: \"Uniform Resource Identifier (URI): Generic Syntax\".\n[10]\tIETF RFC 5789: \"PATCH Method for HTTP\".\n[11]\tIETF RFC 8288: \"Web Linking\".\n[12]\tIANA: \"HTTP Status Code Registry at IANA\", .\n[13]\tIETF RFC 7540: \"Hypertext Transfer Protocol Version 2 (HTTP/2)\".\n[14]\tFielding, Roy Thomas. Architectural Styles and the Design of Network-based Software Architectures. Doctoral dissertation, University of California, Irvine, 2000.\n[15]\tErik Wilde, Cesare Pautasso, REST: From Research to Practice, Springer.\n[16]\tYAML 1.2: \"YAML Ain't Markup Language\", .\n[17]\tSemantic Versioning Specification: .\n[18]\t3GPP TS 29.510: \"5G System; Network Function Repository Services; Stage 3\".\n[19]\tIETF RFC 9457: \"Problem Details for HTTP APIs\".\n[20]\t3GPP TS 29.502: \"5G System; Session Management Services; Stage 3\".\n[21]\t3GPP TS 29.509: \"5G System; Authentication Server Services; Stage 3\".\n[22]\t3GPP TS 33.501: \"Security architecture and procedures for 5G system\".\n[23]\tIETF RFC 6749: \"The OAuth 2.0 Authorization Framework\".\n[24]\t3GPP TS 29.573: \"5G System; Public Land Mobile Network (PLMN) Interconnection;Stage 3\".\n[25]\t3GPP TR 21.900: \"Technical Specification Group working methods\".\n[26]\tIETF RFC 5234: \"Augmented BNF for Syntax Specifications: ABNF\".\n[27]\t3GPP TS 23.003: \"Numbering, addressing and identification\".\n[28]\t3GPP TS 29.503: \"5G System; Unified Data Management Services; Stage 3\".\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "3\tDefinitions and abbreviations",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "3.1\tDefinitions",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the terms and definitions given in 3GPP TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [1].\nAbsolute URI: Absolute URI follows generic URI syntax and consists of a hierarchical sequence of the following components: the \"scheme\", \"authority\", \"path\" and \"query\", i.e. excluding the \"fragment\" component. See clause 4.3 in IETF RFC 3986 [9].\napiRoot: apiRoot follows an absolute URI syntax, but excludes the following absolute URI identifiers: the \"query\" and \"fragment\" components. The API root contains the \"scheme\" and the \"authority\" components and may also contain an API prefix subcomponent. See clause 4.4.1. In 3GPP APIs, the default apiRoot value is \"\" (see e.g. Annex A.2 in 3GPP TS 29.502 [20]), where \"example.com\" is replaced by the operator specific FQDN (for FQDN examples see clause 28.3.2 in 3GPP TS 23.003 [27]).\nAPI Prefix: API prefix is an optional, deployment-specific string, which is a subcomponent of the \"apiRoot\". API prefix format follows \"path-absolute\" syntax and that starts with a \"/\" reserved character (see clause 4.4.1and also clause 3.3 in IETF RFC 3986 [9]). In 3GPP APIs, the default apiRoot does not contain API Prefix (see e.g. Annex A.2 in 3GPP TS 29.502 [20]).\nAPI URI: API URI has the following format: \"{apiRoot}/<apiName>/<apiVersion>\". For more details see clause 4.4.1. As an example, for the Nudm_SDM API defined in 3GPP TS 29.503 [28], the API URI is: \"{apiRoot}/nudm-sdm/v2\".\nBase URI: Base URI is used as a reference against which the relative URI reference is applied. See clause 4.6.1.1.1.2 and also clause 5.1 in IETF RFC 3986 [9]. As an example, for the resource URI of the SM contexts collection that is defined in Nsmf_PDUSession API (see 3GPP TS 29.502 [20]), the base URI is \"{apiRoot}/nsmf-pdusession/<apiVersion>\".\nCallback URI: Callback URI follows an absolute URI syntax, but excludes the following absolute URI identifiers: \"userinfo\" subcomponent of the \"authority\" component and also the \"query\" component (\"fragment\" component is already excluded from the absolute URI). Therefore, callback URI contains the \"scheme\", \"authority\" (excluding \"userinfo\" subcomponent) and the \"path\" components. See clause 4.4.3. As an example, for the Nsmf_PDUSession API defined in 3GPP TS 29.502 [20], \"smContextStatusUri\" is one of the callback references that can be provided by the NF Service Consumer. A complete callback URI for the \"smContextStatusUri\" has the following structure , where \"consumer-host\" is either an FQDN or an IP address (see clause 4.4.3).\nRelative path after API URI: Refers to the sequence of path segments of a resource URI that are below the API URI (see the definition of the \"Paths Object\" in OpenAPI specification [4]). When appended to the API URI of the concerned API, it constitutes the resource URI. As an example, for the Nudm_SDM API defined in 3GPP TS 29.503 [28] for which the API URI is \"{apiRoot}/nudm-sdm/v2\", the \"relative path after API URI\" for the \"AccessAndMobilitySubscriptionData\" resource is: \"/{supi}/am-data\".\nRelative URI: Relative URI is deprecated and shall not be use in SBI spcificationsSee clause 1.2.3 in IETF RFC 3986 [9].\nResource URI: Resource URI identifies an abstract or a physical resource. See the Abstract of the IETF RFC 3986 [9]. In this specification this generally means \"an URI of a resource\". Resource URI structure is defined in clause 4.4.1. As an example, for the resource URI of the SM contexts collection that is defined in Nsmf_PDUSession API (see 3GPP TS 29.502 [20]), the resource URI is \"{apiRoot}/nsmf-pdusession/<apiVersion>/sm-contexts\".\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.2\tAbbreviations",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [1].\n5GC\t5G Core Network\nCNF\tConjunctive Normal Form\nCRUD\tCreate, Read, Update, Delete\nDNF\tDisjunctive Normal Form\nHAL\tHypertext Application Language\nHATEOAS\tHypermedia as the Engine of Application State\nREST\tREpresentational State Transfer\nRPC\tRemote-Procedure-Call\nSBI\tService Based Interface\nYAML\tYAML Ain't Markup Language\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.3\tSpecial characters, operators and delimiters",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "3.3.1\tGeneral",
                            "text_content": "A number of characters have special meaning and are used as delimiters in this document and also in other stage 3 SBI specifications. Below clauses specify the usage of a selected set of the special characters. Full set of these special characters are specified in the respective IETF specifications.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "3.3.2\tABNF operators",
                            "text_content": "Special characters that are used as delimiters in ABNF syntax have somewhat different purpose from the same characters when used by URI syntax. See clause 3.3.2 in 3GPP TS 29.500 [2].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "3.3.3\tURI reserved and special characters",
                            "text_content": "/\tReserved character. The forward slash character is a delimiter, which precedes an URI path component and also separates a sequence of path segments. See clauses 2.2 and 3.3 in IETF RFC 3986 [9].\n#\tReserved character. The number sign (hash) character is a delimiter, which terminates either an URI path component, or an authority component, or a query component and starts a fragment component. See clauses 2.2, 3.2, 3.3 and 3.5 in IETF RFC 3986 [9].\n?\tReserved character. The question mark character is a delimiter, which terminates either an URI path component, or an authority component and starts a query component/parameter. See clauses 2.2, 3.2, 3.3 and 3.4 in IETF RFC 3986 [9].\n=\tReserved character. The equal sign character is a delimiter, which separates a parameter name and its value, e.g. in an URI query. See clauses 1.2.3 and 3.3 in IETF RFC 3986 [9].\n[ ]\tReserved character. The square bracket characters enclose an IPv6 literal address. This is the only place where square bracket characters are allowed in the URI syntax. See clause 3.2.2 in IETF RFC 3986 [9].\n< >\tSpecial characters. The angle bracket characters are delimiters and enclose a complete URI or an URI component or a subcomponent. See Appendix C in IETF RFC 3986 [9].\n;\tReserved character. The semicolon character is a delimiter, which is often used to separates a parameter name and its value in a path segment. See clause 3.3 in IETF RFC 3986 [9].\n:\tReserved character. The colon character is a delimiter, which either terminates an URI scheme component, or userinfo subcomponent, or separates host subcomponent from the port subcomponent, an authority component, or a query component and starts a fragment component. See clauses 2.2, and 3.2 in IETF RFC 3986 [9].\n\nNOTE:\tThe same characters, like \"/\", \"#\", etc. lead to different processing in ABNF and URI grammars. For instance, in URI syntax, \";\" character separates parameter and its value, while in ABNF \";\" starts a comment.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "3.3.4\tSBI specific usage of delimiters",
                            "text_content": "The braces (curly brackets) are used as delimiters across the SBI specifications, but have somewhat different purpose as specified below.\n{ }\tDelimiters. The braces (curly brackets) characters enclose a name of a variable in an URI path segment (see clause 5.1.3.2). Example: …/subscriber-data/{supi}.\n{ }\tDelimiters. The braces (curly brackets) characters enclose a parameter value in a query (see clause 5.1.3.3). Example: ?nf-id={chooseAValue}\n\nNOTE:\tIn SBI specifications, \"< >\" is a generic placeholder, while \"{ }\" enclose specifically a variable.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "4\tDesign Principles for 5GC SBI APIs",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "4.1\tGeneral Principles",
                    "description": "",
                    "summary": "",
                    "text_content": "Each 5GC SBI API specification should include the following information for each specified service:\n-\tPurpose of the API;\n-\tURIs of resources;\n-\tSupported HTTP methods for a given resource;\n-\tSupported representations (e.g. JSON, see IETF RFC 8259 [3]);\n-\tRequest body schema(s) (where applicable);\n-\tResponse body schema(s) (where applicable);\n-\tSupported response status codes;\n-\tRelation types supported if HATEOAS is implemented by the API;\n-\tA reference in the resource description clause to one of the archetypes defined in Annex C if the resource design matches one of them; and\n-\tA list defining identifiers of optional features (see clause 6.6 of 3GPP TS 29.500 [2] for related procedures).\nFor each specified service a clause to a normative Annex should be provided containing the OpenAPI definitions according to OpenAPI Specification [4] for the service. The specifications should state that content of this normative annex takes precedence when being discrepant to other parts of the specification with respect to the encoding of information elements and methods.\nNOTE:\tThe semantics and procedures, as well as conditions, e.g. for the applicability and allowed combinations of attributes or values, not expressed in the OpenAPI definitions but defined in other parts of the specification also apply.\nThe TS Skeleton Template as provided in Annex A should be used as a starting point when drafting 5GC SBI API specifications.\nCommon procedures, HTTP extensions and error handling applicable to several 5GC SBI API specifications should be defined in 3GPP TS 29.500 [2] and should be referenced from individual 5GC SBI API specifications.\nCommon data types applicable to several 5GC SBI API specifications should be defined in 3GPP TS 29.571 [5] and should be referenced from individual 5GC SBI API specifications.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.2\tAPI Design Style and REST Implementation Levels",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.2.1\tGeneral",
                            "text_content": "5GC SBI API specifications should apply a protocol design framework as follows:\na)\tREST-style service operations should implement the Level 2 of the Richardson maturity model, with standard HTTP methods, whenever it is a good match for the style of interaction to model, e.g. service operations that can naturally map to one of the standard methods (CRUD operations), this should be the preferred modelling attempt;\nb)\tservice operations may use custom API operations (RPC-style interaction), when it is seen a better fit for the style of interaction to model, e.g. non-CRUD service operations;\nc)\tit is possible to mix REST-style operations and RPC-style operations in the same API.\nNOTE:\tLevel 3 (HATEOAS) of the Richardson maturity model in the 5G Service-Based Architecture can be implemented by an API but is optional. Hypermedia usage guidelines are provided in clause 4.7 of the present specification.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.2\tAPI Design Principles for Query Operation",
                            "text_content": "When designing a query operation API, i.e. the NF service consumer invokes the API aiming to retrieve certain information from the NF service producer, the following principles should be applied:\na)\tif the query operation does not require any input parameter for the NF service producer, then the REST-style service operation with standard HTTP GET method should be used (see clause 4.6.1.1.2);\nb)\tif\n-\tthe query operation requires input parameter(s) for the NF service producer; and\n-\tall the required input parameter(s) are used to identify a particular resource and/or control the content of the result of the query operation;\nthen the REST-style service operation with standard HTTP GET method should be used (see clause 4.6.1.1.2);\nc)\tstandard HTTP GET method shall not be used for non-safe operations and non-idempotent operations.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.3\tAPI Design Principles for Delete Operation",
                            "text_content": "When designing a delete operation API, i.e. the NF service consumer invokes the API aiming to delete certain resource on the NF service producer, the following principles should be applied:\na)\tif the delete operation does not require any input parameter for the NF service producer, then the REST-style service operation with standard HTTP DELETE method should be used (see clause 4.6.1.1.4);\nb)\tif\n-\tthe delete operation requires input parameter(s) for the NF service producer; and\n-\tall the required input parameter(s) are used to identify a particular resource and/or control the content of the result of the delete operation;\nthen the REST-style service operation with standard HTTP DELETE method should be used (see clause 4.6.1.1.4);\nc)\tstandard HTTP DELETE method shall not be used for non-idempotent operations.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.3\tVersion Control",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.3.0\tGeneral",
                            "text_content": "The version control mechanism in the present clause allows the management of changes to an API and provides a version number that is incremented whenever changes to the API are applied.\nNOTE:\tThe version number does not reflect the usage of optional features. A mechanism to negotiate the usage of optional features is defined in clause 6.6 of 3GPP TS 29.500 [2].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.1\tStructure of API version numbers",
                            "text_content": "API version numbers shall consist of at least 3 fields, following a MAJOR.MINOR.PATCH pattern according to the Semantic Versioning Specification [17].\nThe 1st Field (MAJOR), the 2nd Field (MINOR), and the 3rd Field (PATCH) shall contain unsigned integer numbers, and they shall not contain leading zeroes.\nAn additional field (called \"pre-release version\" in Semantic Versioning Specification [17]) is added to denote an OpenAPI version under development, i.e. prior to the freeze of the corresponding OpenAPI description for a given 3GPP Release. This additional field is appended after the 3 first version fields using the hyphen \"-\" character and shall have the format \"alpha.n\", where \"n\" is an unsigned integer number without leading zeroes.\nNOTE:\tAn OpenAPI is referred to as \"non-frozen\", if for a given 3GPP Release the OpenAPI freeze milestone was not reached. Otherwise, an OpenAPI is referred to as \"frozen\".\nAfter the freeze of a 3GPP Release, additional fields (called \"build metadata\" in Semantic Versioning Specification [17]), containing operator-specific version information, may be appended after the 3 first version fields using the plus sign \"+\" character and they shall consist of a list of dot-separated identifiers, where each identifier may contain only alphanumeric characters and hyphens ([0-9A-Za-z-]).\nNOTE:\tOperator-specific version information are ignored when determining version precedence. Thus, two versions that differ only in the operator-specific version information, have the same precedence.\nEXAMPLES:\n\"1.0.0-alpha.1\"\n\"3.0.1+orange.2020-09\"\nThe first version of a new API under development shall obtain the version number \"1.0.0-alpha.1\". At the first publication of the 3GPP Technical Specification defining the API after the OpenAPI freeze of the first 3GPP Release that contains the API, the version number of the API shall be set to \"1.0.0\".\nWhen a new version of the 3GPP TS containing OpenAPI file(s) is published, the fields of the corresponding API version number(s) shall be incremented according to the following rules:\n-\tThe 1st Field (MAJOR) shall be incremented only if the applied change is backward incompatible relative to the earlier, i.e. frozen version of the given OpenAPI (see the details below). For a non-frozen OpenAPI, the first backwards incompatible change relative to the latest frozen version triggers incrementing the 1st Field (MAJOR), while subsequent backwards incompatible changes do not increment the value, until the OpenAPI stays non-frozen. When the 1st Field (MAJOR) is incremented, this impacts the lower level fields as follows:\n-\tThe 2nd Field (MINOR) shall be reset to \"0\";\n-\tThe 3rd Field (PATCH) shall be reset to \"0\";\n-\tThe 4th Field (NON-FROZEN), if present shall be reset to \"alpha.1\" (this field is removed when the OpenAPI freezes).\nThe 2nd Field (MINOR) shall be incrementd only if the applied change is a backward compatible new feature relative to the earlier, i.e. frozen version of the given OpenAPI (see the details below). For a non-frozen OpenAPI, the first backwards compatible change relative to the latest frozen version triggers incrementing the 2nd Field (MINOR), while subsequent backwards incompatible changes do not increment the value, until the OpenAPI stays non-frozen. When the 2nd Field (MINOR) is incremented, this impacts the lower level fields as follows:\n-\tThe 3rd Field (PATCH) shall be reset to \"0\";\n-\tThe 4th Field (NON-FROZEN), if present shall be reset to \"alpha.1\" (this field is removed when the OpenAPI freezes).\nThe 3rd Field (PATCH) shall be incrementd only if the applied change is a backward compatible correction relative to the earlier, i.e. frozen version of the given OpenAPI (see the details below). For a non-frozen OpenAPI, the first backwards compatible change relative to the latest frozen version triggers incrementing the 3rd Field (PATCH), while subsequent backwards incompatible changes do not increment the value, until the OpenAPI stays non-frozen. When the 3rd Field (PATCH) is incremented, this impacts the lower level field as follows:\n-\tThe 4th Field (NON-FROZEN), if present shall be reset to \"alpha.1\" (this field is removed when the OpenAPI freezes).\n-\tThe 4th Field (NON-FROZEN), if present shall be incremented in a non-frozen OpenAPI every time any kind of changes are applied the given non-frozen OpenAPI (see the details below). This field is removed when the OpenAPI freezes.\n1st Field (MAJOR):\n-\tThis numerical field shall be incremented when:\na)\tthere are one or more backward incompatible changes to the API after the OpenAPI freeze for a given 3GPP Release; and\nb)\tthere are the first backward incompatible change(s) to the existing API with respect to the latest version in the previous 3GPP Release while a 3GPP Release is under development (i.e. prior to the OpenAPI freeze for a given 3GPP Release).\nEXAMPLE 1:\tAssuming that 3GPP Rel-16 under development contains API version \"1.1.0-alpha.2\", and a backward incompatible change with respect to the latest version in the previous 3GPP Release is applied to that API before the OpenAPI freeze, the new Rel-16 API version is \"2.0.0-alpha.1\".\nNOTE 1:\tSubsequent changes in a given 3GPP Release under development do not lead to increment of the 1st field (MAJOR) and 2nd field (MINOR).\nNOTE 2:\tRules for determining backward incompatible changes are provided in Annex B.\nNOTE 3:\tIt is recommended to avoid backward incompatible change to the API after the OpenAPI freeze whenever possible, especially after OpenAPI freeze of a succeeding Release. It is preferable to introduce such changes only in the 3GPP Release under development.\n-\tIf a backward incompatible change needs to be applied to several 3GPP Releases the following applies:\na)\tIf the 3GPP Releases contain different MAJOR versions of the same API, a new MAJOR API version shall be assigned to each 3GPP Release in the order of those 3GPP Releases in such a manner that the lowest of those 3GPP Releases shall obtain the first unassigned MAJOR version value.\nEXAMPLE 2:\tAssuming that 3GPP Rel-15 contains API version \"1.0.0\", and Rel-16 contains API version \"2.0.0\", and that the same backward incompatible change is applied to that API in both Releases, the new Rel-15 API version is \"3.0.0\" and the new Rel-16 API version is \"4.0.0\".\nb)\tIf the 3GPP Releases contain the same MAJOR version but different MINOR versions of the same API, a single new MAJOR API version value shall be assigned for all those 3GPP Releases, unless other backward incompatible changes only applied to some of those Releases require the creation of separate MAJOR versions.\nNOTE 4:\tFor each such Release a new MINOR version is assigned.\nEXAMPLE 3:\tAssuming that 3GPP Rel-15 and Rel-16 contain API version \"1.0.0\", and Rel-17 contains API version \"1.2.0\", and that the same backward incompatible change is applied to that API in all 3GPP Releases, the new 3GPP Rel-15 and Rel-16 API version is \"2.0.0\" and the new 3GPP Rel-17 API version is \"2.2.0\".\nc)\tIf the 3GPP Releases contain the same API versions, a single new API version shall be assigned for all those 3GPP Releases, unless other changes only applied to some of those Releases require the creation of separate versions.\nEXAMPLE 4:\tAssuming that 3GPP Rel-15 and 3GPP Rel-16 contain API version \"1.0.0\", and that only the same backward incompatible change is applied to that API in both 3GPP Releases, the new 3GPP Rel-15 and Rel-16 API version is \"2.0.0\".\nEXAMPLE 5:\tAssuming that 3GPP Rel-15 and Rel-16 contain API version \"1.0.0\", and that the same backward incompatible change is applied to that API in both Releases and an additional backward compatible change is applied in 3GPP Rel-16, the new 3GPP Rel-15 API version is \"2.0.0\", and the 3GPP Rel-16 API version is \"2.1.0\".\nEXAMPLE 6:\tAssuming that 3GPP Rel-15 and Rel-16 contain API version \"1.0.0\", and that the same backward incompatible change is applied to that API in both Releases and an additional backward incompatible change is applied in 3GPP Rel-16, the new 3GPP Rel-15 API version is \"2.0.0\", and the 3GPP Rel-16 API version is \"3.0.0\".\n2nd Field (MINOR):\n-\tThis numerical field shall be incremented when:\na)\tthere are the first one or more backward compatible changes not corresponding to changes to earlier 3GPP Releases (i.e. changes introduced by 3GPP CR with other categories than \"mirror\") to the same API in a given 3GPP Release without any prior backward incompatible changes in that Release. If the same 1st field (MAJOR) and the 2nd field (MINOR) are assigned to n previous 3GPP Releases, a MINOR version number shall be reserved for each intermediate 3GPP Release for possible subsequent changes in that Release and the MINOR version number shall be incremented by n; and\nEXAMPLE 7:\tAssuming that 3GPP Rel-15 and Rel-16 contain API version \"1.0.0\" (because there were no changes to the API in Rel-16), and in Rel-17 the first backward compatible new feature is added before the OpenAPI freeze, the API version \"1.2.0-alpha.1\" is assigned to Rel-17.\nb)\tthere are one or more subsequent backward compatible additions of features not corresponding to changes to previous 3GPP Releases to the API in a frozen 3GPP Release before a higher MINOR number has been allocated for the same MAJOR version (for a subsequent Release).\n-\tThis field shall be reset to \"0\" if the 1st field (MAJOR) is changed, unless a backward incompatible change needs to be applied to several 3GPP Releases that already contain the same MAJOR but different MINOR API versions. In that case a single new major API version is assigned, and for each such 3GPP Release with an own MINOR version, a new MINOR version shall be assigned, starting with MINOR version \"0\" for the lowest such Release, and reserving a MINOR version number for each intermediate Release without an own MINOR version. (see Example 3)\nNOTE 5:\tIn most cases the MINOR version is incremented when new backward compatible features are added in a 3GPP Release. In rare cases, where only backward compatible changes not corresponding to changes to previous 3GPP Releases are applied to a 3GPP Release, the MINOR version is also incremented. It is recommended to avoid such changes in 3GPP Releases without added functionality whenever possible.\nNOTE 6:\tSubsequent backward compatible changes in a given 3GPP Release before OpenAPI freeze do not lead to an increment of the 2nd field (MINOR).\nNOTE 7:\tChanges corresponding to changes in previous 3GPP Releases do not lead to an increment of the 2nd field (MINOR).\nNOTE 8:\tIf two 3GPP Releases are under parallel development (because the work on Rel-X+1 has commenced before the OpenAPI freeze of Rel-X), the corresponding APIs will obtain distinct values of the 1st field (MAJOR) or 2nd field (MINOR).\nEXAMPLE 8:\tAssuming that an API was introduced with version \"1.0.0\" in Rel-15, and that the Rel-16 version is \"1.1.0-alpha.5\" because the OpenAPI is not yet frozen in Rel-16, and that a new backward compatible Rel-17 feature is added, the Rel-17 API version is \"1.2.0-alpha.1\".\n3rd Field (PATCH):\n-\tThis numerical field shall be incremented:\na)\tif the changes are only one or more backward-compatible corrections (but no changes requiring an update of the 1st field (MAJOR) or of the 2nd field (MINOR) are made to the API after the OpenAPI freeze of a 3GPP Release; and\nb)\tif one or more backward compatible additions of features, but no changes requiring an update of the 1st field (MAJOR) or of the 2nd field (MINOR), are made to the API after the OpenAPI freeze of a 3GPP Release and after the assignment of a MINOR version to a higher 3GPP Release.\n-\tThis field shall be reset to \"0\" if the 1st field (MAJOR) or 2nd field (MINOR) is changed.\nNOTE 9:\tBefore the OpenAPI freeze for a given 3GPP Release, the 3rd field (PATCH) will not be incremented.\nNOTE 10:\tIf the 1st field (MAJOR) and 2nd field (MINOR) were not incremented between 3GPP Releases (because there were no added features and no backward incompatible changes), and the same backward compatible changes are then applied to those 3GPP Releases, the API files in those 3GPP Releases are identical and will obtain the same API version number.\nNOTE 11:\tIn rare cases for which a new backward compatible functionality needs to be added in an older 3GPP Release after the OpenAPI freeze and work on that API already started in a later Release, the new functionality is exceptionally introduced as a PATCH correction and a new supported feature could be defined accordingly.\nThe 4th Field (NON-FROZEN and/or OPERATOR-SPECIFIC):\n-\tThe 4th Fields may or may not be present, based on the following conditions.\n-\tNON-FROZEN type. The presence of this filed type depends on the OpenAPI status, as follows:\n-\tThe 4th Field (NON-FROZEN) shall be present before the OpenAPI freeze of a 3GPP Release. An additional field (separated from the 3 first version fields by a hyphen \"-\" character) shall be supplied as follows:\na)\tWhen the 1st field (MAJOR) or 2nd field (MINOR) is incremented before the OpenAPI freeze of a 3GPP Release, this field shall obtain the value \"alpha.1\".\nb)\tThe numerical value \"n\" within the field value \"alpha.n\" shall be incremented if one or more subsequent changes (either backward incompatible, or backward compatible) are made to the given non-frozen OpenAPI.\n-\tThe 4th Field (NON-FROZEN) shall not be present after the OpenAPI freeze of a 3GPP Release., this additional field (including the hyphen \"-\" character) containing pre-release version info is removed from the API version.\n-\tOPERATOR-SPECIFIC type that represents operator-specific version field(s) . The presence of these fields depends on the OpenAPI status, and the operator preferences:\n-\tThe 4th Field (OPERATOR-SPECIFIC) shall be present after the OpenAPI freeze of a 3GPP Release. Additional fields may be supplied based on operator policy after the 3 first version fields and separated by a plus sign \"+\" character. The rules for setting, or incrementing, such fields are out of the scope of 3GPP, but they shall comply with the rules described in the Semantic Versioning Specification [17], and contain a list of dot-separated labels within the allowed character set ([0-9A-Za-z-]).\nIf no change is applied to an API in a new published TS version, the API version number shall not be incremented unless the additional field (\"-alpha.n\") needs to be removed at OpenAPI freeze. This also applies if the TS is published in a new 3GPP Release.\nNOTE 12:OpenAPI files can contain references to other OpenAPI files. Changes to referenced parts of such other OpenAPI files need to be considered when determining if and how to update an API version.\nNOTE 13:The API version number of those version fields managed by 3GPP is incremented using 3GPP change requests.\nThe API version shall be indicated in the resource URI of every API, as described in clause 4.4.1.\nThe API version shall be indicated as the concatenation of the letter \"v\" and the 1st field (MAJOR) of the API version number.\nThe other fields shall not be included in the resource URI.\nNOTE:\tIncluding these digits in the URI would force the NF service consumer to select a specific sub-version, at the risk of seeing the request rejected if the NF service provider does not support it, while the request could have been served by ignoring unknown elements.\nThe full API version number (i.e., containing all the fields) shall be visible in the OpenAPI specifications, in the \"version\" subfield of the \"info\" field, as described in clause 5.3.3.\nThere is no one-to-one mapping between an API version number and the version number of the 3GPP Technical Specification defining this API.\nA 3GPP Technical Specification specifies one or more APIs, which may have different versions.\nA change in the 3rd field (PATCH) of a 3GPP TS version number (i.e. an editorial change) should not lead to a change in the version number of the APIs specified in the 3GPP TS.\nA change in the 1st field (MAJOR) and 2nd fields (MINOR) of the 3GPP TS version number is likely to lead to at least a change in the minor version number of the APIs specified in the 3GPP TS.\nEXAMPLE:\tIf version 15.4.1 of a 3GPP TS contains version \"1.1.1\" of API A, B and C, and a version 16.0.0 of this 3GPP TS is derived from version 15.4.1, TS version 16.0.0 can contain version \"1.2.0.alpha-1\" of API A (if all changes made are backward compatible), version \"2.0.0.alpha-1\" of API B (if some changes are no backward compatible) and version \"1.1.1\" of API C (if no changes were made).\nThe 3GPP TS defining the API is indicated in the OpenAPI specification of the API, as described in clause 5.3.4.\nThe NF service consumer may discover the API version(s) supported by an NF service producer using the following mechanisms:\n-\tNRF query:\tThe NF service consumer may retrieve from the NRF the NF profile of a given NF Instance. This NF profile contains the full version number(s) of the API(s) supported by an NF Service Instance, as described in the clause 6.2.6.2.4 of 3GPP TS 29.510 [18] and the planned retirement date.\n-\tNF profile change notifications: The NF service consumer may subscribe for NF status change notifications with the NRF as specified in clause 5.2.2.5 of 3GPP TS 29.510 [18]. The NRF shall notify as specified in clause 5.2.2.6 of 3GPP TS 29.510 [18], any change to the NF profile which may include updated NF service profile containing the current list of NF services and their versions supported by the NF.\nWhen a new major version is created, the NF service producer shall continue supporting at least the previous major version until a retirement date unless all API versions (except for draft API versions published prior to the OpenAPI freeze) with that previous major version are withdrawn (see clause 4.3.1.6); this enables NF service consumers to migrate to the new version. After expiration of the retirement date, the old major version should be deprecated. The retirement date of an old major version supported by a NF service instance may be updated in the NF profile in the NRF.\nIf it is discovered that one or several previous API versions are not providing the basic mandatory functionality of an API due to severe functional or encoding deficits (for instance, there is no or very limited interoperability between the NF service consumer and NF service producer when such an API version is used, or the API is hardly implementable because of severe deficits in the OpenAPI file that cannot easily be fixed by implementers in an interoperable manner), those API versions shall be listed as withdrawn in subsequent versions of the TS defining the corresponding API; any withdrawn API versions from the same or previous 3GPP releases shall be listed. API versions published before the OpenAPI freeze of the corresponding 3GPP Release, i.e. with a 4th Field (NON-FROZEN and/or OPERATOR-SPECIFIC) as part of the version number, shall not be withdrawn.\nNOTE 1:\tIt is recommended to avoid withdrawing API versions whenever possible. It is expected that a need to withdraw API versions is most likely detected when discussing corrections soon after the OpenAPI freeze of a new API.\nNOTE 2:\tCorrections to optional or minor parts of the API functionality do not lead to the withdrawal of API versions. However, if severe functional or encoding deficits of the functionality related to an optional functionality with a corresponding supported feature (see 3GPP TS 29.500 [2] clause 6.6.2) are discovered, a new supported feature can be introduced to enable a negotiation of the support of the correction, and the old corresponding supported feature can be marked as \"withdrawn\" in the table defining the supported features of an API.\nWithdrawn API versions should not be deployed.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.4\tURI Structure",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.4.1\tResource URI structure",
                            "text_content": "Resources are either individual resources, or structured resources that can contain child resources. It is recommended to design each resource following one of the archetypes provided in the Annex C.\nA URI uniquely identifies a resource. In the 5GC SBI APIs, when a resource URI is an absolute URI, its structure shall be specified as follows:\n{apiRoot}/<apiName>/<apiVersion>/<apiSpecificResourceUriPart>\n\"apiRoot\" shall be a concatenation of the following parts:\n-\tscheme (\"http\" or \"https\")\nNOTE:\tIn this release of the specification both http and https scheme URIs are allowed. See clause 13.1 of 3GPP TS 33.501[22] for further details on security of Service Based Interfaces.\n-\tthe fixed string \"://\"\n-\tauthority (host and optional port) as defined in IETF RFC 3986 [9]. The host should be represented by the operator specific FQDN (for FQDN examples see clause 28.3.2 in 3GPP TS 23.003 [27]).\n-\tan optional deployment-specific string (API prefix) that starts with a \"/\" character.\napiName\" shall define the name of the API. For example, 'nsmf-pdusession'.\n\"apiVersion\" shall indicate  the MAJOR version of the  API. The format is specified in clause 4.3.1.3. For example, 'v1'.\nWhile \"apiRoot\", \"apiName\" and \"apiVersion\" together define the API URI of the corresponding API, each \"apiSpecificResourceUriPart\" defines a resource URI of the API relative to the API URI.\nAn API URI should not contain a trailing slash as defined in clause 3.1, and if it contains one, then it should be ignored/removed.\nExample of an API URI from 3GPP TS 29.502 [20]:\n- url: '{apiRoot}/nsmf-pdusession/v1'\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.2\tCustom operations URI structure",
                            "text_content": "The custom operation definition is in Annex C.\nThe URI of a custom operation which is associated with a resource shall have the following structure:\n{apiRoot}/<apiName>/<apiVersion>/<apiSpecificResourceUriPart>/<custOpName>\nCustom operations can also be associated with the service instead of a resource. The URI of a custom operation which is not associated with a resource shall have the following structure:\n{apiRoot}/<apiName>/<apiVersion>/<custOpName>\nIn the above URI structures, \"apiRoot\", \"apiName\", \"apiVersion\" and \"apiSpecificResourceUriPart\" are as defined in clause 4.4.1 and \"custOpName\" represents the name of the custom operation as defined in clause 5.1.3.2.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.3\tCallback URI structure",
                            "text_content": "The purpose of the callback URI is to enable NF service consumer to provide the URI to be used by an NF Service Producer to send notification or callback requests.\nThe callback URI shall be in the form of an absolute URI as defined in clause 4.3 of IETF RFC 3986 [9], including an authority, and excluding any query component, any fragment component and any userinfo subcomponent.\nTherefore, callback URI consists of the following components, specified with ABNF syntax (see IETF RFC 5234 [26]):\nURI = scheme \":\" \"//\" host [ \":\" port ] [ prefix ] \"/\" <callbackUriPart>\nWhere:\n-\tscheme is either \"http\" or \"https\";\nNOTE:\tIn this release of the specification both http and https scheme URIs are allowed. See clause 13.1 of 3GPP TS 33.501[22] for further details on security of Service Based Interfaces.\n-\t'host' is either an FQDN or an IP address;\n-\tthe URI may contain an optional port;\n-\tthe URI may contain an optional deployment-specific string (prefix) that starts with a \"/\" character;\n-\tthe \"callbackUripart\" is the part of the callback URI, after the prefix (if any), of the path to an HTTP resource on the consumer, which is implementation specific; and\n-\tthe path of the callback URI comprises the prefix (if any) and the \"callbackUriPart\".4.5\tResource Representation and Content Format Negotiation\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.5.1\tResource Representation",
                            "text_content": "A resource representation is a serialization of the resource state in a particular content format. It's included in the data frame of an HTTP/2 request or response. Representation header fields provide metadata about the representation. When a message includes a data frame, the representation data enclosed in the data frame. HTTP/2 reuses the definition of Representation header as HTTP 1.1 in IETF RFC 7231 [6]. Content-type field in HTTP/2 header performs as representation header fields and describes the representation data that would have been enclosed in the data frame, e.g. if content-type is application/json, resource representation in data frame is serialized in JSON format.\nServer supports the content format of the representation received in the data frame of the request and returns the \"200 OK\" response code.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.5.2\tContent Format Negotiation",
                            "text_content": "IETF RFC 7231 [6] provides a mechanism to negotiate the content format of a representation.\nIn HTTP/2 requests and responses, the \"Content-Type\" HTTP/2 header field is used to signal the format of the actual representation included in the data frame. If the format of the representation in an HTTP/2 request is not supported by the server, it responds with the \"415 Unsupported Media Type\" response code.\nFor GET method, the \"Accept\" HTTP header of the HTTP/2 request signals the content formats that a client supports. If the server cannot provide any of the accepted formats, it returns the \"406 Not Acceptable\" response code.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.6\tUse of HTTP Methods",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.6.1\tUse of Request/Response Communication",
                            "text_content": "4.6.1.1.1.1\tGeneral\nProcedures that allow an NF service consumer to create a new resource at the NF service producer shall be specified to either use the HTTP POST method with procedures according to clause 4.6.1.1.1.2 or the HTTP PUT method with procedures according to clause 4.6.1.1.1.3.\n4.6.1.1.1.2\tCreating a Resource using POST\nThe HTTP POST method (see IETF RFC 7231 [6]) allows an NF service consumer to create a new child resource at the NF service producer in such a manner that the NF service producer selects the child resource identifier and the URI for the child resource.\nFigure 4.6.1.1.1.2-1 illustrates creating a resource using POST.\nThe figure depicts a resource creation process using the POST method, which is a common method for creating resources in various systems. The figure shows a step-by-step guide on how to create a new resource, including the necessary parameters and steps to follow. The figure is useful for understanding the process of creating a new resource in a system, and can be used to guide users through the creation process.\nFigure 4.6.1.1.1.2-1: Creating a resource using POST\n1.\tThe parent resource of which the new resource is to be created as a child is identified by the request URI. The payload body of the POST request shall contain a representation of the resource to be created without a child resource identifier. For forward compatibility, the NF service producer ignores unknown attributes in the received resource representation unless specified otherwise by the particular application.\n2.\tThe NF service producer generates a child resource identifier and constructs the URI for the created resource by appending that child resource identifier to the parent resource URI received as request URI of the POST request (e.g. \"…/parent-resource/childresource1\").\nOn success, \"201 Created\" shall be returned, the payload body of the POST response should contain a representation of the created resource, and the \"Location\" header shall be present and shall contain the URI of the created resource. The created resource shall be served by the same NF (service) instance that received the service request, unless the 5GC SBI API specifications explicitly specified that in specific use cases the created resource may be served by another NF (service) instance. If in such specific use cases the resource is created in a different NF (service) instance, the identifier of the serving NF (service) instance shall be included in the response message.\nIf the HTTP scheme used in the returned URI is \"https\", then the authority of the URI included in the Location header shall be an FQDN, and not an IP address.\nThe URI included in the \"Location\" header may be an absolute URI or a relative URI reference (see IETF RFC 3986 [9]); when the URI is in relative form, the base URI used to resolve the URI reference is the target URI included in the received POST request.\nNOTE:\tThe representations of the resource in the request and response can differ, e.g. the representation of the resource in the response can be empty or can contain a subset of the representation as received in the request possibly with modified attributes, and in addition can contain additional attributes. Exact details will be specified by the application.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the POST response body (see clause 4.8).\nA collection may be used to model a resource that serves as a directory of resources that may be distributed on different processing instances or hosts. If so:\n-\tthe authority and/or deployment-specific string of the apiRoot of the created resource URI returned by the NF Service Producer in the \"Location\" header may differ from the authority and/or deployment-specific string of the apiRoot of the request URI received in the POST request.\n-\tthe NF Service Consumer shall be capable to receive and process an authority and/or deployment-specific string in the apiRoot of the created resource URI that differs from the authority and/or deployment-specific string of the apiRoot of the Request URI.\nIt needs to be clearly stated in the 5GC SBI API specifications when a NF Service Producer may return a different authority and/or deployment-specific string in the apiRoot of the created resource URI for a collection resource.\n4.6.1.1.1.3\tCreating a Resource using PUT\nThe HTTP PUT method (see IETF RFC 7231 [6]) allows an NF service consumer to create a new resource at the NF service producer in such a manner that the NF service consumer selects the resource identifier and the URI for the resource.\nFigure 4.6.1.1.1.3-1 illustrates creating a resource using HTTP PUT.\nThe figure depicts a resource creation process using HTTP PUT, illustrating the steps involved in creating a new resource in a web application. The figure includes a step-by-step guide on how to perform the HTTP PUT request, with visual cues such as the HTTP GET request, the HTTP POST request, and the HTTP DELETE request. The figure also includes a step-by-step guide on how to handle the response from the server, with visual cues such as the HTTP 200 response and the HTTP 201 response. The figure concludes with a step-by-step guide on how to handle the response from the server, with visual cues such as the HTTP 200 response and the HTTP 201 response.\nFigure 4.6.1.1.1.3-1: Creating a Resource using HTTP PUT\n1.\tThe NF service consumer selects a resource identifier and constructs the URI for the resource to be created by appending that resource identifier to the parent resource URI. The resource that is to be created is identified by that URI as request URI. The payload body of the PUT request shall contain a representation of the resource to be created. For forward compatibility, the NF service producer ignores unknown attributes in the received resource representation unless specified otherwise by the particular application.\n2.\tOn success, \"201 Created\" shall be returned, the payload body of the PUT response should contain the representation of the created resource, and the \"Location\" header shall be present and shall contain the URI of the created resource. The created resource shall be served by the same NF (service) instance that received the service request, unless the 5GC SBI API specifications explicitly specified that in specific use cases the created resource may be served by another NF (service) instance. If in such specific use cases the resource is created in a different NF (service) instance, the identifier of the serving NF (service) instance shall be included in the response message.\nIf the HTTP scheme used in the returned URI is \"https\", then the authority of the URI included in the Location header shall be an FQDN, and not an IP address.\nNOTE:\tThe representations of the resource in the request and response can differ, e.g. the representation of the resource in the response can be empty or can contain a subset of the representation as received in the request possibly with modified attributes, and in addition can contain additional attributes. Exact details will be specified by the application.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the PUT response body (see clause 4.8).\nIf the resource that is to be created already exists at the NF service producer, the following applies:\n1)\tIf the update of that resource by PUT is supported, the existing representation of the resource is replaced with the representation received in the PUT request body; see clause 4.6.1.1.3.1.\n2)\tIf the update of that resource by PUT is not supported, the \"403 Forbidden\" HTTP status code shall be returned and appropriate additional error information should be returned in the PUT response body (see clause 4.8).\n4.6.1.1.2.1\tReading a Single Resource\nProcedures that allow a service consumer NF (client) to read information from the server shall be specified to use the HTTP GET method (see IETF RFC 7231 [6]) to obtain the current representation of a resource.\nFigure 4.6.1.1.2-1 illustrates reading a resource.\nThe figure depicts a resource reading process, showing how a user interacts with a device to access and analyze data. The figure includes various components such as a display, buttons, and a user interface, all of which are essential for the user's interaction and data access. The figure also includes a schematic representation of the device's components, providing a clear and concise visual guide for the user.\nFigure 4.6.1.1.2.1-1: Reading a resource\n1.\tThe resource of which a representation is to be obtained is identified by the request URI. Query parameters may be used to control the content of the result.\nThe payload body of the GET request shall be empty.\n2.\tOn success, \"200 OK\" shall be returned and the payload body of the GET response shall contain the obtained resource representation.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the GET response body (see clause 4.8).\n4.6.1.1.2.2\tQuerying a Set of Resources\nProcedures that allow a service consumer NF (client) to querying a set of resources from the server shall be specified to use HTTP GET method towards a resource modelled as Collection or Store archetype.\nQuery parameters (see clause 4.6.1.1.5) may be provided when querying a set of resources. The query component contains non-hierarchical data that, along with data in the path component, to filter the resources identified within the scope of the URI's scheme to a subset of the resources matching the query parameters. The query component is indicated by the first question mark (\"?\") character and terminated by a number sign (\"#\") character or by the end of the URI.\n\nThe figure depicts a collection of resources, specifically a set of query parameters, which are used to query a database. The parameters are organized in a hierarchical structure, with each parameter having a specific role in the query execution. The figure illustrates the use of these parameters in a database query, highlighting the importance of each parameter in determining the results of the query.\nFigure 4.6.1.1.2.2-1: Query of a collection of resources by using query parameters.\nStep 1. The client shall send a HTTP GET request using the URI of a resource modelled as Collection or Store archetype, optionally with query parameters, to the server.\nStep 2. On success, the server shall return a set of sub-resources that includes only those entries filtered by the query parameters. If no sub-resource is matched for the querying service operation, the server shall return \"200 OK\" with an empty array (e.g. \"[ ]\" in JSON) in response body. If the resource in the URI doesn't exist on the server, the server shall return \"404 Not Found\" with optionally the cause information in response body.\nNOTE:\tThe result array/empty array can be defined as an attribute of an object, if the service operation returns an object in the response payload for extensibility consideration.\nClause 4.9 specifies some possible options for an NF Service Producer to return the representations of multiple resources to a NF Service Consumer.\n4.6.1.1.3.1\tUsage of HTTP PUT\nProcedures that allow a service consumer NF (client) to update information stored at the server by means of a complete replacement shall be specified to use the HTTP PUT method to replace the current representation of a resource with a new representation.\nFigure 4.6.1.1.3.1-1 illustrates updating a resource using HTTP PUT.\nThe figure depicts a resource update process using HTTP PUT, illustrating the steps involved in updating a resource. The figure includes a flowchart, which outlines the steps from the client initiating the request to the server processing the request and returning the updated resource. The figure also includes a visual representation of the HTTP request and response, as well as a description of the HTTP method and the resource being updated.\nFigure 4.6.1.1.3.1-1: Updating a Resource using HTTP PUT\n1.\tThe resource that is to be updated is identified by the request URI. The payload body of the PUT request shall contain the new representation of the resource. For forward compatibility, the NF service producer ignores unknown attributes in the received resource representation unless specified otherwise by the particular application.\n2.\tOn success, \"204 No Content\" or \"200 OK\" shall be returned.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the PUT response body (see clause 4.8).\nIf the resource that is to be updated does not exist at the NF service producer, the following applies:\n1.\tIf the creation of that resource by PUT is supported, the resource is created according to the procedure in clause 4.6.1.1.1.3.\n2.\tIf the creation of that resource by PUT is not supported, the \"403 Forbidden\" HTTP status code shall be returned and appropriate additional error information should be returned in the PUT response body (see clause 4.8).\n4.6.1.1.3.2\tUsage of HTTP PATCH\nProcedures that allow a service consumer NF (client) to update information stored at the server by means of a partial replacement shall be specified to use the HTTP PATCH method (see IETF RFC 5789 [10]) to modify the current representation of a resource according to given modification instructions. The format of the PATCH message body shall be specified for each resource where the PATCH method is supported using one or several of the following encodings:\n-\tIf no modification of individual elements within an array needs to be supported, the \"JSON Merge Patch\" encoding of changes defined in IETF RFC 7396 [7] should be used.\n-\tIf a modification of individual elements within an array needs to be supported, the \"JSON Patch\" encoding of changes defined in IETF RFC 6902 [8] shall be used.\nA single of the above encodings shall be specified for each resource where the PATCH method is supported unless backward compatibility considerations necessitate the support of both encodings.\nNOTE 1:\tIn Rel-15 a single encoding will be selected for each resource as backward compatibility considerations do not yet apply.\nNOTE 2:\t\"JSON Merge Patch\" does not support the modification of individual elements within an array. However, it supports the modification of individual elements within maps (see clause 5.2.4.2). Collections of elements can be modelled as maps, instead of arrays, if a partial modification using PATCH is desired.\nNOTE 3:\tThe Open API description of the body of HTTP PATCH requests is specified in clause 5.3.8.\nFigure 4.6.1.1.3.2-1 illustrates updating a resource using HTTP PATCH.\nThe figure depicts a resource updating process using HTTP PATCH, illustrating the steps involved in updating a resource in a resource-intensive system. The figure includes a flowchart, which outlines the steps from the client initiating the request to the server processing the request and updating the resource. The figure also includes a visual representation of the HTTP request and response, as well as a diagram of the resource's state before and after the update.\nFigure 4.6.1.1.3.2-1: Updating a Resource using HTTP PATCH\n1.\tThe resource that is to be updated is identified by the request URI. The payload body of the PATCH request shall contain a description of the requested modifications of the resource. For the \"JSON Merge Patch\" encoding defined in IETF RFC 7396 [7] and the \"Content-Type\" header shall be set to \"application/merge-patch+json\". For the \"JSON Patch\" encoding of changes defined in IETF RFC 6902 [8] the \"Content-Type\" header shall be set to \"application/json-patch+json\". For forward compatibility, the NF service producer shall ignore received modification instructions of unknown attributes in the resource unless specified otherwise by the particular application.\n2.\tOn success, \"204 No Content\" or \"200 OK\" shall be returned.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the PATCH response body (see clause 4.8).\nProcedures that allow a service consumer NF (client) to delete a resource from the server shall be specified to use the HTTP DELETE method (see IETF RFC 7231 [6]).\nFigure 4.6.1.1.4-1 illustrates deleting a resource.\nThe figure depicts a resource deletion process in a network, showing the steps involved in removing a resource from the network. The process includes selecting the resource to be deleted, creating a deletion request, and then deleting the resource. The figure provides a visual representation of the process, making it easier to understand and follow.\nFigure 4.6.1.1.4-1: Deleting a resource\nThe resource that is to be deleted is identified by the request URI.\nThe payload body of the DELETE request shall be empty.\nOn success, \"204 No Content\" should be returned and then the payload body of the DELETE response shall be empty.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the DELETE response body (see clause 4.8).\n4.6.1.1.5.1\tGeneral\nThe query component in the URI contains non-hierarchical data that, along with data in the path component, to filter the resources identified within the scope of the URI's scheme to a subset of the resources matching the query parameters. The query component is indicated by the first question mark (\"?\") character and terminated by a number sign (\"#\") character or by the end of the URI. The syntax of the query component is specified in IETF RFC 3986 [9].\nWhen a server receives a request with a query component, it shall parse the query string in order to identify filters. The first question mark is used to be a separator and is not part of the query string. A query string is composed of a series of \"key=value\" pairs, separated by \"&\". If one query parameter contains more than one value, i.e. an array of data elements, different values shall be separated by comma (\",\").\nThe behaviour of the server, when receiving an HTTP/2 method with a query parameter which is of type array and only some of the members in the array can be matched, depends on each API and the behaviour shall be clearly described.\nIf multiple query parameters are defined for a method on the resource, the logical 'AND' represents the default logical relationship between the query parameters for this resource. If a logical relationship between multiple query parameters is specified in an API, then this overrides the default relationship. If multiple query parameters are defined for a method on the resource in an API, but there is no need to specify any logical relationship between these query parameters, the API shall explicitly state this.\n4.6.1.1.5.2\tComplex query expression\nThe complex query expression is used when there are multiple query parameters in the URI and the query condition needs to be expressed by a logical combination of multiple query parameters which overrides the default logical relationship of the query parameters. The complex query expression is either a Conjunctive Normal Form (CNF) or a Disjunctive Normal Form (DNF) which is equivalent to the logical combination of query parameters reflecting the query condition.\nThe \"complex-query\" query parameter may be used when a complex query expression is needed to express a query condition. The value of the \"complex-query\" query parameter is of type \"ComplexQuery\" which is a JSON object, the corresponding CNF or DNF is encoded into that JSON object (see 3GPP TS 29.571 [5] for the details of the data type \"ComplexQuery\"). The use of \"complex-query\" shall be negotiated using the feature negotiation procedure as defined in 3GPP TS 29.500 [2].\nIf a query parameter is included in the \"complexQuery\" then the same query parameter shall not be included outside the \"complexQuery\" in the same request message.\nNOTE 1:\tIt is not assumed that all APIs support \"complex-query\", the API supports this feature only when it is described in the corresponding specification.\nNOTE 2:\tThe logical relationship between \"complex-query\" and the other query parameters defined for a particular API is described in the corresponding specification of that API.\nNTOE 3:\tThe \"complex-query\" is not an additional explanation of the other query parameters, the condition expressed in the \"complex-query\" is evaluated along with the other queries.\n\nCustom Operations provide procedures that allow a service consumer NF (client) to interact with an NF service producer in other ways than what is supported by the CRUD methods described in clause 4.6.1.1.\nCustom Operation can be related to a resource or can be related to an entire service and be independent of a resource.\n\nFigure 4.6.1.2-1 illustrates the use of a custom operation related to a resource.\nThe figure depicts a custom operation on a resource using HTTP POST, illustrating the process of modifying a resource's state. The figure includes a visual representation of the resource, a description of the operation, and a step-by-step guide for performing the operation.\nFigure 4.6.1.2-1: Custom Operation on a Resource using HTTP POST\n1.\tThe request URI identifies the custom operation to be executed and the resource the custom operation relates to and is constructed by adding a verb as name for the custom operation at the end of the resource URI (see clauses 4.4.2 and 5.1.3.2). Parameters for the custom operation are included in the request body.\n2.\tOn success, \"204 No Content\" or \"200 OK\" shall be returned. \"200 OK\" shall contain a body with data related to the custom operation.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the POST response body (see clause 4.8).\n\nFigure 4.6.1.2-2 illustrates the use of a custom operation related to a service.\nThe figure depicts a custom operation related to Service using HTTP POST, illustrating the steps involved in creating a new service. The figure includes a diagram of the service, a flowchart, and a list of steps, providing a clear and concise visual representation of the process.\nFigure 4.6.1.2-2: Custom Operation related to Service using HTTP POST\n1.\tThe request URI identifies the custom operation to be executed and is constructed by adding a verb as name for the custom operation at the end of the service URI (see clauses 4.4.2 and 5.1.3.2). Parameters for the custom operation are included in the request body.\n2.\tOn success, \"204 No Content\" or \"200 OK\" shall be returned. \"200 OK\" shall contain a body with data related to the custom operation.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the POST response body (see clause 4.8).\nCertain service operations may be designed to allow the invocation of a request so that the response can be received asynchronously: if the NF service consumer when sending a request cannot expect to receive an immediate final response, the service consumer may provide a callback reference for final result notification. The service provider, when receiving a request that contains a callback reference for final result notification, may then return an immediate \"202 Accepted\", and notify the service consumer about the final result using the received callback reference at a later point in time.\nServices provided by the AMF can be transferred seamlessly to a new AMF when the corresponding UE context is transferred to that AMF.\nTo support a seamless change of the AMF as NF service producer, the procedures in clause 4.6.1 are applied with the following special provisions:\n1.\tWhen becoming aware that a new AMF is serving the resource, the NF service consumer shall exchange the authority part of resource URIs with the address of a new NF service producer and shall use that URI in subsequent communication.\nNOTE:\tAn NF service consumer can become aware of an AMF change via Namf_Communication service AMFStatusChange Notifications, via Error response from old AMF, via link level failures (e.g. no response from the AMF), or via a notification from the NRF that the AMF has deregistered and can then determine the new AMF either via information received within those services or by selecting an AMF from an earlier received AMF set or the backup AMF.\n2.\tEach AMF within a set of AMFs supporting seamless changes shall be prepared to receive updates for resource URIs constructed according to bullet 1 with the own IP address as authority part from the NF service consumer, by either handling the updates, or by replying with an HTTP \"307 temporary redirect\" error response pointing to new NF service producer, or by replying with another HTTP error such as an \"404 Not found\".\n3.\tFor a service that includes notifications from the AMF, the NF service consumer shall be prepared to receive notifications for the that service from any NF service producer within a set of NF service producers supporting seamless changes.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.6.2\tUse of Subscribe/Notify Communication",
                            "text_content": "Subscribe/Notify communication between 5GC NFs can be used to keep involved NFs (consumers of a service) informed of data changes or events that occur at another NF (producer of the service). A notification is a message that contains information about the event.\nService consumer NFs (clients) need to subscribe to notifications at the service provider NF (server). This either happens explicitly by means of creating a new subscription resource (see clause 4.6.2.2), or implicitly by updating a relevant resource.\nService consumer NFs can in principle explicitly or implicitly subscribe to be notified about data change to any type of resource of any resource archetype (Document, Store or Collection). It is up to the API to define the resources that support subscriptions.\nWhen the change/event occurs at the service producer NF, notifications (see clause 4.6.2.3) are sent from the service producer NF to the service consumer NFs. This communication initiated by the service producer to the service consumers requires that the service consumer NF (client) takes the role of an HTTP server and the service producer NF (server) takes the role of an HTTP client.\nDuring the explicit subscription the service consumer NF (client) provides a callback URI and possibly additional filter criteria to the service producer NF (server). When the data-change/event occurs that matches the filter criteria in the subscription, the service producer NF (taking the role of an HTTP client) uses the provided callback URI to notify the service consumer NF (taking the role of an HTTP server) about the change.\nThe HTTP method to create a subscription shall be POST. The HTTP method to modify a subscription shall be PUT or PATCH. The HTTP method to delete a subscription (i.e. to unsubscribe) shall be DELETE (see IETF RFC 7231 [6]).\nSubscriptions may be implicit, i.e. exist without being explicitly created by a dedicated subscribe operation.\nTwo types of implicit subscriptions exist:\n1.\tThe subscription is implied by an explicit operation different from the subscribe operation, which does not use the GET method. The subscription implied by the explicit operation and the corresponding notification shall be part of the same service.\n2.\tThe subscription exists without any explicit operation.\nAs an example for the first type, at the UDM the registered AMF (as long as it is registered) is implicitly subscribed to notification about de-registration and (possibly) P-CSCF restoration as side effect of the registration.\nAs another example for the first type, at the SMF, the AMF that created a SM Context for a PDU session is implicitly subscribed for SM Context Status notification. At AMF change the new AMF updates the SMF with its callback URI for receiving subsequent SM Context Status notification.\nAs an example for the second type, at the UDR any available UDM is implicitly subscribed to notification about changes of provisioned subscriber data. When provisioned subscriber data are modified at the UDR by means of provisioning, the UDR selects one of the available UDMs (i.e. one of the implicitly subscribed UDMs) and notifies it about the subscriber data change.\nIn the OpenAPI specification file, notifications for the second type of implicit subscriptions shall be specified as part of an explicit subscription.\nFigure 4.6.2.2.2-1 illustrates explicit creation of a subscription.\nThe figure depicts a subscription creation process in a telecommunications network, illustrating the steps involved in creating a new subscription. The process includes selecting a subscription type, specifying the subscription's parameters, and submitting the request to the network. The figure provides a visual representation of the steps, making it easier to understand the process.\nFigure 4.6.2.2.2-1: Creation of a subscription\nThe parent resource (collection of subscriptions) is identified by the request URI.\nThe data structure in the payload body of the POST request shall contain a callback URI, and may contain additional criteria to filter the set of events that trigger a notification. The request may contain an expiry time, suggested by the NF Service Consumer as a hint, representing the time up to which the subscription is desired to be kept active and the time after which the subscribed event shall stop generating notifications.\nOn success, \"201 Created\" shall be returned, the payload body of the POST response shall contain a representation of the created subscription, and the \"Location\" header shall contain the URI of the created resource. The created resource shall be served by the same NF (service) instance that received the service request, unless the 5GC SBI API specifications explicitly specified that in specific use cases the created resource may be served by another NF (service) instance. If in such specific use cases the resource is created in a different NF (service) instance, the identifier of the serving NF (service) instance shall be included in the response message.\nIf the HTTP scheme used in the returned URI is \"https\", then the authority of the URI included in the Location header shall be an FQDN, and not an IP address.\nThe response based on operator policies and taking into account the expiry time included in the request, may contain an expiry time (i.e. a future timestamp), as determined by the NF Service Producer, after which the subscription becomes invalid. If an expiry time was included in the request, then the expiry time returned in the response should be less than or equal to that value. Once the subscription expires, if the NF Service Consumer wants to keep receiving notifications, it shall create a new subscription in the NF Service Producer. The NF Service Producer shall not provide the same expiry time (i.e. a future timestamp) for many subscriptions in order to avoid all of them expiring and recreating the subscription at the same time. If the expiry time is not included in the response, the NF Service Consumer shall consider the subscription to be valid without an expiry time.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the POST response body (see clause 4.9).\n4.6.2.2.3.1\tModification of a Subscription Using HTTP PUT\nProcedures that allow a NF service consumer to update the subscription at the server by means of a complete replacement shall use the HTTP PUT method to replace the current subscription with a new representation.\nFigure 4.6.2.2.3.1-1 illustrates modification a subscription using HTTP PUT.\nThe figure depicts a simplified representation of a subscription modification using HTTP PUT. It shows the steps involved in modifying a subscription, including the use of HTTP PUT method, the HTTP request body, and the response body. The figure provides a clear and concise visual representation of the process, making it easy to understand and follow.\nFigure 4.6.2.2.3.1-1: Modification a subscription using HTTP PUT\n1.\tThe NF Service Consumer shall send a PUT request to the resource URI representing the individual subscription. The payload body of the PUT request shall contain the subscription information to be replaced including the criteria to filter the set of events that trigger a notification. The request may contain an updated expiry time, suggested by the NF Service Consumer as a hint, to extend the subscription lifetime, representing the time upto which the subscription is desired to be kept active and the time after which the subscribed event shall stop generating notifications. If the request does not contain an expiry time, the NF Service Producer shall consider that the NF Service Consumer requests for an extension of the existing subscription lifetime without indicating any specific expiration time; still, the NF Service Producer shall be authoritative to set the expiry time in the subscription response according to its own policies.\n2.\tOn success, \"204 No Content\" without any response body or \"200 OK\" with a response body providing current resource representation shall be returned.\n\nWhen \"200 OK\" is returned, the response based on operator policies and taking into account the expiry time included in the request, may contain an expiry time (i.e a future timestamp), as determined by the NF Service Producer, after which the subscription becomes invalid. If an expiry time was included in the request, then the expiry time returned in the response should be less than or equal to that value. Once the subscription expires, if the NF Service Consumer wants to keep receiving notifications, it shall create a new subscription in the NF Service Producer, as specified in clause 4.6.2.2.2. The NF Service Producer shall not provide the same expiry time (i.e. a future timestamp) for many subscriptions in order to avoid all of them expiring and recreating the subscription at the same time. If the expiry time is not included in the response, the NF Service Consumer shall consider the subscription to be valid without an expiry time.\n\nWhen \"204 No Content\" is returned, it shall be interpreted that the NF Service Producer accepted entirely the resource representation provided by the NF Service Consumer in the request; e.g., if the request contained a proposed expiry time, a 204 response shall be interpreted as if such timestamp is accepted by the NF Service Producer as the expiration time for the subscription and, similarly, if the request did not contain a proposed expiry time, a 204 response shall be interpreted as if no expiration time is set by the NF Service Producer for the subscription.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the PUT response body (see clause 4.8).\nIf the NF Service Consumer is not allowed to update the subscription information, the \"403 Forbidden\" HTTP status code shall be returned and appropriate additional error information should be returned in the PUT response body (see clause 4.8).\nIf the resource that is to be updated does not exist at the NF service producer, the \"404 Not Found\" HTTP status code shall be returned.\n4.6.2.2.3.2\tModification of a Subscription Using HTTP PATCH\nProcedures that allow a NF service consumer to update subscription at the server by means of a partial replacement shall use the HTTP PATCH method (see IETF RFC 5789 [10]) to modify the current subscription according to given modification instructions.\nFigure 4.6.2.2.3.2-1 illustrates updating a resource using HTTP PATCH.\nThe figure depicts a simplified representation of a subscription modification using HTTP PATCH. It shows a user interface with a button labeled \"Modify Subscription\" and a text field where the user can input the desired changes. The figure also includes a diagram of the subscription's structure, including the subscription ID, subscription type, and subscription status. The figure is designed to be user-friendly and easy to understand, making it suitable for individuals with limited technical knowledge.\nFigure 4.6.2.2.3.2-1: Modification a subscription using HTTP PATCH\n1.\tThe NF Service Consumer shall send a PATCH request to the resource URI representing the individual subscription. The payload body of the PATCH request shall contain the modification instructions. The request may contain an expiry time (i.e. a future timestamp), requested by the NF Service Consumer, representing the time upto which the subscription is desired to be kept active and the time after which the subscribed event shall stop generating notifications.\n2.\tOn success, \"204 No Content\" without any response body or \"200 OK\" with a response body containing the modified subscription information shall be returned. When \"204 No Content\" is returned and if the request included an expiry time, then the requested expiry time shall be accepted by the NF Service Producer. When \"200 OK\" is returned and if the request included an expiry time then the response based on operator policies and taking into account the expiry time included in the request, shall contain an expiry time (i.e. a future timestamp), as determined by the NF Service Producer, after which the subscription becomes invalid. If an expiry time was included in the request, then the expiry time returned in the response should be less than or equal to that value. Once the subscription expires, if the NF Service Consumer wants to keep receiving notifications, it shall create a new subscription in the NF Service Producer, as specified in clause 4.6.2.2.2. The NF Service Producer shall not provide the same expiry time (i.e. a future timestamp) for many subscriptions in order to avoid all of them expiring and recreating the subscription at the same time.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the PATCH response body (see clause 4.8).\nFigure 4.6.2.2.4-1 illustrates explicit deletion of a subscription.\nThe figure depicts a simplified representation of a subscription management system, showing the deletion of a subscription. The system includes a subscription list, a subscription management interface, and a subscription management database. The deletion of a subscription is represented by the removal of the subscription from the list and the deletion of the associated subscription management interface and database records.\nFigure 4.6.2.2.4-1: Deletion of a subscription\n1.\tThe NF Service Consumer shall send a DELETE request to the resource URI representing the individual subscription. The request body shall be empty.\n2.\tOn success, \"204 No Content\" shall be returned. The response body shall be empty.\nOn failure, the appropriate HTTP status code indicating the error shall be returned in the DELETE response body (see clause 4.8).\nThe HTTP method for the notification that corresponds to an explicit subscription shall be POST (see IETF RFC 7231 [6]).\nNOTE:\tClause 5.3.7 describes how to encode Notifications in OpenAPI specification files.\nFigure 4.6.2.3-1 illustrates a notification.\nThe figure depicts a notification system in a 5G network, showing the various components involved in the notification process. The system includes a base station (gNB), a user equipment (UE), and a network element (NE). The figure illustrates the signal propagation, highlighting the importance of beamforming techniques to mitigate interference.\nFigure 4.6.2.3-1: Notification\n1.\tThe callback reference provided during creation of the subscription resource, or otherwise known from implicit subscription, is used as the request URI. The callback reference for implicit subscriptions are obtained from the NRF. When an NF / NF service registers with the NRF, the default notification subscriptions along with the callback URI for receiving those notifications may be provided (see clause 6.1.6.2.3 of 3GPP TS 29.510 [18]).\nThe payload body of the POST request shall contain the notification payload.\nThe payload body of the notification should follow the resource definition of the subscribed resource and can for example be based on the resource definition of the GET operation, but it is up to the API to define the notification resource definition.\nEach API that supports subscription to collection/store archetype resources, should specify in their semantics whether notifications should be sent by changes on the collection/store resource ONLY (i.e. creation/deletion of the main top-level resource itself, and creation/deletion of its children), or if in addition the consumer can expect to get notifications from changes on the resource representation.\n2.\tOn success, \"200 OK\" shall be returned if any information needs to be included in the payload body of the POST response; otherwise, \"204 No Content\" shall be returned and the payload body of the POST response shall be empty.\nOn failure, the appropriate HTTP status code indicating the error shall be returned and appropriate additional error information should be returned in the POST response body (see clause 4.8).\nServices consumed by an AMF can be transferred seamlessly to a new AMF when the corresponding UE context is transferred to that AMF.\nTo support a seamless change of AMF as NF service consumer, the procedures in clause 4.6.2 are applied with the following special provisions:\n1.\tWhen becoming aware that a new AMF is requiring notifications related to a subscription resource, the NF service producer shall exchange the authority part of the corresponding Notification URI with the address of that new NF service consumer and shall use that URI in subsequent communication.\nNOTE:\tAn NF service producer can become aware of an AMF change via Namf_Communication service AMFStatusChange Notifications, via Error response from old AMF, via link level failures (e.g. no response from the AMF), or via a notification from the NRF that the AMF has deregistered and can then determine the new AMF either via information received within those services or selecting an AMF from an earlier received AMF set or the backup AMF.\n2.\tEach AMF within a set of AMFs supporting seamless changes shall be prepared to receive notifications at the Notification URI constructed according to bullet 1 with the own IP address as authority part from the NF service producer, by either handling the notifications, or by replying with an HTTP \"307 temporary redirect\" error response pointing to new NF service consumer, or by replying with another HTTP error such as an \"404 Not found\".\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.7\tHATEOAS",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.7.1\tGeneral",
                            "text_content": "As defined in [14], HATEOAS stands for Hypermedia As The Engine Of Application State. It means that the hypermedia models application state transitions and describe application protocols.\nAs defined in [15] clause 3 RESTful Domain Application Protocols, an application is a software implementation defined to achieve a particular goal. It consists of a set of constrained interactions between NF Service Consumer and Producer performed at run-time that are guided by an application specific set of rules. The application transits across some intermediate states until the application's goal is achieved. The application has then reached its final state.\nAn application state is a snapshot of an application instance.\nOn each interaction, the NF Service Consumer and Producer exchange representations of resource state. According to [14], \"REST concentrates all of the control state into the representations received in response to interactions.\" and \"The model application is therefore an engine that moves from one state to the next by examining and choosing from among the alternative state transitions in the current set of representations.\" After each interaction the NF Service Consumer is then presented with control state options to interact with additional resources. These control states are in the form of hypermedia markups embedded in the returned resource representation. The application state changes when an NF Service Consumer examines and chooses which control to operate and subsequently interacts with the resources identified in the selected control state.\nHATEOAS support is optional. If HATEOAS is supported, the procedure in the present clause 4.7 shall apply.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.7.2\t3GPP hypermedia format",
                            "text_content": "NOTE 1:\tBasic 3GPP hypermedia format is derived from Hypertext Application Language (HAL). HAL is specified in an expired internet draft available at \"https://tools.ietf.org/html/draft-kelly-json-hal-08\".\nBasic 3GPP hypermedia format specifies the following optional reserved properties (see 3GPP TS 29.571 [5] for the complete list and definition of objects and object members):\n-\t\"_links\": contains links to other resources and expresses valid state transitions.\nA NF service producer shall construct a basic 3GPP hypermedia document by taking a 3GPP defined JSON object attribute list and then adding a \"_links\" attribute.\nTable 4.7.2.1-1: _links attribute\n\nThe LinksValueSchema data type shall be added to the list of re-used data types of the hypermedia enabled API (see 3GPP TS 29.509 [21] for an example of implementation of a hypermedia API).\nNOTE 2:\tDepending of the applicable situation, the presence condition and the cardinality can be changed in accordance. LinksValueSchema data type is defined in 3GPP TS 29.571 [5].\nThe \"_links\" member names are link relation types (as defined by IETF RFC 8288 [11]) and values are either a \"link\" object or an array of \"link\" objects.\nBasic 3GPP hypermedia format specifies the following \"link\" attribute:\n-\t\"href\": contains the URI of the linked resource.\nA NF service producer shall set the Content-Type HTTP header to \"application/3gppHal+json\" when returning an HTTP payload with a basic 3GPP hypermedia enabled document.\nA NF service consumer supporting HATEOAS shall advertise it by adding an \"Accept\" HTTP header with \"application/3gppHal+json\" as media type.\nNOTE 3:\tThe HATEOAS principle relies on NF Service Producer providing control state options (_links objects) embedded in the returned resource representation to the NF Service Consumer. An NF Service Consumer may decide to use the format of the _links attribute in HTTP requests to transfer URIs. This is beyond the scope of HATEOAS and another content type than \"3gppHal+json\" such as \"application/json\" can be used.\nNOTE 1:\tExtended 3GPP hypermedia format is derived from HAL-FORMS media type, see \"https://rwcbook.github.io/hal-forms/\".\nExtended 3GPP hypermedia format specifies the following optional reserved properties (see 3GPP TS 29.571 [5] for the complete list and definition of objects and object members):\n-\t\"_links\": contains links to other resources and expresses valid state transitions;\n-\t\"_templates\": contains the HAL templates corresponding to the _links attribute.\nA NF service producer shall construct a extended 3GPP hypermedia document by taking a 3GPP defined JSON object attribute list and then adding \"_links\" attribute and \"_templates\" attribute.\nTable 4.7.2.2-1: _halForms attribute\n\nThe Link data type and HalTemplate data type shall be added to the list of re-used data types of the hypermedia enabled API.\nNOTE 2:\tDepending of the applicable situation, the presence condition can be changed in accordance. Link and HalTemplate data types are defined in 3GPP TS 29.571 [5].A NF service producer shall set the Content-Type HTTP header to \"application/3gppHalForms+json\" when returning an HTTP payload with Extended 3GPP hypermedia enabled document.\nA NF service consumer supporting HATEOAS and extended 3GPP hypermedia shall advertise it by adding an \"Accept\" HTTP header with \"application/3gppHalForms+json\" as media type.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 4.7.2.1-1: _links attribute",
                                    "table number": 3,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 4.7.2.2-1: _halForms attribute",
                                    "table number": 4,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "4.7.3\tAdvertising legitimate application state transitions",
                            "text_content": "When a NF service producer responds to a NF service consumer and there is one or more application state transition possible, the NF service producer shall advertise them by adding a \"_links\" property in the returned resource representation. When there are multiple state transitions with different relation types, then one member per relation type shall be added to the \"_links\" object which name is equal to the relation type. If there is only one state transition for a given relation type then the value of the member is a \"link\" object otherwise it is an array of \"link\" objects.\nA NF service producer shall include a link into the returned resource representation with a registered relation type \"self\" when it is expected further actions upon it (for instance reading it again or replacing the resource state).\nNOTE 1:\tFor a hypermedia application, a returned representation without any link denotes for the NF service consumers the end of the interaction with the NF service producer. 3GPP APIs does not fulfil this rule.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.7.4\tInferring link relation semantic",
                            "text_content": "When a NF service consumer receives a response with linked resources then it shall infer the link relation semantic from the relation type. It shall not infer it from the linked resource URI format.\nIn 3GPP hypermedia, relation types are the name of \"_links\" object members.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.7.5\tCommon Relation Types",
                            "text_content": "This clause contains the list of relation types supported in 3GPP Service Based Interface APIs.\nAs defined in IETF RFC 8288 [11] clause 2.1, a link relation type identifies the semantics of a link. It describes how resources are related to each other. It may also be used to indicate that the target resource of a link has particular attributes, or exhibits particular behaviours. Relation types shall not be confused with media types. It does not identify the format of the representation that results when the link is dereferenced.\nThere are two kinds of relation types:\n-\tRegistered relation types;\n-\tExtension relation types.\nRegistered relation types are identified by a token (for instance \"self\") and can be reused by other applications such as 3GPP SBI APIs. They are registered by IANA. Registered relation types shall be preferred against extension relation types when expressing the link relation between two resources.\nIf there is a need to define a relation type that does not correspond to a registered one but it is not wanted to register it then an extension relation type shall be used instead.\nThe \"Link Relations\" registry is located at: https://www.iana.org/assignments/link-relations.\nTable 4.7.5.2-1 specifies the list of registered relation types supported by all hypermedia enabled 3GPP APIs.\nTable 4.7.5.2-2 specifies the list of registered relation types that can be used by some hypermedia enabled 3GPP APIs, depending on the API design.\nTable 4.7.5.2-1: mandatory registered relation types\nTable 4.7.5.2-2: optional registered relation types\n\nWhen no registered relation exists to express the relation between two resources, an extension relation type shall be used instead. It may be defined as a string token or as a URI as defined in IETF RFC 8288 [11].\nAn API specification using extension relation types shall contain a clause \"Relation types\" in the clause \"Simple data types and enumerations\" (see 3GPP TS 29.509 [21] for an example of implementation of a hypermedia API). The clause shall contain a table listing the token or the URI of the created relation types. It shall also contain a detailed specification of the semantic of the relation types defining the conditions that the NF Service Consumer shall match to follow a link.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 4.7.5.2-1: mandatory registered relation types",
                                    "table number": 5,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 4.7.5.2-2: optional registered relation types",
                                    "table number": 6,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "4.7.6\tNegotiating the support of optional HATEOAS features",
                            "text_content": "The supported feature mechanism in clause 6.6.2 of 3GPP TS 29.500 [2] should be used to negotiate the usage of optional HATEOAS features in addition to negotiating the content type \"3gppHal+json\" and \"3gppHalForms+json\". Separate supported features can be defined for link relation types related to different use cases.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.8\tError Responses",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.8.1\tError Response Status Code",
                            "text_content": "When an error occurs that prevents the NF/NF service acting as an HTTP server from successfully fulfilling the HTTP request, the NF/NF service shall map an application error to the most similar 4xx/5xx HTTP status code as defined in clause 5.2.7 of 3GPP TS 29.500 [2].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.8.2\tError Response Body",
                            "text_content": "When the HTTP status code is not enough for the NF/NF service acting as an HTTP client to determine the cause of the error, the NF/NF service acting as an HTTP server should provide additional application related error information, by including in the response body a representation of a \"ProblemDetails\" data structure according to IETF RFC 9457 [19] that provides additional details of the error.\nNOTE 1:\tThe response body with the \"ProblemDetails\" data structure does not need to be sent on a 3GPP 5GC API for a particular HTTP status code if that HTTP status code itself provides enough information of the error, or if there are security concerns disclosing detailed error information.\nThe definition of the general \"ProblemDetails\" data structure from IETF RFC 9457 [19] is specified in clause 5.2.4.1 of 3GPP TS 29.571 [5]. The \"ProblemDetails\" data structure is a JSON object, as defined in IETF RFC 9457 [19], and contains the following attributes:\na)\t\"type\" - a URI reference according to IETF RFC 3986 [9] that identifies the problem type;\nb)\t\"title\" - a short, human-readable summary of the problem type that should not change from occurrence to occurrence of the problem;\nc)\t\"status\" - the HTTP status code for this occurrence of the problem;\nd)\t\"detail\" - a human-readable explanation specific to this occurrence of the problem; and\ne)\t\"instance\" - a URI reference that identifies the specific occurrence of the problem.\nA particular API may define additional attributes that provide more information about the error.\nNOTE 2:\tIETF RFC 9457 [19] allows adding of new properties in the \"ProblemDetails\" object.\nThe following additional attributes are generic extensions defined for the 3GPP 5GC APIs:\na)\t\"cause\"- a machine-readable application error cause specific to this occurrence of the problem; and\nb)\t\"invalidParams\" - invalid parameters causing a request to be rejected.\nThe \"cause\" attribute should be included and provide application-related error information, if available. Application error causes should be defined in 5GC SBI APIs specifications, using the UPPER_WITH_UNDERSCORE case convention specified in clause 5.1.1.\nEXAMPLE 1:\t\"OUT_OF_LADN_SA\".\nThe \"invalidParams\" attribute should be used to report invalid parameters when a request is rejected due to invalid parameters.\nAll the application error causes supported by an API should be defined in a specific clause \"Application Errors\" under the \"Error Handling\" clause specified for the API. The application error causes that a specific service operation may respond should be further listed in the table defining the data structure supported by the response body, with the associated HTTP error status code.\nTo enable a SEPP or an SCP for Indirect Communications to provide error details in error responses they originate, all service operations should support returning error responses including a representation of a \"ProblemDetails\" data structure. If additional application specific information is required in the error responses, the API should support returning the additional applicative information as specified in clause 4.8.3. The NF/NF service that generates the HTTP response shall include in the HTTP response a \"Content-Type\" header field set to:\n-\t\"application/problem+json\", if the response includes a payload body containing the \"ProblemDetails\" (or extended ProblemDetails, see clause 4.8.3) data structure; or\n-\t\"application/json\", if the response includes a payload body containing an application-specific data structure.\nNOTE 3:\tDesigning an error response payload body containing an application-specific data structure is discouraged for new APIs or service operations as this prevents a SEPP or an SCP when using indirect communications to include error details for errors they originate. If an API is defined with an application-specific error response body, the API also needs to support an error response body encoding a ProblemDetails object.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.8.3\tExtending ProblemDetails for API Backward Compatibility",
                            "text_content": "For a service operation that returns \"ProblemDetails\" in error responses in a given release, if in a later release it is required to provide additional application specific information in the error responses, the API should be modified to return an Extended-ProblemDetails data type by reusing the \"ProblemDetails\" common data type, as specified in clause 5.3.17, to keep the API backward compatibility.\nThe \"Content-Type\" header shall be set to \"application/problem+json\" for the error response with the payload body containing the Extended-ProblemDetails data type define above.\nEXAMPLE:\n-\tan \"AdditionInfo<ServiceOperation>\" structured data type containing the additional information to be returned, as specified in clause 5.2.4.2:\nTable 4.8.3-1 Definition of type AdditionInfo<ServiceOperation>\n\n-\ta \"ProblemDetails<ServiceOperation>\" data type as combination of \"ProblemDetails\" common data type and \"AdditionInfo<ServiceOperation>\" data type define above, as specified in clause 5.2.4.5:\nTable 4.8.3-2 Definition of type ProblemDetails<ServiceOperation> as a list of to be combined data types\n\nExample OpenAPI specification of ProblemDetails<ServiceOperation> data type, as specified in clause 5.3.10:\ncomponents:\nschemas:\nProblemDetails<ServiceOperation>:\nallOf:\n- $ref: 'TS29571_CommonData.yaml#/components/schemas/ProblemDetails'\n- $ref: '#/components/schemas/AdditionInfo<ServiceOperation>'\n\nExample OpenAPI specification of an error response returning ProblemDetails<ServiceOperation> data type:\nresponses:\n'504':\ndescription: Gateway Timeout\ncontent:\napplication/problem+json:\nschema:\n$ref: '#/components/schemas/ProblemDetails<ServiceOperation>'\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 4.8.3-1 Definition of type AdditionInfo<ServiceOperation>",
                                    "table number": 7,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 4.8.3-2 Definition of type ProblemDetails<ServiceOperation> as a list of to be combined data types",
                                    "table number": 8,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "4.9\tTransferring multiple resources to a NF Service Consumer",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.9.1\tGeneral",
                            "text_content": "This clause describes some possible options that an API may implement when a NF Service Producer needs to return the representations of multiple resources to a NF Service Consumer, e.g. during the query of a large collection of resources (see clause 4.6.1.1.2.2).\nWhich options an API may support is defined in the respective stage 3 specification of the API.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.9.2\tDirect Delivery",
                            "text_content": "A NF Service Producer may return the representations of the resources directly in the response body, i.e. the response body contains an array of the resource representations.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.9.3\tDirect Delivery with Iterations",
                            "text_content": "If a large number of resource representations need to be returned, the NF Service Producer may return a representation containing a partial list of the requested resources in the response body, with link(s) containing URI(s) allowing the client to retrieve the remaining part(s) of the resources.\n\nThe returned representation containing a partial list of the requested resource is a \"3gppHal+json\" document. The document is a JSON object with two members whose names are below.\n-\t_links.\n-\tchild: contains the resources of the partial list.\nThe member whose name is \"_links\" shall contain a member whose name is \"self\" and whose value is a \"link\" object that contains the URI of the returned representation. It shall also contain a member whose name is \"next\" and whose value is a \"link\" object that contains the URI of the next partial list of the collection if the returned partial list is not the last one.\nThe member whose name is \"_links\" should also contain members whose names are \"first\", \"previous\" and \"last\" and whose values contain a \"link\" object that contains the URIs of the first, previous and last partial lists of the collection if such lists exist.\nThe returned representation shall have a member whose name is \"child\" and whose value is an array of objects. Each of the individual resource representations returned in the partial list shall be embedded in an object of that array. Each object shall also have a member whose name is \"_links\". The later shall contain a member whose name is \"self\" and whose value is a \"link\" object that contains the URI of the embedded representation.\nThe table below provides a template to be added in the clause describing the GET operation of a 3GPP API using the direct delivery with iteration mechanism.\nTable 4.9.3-1: Data structures supported by the GET Response Body on this resource\n\nThe following data types shall be added to the list of specific data types and described as below in the structured data type clause.\nTable 4.7.2-1: PartialList\n\nTable 4.7.2-1: ApiSpecificHypermediaEnabledIndividualResource\n\nNOTE 1:\tattributes 1 to N are the attributes of the original individual resource.\nThe LinksValueSchema and SelfLink data types shall be added to the list of re-used data types of the 3GPP API.\nA NF Service Consumer that receives link(s) in the response body may retrieve the remaining part(s) of the resources by sending GET requests towards the URI(s) contained in the link(s).\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 4.9.3-1: Data structures supported by the GET Response Body on this resource",
                                    "table number": 9,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 4.7.2-1: PartialList",
                                    "table number": 10,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 4.7.2-1: ApiSpecificHypermediaEnabledIndividualResource",
                                    "table number": 11,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "4.9.4\tIndirect Delivery",
                            "text_content": "A NF Service Producer may not return any requested resource representation and instead may return a representation containing only a list of links to the requested resources in the response body.\nThe returned representation containing the list is a \"3gppHal+json\" document. The document is a JSON object with one member whose name is:\n-\t_links.\nThis member shall contain a member whose name is \"item\" and whose value is an array of \"link\" objects. Each of the link objects contains one requested resource URI. There shall be one link object per requested resource.\nIt shall also contain a member whose name is \"self\" and whose value is a \"link\" object that contains the URI of the returned representation.\nA NF Service Consumer that receives such a response may then send a GET request per resource URI to retrieve the requested resources from the NF Service Producer.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.9.5\tIndirect Delivery with HTTP/2 Server Push",
                            "text_content": "A NF Service Producer may use HTTP/2 Server Push, if HTTP/2 Server Push is supported in the PLMN.\nTo use HTTP/2 Server Push, the NF Service Producer shall send PUSH_PROMISE frames in the HTTP response, with each PUSH_PROMISE frame containing a GET request targeting the URI of one resource to be transferred and the reserved stream identifier to be used for transferring the resource. Then the NF Service Producer shall send Push Responses via the corresponding reserved streams, with each Push Response containing the representation of the associated resource. The NF Service Producer shall also send links with the URIs of the resources in DATA frame(s) of the response message.\nA NF Service Consumer may disable HTTP/2 Server Push by sending SETTINGS_ENABLE_PUSH parameter with value \"0\" on HTTP level, as specified in IETF RFC 7540 [13].\nThe figure depicts a scenario where an HTTP/2 server is pushing content to a client, which is being delivered indirectly through a network of HTTP/2 servers. This is achieved through the use of a Content Delivery Network (CDN) to distribute the content across multiple servers, ensuring faster and more reliable delivery.\nFigure 4.9.5-1 Indirect Delivery with HTTP/2 Server Push\n1.\tA NF Service Consumer sends a HTTP request to get resources(s) to the NF Service Producer, e.g. a query of a collection of resources.\n2.\tThe NF Service Producer detects that multiple resources are to be returned and choose to indirectly deliver the resources with the Server Push mechanism.\n3.\tThe NF Service Producer returns multiple PUSH_PROMISE Requests before HEADERS frame and DATA frames(s) to the NF Service Consumer. Each PUSH_PROMISE Request contains the URI of one resource to be transferred and the identifier of the reserved stream used for transferring the resource. The NF Service Producer shall also send links with the URIs of the resources in DATA frame(s) of the response message.\n4.1-4.n. The NF Service Producer sends Push Reponses via corresponding reserved streams. Each Push Response contains the representation of the associated resource.\n5. If the NF Service Consumer does not successfully receive a resource in time, it may send a request to get that resource, using the resource URI previously received from the Push Request.\n5.a. The NF Service Producer returns the data of the requested resource in the response.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.9.6\tCriteria for choosing the transfer method",
                            "text_content": "The following considerations may be used to determine which method to use transfer multiple resources to a NF Service Consumer.\nIf the size of the representation of each resource is small, direct delivery is preferred. If the number of resources to be returned is large, the NF Service Producer may choose iterative delivery.\nNOTE 1:\tFor this release of this specification, a JSON payload size less than 64000 octets is considered as not large and a JSON payload size larger than 64000 octets is considered as large.\nIf the size of the representation of each resource is large, indirect delivery is preferred. If the NF Service Producer supports HTTP/2 Server Push, then:\n-\twhen SETTINGS_ENABLE_PUSH parameter with value \"1\" has been received from the NF Service Consumer, as specified in IETF RFC 7540 [13], it should choose HTTP/2 Server Push to deliver the resource.\n-\twhen SETTINGS_ENABLE_PUSH parameter with value \"0\" has been received from the NF Service Consumer, as specified in IETF RFC 7540 [13], it must not choose HTTP/2 Server Push to deliver the resources.\n-\twhen SETTINGS_ENABLE_PUSH parameter has not been received from the NF Service Consumer, as specified in IETF RFC 7540 [13], it may decide whether to use HTTP/2 Server push or not, depending on other factors, e.g. operator policy, whether the client and server pertain to the same PLMN, etc.\nAn NF Service Producer shall use Indirect Delivery with HTTP/2 Server Push only if the NF Service Consumer (client) indicated support for accepting server pushed resource representations, via the Supported Features negotiation as specified in clause 6.6.2 of 3GPP TS 29.500 [2].\nNOTE 2:\tIn this release the Indirect Delivery with HTTP/2 Server Push is not used by 3GPP service based interface APIs.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.10\tScopes definition for OAuth2.0 access token",
                    "description": "",
                    "summary": "",
                    "text_content": "As indicated in 3GPP TS 33.501 [22] and in clause 6.7.3 of 3GPP TS 29.500 [2], the access to an 5GC API may be authorized by means of the OAuth 2.0 protocol (see IETF RFC 6749 [23]), based on local configuration. OAuth 2.0 supports the concept of scope values to signal which actual access rights an access token represents.\nEach 5GC API shall define a service-level scope set to the service name of the NF Service. This scope grants generic access to the given API, for those operations on resources that do not require a specific authorization. In addition, a 5GC API may define additional resource/operation-level scopes, that uniquely represents the type of operation (e.g. create/modify/read), the resource and the service; a resource/operation-level scope and the service-level scope, together, grant access to the operations on resources that require a specific authorization.\nThe need for defining additional resource/operation-level scopes in a 5GC API depends on the API functionalities and service operations and on the expected NF service consumers, and thus is up to the API responsible Working Group to decide. The following points may be considered when assessing the need for additional scopes:\n-\tIt should be carefully assessed during the design of the 5GC API whether different access rights to the functionalities provided by the API may be needed for different NF service consumers, e.g. considering example NF service consumers of the different service operations supported by the API.\n-\tA 5GC API defined with a service-level scope only, i.e. without additional resource/operation-level scopes, grants access permissions to all its service operations to all NF service consumers allowed to access the service. It should be ensured that designing the API in this way does not cause any vulnerability to the 5GS, e.g. by granting inappropriate read access to sensitive data to undue NF service consumers or by granting inappropriate write (or delete) access to undue NF service consumers.\n-\tAdditional scopes should be defined when it is needed to enable restricting the access to certain resource/operations of the 5GC API to specific NF service consumers. This may be the case e.g. when an API supports multiple service operations that may be invoked by different NF service consumers (possibly with different NF types or belonging to different S-NSSAIs, PLMNs or SNPNs), or when it is needed to differentiate access rights for read vs. create/modify/write operations.\n-\tThe definition of additional scopes comes with some implementation and network operation complexity. Care should be taken not to increase unreasonably the number of scopes defined in a 5GC API.\n-\tEach additional resource/operation-level scope shall be defined with a clear description (in the main body and in the OpenAPI file of the Technical Specification defining the API) of the access right the additional scope corresponds to. The naming of the resource/operation-level scopes should follow the conventions defined in clause 5.3.16 for ease of understanding and consistency across all 5GC APIs.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "5\tDocumenting 5GC SBI APIs",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "5.1\tNaming Conventions",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.1.1\tCase Conventions",
                            "text_content": "The following case conventions for names and strings are used in the 5GC SBI service APIs.\n1)\tUPPER_WITH_UNDERSCORE\nAll letters of a string are capital letters. Digits are allowed. Word boundaries are represented by the underscore \"_\" character. No other characters are allowed.\nExample 1:\na)\tDATA_MANAGEMENT\nb)\tCELL_CHANGE\n2)\tlower_with_underscore\nAll letters of a string are lowercase letters. Digits are allowed. Word boundaries are represented by the underscore \"_\" character. No other characters are allowed.\nExample 2:\na)\tdata_management;\nb)\tcell_change.\n3)\tUPPER-WITH-HYPHEN\nAll letters of a string are capital letters. Digits are allowed. Word boundaries are represented by the hyphen \"-\" character. No other characters are allowed.\nExample 3:\na)\tDATA-MANAGEMENT\nb)\tCELL-CHANGE\n4)\tlower-with-hyphen\nAll letters of a string are lowercase letters. Digits are allowed. Word boundaries are represented by the hyphen \"-\" character. No other characters are allowed.\nExample 4:\na)\tdata-management;\nb)\tcell-change.\n5)\tUpperCamel\nA string is formed by concatenating words. Each word starts with a letter or a digit. The first letter of each word shall be an uppercase letter; all other characters in the word shall be lowercase letters or digits.\nAbbreviations follow the same scheme (i.e. first letter uppercase, all other letters lowercase).\nExample 5:\na)\tDataManagement.\nb)\tCellChange\nc)\t5QiPriorityLevel\nd)\tAmf3GppAccessRegistration\n6)\tlowerCamel\nA string is formed by concatenating words.Each word starts with a letter or a digit. The first letter of the first word shall be a lowercase letter; the first letter of the rest of the words shall be an uppercase letter. All other characters in the words shall be lowercase letters or digits.\nAbbreviations follow the same scheme.\nExample 6:\na)\tdataManagement\nb)\tcellChange\nc)\t5qiPriorityLevel\nNOTE:\tThese naming conventions are used as guidelines, to provide some uniformity in the specification of the different 5GC APIs. However, for different reasons, sometimes exceptions can be made. In any case, the OpenAPI specifications are mandatory, and the different network elements cannot determine that a certain message, that otherwise complies to the OpenAPI specification, is incorrect based only on the fact that it does not follow a given naming convention in a certain data element.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.1.2\tAPI Naming Conventions",
                            "text_content": "An API shall take the name of the corresponding service (e.g. Nudm_SubscriberDataManagement). When used in URIs the name shall be converted to lower-with-hyphen and may use an abbreviated form (e.g. nudm-sdm).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.1.3\tConventions for URI Parts",
                            "text_content": "The parts of the URI syntax that are relevant in the context of the 5GC SBI service APIs are as follows:\n-\tPath, consisting of segments, separated by \"/\" (e.g. segment1/segment2/segment3).\n-\tQuery, consisting of pairs of parameter name and value (e.g., ?mcc=262&mnc=01, where two pairs are presented).\na)\tAll path segments of a resource URI which represent a string constant shall use lower-with-hyphen (this implies that a path cannot end with \"/\").\nExample 1:\nsubscriber-data\nb)\tIf a resource represents a collection of entities and the last path segment of the resource URI is a string constant, that last path segment shall be plural.\nExample 2:\n…/prefix/api/v1/users\nc)\tFor resources where the last path segment of the resource URI is a string constant, that last path segment shall be a noun or a composite noun.\nExample 3:\n…/prefix/api/v1/users\nExample 4:\n…/prefix/api/v1/user-session\nd)\tFor custom operations, the last path segment of the URI via which the operation is invoked shall be a verb, or shall start with a verb.\nExample 5:\n…/app_instances/{appInstanceId}/instantiate\nExample 6:\n…/sessions/terminate-all\ne)\tAll path segments of a URI which are variable names shall use lowerCamel, and shall be surrounded by curly brackets.\nExample 7:\n…/subscriber-data/{supi}\nf)\tOnce a variable is replaced at runtime by an actual string, the string shall follow the rules for a path segment defined in IETF RFC 3986 [9]. IETF RFC 3986 [9] disallows certain characters from use in a path segment. Each actual 5GC SBI service API specification shall define this restriction to be followed when generating values for path segment variables, or propose a suitable encoding (such as percent-encoding according to IETF RFC 3986 [9]), to escape such characters if they can appear in input strings intended to be substituted for a path segment variable.\na)\tURI query parameter names in queries shall use lower-with-hyphen.\nExample 1:\n?nf-type=AMF\nb)\tVariables that represent actual parameter values in queries shall use lowerCamel and shall be surrounded by curly brackets.\nExample 2:\n?nf-id={chooseAValue}\nc)\tWhen a variable is replaced at runtime by an actual string, the convention defined in clause 5.1.3.2 item f) applies to that string.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.1.4\tConventions for Names in Data Structures",
                            "text_content": "The following syntax conventions apply when defining the names for attributes in the 5GC SBI service API data structures, carried in the payload body of http requests and responses.\na)\tNames of attributes shall be represented using lowerCamel.\nExample 1:\nattributeName\nb)\tNames of arrays (i.e. those with cardinality 1..N or 0..N) shall be plural rather than singular.\nExample 2:\nusers\nc)\tEach value of an enumeration type shall be represented using UPPER_WITH_UNDERSCORE.\nExample 3:\nPROHIBITTED_LISTED\nd)\tThe names of data types shall be represented using UpperCamel.\nExample 4:\nResourceHandle\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.2\tAPI Definition",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.2.1\tResource Structure",
                            "text_content": "Resource structure shall define the structure of the resource URIs, the resources, the associated HTTP methods and custom operations used for the service.\nFigure 5.2.1-1 provides an example of the resource URI structure (i.e. resource tree) of an API. Table 5.2.1-1 provides an example of an overview of the resources defined for the service, and their applicable HTTP methods and custom operations.\nThe figure depicts the structure of the <xyz> API's resource URI, which is a crucial component of the API's structure. It includes the base URL, path, and query parameters, providing a clear and concise representation of the API's functionality.\nFigure 5.2.1-1: Resource URI structure of the <xyz > API\nIn figure 5.2.1-1 the following graphical conventions are used:\n-\ta child node with a solid-line frame represents:\n-\ta resource-URI that has at least one supported HTTP method associated, see e.g. \"/resource A\" in Figure 5.2.1-1. Such node may be any of the archetypes defined in Annex C1, C2 and C3;\n-\ta resource-URI, which does not have any standard HTTP operation defined, but has a custom operation, see e.g. \"/individual child resource A2\" in Figure 5.2.1-1;\n-\ta child node with a dashed-line frame represents a  a specific custom operation, see e.g. \"/custom operation A3\" and \"/custom operation C1\" in Figure 5.2.1-1. Such node is a Custom operation archetype, see Annex C4;\n-\ta child node without a line around its frame (e.g. \"/special node type B\" in Figure 5.2.1-1)  typically represents a path segment for which no standard HTTP operation is specified. This graphical representation is also used when a custom operation without an associated resource is defined for a path segment.  .\nTable 5.2.1-1: Resources and methods overview\n\nNOTE 1:\tThe \"API URI\" is defined in clauses 3.1 and 4.4.1.\nFor a resource, the \"relative path after API URI\" is appended to the API URI to form the resource URI as defined in clause 3.1.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.1-1: Resources and methods overview",
                                    "table number": 12,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.2.2\tResources and HTTP Methods",
                            "text_content": "Resources and HTTP methods shall specify the resource URI, resource URI variables for the resource and the standard HTTP methods supported by the resource.\n\nExample:\nResource URI: {apiRoot}/<apiName>/<apiVersion>/<apiSpecificResourceUriPart>\n\nThe resource URI variables supported by the resource shall be defined as table 5.2.2-1 illustrates.\nTable 5.2.2-1: Resource URI variables for the resource\n\nThe {apiRoot} URI variable should be defined in clauses and this definition should be referenced to ease a possible update of the apiVersion value.\nEach method supported by the resource shall be described including the URI query parameters supported by the method, data structures supported by the request body, and the data structures supported by the response body.\n\nURI query parameters supported by the method shall be defined as table 5.2.2-2 illustrates.\nTable 5.2.2-2: URI query parameters supported by a method on the resource\n\nName: Name of query parameter in URI. If no query parameters are defined for the URI, the name should be marked as \"n/a\".\nData type: Data type of URI query parameters, i.e. a data type defined in the specification. If no query parameter is defined for the URI, the column is left empty.\nP: Presence condition of URI query parameters. It shall be one of \"M\" (for Mandatory), \"C\" (for Conditional) and \"O\" (for Optional). If no query parameter is defined for the URI, the column is left empty.\nCardinality: Defines the allowed number of occurrence. It shall be \"0..1\", \"1\", \"0..N\", \"1..N\" . If no query parameter is defined for the URI, the column is left empty.\nDescription: Additional information for URI query parameter, i.e. describes the use of the parameter or the presence condition of the parameter and so on.\nApplicability: If the URI query parameter is only applicable for optional feature(s) negotiated using the mechanism defined in clause 6.6.2 of 3GPP TS 29.500 [2], the name of the corresponding feature(s) shall be indicated in this column. If no feature is indicated. the attribute can be used with any feature.\nNOTE 1:\tIf no optional features are defined for an API, the applicability column can be omitted for that API.\nData structures supported by the request body of the method shall be specified as table 5.2.2-3 illustrates.\nTable 5.2.2-3: Data structures supported by the request body on the resource\n\nData type: Data type of the data structure in the request body. If the data type is indicated as \"<type>\", the request body shall be of data type <type>. If the data type is indicated as \"array(<type>)\", the request body shall be an array (see IETF RFC 8259 [3]) that contains elements of data type <type>. If the data type is indicated as \"map(<type>)\", the request body shall be an object (see IETF RFC 8259 [3]) encoding a map (see clause 5.2.4.2) that contains as values elements of data type <type>.  <type> can either be \"integer\", \"number\", \"string\" or \"boolean\" (as defined in the OpenAPI specification [4]), or a data type defined in a 3GPP specification. If no request body is allowed, the Data type shall be marked as \"n/a\".\nP: Presence condition of a data structure in request body. It shall be one of \"M\" (for Mandatory), \"C\" (for Conditional) and \"O\" (for Optional).\nCardinality: Defines the allowed number of occurrence of data type <type>. A cardinality of \"M..N\", is only allowed for data types \"array(<type>)\" and \"map(<type>)\" and indicates the number of elements within the array or map; the values M and N can either be the characters \"M\" and \"N\", respectively, or integer numbers with M being greater than or equal 0, and N being greater than 0 and M. For data type \"<type>\", the cardinality shall be set to \"0..1\" if the Presence condition is \"C\" or \"O\", and to \"1\" if the Presence condition is \"M\". The Cardinality shall be left empty if no request body is allowed.\nDescription: Additional information for a data structure, i.e. describes the use of the data structure or the presence condition of the data structure and so on.\nNOTE 2:\tThe cardinality of \"0..N\" does not imply that the presence condition of the array or map is optional or conditional, i.e. the presence condition can be \"M\" while the cardinality is \"0..N\", the presence condition can be \"O\" or \"C\" while the cardinality is \"1..N\".\nData structures supported by the response body of the method shall be specified as table 5.2.2-4 illustrates.\nTable 5.2.2-4: Data structures supported by the response body on the resource\n\nData type: Data type of the data structure in the response body. If the data type is indicated as \"<type>\", the response body shall be of data type <type>. If the data type is indicated as \"array(<type>)\", the response body shall be an array (see IETF RFC 8259 [3]) that contains elements of data type <type>. If the data type is indicated as \"map(<type>)\", the response body shall be an object (see IETF RFC 8259 [3]) encoding a map (see clause 5.2.4.2)  that contains as values elements of data type <type>. <type> can either be \"integer\", \"number\", \"string\" or \"boolean\" (as defined in the OpenAPI specification [4]), or a data type defined in a 3GPP specification. If no response body is allowed, the Data type shall be marked as \"n/a\".\nP: Presence condition of a data structure in response body. It shall be one of \"M\" (for Mandatory), \"C\" (for Conditional) and \"O\" (for Optional).\nCardinality: Defines the allowed number of occurrence of data type <type>. A cardinality of \"M..N\", is only allowed for data types \"array(<type>)\" and \"map(<type>)\" and indicates the number of elements within the array or map; the values M and N can either be the characters \"M\" and \"N\", respectively, or integer numbers with M being greater than or equal 0, and N being greater than 0 and M. For data type \"<type>\", the cardinality shall be set to \"0..1\" if the Presence condition is \"C\" or \"O\", and to \"1\" if the Presence condition is \"M\". The Cardinality shall be left empty if no response body is allowed.\nResponse codes: Lists applicable response codes with name from HTTP Status Code Registry at IANA [12]. Mandatory HTTP status codes listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [2] for the corresponding HTTP method shall only be included if specific clarifications in the description part or special data types of the response body are required. Applicable HTTP status codes in addition to the mandatory HTTP status codes listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [2] for the corresponding HTTP method shall be included.\nDescription: Additional information for a response, i.e. describes the meaning of the success case or meaning of the error case with additional statement regarding error handling.\nNOTE 3:\tThe cardinality of \"0..N\" does not imply that the presence condition of the array or map is optional or conditional, i.e. the presence condition can be \"M\" while the cardinality is \"0..N\", the presence condition can be \"O\" or \"C\" while the cardinality is \"1..N\".\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.2-1: Resource URI variables for the resource",
                                    "table number": 13,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.2-2: URI query parameters supported by a method on the resource",
                                    "table number": 14,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.2-3: Data structures supported by the request body on the resource",
                                    "table number": 15,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.2-4: Data structures supported by the response body on the resource",
                                    "table number": 16,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.2.3\tRepresenting RPC as Custom Operations on Resources",
                            "text_content": "Custom operations (RPC-style interaction) may be used on a resource. The description of each custom operation contains the custom operation URI, the HTTP method on which the operation is mapped (typically POST), data structures supported by the request body and the data structures supported by the response body.\nAn overview of the custom operations on a resource is illustrated in table 5.2.3-1.\nTable 5.2.3-1: Custom operation\n\nData structures supported by the request body of the method shall be specified as table 5.2.3-2 illustrates.\nTable 5.2.3-2: Data structures supported by the mapped HTTP method request body on the resource\n\nData type: Data type of the data structure in the request body. If the data type is indicated as \"<type>\", the request body shall be of data type <type>. If the data type is indicated as \"array(<type>)\", the request body shall be an array (see IETF RFC 8259 [3]) that contains elements of data type <type>. If the data type is indicated as \"map(<type>)\", the request body shall be an object (see IETF RFC 8259 [3]) encoding a map (see clause 5.2.4.2)  that contains as values elements of data type <type>. <type> can either be \"integer\", \"number\", \"string\" or \"boolean\" (as defined in the OpenAPI specification [4]), or a data type defined in a 3GPP specification. If no request body is allowed, the Data type shall be marked as \"n/a\".\nP: Presence condition of a data structure in request body. It shall be one of \"M\" (for Mandatory), \"C\" (for Conditional) and \"O\" (for Optional).\nCardinality: Defines the allowed number of occurrence of data type <type>. A cardinality of \"M..N\", is only allowed for data types \"array(<type>)\" and \"map(<type>)\" and indicates the number of elements within the array or map; the values M and N can either be the characters \"M\" and \"N\", respectively, or integer numbers with M being greater than or equal 0, and N being greater than 0 and M. For data type \"<type>\", the cardinality shall be set to \"0..1\" if the Presence condition is \"C\" or \"O\", and to \"1\" if the Presence condition is \"M\". The Cardinality shall be left empty if no request body is allowed.\nDescription: Additional information for a data structure, i.e. describes the use of the data structure or the presence condition of the data structure and so on.\nNOTE 1:\tThe cardinality of \"0..N\" does not imply that the presence condition of the array or map is optional or conditional, i.e. the presence condition can be \"M\" while the cardinality is \"0..N\", the presence condition can be \"O\" or \"C\" while the cardinality is \"1..N\".\nData structures supported by the response body of the method shall be specified as table 5.2.3-3 illustrates.\nTable 5.2.3-3: Data structures supported by the mapped HTTP method response body on the resource\n\nData type: Data type of the data structure in the response body. If the data type is indicated as \"<type>\", the response body shall be of data type <type>. If the data type is indicated as \"array(<type>)\", the response body shall be an array (see IETF RFC 8259 [3]) that contains elements of data type <type>. If the data type is indicated as \"map(<type>)\", the response body shall be an object (see IETF RFC 8259 [3]) encoding a map (see clause 5.2.4.2) that contains as values elements of data type <type>. <type> can either be \"integer\", \"number\", \"string\" or \"boolean\" (as defined in the OpenAPI specification [4]), or a data type defined in a 3GPP specification. If no response body is allowed, the Data type shall be marked as \"n/a\".\nP: Presence condition of a data structure in response body. It shall be one of \"M\" (for Mandatory), \"C\" (for Conditional) and \"O\" (for Optional).\nCardinality: Defines the allowed number of occurrence of data type <type>. A cardinality of \"M..N\", is only allowed for data types \"array(<type>)\" and \"map(<type>)\" and indicates the number of elements within the array or map; the values M and N can either be the characters \"M\" and \"N\", respectively, or integer numbers with M being greater than or equal 0, and N being greater than 0 and M. For data type \"<type>\", the cardinality shall be set to \"0..1\" if the Presence condition is \"C\" or \"O\", and to \"1\" if the Presence condition is \"M\". The Cardinality shall be left empty if no response body is allowed.\nResponse codes: Lists applicable response codes with name from HTTP Status Code Registry at IANA [12]. Mandatory HTTP status codes listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [2] for the corresponding HTTP method shall only be included if specific clarifications in the description part or special data types of the response body are required. Applicable HTTP status codes in addition to the mandatory HTTP status codes listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [2] for the corresponding HTTP method shall be included.\nDescription: Additional information for a response, i.e. describes the meaning of the success case or meaning of the error case with additional statement regarding error handling.\nNOTE 2:\tThe cardinality of \"0..N\" does not imply that the presence condition of the array or map is optional or conditional, i.e. the presence condition can be \"M\" while the cardinality is\"0..N\", the presence condition can be \"O\" or \"C\" while the cardinality is \"1..N\".\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.3-1: Custom operation",
                                    "table number": 17,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.3-2: Data structures supported by the mapped HTTP method request body on the resource",
                                    "table number": 18,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.3-3: Data structures supported by the mapped HTTP method response body on the resource",
                                    "table number": 19,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.2.3A\tNotifications",
                            "text_content": "Notifications based on the Callback URI as specified in clause 4.6.2.3 and clause 6.2 of 3GPP TS 29.500 [2] may be supported. The description of each notification contains the Callback URI, the HTTP method (typically POST), data structures supported by the request body and the data structures supported by the response body.\nAn overview of the notifications is illustrated in table 5.2.3A-1.\nTable 5.2.3A-1: Notifications overview\n\nExample:\nCallback URI: {notifUri}\n\nThe callback URI variables shall be defined as table 5.2.3A-2 illustrates.\nTable 5.2.3A-2: Callback URI variables\n\nData structures supported by the request body of the method shall be specified as table 5.2.3A-3 illustrates.\nTable 5.2.3A-3: Data structures supported by the HTTP method request body\n\nData type: Data type of the data structure in the request body. If the data type is indicated as \"<type>\", the request body shall be of data type <type>. If the data type is indicated as \"array(<type>)\", the request body shall be an array (see IETF RFC 8259 [3]) that contains elements of data type <type>. If the data type is indicated as \"map(<type>)\", the request body shall be an object (see IETF RFC 8259 [3]) encoding a map (see clause 5.2.4.2)  that contains as values elements of data type <type>. <type> can either be \"integer\", \"number\", \"string\" or \"boolean\" (as defined in the OpenAPI specification [4]), or a data type defined in a 3GPP specification. If no request body is allowed, the Data type shall be marked as \"n/a\".\nP: Presence condition of a data structure in request body. It shall be one of \"M\" (for Mandatory), \"C\" (for Conditional) and \"O\" (for Optional).\nCardinality: Defines the allowed number of occurrence of data type <type>. A cardinality of \"M..N\", is only allowed for data types \"array(<type>)\" and \"map(<type>)\" and indicates the number of elements within the array or map; the values M and N can either be the characters \"M\" and \"N\", respectively, or integer numbers with M being greater than or equal 0, and N being greater than 0 and M. For data type \"<type>\", the cardinality shall be set to \"0..1\" if the Presence condition is \"C\" or \"O\", and to \"1\" if the Presence condition is \"M\". The Cardinality shall be left empty if no request body is allowed.\nDescription: Additional information for a data structure, i.e. describes the use of the data structure or the presence condition of the data structure and so on.\nNOTE 1:\tThe cardinality of \"0..N\" does not imply that the presence condition of the array or map is optional or conditional, i.e. the presence condition can be \"M\" while the cardinality is \"0..N\", the presence condition can be \"O\" or \"C\" while the cardinality is \"1..N\".\nData structures supported by the response body of the method shall be specified as table 5.2.3A-4 illustrates.\nTable 5.2.3A-4: Data structures supported by the mapped HTTP method response body\n\nData type: Data type of the data structure in the response body. If the data type is indicated as \"<type>\", the response body shall be of data type <type>. If the data type is indicated as \"array(<type>)\", the response body shall be an array (see IETF RFC 8259 [3]) that contains elements of data type <type>. If the data type is indicated as \"map(<type>)\", the response body shall be an object (see IETF RFC 8259 [3]) encoding a map (see clause 5.2.4.2) that contains as values elements of data type <type>. <type> can either be \"integer\", \"number\", \"string\" or \"boolean\" (as defined in the OpenAPI specification [4]), or a data type defined in a 3GPP specification. If no response body is allowed, the Data type shall be marked as \"n/a\".\nP: Presence condition of a data structure in response body. It shall be one of \"M\" (for Mandatory), \"C\" (for Conditional) and \"O\" (for Optional).\nCardinality: Defines the allowed number of occurrence of data type <type>. A cardinality of \"M..N\", is only allowed for data types \"array(<type>)\" and \"map(<type>)\" and indicates the number of elements within the array or map; the values M and N can either be the characters \"M\" and \"N\", respectively, or integer numbers with M being greater than or equal 0, and N being greater than 0 and M. For data type \"<type>\", the cardinality shall be set to \"0..1\" if the Presence condition is \"C\" or \"O\", and to \"1\" if the Presence condition is \"M\". The Cardinality shall be left empty if no response body is allowed.\nResponse codes: Lists applicable response codes with name from HTTP Status Code Registry at IANA [12]. Mandatory HTTP status codes listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [2] for the corresponding HTTP method shall only be included if specific clarifications in the description part or special data types of the response body are required. Applicable HTTP status codes in addition to the mandatory HTTP status codes listed in Table 5.2.7.1-1 of 3GPP TS 29.500 [2] for the corresponding HTTP method shall be included.\nDescription: Additional information for a response, i.e. describes the meaning of the success case or meaning of the error case with additional statement regarding error handling.\nNOTE 2:\tThe cardinality of \"0..N\" does not imply that the presence condition of the array or map is optional or conditional, i.e. the presence condition can be \"M\" while the cardinality is\"0..N\", the presence condition can be \"O\" or \"C\" while the cardinality is \"1..N\".\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.3A-1: Notifications overview",
                                    "table number": 20,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.3A-2: Callback URI variables",
                                    "table number": 21,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.3A-3: Data structures supported by the HTTP method request body",
                                    "table number": 22,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.3A-4: Data structures supported by the mapped HTTP method response body",
                                    "table number": 23,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.2.4\tData Models",
                            "text_content": "The application data model supported by the API shall be specified with the following data types:\n1.\tStructured data types\n2.\tSimple data types\n3.\tEnumerations\n4.\tBinary data\n5.\tData types describing alternative data types\n6.\tData types describing combinations of data types\nEach data type can be specific for the API or common to multiple APIs (offered by the same or different NFs). The common data types shall be specified in 3GPP TS 29.571 [5].\nCharacters in an enumeration or string data type in both simple and structured/combination data types specific for the API or common to multiple APIs shall be handled as case sensitive by default, unless stated otherwise.\nStrings representing a numerical value or a binary octet string, encoded as hexadecimal characters, shall be handled as case insensitive.\nThe structured data types shall represent an object (see IETF RFC 8259 [3]). The structured data types shall contain attributes that are simple data types, structured data types, arrays (see below), maps (as defined below), enumerations, data types describing alternative data types, data types describing combinations of data types or \"Any Type\" (as described below).\nAn array (see IETF RFC 8259 [3]) shall represent a list of values without keys and with significance in the order of sequence. All values shall be of the same type.\nA map shall represent an object (see IETF RFC 8259 [3]) with a list of key-value pairs (with no significance in the order of sequence), where all keys are of type string and shall be unique identifiers assigned by the application rather than by the schema, and where all values shall be of the same type.\nNOTE 1:\tMaps are supported by the OpenAPI specification [4] as described at https://swagger.io/docs/specification/data-models/dictionaries/. Maps can enable a faster lookup of elements identified by some key in huge data structures compared to arrays that contain the key within the elements. Maps can also be used instead of arrays to modify individual elements when modification instructions of the PATCH method are compliant to IETF RFC 7396 [7].\nEach structured data type shall be specified in a separate clause as illustrated in table 5.2.4.2-1.\nTable 5.2.4.2-1: Definition of type <Data type>\n\nTable 5.2.4.2-2: Definition of type <Data type> with nested structures\n\nAttribute name: Name of attributes that belong to the specified data type. The attribute names within a structured data type shall be unique, and their relative order inside the structured data type shall not imply any specific ordering of the corresponding JSON elements in a JSON object.\nNOTE 2:\tThe JSON specification (IETF RFC 8259 [3]) allows duplicate keys in a JSON object, but its usage is discouraged, since it makes interoperability more difficult, and makes the behavior of the JSON parsing software unpredictable. Similarly, that RFC encourages to make implementations not dependent on attribute ordering.\nData type: Data type of the attribute. If the data type is indicated as \"<type>\", the attribute shall be of data type <type>. If the data type is indicated as \"array(<type>)\", the attribute shall be an array (see IETF RFC 8259 [3]) that contains elements of data type <type>. If the data type is indicated as \"map(<type>)\", the attribute shall be an object (see IETF RFC 8259 [3]) encoding a map that contains as values elements of data type <type>. <type> can either be \"integer\", \"number\", \"string\" or \"boolean\" (as defined in the OpenAPI specification [4]), or a data type defined in a 3GPP specification. If the data type is indicated as \"Any Type\", the attribute can either be \"integer\", \"number\", \"string\", \"boolean\", \"array\" or \"object\" (as defined in the OpenAPI specification [4]), or a data type defined in a 3GPP specification.\nP: Presence condition of a data structure in request body. It shall be one of \"M\" (for Mandatory), \"C\" (for Conditional) and \"O\" (for Optional).\nCardinality: Defines the allowed number of occurrence of data type <type>. A cardinality of \"M..N\", is only allowed for data types \"array(<type>)\" and \"map(<type>)\" and indicates the number of elements within the array or map; the values M and N can either be the characters \"M\" and \"N\", respectively, or integer numbers; with M being greater than or equal 0, and N being greater than 0 and M. For data type with nested structures, the cardinality is expressed in a nested manner, each level of the M and N values describe the cardinality of the corresponding level of the data structure. For data type \"<type>\" and \"Any Type\", the cardinality shall be set to \"0..1\" if the Presence condition is \"C\" or \"O\", and to \"1\" if the Presence condition is \"M\".\nDescription: Describes the meaning and use of the attribute and may contain normative statements.\nApplicability: If the attribute is only applicable for optional feature(s) negotiated using the mechanism defined in clause 6.6 of 3GPP TS 29.500 [2], the name of the corresponding feature(s) shall be indicated in this column. If no feature is indicated. the attribute can be used with any feature.\nNOTE 3:\tThe cardinality of \"0..N\" does not imply that the presence condition of the array or map is optional or conditional, i.e. the presence condition can be \"M\" while the cardinality is \"0..N\", the presence condition can be \"O\" or \"C\" while the cardinality is \"1..N\".\nNOTE 4:\tIf no optional features are defined for an API, the applicability column can be omitted for that API.\nThe simple data types and enumerations can be referenced from data structures. All simple data types and enumerations should map to base types supported by OpenAPI specification [4]. Simple data types shall be specified as illustrated in table 5.2.4.3-1.\nTable 5.2.4.3-1: Simple data types\n\nType Name: The name of the simple data type.\nType Definition: Base types supported by OpenAPI specification [4], i.e. Boolean, integer, string and so on.\nDescription: Additional descriptions for simple data types like range, string length, string pattern (regular expression) and so on.\nApplicability: If the type is only applicable for optional feature(s) negotiated using the mechanism defined in clause 6.6 of 3GPP TS 29.500 [2], the name of the corresponding feature(s) shall be indicated in this column. If no feature is indicated. the type can be used with any feature.\nNOTE 1:\tIf no optional features are defined for an API, the applicability column can be omitted for that API.\n\nEach enumeration type shall be respectively specified for their elements sets as illustrated in table 5.2.4.3-2.\nTable 5.2.4.3-2: Enumeration < EnumType>\n\nEnumeration value: Defines the valid values, which can be integer, string or boolean, it is suggested to keep the same value style in one API specification.\nDescription: Additional descriptions for enumeration attributes, like the meaning and usage of enumeration elements.\nApplicability: If the enumeration value is only applicable for optional feature(s) negotiated using the mechanism defined in clause 6.6 of 3GPP TS 29.500 [2], the name of the corresponding feature(s) shall be indicated in this column. If no feature is indicated. the enumeration value can be used with any feature.\nNOTE 2:\tIf no optional features are defined for an API, the applicability column can be omitted for that API.\nThe data types describing alternative data types or combinations of data types shall represent an OpenAPI schema object using the \"oneOf\" , \"anyOf\" or \"allOf\" keyword to list alternative or to be combined data types (see the OpenAPI specification [4] and ).\nAn instance (i.e. a corresponding part of a JSON file to be evaluated against the schema) matches a list of mutually exclusive alternative data types , as described using the OpenAPI \"oneOf\" keyword, if the instance matches against one and only one of the alternative data types.\nNOTE 1:\tData types with the same simple data type but different format and/or pattern attributes are mutually exclusive if the corresponding formats and/or patterns are mutually exclusive.\nAn instance (i.e. a corresponding part of a JSON file to be evaluated against the schema) matches a list of non-exclusive alternative data types, as described using the OpenAPI \"anyOf\" keyword, if the instance matches against one or more of the alternative data types.\nAn instance (i.e. a corresponding part of a JSON file to be evaluated against the schema) matches a list of to be combined data types, as described using the OpenAPI \"allOf\" keyword, if the instance matches against all of the to be combined data types.\nThe alternative or to be combined data types shall be simple data types, structured data types, arrays (see clause 5.2.4.2), maps (see clause 5.2.4.2), enumerations, data types describing alternative data types, or data types describing combinations of data types.\nEach structured data type shall be specified in a separate clause as illustrated in table 5.2.4.2-1.\nTable 5.2.4.2-1: Definition of type <Data type> as a list of <\"mutually exclusive alternatives\" / \"non-exclusive alternatives\" / \"to be combined data types\">\n\nData type: Data type of the alternative or to be combined data type. If the data type is indicated as \"<type>\", the alternative or to be combined data type shall be of data type <type>. If the data type is indicated as \"array(<type>)\", the alternative or to be combined data type shall be an array (see IETF RFC 8259 [3]) that contains elements of data type <type>. If the data type is indicated as \"map(<type>)\", the alternative or to be combined data type shall be an object (see IETF RFC 8259 [3]) encoding a map (see clause 5.2.4.2) that contains as values elements of data type <type>. <type> can either be \"integer\", \"number\", \"string\" or \"boolean\" (as defined in the OpenAPI specification [4]), or a data type defined in a 3GPP specification.\nCardinality: Defines the allowed number of occurrence of data type <type>. A cardinality of \"M..N\", is only allowed for data types \"array(<type>)\" and \"map(<type>)\" and indicates the number of elements within the array or map; the values M and N can either be the characters \"M\" and \"N\", respectively, or integer numbers; with M being greater than or equal 0, and N being greater than 0. For data type \"<type>\", the cardinality shall be set to \"1\".\nDescription: Describes the meaning and use of the attribute and may contain normative statements.\nApplicability: If the type is only applicable for optional feature(s) negotiated using the mechanism defined in clause 6.6 of 3GPP TS 29.500 [2], the name of the corresponding feature(s) shall be indicated in this column. If no feature is indicated. the type can be used with any feature.\nNOTE 2:\tIf no optional features are defined for an API, the applicability column can be omitted for that API.\nNOTE 3:\tData types describing alternative data types or combinations of data types can only be extended with additional data types in a backward compatible manner if the new data types are associated with an optional feature and the mechanism defined in clause 6.6 of 3GPP TS 29.500 [2] is used to negotiate the support of that optional feature before that new data type is used.\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.4.2-1: Definition of type <Data type>",
                                    "table number": 24,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.4.2-2: Definition of type <Data type> with nested structures",
                                    "table number": 25,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.4.3-1: Simple data types",
                                    "table number": 26,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.4.3-2: Enumeration < EnumType>",
                                    "table number": 27,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.4.2-1: Definition of type <Data type> as a list of <\"mutually exclusive alternatives\" / \"non-exclusive alternatives\" / \"to be combined data types\">",
                                    "table number": 28,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.2.5\tVoid",
                            "text_content": "",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.6\t3GPP Custom HTTP Headers",
                            "text_content": "The definition of 3GPP APIs for the Service-Based Architecture includes the definition of 3GPP-specific HTTP headers, both generic (i.e. applicable to any API), and also API-specific headers.\nThe definition of the generic HTTP headers is done in 3GPP TS 29.500 [2]. It consists of the ABNF definition of each header, along with a detailed description of the syntax and expected behaviour and handling by the receiver of such header; each header is specified in its own separate clause.\n3GPP TS 29.500 [2], Annex D, contains a self-contained full grammar of the entire set of custom HTTP headers, comprising both the definition of ABNF components/rules re-used from IETF RFCs, and the 3GPP-specific ABNF rule definitions.\nIn addition, the zip file of the published 3GPP TS 29.500 [2] shall contain a file, named \"TS29500_CustomHeaders.abnf\", that reflects the content of such Annex D, and the same file shall be made available on the 3GPP Forge GitLab repository mentioned in clause 5.3.1, along with the OpenAPI files, where tooling can be used for validation of the ABNF grammar.\nFor API-specific HTTP header definition, a similar procedure shall be followed: if an API defines custom HTTP headers, their ABNF shall be included in the TS where such API is defined, along with the description of each header; each header shall be described in its own separate clause.\nSimilarly, each TS that defines custom HTTP headers shall contain an Annex with a self-contained and minimal set of ABNF rules, including re-used rules from other sources (e.g. IETF RFCs, 3GPP TS 29.500, etc.). The zip file of the published TS shall contain a file with \".abnf\" extension, with the same content as the Annex, and such file shall be made available, and validated, on 3GPP Forge/GitLab.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.3\tOpenAPI specification files",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.3.1\tGeneral",
                            "text_content": "5GC SBI APIs' OpenAPI specification files shall comply with the OpenAPI specification [4] and with the present clause 5.3.\nEach API shall be described in one OpenAPI specification file contained in an Annex of the 3GPP specification that describes the corresponding API. In addition, 3GPP specifications may contain OpenAPI specification file with common data types.\nInformative copies of all OpenAPI specification files contained in 3GPP Technical Specifications are available on a Git-based repository hosted in 3GPP Forge, that uses the GitLab software version control system.\nThe repository is named \"5G APIs\" and is publicly accessible via the following URI:\nhttps://forge.3gpp.org/rep/all/5G_APIs\nNOTE:\tAs indicated in 3GPP TR 21.900 [25], clause 5C, there is an alternative option for the availability and distribution of OpenAPI specification files (decided by the responsible Working Group of each TS), where these files can be stored in a 3GPP Forge GitLab repository and can be declared as normative.\n\nIn that case, the TS does not contain OpenAPI descriptions in normative Annexes and instead it includes information about the repository used for the storage of OpenAPI files, e.g., GitLab group, repository name, branch, directory path (if any), and a Git tag representing the repository snapshot that corresponds to the specific TS version.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.2\tFormatting of OpenAPI specification files",
                            "text_content": "The following guidelines shall be used when documenting OpenAPI specification files:\n-\tOpenAPI specification files shall be documented using YAML format (see YAML 1.2 [16]). For specific restrictions on the usage of YAML in OpenAPI, see OpenAPI Specification [4].\n-\tThe style used for the specification shall be \"PL\" (Programming Language).\n-\tThe different scopes in the YAML data structures representing collections (objects, arrays…) shall use an indentation of two white spaces.\n-\tComments may be added by following the standard YAML syntax (\"#\").\n-\tTabs shall not be used in OpenAPI specification files (e.g. within description fields).\n-\t\"Unbreakable\" spaces (UTF-8 'NO-BREAK SPACE' (U+00A0)) shall not be used in OpenAPI specification files (e.g. within description fields). Only \"normal\" spaces (UTF-8 'SPACE' (U+0020)) shall be allowed.\n-\tTrailing spaces (i.e. white spaces at the end of a line) should not be used in OpenAPI specification files.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.3\tInfo",
                            "text_content": "The OpenAPI specification file of an API shall contain an \"info\" object with the title that should be set to the same value as chosen for the API name in the heading of Annex A.x of the corresponding 3GPP TS, and with the version set as described in clause 4.3.\nThe \"info\" object shall also include a \"description\" field, containing the name of the service that the API implements, and the same copyright notice as included in the front page of the corresponding 3GPP TS that specifies the API. The content of the \"description\" field shall be formatted using the YAML block notation for scalars (i.e. using the \"|\" character).\nEXAMPLE:\t\"info\" object with the title, version and description of the API.\ninfo:\ntitle: 'Nsmf_PDUSession'\nversion: '1.0.0'\ndescription: |\nSMF PDUSession Service.\n© 2020, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).\nAll rights reserved.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.4\texternalDocs",
                            "text_content": "Each OpenAPI specification file shall provide an \"externalDocs\" object as illustrated in the example below that shall contain:\n-\twithin the \"description\" field the 3GPP TS number, the version number and the name of the 3GPP TS describing the API, and\n-\twithin the \"url\" field a reference to the folder of that TS within the specification archive of the public 3GPP fileserver (i.e. \"\").\nThe version number in the \"externalDocs\" object shall be updated each time when the TS version contains new changes to the OpenAPI specification file.\nNOTE 1:\tIf a new TS version is provided without any changes to the OpenAPI specification file, the TS version number included in the \"description\" field of the \"externalDocs\" field in the OpenAPI specification file is not updated.\nNOTE 2:\tIf a new TS version is provided with changes to the OpenAPI specification file, the TS version number included in the \"description\" field of the \"externalDocs\" object is updated. However, if the API version in a given release is still the same as in a previous release, the first TS version in the first release that contains that API version is provided as TS version within the \"externalDocs\" object also in the TS versions of the subsequent releases.\n\nEXAMPLE:\t\"externalDocs\" object.\nexternalDocs:\ndescription: 3GPP TS 29.503 V15.1.0; 5G System; Unified Data Management Services\nurl: 'http://www.3gpp.org/ftp/Specs/archive/29_series/29.503/'\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.5\tServers",
                            "text_content": "As defined in clause 4.4.1, the API URI consists of {apiRoot}/<apiName>/<apiVersion>. It shall be encoded in the corresponding OpenAPI specification file as \"servers\" field with {apiRoot} as variable.\nExample:\nservers:\n- url: '{apiRoot}/nxxx-yyyy/v1'\nvariables:\napiRoot:\ndefault: https://example.com\ndescription: apiRoot as defined in clause 4.4.1 of 3GPP TS 29.501\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.6\tReferences to other 3GPP-defined OpenAPI specification files",
                            "text_content": "Open API specification files may contain references to fragments of other 3GPP-defined Open API specification files.\nSuch references shall be formatted to refer to local files stored on the same folder.\nNOTE 1:\tFor the purpose of referencing, it is assumed that each OpenAPI specification file contained in a 3GPP specification is stored as separate physical file and that all OpenAPI specification files are stored in the same directory on the local server.\nThe referenced file names for other 3GPP-defined Open API specification files shall comply with the following convention, unless a specific file name is indicated in the Annex of a 3GPP specification defining an OpenAPI specification file. The file name shall consist of (in the order below):\n-\tthe 3GPP specification number in the format \"TSxxyyy\";\n-\tan \"_\" character;\n-\tif the OpenAPI specification file contains an API definition: the API name which shall be taken from the heading of the relevant annex A.x as defined in the corresponding 3GPP TS of that API.\n-\tif the OpenAPI specification file contains a definition of CommonData: the string \"CommonData\"; and\n-\tthe string \".yaml\".\nNOTE 2:\tThe informative copies of OpenAPI specification files contained in 3GPP Technical Specifications at the public 3GPP file server (see clause 5.3.1) follow the above conventions and can be copied into a local folder in order to resolve references.\nSuch a reference to another OpenAPI specification file shall be interpreted as refering to the related OpenAPI specification file contained in the version of the corresponding 3GPP TS indicated in the reference clause of the specification, i.e. for a non-specific reference the latest version of that 3GPP TS in the same Release as the specification.\nEXAMPLE:\tReference to Data Type \"Xxx\" defined in the same file\n$ref: '#/components/schemas/Xxx'\n\nEXAMPLE:\tReference to Data Type \"Xxx\" defined as Common Data in 3GPP TS 29.571:\n$ref: 'TS29571_CommonData.yaml#/components/schemas/Xxx'\n\nEXAMPLE:\tReference to Data Type \"Xxx\" defined within API \"Nudm_UEAU\" in 3GPP \"TS 29.503\":\n$ref: 'TS29503_Nudm_UEAU.yaml#/components/schemas/Xxx'\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.7\tServer-initiated communication",
                            "text_content": "If an API contains server-initiated communication (see clause 6.2 of 3GPP TS 29.500 [2]), e.g. for notifications as described in clause 4.6.2.3, it should be described as \"callbacks\" in OpenAPI specification files.\nExample:\npaths:\n/subscriptions:\npost:\nrequestBody:\nrequired: true\ncontent:\napplication/json:\nschema:\ntype: object\nproperties:\ncallbackUrl: # Callback URL\ntype: string\nformat: uri\nresponses:\n'201':\ndescription: Success\ncallbacks:\nmyNotification: # arbitrary name\n'{$request.body#/callbackUrl}': # refers The callback URL in the POST\npost:\nrequestBody: # Contents of the callback message\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/NotificationBody'\nresponses: # Expected responses to the callback message\n'204':\ndescription: xxx\n\nAn API description may consist of standalone notifications, i.e., notifications where there is no previous interaction between consumer and producer to create a subscription. In such case, the API shall be documented by including a \"dummy\" subscription request pseudo-operation that shall not be used by the consumer. In such case, the notification URI may be obtained by the producer by different means (e.g. out of band configuration, or via a separate signaling interaction with the producer, or by querying NRF for the NF Profile of the consumer and looking for a \"default notification endpoint\").\nExample:\npaths:\n/subscriptions:\npost:\n# This is a pseudo operation, consumers shall NOT invoke this method!\nrequestBody:\nrequired: true\ncontent:\napplication/json:\n# Unspecified schema for the JSON body, since this is not used by consumer or producer\nschema: {}\nresponses:\ndefault:\n$ref: 'TS29571_CommonData.yaml#/components/responses/default'\ncallbacks:\nstandaloneNotification:\n'{notificationUri}':\n# The URI in {notificationUri} is obtained out of band by the producer\npost:\nrequestBody: # Contents of the callback message\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/NotificationBody'\nresponses: # Expected responses to the callback message\n'204':\ndescription: xxx\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.8\tDescribing the body of HTTP PATCH requests",
                            "text_content": "As described in clause 4.6.1.1.3.2, the bodies of HTTP PATCH requests either use a \"JSON Merge Patch\" encoding as defined in IETF RFC 7396 [7], or a \"JSON Patch\" encoding as defined IETF RFC 6902 [8].\nIt is possible to allow both encodings in a OpenAPI Specification [4] offering both schemas as alternative contents.\nNOTE:\tIn Rel-15 a single encoding will be selected for each resource as backward compatibility considerations do not yet apply.\nAn example OpenAPI specification file offering both PATCH encodings is included in Annex D.\nIn the OpenAPI Specification [4] file, the content field key of the Request Body Object shall contain \"application/merge-patch+json\". The content field value is a Media Type Object identifying the applicable patch body Schema Object. The patch body Schema Object may contain structured data types derived from the data types used in the schema to describe a complete representation of the resource in such a manner that attributes that are allowed to be modified are listed in the \"properties\" validation keyword.\nNOTE 1:\tA derived structured data type is beneficial if the data types used to describe a complete representation of the resource contains mandatory attributes, if attributes are allowed to be removed by the PATCH operation, or if a checking by the OpenAPI tooling that only allowed modifications are done via the \"additionalProperties: false\" keyword is desired. It also provides a clear description in the OpenAPI specification file to developers which modifications need to be supported.\nAs an alternative, the data types used in the schema to describe a complete representation of the resource may be used if any attributes that are allowed to be removed are marked as \"nullable: true\" in that schema.\nAny attributes that are allowed to be removed shall be marked as \"nullable: true\" in the patch body Schema Object.\nThe \"additionalProperties: false\" keyword may be set.\nNOTE 2:\tThe \"additionalProperties: false\" keyword enables the OpenAPI tooling to check that only allowed modifications are done. Extensions of the object in future releases are still possible under the assumption that the supported features mechanism is used to negotiate the usage of any new attribute prior to the PATCH invocation. If new optional attributes are expected to be introduced without corresponding supported feature or if PATCH can be used as first operation in an API, the usage of the \"additionalProperties: false\" keyword is not appropriate.\nIn the OpenAPI Specification [4] file, the content field of the key Request Body Object shall contain \"application/json-patch+json\". The content field value is a Media Type Object identifying the applicable patch body. It may contain a mutually exclusive list (using the \"oneOf\" keyword) of all allowed modifications as <path, op, value> tuples, where \"path\" is a string containing a JSON Pointer value referring to a JSON object that is allowed to be modified, \"op\" is an enumeration of allowed JSON PATCH operations on the JSON object identified by \"path\" and \"value\" representing the schema/type of the value that will be updated or added at the JSON object identified by \"path\". In addition, an open alternative containing an object with no properties may be added using the \"anyOf\" keyword.\nNOTE 1:\tA mutually exclusive list provides a clear description in the OpenAPI specification file to developers which modifications need to be supported. This is of particular interest if only a limited number of modifications need to be supported. If no open alternative is included, the OpenAPI tooling will also check that only allowed modifications are done.\nNOTE 2:\tThe open alternative allows for extensions of the PATCH in scenarios where new optional attributes are expected to be introduced without corresponding supported feature or if PATCH can be used as first operation in an API.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.9\tStructured data types",
                            "text_content": "For a structured data type, as defined in clause 5.2.4.2, the OpenAPI Specification [4] file shall contain a definition in the components/schemas clause defining a schema with the name of the structured data type as key.\nThe schema shall contain:\n-\t\"type: object\";\n-\t\"description: <description>\", where <description> is the description of the data type in the table defining the structured data type. The \"description\" attribute should be provided for all data types, specially if they are frequently reused from the same or other OpenAPI specification files; the \"description\" attribute shall always be provided for data types defined as maps, with a clear indication of the values (strings) used as key of the map.\n-\tif any attributes in the structured data type are marked as mandatory, a \"required\" keyword listing those attributes; and\n-\ta \"properties\" keyword containing for each attribute in the structured data type an entry with the attribute name as key and:\n1.\tif the data type is \"<type>\":\na.\tif the data type of the attribute is \"string\", \"number\", \"integer\", or \"boolean\";\ni)\ta type definition using that data type as value (\"type: <data type>\"); and\nii)\toptionally \"description: <description>\", where <description> is the description of the attribute in the table defining the structured data type; or\nb.\totherwise a reference to the data type schema for the data type <data type> of the attribute, i.e. \"$ref: '#/components/schemas/<data type>'\" if that data type schema is contained in the same OpenAPI specification file and \"$ref: '<filename>#/components/schemas/<data type>'\" if that data type schema is contained in file <filename> in the same directory on the same server;\n2.\tif the data type is \"array(<type>)\":\na.\ta type definition \"type: array\";\nb.\tan \"items:\" definition containing:\ni).\tif the data type of the attribute is \"string\", \"number\", \"integer\", or \"boolean\", a type definition using that data type as value (\"type: <data type>\"); or\nii).\totherwise a reference to the data type schema for the data type <data type> of the attribute, i.e. \"$ref: '#/components/schemas/<data type>'\" if that data type schema is contained in the same OpenAPI specification file and \"$ref: '<filename>#/components/schemas/<data type>'\" if that data type schema is contained in file <filename> in the same directory on the same server;\nc.\tif the cardinality contained an integer value <m> as lower boundary, \"minItems: <m>\"; and\nd.\tif the cardinality contained an integer value <n> as upper boundary, \"maxItems: <n>\"; and\ne.\toptionally \"description: <description>\", where <description> is the description of the attribute in the table defining the structured data type;\n3.\tif the data type is \"map(<type>)\":\na.\ta type definition \"type: object\"; and\nb.\tan \"additionalProperties:\" definition containing:\ni).\tif the data type of the attribute is \"string\", \"number\", \"integer\", or \"boolean\", a type definition using that data type as value (\"type: <data type>\"); or\nii).\totherwise a reference to the data type schema for the data type <data type> of the attribute, i.e. \"$ref: '#/components/schemas/<data type>'\" if that data type schema is contained in the same OpenAPI specification file and \"$ref: '<filename>#/components/schemas/<data type>'\" if that data type schema is contained in file <filename> in the same directory on the same server;\nc.\tif the cardinality contained an integer value <m> as lower boundary, \"minProperties: <m>\"; and\nd.\tif the cardinality contained an integer value <n> as upper boundary, \"maxProperties: <n>\"; and\ne.\t\"description: <description>\", where <description> is the description of the attribute in the table defining the structured data type; the \"description\" attribute shall always be provided for attributes defined as maps, with a clear indication of the values (strings) used as key of the map.\nNOTE:\tAn omission of the \"minProperties\", and \"maxProperties\" keywords indicates that no lower or upper boundaries respectively, for the number of properties in an object are defined. An omission of the \"minItems\", and \"maxItems\" keywords indicates that no lower or upper boundaries, respectively, for the number of items in an array are defined.\n4.\tif the data type is \"Any Type\":\na.\tif no properties to be defined, a pair of curly braces after the attribute name key \"<attribute name>: {}\", which is shorthand syntax for an arbitrary-type schema; or\nb.\tat least one of the following properties:\ni)\tif null value is allowed, \"nullable: true\"; or\nii).\t\"description: <description>\", where <description> is the description of the attribute in the table defining the structured data type.\nIn the OpenAPI 3.0.0 Specification [4], the '$ref' keyword must be the only attribute of the JSON object. Therefore it is not allowed to use e.g. a \"description\" attribute along with the '$ref' keyword. However, if it is deemed necessary, a \"description\" attribute can be added before or after the '$ref' keyword as a comment, i.e. by adding a comment sign '#' in front of the \"description\" field.\nNOTE:\tCT4 decides on case-by-case basis when it is deemed necessary to add such a \"description\" attribute along with the '$ref' keyword.\nExample:\nTable 5.3.9-1: Definition of type ExampleStructuredType\n\nThe data structure in table 5.3.9-1 is described in an OpenAPI specification file as follows:\ncomponents:\nschemas:\nExampleStructuredType:\ntype: object\ndescription: ExampleStructuredType data type description\nrequired:\n- exSimple\n- exMapElements\nproperties:\nexSimple:\n$ref: '#/components/schemas/ExSimple'\nexArrayElements:\ntype: array\nitems:\ntype: string\nminItems: 0\nmaxItems: 10\ndescription: exArrayElements attribute description\nexMapElements:\ntype: object\nadditionalProperties:\n# description: commented out description of the additionalProperties\n$ref: '#/components/schemas/ExStructure'\nminProperties: 1\ndescription: exMapElements attribute description, indicating values of the map keys\nexNestedArray:\ntype: array\nitems:\ntype: object\nadditionalProperties:\ntype: string\nminProperties: 1\ndescription: exNestedArray attribute description\nexNestedMap:\ntype: object\nadditionalProperties:\ntype: array\nitems:\ntype: string\nminItems: 2\nminProperties: 1\ndescription: exNestedMap attribute description\nexAnyTypeNullableElement:\nnullable: true\ndescription: exAnyTypeNullableElement attribute description\nexAnyTypeNoDescription: {}\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.3.9-1: Definition of type ExampleStructuredType",
                                    "table number": 29,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.3.10\tData types describing alternative data types or combinations of data types",
                            "text_content": "For a data type describing alternatives, as defined in clause 5.2.4.5, the OpenAPI Specification [4] file shall contain a definition in the components/schemas clause defining a schema with the name of the data type describing alternatives as key.\nThe schema shall contain:\n-\tthe \"oneOf\", \"anyOf\" or \"allOf\" keyword selected as follows:\n1.\tfor table caption \"Definition of type <Data type> as a list of mutually exclusive alternatives\", the \"oneOf\" keyword;\n2.\tfor table caption \"Definition of type <Data type> as a list of non-exclusive alternatives\", the \"anyOf\" keyword;\n3.\tfor table caption \"Definition of type <Data type> as a list of to be combined data types\", the \"allOf\" keyword;\n-\ta list of alternatives, containing for each line in the table describing the data type a separate line starting with \"-\":\n1.\tif the data type is \"<type>\":\na.\tif the data type of the attribute is \"string\", \"number\", \"integer\", or \"boolean\";\ni)\ta type definition using that data type as value (\"type: <data type>\"); and\nii)\toptionally \"description: <description>\", where <description> is the description of the attribute in the table defining the structured data type; or\nb.\totherwise a reference to the data type schema for the data type <data type> of the attribute, i.e. \"$ref: '#/components/schemas/<data type>'\" if that data type schema is contained in the same OpenAPI specification file and \"$ref: '<filename>#/components/schemas/<data type>'\" if that data type schema is contained in file <filename> in the same directory on the same server;\n2.\tif the data type is \"array(<type>)\":\na.\ta type definition \"type: array\";\nb.\tan \"items:\" definition containing:\ni).\tif the data type of the attribute is \"string\", \"number\", \"integer\", or \"boolean\", a type definition using that data type as value (\"type: <data type>\"); or\nii).\totherwise a reference to the data type schema for the data type <data type> of the attribute, i.e. \"$ref: '#/components/schemas/<data type>'\" if that data type schema is contained in the same OpenAPI specification file and \"$ref: '<filename>#/components/schemas/<data type>'\" if that data type schema is contained in file <filename> in the same directory on the same server;\nc.\tif the cardinality contained an integer value <m> as lower boundary, \"minItems: <m>\"; and\nd.\tif the cardinality contained an integer value <n> as upper boundary, \"maxItems: <n>\"; and\ne.\toptionally \"description: <description>\", where <description> is the description of the attribute in the table defining the structured data type;\n3.\tif the data type is \"map(<type>)\":\na.\ta type definition \"type: object\"; and\nb.\tan \"additionalProperties:\" definition containing:\ni).\tif the data type of the attribute is \"string\", \"number\", \"integer\", or \"boolean\", a type definition using that data type as value (\"type: <data type>\"); or\nii).\totherwise a reference to the data type schema for the data type <data type> of the attribute, i.e. \"$ref: '#/components/schemas/<data type>'\" if that data type schema is contained in the same OpenAPI specification file and \"$ref: '<filename>#/components/schemas/<data type>'\" if that data type schema is contained in file <filename> in the same directory on the same server;\nc.\tif the cardinality contained an integer value <m> as lower boundary, \"minProperties: <m>\"; and\nd.\tif the cardinality contained an integer value <n> as upper boundary, \"maxProperties: <n>\"; and\ne.\toptionally \"description: <description>\", where <description> is the description of the attribute in the table defining the structured data type.\nNOTE:\tAn omission of the \"minProperties\", and \"maxProperties\" keywords indicates that no lower or upper boundaries respectively, for the number of properties in an object are defined. An omission of the \"minItems\", and \"maxItems\" keywords indicates that no lower or upper boundaries, respectively, for the number of items in an array are defined.\nExample:\nTable 5.3.10-1: Definition of type ExampleAlternativesType as a list of mutually exclusive alternatives\n\nThe data structure in table 5.3.10-1 is described in an OpenAPI specification file as follows:\ncomponents:\nschemas:\nExampleAlternativesType:\noneOf:\n- $ref: '#/components/schemas/ExSimple'\n- type: array\nitems:\ntype: string\nminItems: 0\nmaxItems: 10\ndescription: exArrayElements attribute description\n- type: object\nadditionalProperties:\n$ref: '#/components/schemas/ExStructure'\nminProperties: 1\ndescription: exMapElements attribute description\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.3.10-1: Definition of type ExampleAlternativesType as a list of mutually exclusive alternatives",
                                    "table number": 30,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.3.11\tError Responses",
                            "text_content": "As described in clause 4.8 of the present specification and clause 5.2.7 of 3GPP TS 29.500 [2], 5GC SBI APIs use valid HTTP response codes as error codes in HTTP responses and may include a \"ProblemDetails\" data structure specified in clause 5.2.4.1 of 3GPP TS 29.571 [5] or an application-specific data structure.\nTable 5.2.7.1-1 of 3GPP TS 29.500 [2] specifies HTTP status code per HTTP method. For each HTTP method of an API, HTTP status codes shall be specified using response code tables as described in clauses 5.2.2 and 5.2.3. OpenAPI specification files shall include in the description of an HTTP method in the \"paths\" segment the mandatory HTTP status codes in Table  5.2.7.1-1 of 3GPP TS 29.500 [2] and the HTTP status codes listed in response codes table of that HTTP method.\nFor the purpose of referencing, HTTP error responses with \"ProblemDetails\" data structure are specified as part of the CommonData OpenAPI specification file in Annex A of 3GPP TS 29.571 [5].\nExample:\nIn the example below, the 400, 500 and default error response descriptions defined in 3GPP TS 29.571 [5] are referenced.\n\npaths:\n/users:\nget:\nresponses:\n'200':\ncontent:\napplication/json\nschema:\n$ref: '#/components/schemas/ExampleGetBody'\n'400':\n$ref: 'TS29571_CommonData.yaml#/components/responses/400'\n'500':\n$ref: 'TS29571_CommonData.yaml#/components/responses/500'\ndefault:\n$ref: 'TS29571_CommonData.yaml#/components/responses/default'\n\nThe following definitions provided in Annex A of 3GPP TS 29.571 [5] are used in that example:\ncomponents:\nresponses:\n'400':\ndescription: Bad request\ncontent:\napplication/problem+json:\nschema:\n$ref: '#/components/schemas/ProblemDetails'\n'500':\ndescription: Internal Server Error\ncontent:\napplication/problem+json:\nschema:\n$ref: '#/components/schemas/ProblemDetails'\ndefault:\ndescription: Generic Error\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.12\tEnumerations",
                            "text_content": "For enumerations, as defined in clause 5.2.4.3, the OpenAPI Specification [4] file shall contain a definition in the components/schemas clause defining a schema with the name of the enumeration as key.\nThe schema\n-\tshall contain the \"anyOf\" keyword listing as alternatives:\n1.\tthe \"type: string\" keyword and the \"enum\" keyword with a list of all defined values for the enumeration; and\n2.\tthe \"type: string\" keyword and the \"description\" keyword with a description stating that the string is only provided for forward compatibility with future extensions but is not used to encode contents defined in the present version of the specification. Future extensions may need to be defined in conjunction with the supported feature mechanism as specified in clause 6.6.2 of 3GPP TS 29.500 [2], and\n-\tshould contain a description field, containing the overall meaning and purpose of the enumeration; additionally, this field may contain a list of the defined values of the enumeration together with explanations of those values.\nNOTE:\tThe \"enum\" keyword restricts the permissible values of the string to the enumerated ones. This can lead to extensibility problems when new values need to be introduced.\nExample:\nExampleEnumeration represents xxx, and it is used to indicate yyy or zzz; it complies with the provisions defined in Table 5.3.12-1\nTable 5.3.12-1: Enumeration ExampleEnumeration\n\nThe data structure in table 5.3.12-1 is described in an OpenAPI specification file as follows:\ncomponents:\nschemas:\nExampleEnumeration:\nanyOf:\n- type: string\nenum:\n- ONE\n- TWO\n- type: string\ndescription: >\nThis string provides forward-compatibility with future\nextensions to the enumeration but is not used to encode\ncontent defined in the present version of this API.\ndescription: |\nExampleEnumeration represents xxx, and it is used to indicate yyy or zzz;\nit complies with the provisions defined in Table 5.3.12-1 of 3GPP TS ab.cde.\nPossible values are:\n- ONE: Value One description\n- TWO: Value Two description\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.3.12-1: Enumeration ExampleEnumeration",
                                    "table number": 31,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.3.13\tFormatting of structured data types in query parameters",
                            "text_content": "Structured data types shall represent JSON objects or arrays.\nWhen used in query parameters of a URI, the following formatting shall be used:\n-\tJSON objects and arrays of JSON objects: they shall be formatted using the JSON syntax, which is specified in OpenAPI Specification [4] by including a \"content:\" block, and specifying the \"application/json\" media type, followed by the OpenAPI definition of the object.\nEXAMPLE:\n- name: plmn-id\nin: query\ncontent:\napplication/json:\nschema:\ntype: object\nproperties:\nmcc:\ntype: string\nmnc:\ntype: string\n\nThis results in the following formatting:\n.../resource?plmn-id={\"mcc\":\"123\",\"mnc\":\"456\"}\n\n-\tArrays of simple types: they shall be formatted using the OpenAPI \"style\" keyword set to \"form\" and the \"explode\" keyword set to \"false\".\nEXAMPLE:\n- name: service-names\nin: query\nstyle: form\nexplode: false\nschema:\ntype: array\nitems:\ntype: string\n\nThis results in the following formatting:\n.../resource?service-names=service1,service2,service3\n\nAs described in 3GPP TS 29.500 [2], clause 5.2.10, when the URI is composed, it shall escape (percent-encode) certain \"reserved\" characters. When an array of strings is formatted with \"explode: false\" keyword, the COMMA (U+002C) character is used as separator of the different string values; this implies that this character (the value separator) shall not be escaped, while any other comma used inside the different string values shall be escaped (percent-encoded).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.14\tAttribute Presence Conditions",
                            "text_content": "In an OpenAPI Specification [4], presence conditions for attributes in a JSON schema definition shall be expressed by using the \"required\" keyword, indicating a list (array) of attributes that shall always be present in an object conforming to such schema.\nThe \"required\" keyword may be used as part of any of the expressions defined by OpenAPI to combine schemas (\"oneOf\", \"anyOf\", \"allOf\", \"not\").\nEXAMPLES:\n-\tJSON object defining attributes \"a\" and \"b\", of type integer, where attribute \"a\" shall always be present:\ncomponents:\nschemas:\nExampleType1:\ntype: object\nrequired: [ a ]\nproperties:\na:\ntype: integer\nb:\ntype: integer\n\n-\tJSON object defining attributes \"a\" and \"b\", of type integer, where at least one of them, or both, shall be present:\ncomponents:\nschemas:\nExampleType2:\ntype: object\nanyOf:\n- required: [ a ]\n- required: [ b ]\nproperties:\na:\ntype: integer\nb:\ntype: integer\n\n-\tJSON object defining attributes \"a\" and \"b\", of type integer, where at least one of them shall be present, but not both:\ncomponents:\nschemas:\nExampleType3:\ntype: object\noneOf:\n- required: [ a ]\n- required: [ b ]\nproperties:\na:\ntype: integer\nb:\ntype: integer\n\n-\tJSON object defining attributes \"a\" and \"b\", of type integer, where \"a\" and \"b\" can be both absent but, if one of them is present, the other shall be absent:\ncomponents:\nschemas:\nExampleType4:\ntype: object\nnot:\nrequired: [ a, b ]\nproperties:\na:\ntype: integer\nb:\ntype: integer\n\n-\tJSON object defining attributes \"a\" and \"b\", of type integer, where \"b\" shall be present if \"a\" takes a given value (e.g., value 1), but may be absent otherwise:\ncomponents:\nschemas:\nExampleType5:\ntype: object\nproperties:\na:\ntype: integer\nb:\ntype: integer\nanyOf:\n- not:\nrequired: [ a ]\nproperties:\na:\ntype: integer\nenum: [ 1 ]\n- required: [ b ]\n\n-\tJSON object defining attributes \"a\" and \"b\", of type integer, where \"b\" shall be present if and only if \"a\" takes a given value (e.g., value 1):\ncomponents:\nschemas:\nExampleType6:\ntype: object\nproperties:\na:\ntype: integer\nb:\ntype: integer\noneOf:\n- required: [ a ]\nproperties:\na:\ntype: integer\nenum: [ 1 ]\n- not:\nrequired: [ b ]\n\n-\tJSON object defining attributes \"a\", \"b\", \"c\" and \"d\", of type integer, where none of the pairs (\"a\" and \"b\") and (\"c\" and \"d\") shall be present:\ncomponents:\nschemas:\nExampleType7:\ntype: object\nproperties:\na:\ntype: integer\nb:\ntype: integer\nc:\ntype: integer\nd:\ntype: integer\nallOf:\n- not:\nrequired: [ a, b ]\n- not:\nrequired: [ c, d ]\n\nNOTE:\tObject schema definitions should not have property names in the \"required\" attribute for which a corresponding property definition does not exist.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.15\tUsage of the \"tags\" field",
                            "text_content": "In an OpenAPI specification, all HTTP operations belonging to the same resource should include a \"tags\" field containing a same value, briefly describing that resource (e.g. using the name of the resource and its archetype). This results in all operations being grouped by the User Interface of OpenAPI tools, which helps with readibility of the API documentation.\nEXAMPLE:\nopenapi: 3.0.0\n(...)\npaths:\n/nf-instances/{nfInstanceID}:\nget:\nsummary: Read the profile of a given NF Instance\noperationId: GetNFInstance\ntags:\n- NF Instance ID (Document)\n(...)\nput:\nsummary: Register a new NF Instance\noperationId: RegisterNFInstance\ntags:\n- NF Instance ID (Document)\n(...)\npatch:\nsummary: Update NF Instance profile\noperationId: UpdateNFInstance\ntags:\n- NF Instance ID (Document)\n(...)\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.16\tSecurity",
                            "text_content": "As indicated in 3GPP TS 33.501 [22] and 3GPP TS 29.500 [2], the access to an 5GC API may be authorized by means of the OAuth2 protocol (see IETF RFC 6749 [23]), based on local configuration. 5GC APIs thus need to support the OAuth2 protocol.\nTo reflect this, the OpenAPI specification file of an API shall contain:\n-\ta top-level \"security\" field, that applies to the overall API unless overridden by a resource/operation-level \"security\" field, listing as alternatives:\ni)\t\"{}\" to indicate that usage of security is optional; and\nii)\tthe name of the security scheme for oAuth2, including in the array of scopes the name of the API as the only scope; and optionally\n-\ta resource/operation-level \"security\" field, that applies to a specific operation on a specific resource, and overrides the top-level \"security\" field, listing as alternatives:\ni)\t\"{}\" to indicate that usage of security is optional; and\nii)\tthe name of the security scheme for oAuth2, including in the array of scopes the name of the API as the only scope, and\niii)\tthe name of the security scheme for oAuth2, including in the array of scopes the name of the API and the name of one scope to be used to invoke the specific resource/operation, and optionally\niv)\tthe name of the security scheme for oAuth2, including in the array of scopes the name of the API and the names of two scopes to be used to invoke the specific resource/operation, and\nNOTE:\tthe option iv) can be used e.g. to define one scope for a set of specific resources, and a second scope for a specific operation within the set.\n-\ta \"securitySchemes\" field in the \"components\" clause defining a security schema for oAuth2 as follows:\ni)\tto be of type \"oauth2\"; and\nii)\twith a \"flows\" field containing a \"clientCredentials\" field that contains:\n1)\ta \"tokenUrl\" field pointing to the Access Token Request service provided by the NRF (see 3GPP TS 29.510 [18]); and\n2)\ta \"scopes\" field defining all the different scopes applicable to this API, which includes the name of the corresponding API (using the format used within URIs of that API) to be used as the scope required to get access to the overall API, and also including those resource/operation-level scopes to be used as scopes required to invoke a specific operation on a specific resource.\nThe naming of the resource/operation-level scopes should consist of the concatenation of the service name, a string or sequence of strings representing a resource name or set of resource names or custom operation, and optionally a string indicating the type of access (e.g. read/modify/create), separated by the \":\" (colon) character.\nSuch last string component of the resource/operation-level scope, that represents the type of access for a resource, should comply with the following principles:\n-\t\"read\": for GET operations for any resource archetype,\n-\t\"create\": for POST or PUT operations that result in a creation of new resources from a collection or store resource,\n-\t\"modify\": for PUT, PATCH or DELETE operations that result on an update or deletion of a document resource,\n-\t\"invoke\": for POST operations that result in the invocation of a custom operation\n-\t\"write\": for any operation that results in creation, modification or deletion of resource representations.\nExample 1:\nsecurity:\n- {}\n- oAuth2ClientCredentials:\n- nnrf-nfm\n\npaths:\n/nf-instances:\nget:\nsecurity:\n- {}\n- oAuth2ClientCredentials:\n- nnrf-nfm\n- oAuth2ClientCredentials:\n- nnrf-nfm\n- nnrf-nfm:nf-instances:read\nparameters:\n(...)\nresponses:\n(...)\n\ncomponents:\nsecuritySchemes:\noAuth2ClientCredentials:\ntype: oauth2\nflows:\nclientCredentials:\ntokenUrl: '{nrfApiRoot}/oauth2/token'\nscopes:\nnnrf-nfm: Access to the Nnrf_NFManagement API\nnnrf-nfm:nf-instances:read: Read access to the NF Instances (Collection) resource\n\nExample 2:\nsecurity:\n- {}\n- oAuth2ClientCredentials:\n- nudr-dr\n\npaths:\n/exposure-data/{ueId}/access-and-mobility-data:\nget:\nsecurity:\n- {}\n- oAuth2ClientCredentials:\n- nudr-dr\n- oAuth2ClientCredentials:\n- nudr-dr\n- nudr-dr:exposure-data\n- oAuth2ClientCredentials:\n- nudr-dr\n- nudr-dr:exposure-data\n- nudr-dr:exposure-data:read\nparameters:\n(...)\nresponses:\n(...)\n\ncomponents:\nsecuritySchemes:\noAuth2ClientCredentials:\ntype: oauth2\nflows:\nclientCredentials:\ntokenUrl: '{nrfApiRoot}/oauth2/token'\nscopes:\nnudr-dr: Access to the Nudr_DataRepository API\nnudr-dr:exposure-data: Access to the ExposureData data set\nnudr-dr:exposure-data:read: Access to read ExposureData\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.17\tReuse of Structured Data Types",
                            "text_content": "As indicated in clause 5.2.4.1, common data types can be defined in 3GPP TS 29.571 [5], in order to avoid the duplication of data type definitions across multiple APIs.\nWhen such data types are of type object, a given API may require that the common data type is extended with additional attributes, on top of those from the original definition in 3GPP TS 29.571 [5].\nIn such case, the new data type in that API should not re-define entirely the common data type, and instead, it should use appropriate constructs in OpenAPI (i.e. the \"allOf\" keyword) to indicate that the new data type contains all the attributes form the common data type, by referencing to it, and indicate the additional attributes needed in the new data type.\nEXAMPLE:\nThe ProblemDetails data type is defined in 3GPP TS 29.571 [5] as:\nProblemDetails:\ntype: object\nproperties:\ntype:\n$ref: '#/components/schemas/Uri'\ntitle:\ntype: string\nstatus:\ntype: integer\ndetail:\ntype: string\ninstance:\n$ref: '#/components/schemas/Uri'\ncause:\ntype: string\ninvalidParams:\ntype: array\nitems:\n$ref: '#/components/schemas/InvalidParam'\nminItems: 1\n\nThen, if a given API needs to extend ProblemDetails with an additional attribute, e.g. \"action\" of type string, it should define, e.g. an ExtendedProblemDetails data type as follows:\nExtendedProblemDetails:\nallOf:\n- $ref: 'TS29571_CommonData.yaml#/components/schemas/ProblemDetails'\n- $ref: '#/components/schemas/ProblemDetailsExtension'\n\nProblemDetailsExtension:\ntype: object\nproperties:\naction:\ntype: string\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.18\tOperation identifiers",
                            "text_content": "Service operations defined in an OpenAPI specification file should be assigned an Operation ID.\nEXAMPLE:\nget:\noperationId: ReadInfo\nsummary: Read Information.\ntags:\n- Information (Document)\nparameters:\n- name: infoType\nin: path\ndescription: Requested information Type\nrequired: true\nschema:\ntype: string\n(…)\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.19\tFormatting of description fields",
                            "text_content": "As indicated in OpenAPI Specification [4], \"description\" fields support the CommonMark Markdown formatting (see ).\nIn the 3GPP APIs, a description field may consist of multiple lines of YAML text; in order to have a proper output formatting (i.e., to be correctly rendered by tooling producing, e.g., HTML-based content), they should be documented as follows:\n-\tIf line breaks need to be kept in the output formatting, this shall be indicated by two trailing white spaces (see ). Those are represented in the example below as gray-shaded non-break spaces for illustration purposes, but the YAML file shall contain two normal white spaces:\n\ndescription: |\nText in the first line.\nMore text in the second line.\nAdditional text in the third line.\n\n-\tIf the text in the different lines should be formatted as a bulleted HTML list, each line may be prepended by the hyphen \"-\" character, as follows:\ndescription: |\nText in the first line:\n- List item 1\n- List item 2\n\n-\tIf the text should be displayed in the output formatting as a single line, the YAML file may be formatted using one of the following options:\n-\tAll text in a single YAML line, following the \"description\" keyword, such as:\ndescription: This is a long description text that is formatted as a single YAML line, which is correct, but may not be optimal when the YAML file is displayed on a text editor configured to not automatically wrap long lines.\n\n-\tThe \"description\" keyword is followed by the \">\" character and the text is placed in different lines (this option should be the preferred approach, rather than having extremely long lines in the YAML file), such as:\ndescription: >\nThis text is the first part of a single line,\nfollowed by this second line,\nwhere all these 3 lines will be displayed in the same line in the output formatting.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "6\tRequirements for secure API design",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "6.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "This clause contains a list of security requirements for API design provided by SA3.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.2\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "The following requirements are intended as general guidance for 3GPP Stage 3 work in order to specify secure protocols and APIs. As such, these guidelines are independent of the specific technology and shall be followed at all times.\n-\tThe valid format and range of values (when applicable) for each IE shall be defined unambiguously.\nNOTE 1:\tExplicitly defining format and range of values not only helps to improve the security of a certain implementation, but also allows for reliable interoperability between different protocol implementations. Example: Defining a \"lowercase string variable of length 10 and range [a..z]\" is much more explicit that just defining a \"string of length 10\". There are known vulnerabilities such as a denial of service (resulting in the parser converting from a string representing an integer – an attacker can pass in an arbitrarily large integer and trigger an unhandled exception) and such leading to a heap corruption and crash (proof-of-concept available), or potentially remote code execution (no proof-of-concept known). Unicode literals also require special treatment when doing string comparisons to ensure that equivalent strings return true when compared.\n-\tFor each message the number of leaf IEs shall not exceed 2048K. If a leaf IE is an array of a simple data type, then the whole array shall count as one leaf. If a leaf IE is a data structure or an array of data structures, then it shall be considered a branch, i.e. it shall not be counted as a leaf. The data structure's (branch) attributes determine the number of leaves. For instance, a data structure with e.g. three attributes will count as three leaves.\n-\tThe maximum size of the JSON body of any HTTP request/response shall not exceed 16 million octets before compression is applied, if any.\nNOTE 2:\tAPIs need to be designed taking care to avoid a too large HTTP payload size for performance reasons.\n-\tThe maximum nesting depth of leaves shall not exceed 32. If a leaf IE is an array of a simple data type, then the whole array shall be considered as the first level of nesting. If a leaf IE is a data structure or an array of data structures, then it shall be considered a branch and the first level of nesting. The data structure's attributes (leaves) shall be considered as the second level of nesting. For instance, a data structure with e.g. one attribute-A, which is also a data structure with e.g. one attribute-B, then attribute-B will make the third level of nesting.\nNOTE 3:\tThere are resource exhaustion attacks on JSON parsers. Defined maximum numbers of IEs, sizes and nesting depths allow implementations to know an upper bound of required resources. It also allows validation of incoming messages. Recursively processing nested objects leads to stack exhaustion and a denial of service bug.\n-\tFor data structures where values are accessible using names (sometimes referred to as keys), e.g. a JSON object, the name shall be unique. The occurrence of the same name (or key) twice within such a structure shall be an error and the message shall be rejected.\nNOTE 4:\tSerialization schemes (e.g. JSON) can leave the handling of repeated names (keys) up to the implementer's discretion. For example, for a repeated name an error can be raised, the pair can be ignored, or the first or last value read can be used, though there is no canonical order in which a parser should treat the data it receives. Failure to adhere to consistent handling rules can lead to vulnerabilities. From a security perspective rejecting objects with repeated names, rather than accepting according to some rule, is the more robust solution, and aids in identification of potentially malicious activity. There are known attacks with specially crafted malicious messages that are designed to confuse implementations of NFs to get fraudulent messages into a PLMN.\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.3\tSBA-specific requirements",
                    "description": "",
                    "summary": "",
                    "text_content": "The following requirements shall be considered for every network function that implements a service-based interface.\n-\tOpenAPI specifications are machine-readable JSON objects and can be used as the basis for re-configuring an NFs action when an API or message structure changes. Therefore, each OpenAPI specifications shall contain all necessary information to correctly and unambiguously parse the contents of the message body.\nNOTE:\tAttacks often exploit corner cases and unspecified behavior in order to exploit a system. Traffic normalization counters this by either dropping traffic that is malformed or by forcing certain information elements to a \"normal\" value. Typically, this relates to inconsistent fields.\n-\t3GPP TS 33.501 [22] documents which type of information shall be confidentiality protected on the N32 interface. The fields where these types of information (e.g. SUPI) is contained may have different names. Even if the field names are different, the mechanism specified in clause 5.2.3.3 of 3GPP TS 29.573 [24] shall clearly identify the type of information carried in each IE and which information types shall be confidentiality protected.\nA TS Skeleton Template to be used as a starting point of drafting a 5G System SBI Stage 3 specification is available at the following location:\nhttps://www.3gpp.org/ftp/information/All_Templates/29.xxx-SBI-Stage3-Template.zip\nThis Annex provides information about the changes in the API that are considered as backwards compatible and those that are considered as backwards incompatible. This list is to be considered informative and it may be expanded in future releases, when necessary.\nBackward compatible changes are additions or changes in the API that do not break the existing Service Consumer behaviour. Examples of backward compatible changes include:\n-\tAdding a new, optional child resource/URI;\n-\tSupporting a new HTTP method;\n-\tAdding new elements to a resource representation;\n-\tChanging the order of fields in a resource representation;\n-\tAddition of a new status code:\nNOTE 1:\tWhen a NF / NF Service receives a HTTP status code that it cannot recognize it will treat it as the corresponding x00 status code as specified in clause 5.2.7.3 of 3GPP TS 29.500 [2].\n-\tCorrections of obvious errors in an OpenAPI file required to enable a correct parsing of the file such as misspelled references;\n-\tCorrections that only relate to smaller and optional parts of the functionality (e.g. a supported feature, see 3GPP TS 29.500 [2] clause 6.6.2), even if the changes are backward incompatible with respect to that part of the functionality; and\nNOTE 2:\tIt is recommended to only apply corrections which are also backward compatible with respect to such smaller and optional parts of the functionality. If this is not possible a new supported feature can be introduced to enable a negotiation of the support of the correction, and the old corresponding supported feature can be marked as \"withdrawn\" in the table defining the supported features of an API.\n-\tBackward-compatible changes related to the semantics (i.e. functional behaviour) specified for an API.\nChanges in the API that do not result in any loss of existing functionality (i.e. functionality that works fine if both consumer and provider do not support the change) if only consumer or only provider implements the change can be considered as backwards compatible corrections or additions.\nBackward incompatible changes are additions or changes in the API that break the existing Service Consumer behaviour. Here is a list of backward incompatible changes that shall require incrementing the 1st field (MAJOR) of the API version number unless they only relate to smaller and optional parts of the functionality (see above):\n-\tRemoving a resource/URI:\n-\tRemoving support for an HTTP method;\n-\tRenaming a field in a resource representation;\n-\tAdding mandatory parameters to a resource URI or resource representation;\n-\tAttribute data type changes;\n-\tCardinality changes (NOTE 3); and\nNOTE 3:\tWhether attribute cardinality changes are backward compatible depend on the type of change. Examples of non-backward compatibility changes include decreasing the upper bound of a cardinality range for attributes sent by the NF service consumer, changing the meaning of the default behavior associated to the absence of an attribute of cardinality 0..N, etc.\n-\tBackward incompatible changes related to the semantics (i.e. functional behaviour) specified for an API.\nChanges in the API that result in loss of existing functionality (i.e. functionality that works fine if both consumer and provider do not support the change) if only consumer or only provider implements the change can be considered as backwards incompatible modifications.\nWhen a change although being categorised as backwards compatible correction or addition results in interoperability issues, it is expected that the issue will be resolved by implementing the change at both consumer and provider.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "C.0\tGeneral",
            "description": "When designing an API, one shall first think of defining the set of resources consumed. Resources represent objects that are modified by standard HTTP methods and that can be modelled with one of 4 archetypes detailed below. Resource archetypes help API designers to structure the resources. In this process the designer should refer to the appropriate archetype when the resource definition perfectly matches the archetype one. Referring to an archetype immediately defines what operations and HTTP methods are supported by the resource.\nThe archetypes provided hereafter don't preclude the existence of resources of different types.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.1\tDocument",
            "description": "The document archetype is the conceptual base archetype of the other ones. Any resource that is not identified with one of the other resource archetypes is a document.\nA document may have child resources that represent its specific subordinate concepts.\nThe archetype does not place any restriction on HTTP methods when acting on a document.\nOnly CRUD operations are performed directly on a document resource, i.e. by sending an HTTP request to the URI of that resource. Custom methods are not performed directly on the resource, but by sending an HTTP request to a URI that is associated by a convention with the URI of the resource.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.2\tCollection",
            "description": "The collection archetype can be used to model a resource that serves as a directory of resources. A collection is NF Service Provider-managed so the NF Service Provider decides the URIs of each resource that is created in the collection.\nNOTE:\tEven though a collection resource typically contains child resources, it is allowed that a particular collection resource does not contain any child resource at a particular point in time (\"empty collection\").\nThe Create and Read operations are performed on a collection directly.\nMore specifically:\n-\tA collection child resource is created by sending a POST with the collection URI if accepted by the collection;\n-\tA collection is read by sending a GET with the collection URI;\n-\tThe PUT and PATCH methods with the collection URI are not allowed;\n-\tThe DELETE method with the collection URI is only allowed if the collection resource has been created dynamically based on a request from the NF Service Consumer.\n-\tThe authorized operations on a collection child resource depend on that resource's archetype.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.3\tStore",
            "description": "The store archetype can also be used to model a resource that serves as a directory of resources but a store is NF Service Consumer-managed. The NF Service Consumer solely decides what resource shall be added to / deleted from a store. The NF Service Consumer decides what the URI of the added resource is.\nNOTE:\tEven though a store resource typically contains child resources, it is allowed that a particular store resource does not contain any child resource at a particular point in time (\"empty store\").\nThe Read operation is performed on a store directly, and the Create operation is performed on store child resources.\nMore specifically:\n-\tA store child resource is created by sending a PUT with the URI of the child resource to be created.\n-\tA store is read by sending a GET with the store URI;\n-\tThe POST, PUT and PATCH methods with the store URI are not allowed;\n-\tThe DELETE method with the store URI is only allowed if the store resource has been created dynamically based on a request from the NF Service Consumer.\n-\tApart from Create (PUT), the authorized operations on a store child resource depend on that resource's archetype.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.4\tCustom operation",
            "description": "The custom operation archetype can be used to model an unsafe and non-idempotent operation that is not a Create on a collection.\nA custom operation does not operate directly on the resource that would be identified by the custom operation URI. Instead, when the custom operation is associated with a resource, the operation is performed on this associated resource. For instance, a custom operation may modify the associated resource in a special way. This associated resource is identified by stripping the suffix string \"/<custOpName>\" from the custom operation URI template in clause 4.4.2.\nWhen the custom operation is not associated with any resource but with the service, it acts as an executable function with input parameters and returns the result of the executed function in the response body, not modifying any resource.\nPOST is the only method allowed with a custom operation URI.\nThe semantic of the custom operation is encoded in the last segment of the URI template in clause 4.4.2: /{custOpName}.\nAs described in clause 4.6.1.1.3.2, the bodies of HTTP PATCH requests will either use a \"JSON Merge Patch\" encoding as defined in IETF RFC 7396 [7], or a \"JSON Patch\" encoding as defined IETF RFC 6902 [8]. This annex provides an example OpenAPI Specification [4] allowing both encodings.\nNOTE:\tBoth encoding possibilities are shown in this example for illustrative purposes. However, only a single of the above encodings will be specified for each resource where the PATCH method is supported unless backward compatibility considerations necessitate the support of both encodings.\nopenapi: 3.0.0\n\ninfo:\nversion: \"1.0.0\"\ntitle: PATCH Example\n\npaths:\n/inventory:\npost:\nsummary: adds an inventory item\noperationId: addInventory\ndescription: Adds an item to the system\nresponses:\n'201':\ndescription: item created\n'400':\ndescription: 'invalid input, object invalid'\n'409':\ndescription: an existing item already exists\nrequestBody:\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/InventoryItem'\ndescription: Inventory item to add\n\n/inventory/{id}:\nget:\nsummary: read inventory item\nparameters:\n- name: id\nin: path\nrequired: true\nschema:\ntype: integer\nresponses:\n'200':\ndescription: search results matching criteria\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/InventoryItem'\n'400':\ndescription: bad input parameter\npatch:\nsummary: patch inventory item\nparameters:\n- name: id\nin: path\nrequired: true\nschema:\ntype: integer\nrequestBody:\nrequired: true\ncontent:\napplication/json-patch+json:\nschema:\n$ref: '#/components/schemas/PatchInventoryItem'\napplication/merge-patch+json:\nschema:\n$ref: '#/components/schemas/MergePatchInventoryItem'\nresponses:\n'200':\ndescription: Patch was succesfull and updated Inventory Item is returned.\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/InventoryItem'\n'204':\ndescription: Patch was succesfull\n'400':\ndescription: bad input parameter\n\ncomponents:\n\nschemas:\nInventoryItem:\ntype: object\nrequired:\n- name\n- manufacturer\nproperties:\nid:\ntype: integer\nname:\ntype: string\nmanufacturer:\n$ref: '#/components/schemas/Manufacturer'\ncustomers:\ntype: array\nitems:\ntype: string\n\nManufacturer:\ntype: object\ndescription: Represents the manufacturer.\nrequired:\n- name\nproperties:\nname:\ntype: string\nhomePage:\ntype: string\nformat: url\nphone:\ntype: string\n\nManufacturerRm:\ntype: object\ndescription: >\nThis data type is defined in the same way as the \"Manufacturer\" data type,\nbut with the OpenAPI \"nullable: true\" property.\nrequired:\n- name\nproperties:\nname:\ntype: string\nhomePage:\ntype: string\nformat: url\nphone:\ntype: string\nnullable: true\n\n\nPatchInventoryItem:\ntype: array\ndescription: A JSON PATCH body schema to Patch selected parts of an Inventory Item\nitems:\nanyOf:\n- oneOf:\n- type: object\ndescription: Modifies the URL of a Manufacturer\nproperties:\nop:\ntype: string\nenum:\n- \"add\"\n- \"remove\"\n- \"replace\"\npath:\ntype: string\npattern: '^\\/manufacturer\\/homePage$'\nvalue:\ntype: string\nformat: url\nrequired:\n- \"op\"\n- \"path\"\n- type: object\ndescription: Modifies a Manufacturer\nproperties:\nop:\ntype: string\nenum:\n- \"replace\"\npath:\ntype: string\npattern: '^\\/manufacturer$'\nvalue:\n$ref: '#/components/schemas/Manufacturer'\nrequired:\n- \"op\"\n- \"path\"\n- \"value\"\n- type: object\ndescription: Modifies a Customer\nproperties:\nop:\ntype: string\nenum:\n- \"add\"\n- \"remove\"\n- \"replace\"\npath:\ntype: string\npattern: '^\\/customers\\/(-|\\d+)$'\nvalue:\ntype: string\nrequired:\n- \"op\"\n- \"path\"\n- type: object\ndescription: Open Alternative\nminItems: 1\n\nMergePatchInventoryItem:\ndescription: A JSON Merge PATCH body schema to Patch selected parts of an Inventory Item\ntype: object\nproperties:\nmanufacturer:\n$ref: '#/components/schemas/ManufacturerRm'\ncustomers:\ntype: array\ndescription: Allows to replace the entire array, but not to modify individual elements.\nitems:\ntype: string\nThis Annex provides guidelines on the use of JSON arrays on the SBI APIs of the 5GC.\nAs described in clause 5.2.4, the data model of an API definition in a 5GC API consists of any of the different data types supported by OpenAPI, corresponding to the different data structures found in the JSON data format. One of these structures is the \"array\", representing a set of ordered values.\nIt should be noted that, while JSON allows that the value of the elements of an array may be of different types, in OpenAPI Specification [4]this is further restricted, and all elements of an array shall be of the same type.\nAlso, it is important to note that the JSON format itself, as specified in IETF RFC 8259 [3], does not define any syntax to refer to specific array elements.\nHowever, there are certain conventions to specify mechanism to refer to array elements, e.g. based on the position a given element has in the array.\nIn particular, the JSON Pointer syntax defines a string syntax for identifying a specific value within a JSON document. This syntax consists of a number of tokens separated by the \"/\" character; in order to refer to a specific element in an array, then token shall contain an unsigned decimal value, indicating the zero-based index of the element in the array.\nEXAMPLE:\nJSON document:\n{\n\"attr1\": 0,\n\"attr2\": true,\n\"attr3\": [ 1, 2, 3 ]\n}\n\nJSON Pointer expression \"/attr3/0\" evaluated on such JSON document: 1\nThere are several scenarios, frequently employed in the 5GC APIs, that make use of the JSON Pointer mechanism to refer to specific elements in an array:\n-\tUpdate of resources using the PATCH method, as described in clause 4.6.1.1.3.2. If the syntax used in the PATCH request payload is based on the \"JSON Patch\" format, then the JSON Pointer mechanism is used to specify patch operations applied to specific array elements.\n-\tNotifications of events (such as data changes), as described in clause 4.6.2.3, using as notification payload the notation defined in \"NotifyItem\" / \"ChangeItem\" data types defined in 3GPP TS 29.571 [5]. This notation is similar to \"JSON Patch\", so it also makes use of the JSON Pointer syntax to refer to specific array elements.\n-\tExplicit usage of attributes containing JSON Pointer expressions in request or response payloads.\nIn these scenarios, it is critical that any JSON Pointer expression is applied by both client and server on the exact same array representation, since otherwise the indexes may vary, and the JSON Pointer will give unexpected results.\nA typical scenario that may create issues could be as follows:\n1.\tNF Service Consumer sends a first GET request towards a NF Service Producer, including certain query parameters in the HTTP request, that result into retrieving a resource representation that contains a subset of the data that the NF Service Producer holds under such resource. When such subset refers to returning just some of the elements of an array, rather than the entire array, then the content of the array will differ between consumer and producer.\n2a.\tThe NF Service Consumer sends a subsequent PATCH request towards the NF Service Producer, with the intention to modify a given element of the array (specified by the array index, per the JSON Pointer syntax). This results into the server modifying a wrong element in the array, given that the NF Service Producer contains a different array.\n2b.\tThe NF Service Consumer may subscribe to be notified by the NF Service Producer when a given resource representation has changed. When the NF Service Producer detects such a change, it sends a notification that may include a reference to an array index, which may be different than the array index kept by the NF Service Producer.\n2c. The NF Service Consumer is a stateless NF Service Consumer that has no local representation of the array that subscribes to be notified by the NF Service Producer when a given resource representation has changed.\nAnother scenario that may lead to incorrect array updates is:\n1.\tTwo different NF Service Consumer sends a GET request towards a NF Service Producer to retrieve the representation of a certain resource.\n2.\tA first NF Service Consumer NF1 sends a PATCH request towards the NF Service Producer, with the intention to delete a given element of the array (specified by the array index, per the JSON Pointer syntax). This results in some of the array indexes being changed (of those elements placed after the deleted element)\n3.\tA second NF Service Consumer NF2, sends another PATCH request towards the NF Service Producer, to modify any of the elements of the array whose index was affected by the previous operation done by NF1. This results in modifying unintendedly the wrong array element.\nThe design of 5GC SBI APIs should take into account these scenarios and provide mechanisms to avoid unintended modifications of array elements, when they are referred by their position index in the array.\nTo achieve these, both NF Service Consumer and Producer (taking the role of HTTP client and server) should ensure that any resource update takes place on a known and current resource representation, based on the content of ETag values sent along with resource representations by the resource owner.\nIf an NF Service Consumer needs to cache a resource representation received from an NF Service Producer (i.e. the JSON information received in an HTTP response message), it shall use the exact same representation of arrays as received from the service producer.\nWhen sending notifications or modifications whose semantics is based on the JSON Pointer syntax, the sending NF shall use the exact same representation of arrays as previously signalled in a previous interaction with the receiver of such notifications/modifications.Further, when sending notifications whose semantics is based on the JSON Pointer syntax, if the NF Service Consumer is a stateless NF Service Consumer and thus has no local representation of the array, the NF Producer shall use the complete replacement array representation as the NF Service Consumer is otherwise required to request the complete data from the NF Service Producer with a GET request.\n\n\n",
            "summary": "",
            "tables": [
                {
                    "description": "",
                    "table number": 32,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        }
    ]
}