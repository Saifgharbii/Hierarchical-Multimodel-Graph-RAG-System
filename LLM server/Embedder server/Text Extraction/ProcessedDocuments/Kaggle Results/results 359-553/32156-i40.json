{
    "document_name": "32156-i40.docx",
    "content": [
        {
            "title": "Foreword",
            "description": "This Technical Specification has been produced by the 3rd Generation Partnership Project (3GPP).\nThe contents of the present document are subject to continuing work within the TSG and may change following formal TSG approval. Should the TSG modify the contents of the present document, it will be re-released by the TSG with an identifying change of release date and an increase in version number as follows:\nVersion x.y.z\nwhere:\nx\tthe first digit:\n1\tpresented to TSG for information;\n2\tpresented to TSG for approval;\n3\tor greater indicates TSG approved document under change control.\ny\tthe second digit is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc.\nz\tthe third digit is incremented when editorial only changes have been incorporated in the document.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "1\tScope",
            "description": "UML provides a rich set of concepts, notations and model elements to model distributive systems. This paper documents the necessary and sufficient set of UML notations and model elements, including the ones built by the UML extension mechanism <<stereotype>> to model network management systems and their managed nodes. This set of notations and model elements is called the FMC (developed by the Converged Management of Fixed/Mobile Networks project) Model Repertoire; see also 3GPP TS 32.107 [5] and 3GPP TS 28.620 [6].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "2\tReferences",
            "description": "[1]\tOMG \"Unified Modelling Language (OMG UML), Infrastructure\", Version 2. 4.\n[2]\tOMG \"Unified Modelling Language (OMG UML), Superstructure\", Version 2. 4.\n[3]\t3GPP TS 32.300: \"Telecommunication management; Configuration Management (CM); Name convention for Managed Objects\".\n[4]\tVoid\n[5]\t3GPP TS 32.107: \" Telecommunication management; Fixed  Convergence (FMC) Federated Network Information Model (FNIM)\".\n[6]\t3GPP TS 28.620: \" Telecommunication management; Fixed  Convergence (FMC) Federated Network Information Model (FNIM) Umbrella Information Model (UIM)\".\n[7]\tITU-T X.680,\"OSI networking and system aspects – Abstract Syntax Notation One (ASN.1)\".\n[8]\t Void\n[9]\t3GPP TS 32.602 \"Telecommunication management; Configuration Management (CM); Basic CM Integration Reference Point (IRP): Information Service (IS)\".\n[10]\t3GPP TS 32.612: \"Telecommunication management; Configuration Management (CM); Bulk CM Integration Reference Point (IRP): Information Service (IS)\".\n[11]\t3GPP TS 32.111-2: \" Telecommunication management; Fault Management; Part 2: Alarm Integration Reference Point (IRP): Information Service (IS)\".\n[12]\t3GPP TS 32.302: \"Telecommunication management; Configuration Management (CM); Notification Integration Reference Point (IRP): Information Service (IS)\".\n[13]\t3GPP TS 32.404: \"Telecommunication management; Performance Management (PM); Performance measurements - Definitions and template\".\n[14]\t3GPP TS 28.545 \"Management and orchestration; Fault Supervision (FS)\".\n[15]\t3GPP TS 28.541 \"Management and orchestration; 5G Network Resource Model (NRM); Stage 2 and stage 3\".\n[16]\t3GPP TS 28.532 \"Management and orchestration; Generic management services\".\n[17]\t3GPP TS 28.531 \"Management and orchestration; Provisioning\".\n[18]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[19]\t3GPP TS 32.102: “Telecommunication management; Architecture”.\n[20]\t3GPP TS 28.533: “Management and orchestration; Architecture framework”.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "3\tDefinitions and abbreviations",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "3.1\tDefinitions",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the terms and definitions given in 3GPP TR 21.905 [18] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [18].\nNaming attribute: It is a class attribute that holds the class instance identifier. See attribute id of Top_ in TS 28.620 [6]. See examples of naming attribute in 3GPP TS 32.300 [3].\nLower Camel Case: The practice of writing compound words in which the words are joined without spaces and that the initial letter of all except the first word is capitalized.\nEXAMPLES:\t’managedNodeIdentity’ and ‘minorDetails’ are the LCC for \"managed node identity\" and “minor details” respectively.\nUpper Camel Case: The practice of writing compound words in which the words are joined without spaces and that the initial letters of all words are capitalised.\nEXAMPLES:\t‘ManagedNodeIdentity’ and ‘MinorDetails’ are the UCC for \"managed node identity\" and \"minor details\" respectively.\nWell Known Abbreviation: An abbreviation that can be used as the modelled element name or as a component of a modelled element name.\nNOTE 1:\tThe abbreviation, when used in such manner, is in the same document where the modelled element is defined.\nManager: IRP Manager or MnS consumer\nNOTE 2:\tIn the context of the IRP framework as defined in TS 32.102 [x], the term manager designates the IRP Manager. In the context of the SBMA framework as defined in TS 28.533 [y], the term manager designates the MnS consumer.\nAgent: IRP Agent or MnS producer\nNOTE 3:\tIn the context of the IRP framework as defined in TS 32.102 [x], the term agent designates the IRP Agent. In the context of the SBMA framework as defined in TS 28.533 [y], the term agent designates the MnS producer.\nData type: Constraint on an attribute value.\nSimple type: Data type constraining an attribute value to a scalar.\nComplex type: Data type of a structured and/or multi-valued attribute.\nAttribute: Information element of an object composed of an attribute name and an attribute value.\nAttribute name: Name of an attribute.\nAttribute value: Value of an attribute that is defined by a simple type or a complex type.\nAttribute field: Attribute contained in an attribute that can contain attribute fields.\nAttribute field name: Name of an attribute field.\nAttribute field value: Value of an attribute field defined by a simple type or a complex type.\nSimple attribute: Attribute whose value is a simple type.\nComplex attribute: Attribute whose value is a complex type.\nStructured attribute: A kind of a complex attribute whose value contains one or more attribute fields\nMulti-valued attribute: A kind of a complex attribute with multiplicity > 1.\nAttribute element: A single value of a multi-valued attribute.\nAttribute field element: A single value of a multi-valued attribute field.\nData node: An object, an attribute, an attribute field, an attribute element, or an attribute field element.\nAttribute data node: An attribute, an attribute field, an attribute element, or an attribute field element.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.2\tAbbreviations",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [18], 3GPP TS 28.620 [6] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [18], and 3GPP TS 28.620 [6].\nCM\t\tConditional Mandatory\nCO\tConditional Optional\nIRP\t\tIntegration Reference Point\nLCC\t\tLower Camel Case\nM\t\tMandatory\nMnS\tManagement Service\nNA\t\tNot Applicable\nO\tOptional\nOMG\t\tObject Management Group\nUCC\t\tUpper Camel Case\nWKA\t\tWell Known Abbreviation\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "4\tRequirements",
            "description": "The UML notations and model elements captured in this repertoire shall be used to model behaviours of the systems/entities such as the Umbrella Information Model (UIM) of the FNIM in 3GPP TS 28.620 [6].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "5\tModel elements and notations",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "5.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "Note that the graphical notation in this document is only used to represent particular model elements. Although the graphical notation is a correct representation of the model element, it may not be a valid representation of a UML class diagram.\nThe examples used in this document are for illustration purposes only and may or may not exist in specifications.\nUML properties not described in this document shall not be used in specifications based on this repertoire.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "5.2\tBasic model elements",
                    "description": "",
                    "summary": "",
                    "text_content": "UML has defined a number of basic model elements. This subclause lists the subset selected for use in specifications based on this repertoire. The semantics of these selected basic model elements are defined in [1].\nFor each basic model element listed, there are three parts. The first part contains its description. The second part contains its graphical notation examples and the third part contains the rule, if any, recommended for labelling or naming it.\nThe graphical notation has the following characteristics:\n\tSubclause 7.2.7 of [2] specifies \"A class is often shown with three compartments. The middle compartment holds a list of attributes while the bottom compartment holds a list of operations\" and \"Additional compartments may be supplied to show other details\". This repertoire only allows the use of the name (top) compartment and attribute (middle) compartment. The operation (bottom) compartment may be present but is always empty.\n\n\tClasses may or may not have attributes. The graphical notation of a class may show an empty attribute (middle) compartment even if the class has attributes, as shown in figure below.\n\n\tThe visibility symbol shall not appear along with the class attribute, as shown below.\n\n\tThe use of the decoration, i.e. the symbol in the name (top) compartment, is optional.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.2.1\tAttribute",
                            "text_content": "An attribute is a typed element representing a property of a class (Unified Modelling Language (OMG UML), Infrastructure [1], clause 10.2.5.). An element that is typed implies that the element can only refer to a constrained set of values. See clause 10.1.4  of [1] for more information on type.\nSee clauses 5.3.4 and 5.4.3 for predefined data types and user-defined data types that can apply type information to an attribute.\nThe properties of an attribute are described by a set of attribute properties categorized as follows:\n-\tAttribute properties defining valid attribute values: type, allowedValues, multiplicity, isOrdered, isUnique, isNullable, passedById.\n-\tAttribute properties defining valid interactions of managers and agents with attributes values: isInvariant, isWritable, isReadable, isNotifyable, defaultValue.\n-\tOther attribute properties: documentation, supportQualifier.\nThe following tables provide definitions for the attributes of the three categories.\nTable 5.2.1.1-1: Attribute properties defining valid attribute values\n\nTable 5.2.1.1-2: Attribute properties defining valid interactions with attributes\n\nTable 5.2.1.1-3: Attribute properties related to the specification of attributes\n\nUpon completion of any manipulation of an attribute the attribute properties related to valid attribute values shall be respected. If an interaction results in violating at least one of these properties, the manipulation request shall be rejected.\nThe value N/A (Not applicable) shall not be used for attribute properties except for properties \"isOrdered\", \"isUnique\" and \"allowedValues\".\nThis example shows three attributes, i.e., a, b and c, listed in the attribute (the second) compartment of the class Xyz.\nFigure 5.2.1.2-1: Attribute notation depicts the use of attribute notation in the context of a telecommunication system. This figure illustrates the various attributes that can be assigned to different elements within the system, such as signal strength, signal quality, and signal type. The use of attribute notation allows for more efficient and accurate communication of information, enabling better understanding and management of the system.\nFigure 5.2.1.2-1: Attribute notation\nAn attribute name shall use the LCC style.\nWell Known Abbreviation (WKA) is treated as a word if used in a name. However, WKA shall be used as is (its letter case cannot be changed) except when it is the first word of a name; and if so, its first letter must be in lower case.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.1.1-1: Attribute properties defining valid attribute values",
                                    "table number": 1,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.1.1-2: Attribute properties defining valid interactions with attributes",
                                    "table number": 2,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.1.1-3: Attribute properties related to the specification of attributes",
                                    "table number": 3,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.2.2\tAssociation relationship",
                            "text_content": "It shows a relationship between two classes and describes the reasons for the relationship and the rules that might govern that relationship.\nIt has ends. Its end, the association end(s), specifies the role that the object at one end of a relationship performs. Each end of a relationship has properties that specify the role (see 5.2.9), multiplicity (see 5.2.8), visibility and navigability (see the arrow symbol used in Figure 5.2.2.2-2: Unidirectional association relationship notation) and may have constraints. Note that visibility shall not be used in models based on this Repertoire (see bullet 3 of 5.2).\nSee 7.3.3 Association of [2].\nThree examples below show a binary association between two model elements. The association can include the possibility of relating a model element to itself.\nThe first example (Figure 5.2.2.2-1) shows a bi-directional navigable association in that each model element has a pointer to the other. The second example (Figure 5.2.2.2-2) shows a unidirectional association (shown with an open arrow at the target model element end) in that only the source model element has a pointer to the target model element and not vice-versa. The third example (Figure 5.2.2.2-3) shows a bi-directional non-navigable association in that each model element does not have a pointer to the other; i.e., such associations are just for illustration purposes.\nAn association shall have an indication of cardinality (see 5.2.8).\nIt shall, except the case of non-navigable association, have an indication of the role name (see 5.2.9). The model element involved in an association is said to be \"playing a role\" in that association. The role has a name such as aClass in the first example below. Note that the use of \"+\" character in front of the role name, indicating  visibility, is optional.\nThe figure depicts a bidirectional association relationship notation, which is a graphical representation of the association between two entities. It is used to represent the relationship between two entities in a network, such as a router or a switch, where one entity is connected to the other. The figure shows the direction of the association, with arrows indicating the direction of the connection. The figure is used to understand the flow of data between two entities in a network, and to identify any potential issues or conflicts that may arise.\nFigure 5.2.2.2-1: Bidirectional association relationship notation\nThe figure depicts a unidirectional association relationship notation, which is a visual representation of the relationship between two entities. It is used to describe the flow of information or data between two systems or processes. The figure shows a series of arrows, each representing a step in the process, and the labels on the arrows indicate the direction of the flow. This notation is commonly used in network design and analysis to understand the flow of data and to identify potential bottlenecks or inefficiencies.\nFigure 5.2.2.2-2: Unidirectional association relationship notation\nThe figure depicts a non-navigable association relationship notation, which is a visual representation of the relationships between different entities in a network. It is used to represent the connections between nodes in a network, showing the paths that data can take between them. The figure shows the different types of associations, such as direct, indirect, and transitive, and the different levels of the network hierarchy, including the root, leaf, and intermediate nodes. The figure is used to analyze the network structure and understand the relationships between different entities, which is important for network design and management.\nFigure 5.2.2.2-3: Non-navigable association relationship notation\nNote that some tools do not use arrows in the UML graphical representation for bidirectional associations. Therefore, absence of the two arrows is not an indication of a non-navigable association between the two Information Object Class involved; but the absence of the attributes related to role in the two Information Object Class involved is an indication.\nAn Association can have a name. Use of Association name is optional. Its name style is LCC style.\nA role name shall use the LCC style.\nNOTE:\tThe role name needs not resemble the class name.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.3\tAggregation association relationship",
                            "text_content": "It shows a class as a part of or subordinate to another class.\nAn aggregation is a special type of association in which objects are assembled or configured together to create a more complex object. Aggregation protects the integrity of an assembly of objects by defining a single point of control called aggregate, in the object that represents the assembly.\nSee 7.3.2 AggregationKind (from Kernel) of [2].\nA hollow diamond attached to the end of a relationship is used to indicate an aggregation. The diamond is attached to the class that is the aggregate. The aggregation association shall have an indication of cardinality at each end of the relationship (see 5.2.8).\nThe figure depicts the aggregation association relationship notation, which is a visual representation of the relationships between different entities in a network. It shows how different types of entities, such as nodes, links, and services, are connected and how they interact with each other. This notation is used to understand the network's structure and to identify potential problems or inefficiencies.\nFigure 5.2.3.2-1: Aggregation association relationship notation\nAn Association can have a name. Use of Association name is optional. Its name style is LCC.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.4\tComposite aggregation association relationship",
                            "text_content": "A composite aggregation association is a strong form of aggregation that requires a part instance be included in at most one composite at a time. If a composite is deleted, all of its parts are deleted as well.\nA composite aggregation shall contain a description of its use.\nSee 7.3.3 Association (from Kernel) of [2].\nA filled diamond attached to the end of a relationship is used to indicate a composite aggregation. The diamond is attached to the class that is the composite. The composite association shall have an indication of cardinality at each end of the relationship (see 5.2.8).\nThe figure depicts a composite aggregation association relationship notation, which is a visual representation of the relationships between different components in a network. It shows how different types of devices, such as switches, routers, and servers, are interconnected and how they communicate with each other. The figure is used to understand the network architecture and to design and optimize network configurations.\nFigure 5.2.4.2-1: Composite aggregation association relationship notation\nAn Association can have a name. Use of Association name is optional. Its name style is LCC.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.5\tGeneralization relationship",
                            "text_content": "It indicates a relationship in which one class (the child) inherits from another class (the parent).\nSee 7.3.20 Generalization of [2].\nThis example shows a generalization relationship between a more general model element (the Top) and a more specific model element (the NetworkSliceSubnet) that is fully consistent with the first element and that adds additional information.\nThe figure depicts a generalized relationship notation for the generalization of a relationship between two variables. It illustrates the relationship between the two variables, with arrows indicating the direction of the relationship. The figure is used to represent the relationship between two variables in a mathematical or logical context.\nFigure 5.2.5.2-1: Generalization relationship notation\nIt has no name so there is no name style.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.6\tDependency relationship",
                            "text_content": "\"A dependency is a relationship that signifies that a single or a set of model elements requires other model elements for their specification or implementation. This means that the complete semantics of the depending elements is either semantically or structurally dependent on the definition of the supplier element(s)...\", an extract from 7.3.12 Dependency of [2].\nThis example shows that the BClass instances have a semantic relationship with the AClass instances. It indicates a situation in which a change to the target element (the AClass in the example) will require a change to the source element (the BClass in the example) in the dependency.\nThe figure depicts a dependency relationship notation, which is a visual representation of the relationships between different components in a system. It shows the dependencies between different components, such as the input, output, and intermediate components. The figure is used to understand the flow of information and the relationships between different components in a system.\nFigure 5.2.6.2-1: Dependency relationship notation\nA Dependency can have a name. Use of Dependency name is optional. Its name style is LCC.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.7\tComment",
                            "text_content": "A comment is a textual annotation that can be attached to a set of elements.\nSee 7.3.9 Comment (from Kernel) from [2].\nThis example shows a comment, as a rectangle with a \"bent corner\" in the upper right corner. It contains text. It appears on a particular diagram and may be attached to zero or more modelling elements by dashed lines.\nThe figure depicts a comment notation for a specific type of data, which is a crucial aspect of data analysis and communication.\nFigure 5.2.7.2-1: Comment notation\nIt has no name so there is no name style.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.8\tMultiplicity, a.k.a. cardinality in relationships",
                            "text_content": "\"A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending with a (possibly infinite) upper bound. A multiplicity element embeds this information to specify the allowable cardinalities for an instantiation of this element…\", an extract from 7.3.32 MultiplicityElement of [2].\nTable 5.2.8.1-1: Multiplicity-string definitions\nThe use of \"0..n\" is not recommended although it has the same meaning as \" 0..* \" and \" *\".\nThe use of a standalone symbol zero (0) is not allowed.\nThis example shows a multiplicity attached to the end of an association path. The meaning of this multiplicity is one to many. One Class1 instance is associated with zero or more  Class2 instances. Other valid examples can show the “many to many” relationship.\nThe figure depicts a cardinality notation for a 5G network, illustrating the number of base stations (BSs) and user equipment (UE) in a 5G network. The diagram shows the distribution of BSs and UE across different locations, highlighting the importance of network coverage and capacity planning.\nFigure 5.2.8.2-1: Cardinality notation\nThe cardinality zero is not used to indicate the IOC’s so-called “transient state” characteristic. For example, it is not used to indicate that the instance is not yet created but it is in the process of being created. The cardinality zero will not be used to indicate this characteristic since such characteristic is considered inherent in all IOCs. All IOCs defined are considered to have such inherent “transient state” characteristics.\nThe following table shows some valid examples of multiplicity.\nTable 5.2.8.2-1: Multiplicity-string examples\n\nIt has no name so there is no name style.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.8.1-1: Multiplicity-string definitions",
                                    "table number": 4,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.2.8.2-1: Multiplicity-string examples",
                                    "table number": 5,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.2.9\tRole",
                            "text_content": "It indicates navigation, from one class to another class, involved in an association relationship. A role is named. The direction of navigation is to the class attached to the end of the association relationship with (or near) the role name.\nThe use of role name in the graphical representation is optional for bidirectional and unidirectional association relationship notations (see Figure 5.2.2.2-1: Bidirectional association relationship notation and Figure 5.2.2.2-2: Unidirectional association relationship notation). Role name shall not be used in non-navigable association relationship notation (see Figure 5.2.2.2-3: Non-navigable association relationship notation).\nA role at the navigable end of a relationship becomes (or is mapped into) an attribute (called role-attribute) in the source class of the relationship. Therefore, roles have the same behaviour (or properties) as attributes. See Table 5.2.1.1-1: Attribute properties.\nTo avoid clutter in UML diagram, the role names can be removed.\nThe role-attribute shall have all properties defined for attributes in subclause 5.2.1 Attribute and in addition the following property\nTable 5.2.9.1-1: passedById property\n:\nThis example shows that a Person (say instance John) is associated with a Company (say whose DN is “Company=XYZ”). We navigate the association by using the opposite association-end such that John’s Person.company would hold the DN, i.e. \"Company=XYZ\".\nThe figure depicts a role notation for a 5G network, illustrating the various roles and their corresponding responsibilities. The diagram includes a base station (gNB), user equipment (UE), and scatterers, highlighting the importance of each component in the network's operation. The figure also illustrates the use of beamforming techniques to mitigate interference, emphasizing the importance of signal quality in a 5G network.\nFigure 5.2.9.2-1: Role notation\nA role has a name. Use a noun for the name. The name style follows the attribute name style; see subclause 5.2.1.3.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.9.1-1: passedById property",
                                    "table number": 6,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.2.10\tXor constraint",
                            "text_content": "“A Constraint represents additional semantic information attached to the constrained elements. A constraint is an assertion that indicates a restriction that must be satisfied by a correct design of the system. The constrained elements are those elements required to evaluate the constraint specification…“, an extract from 7.3.10 Constraint (from Kernel) of [2].\nFor a constraint that applies to two elements such as two associations, the constraint shall be shown as a dashed line between the elements labeled by the constraint string (in braces). The constraint string, in this case, is xor.\nThe figure below shows a ServerObjectClass instance that has relation(s) to multiple instances of a class from the choice of ClientObjectCLass_Alternative1, ClientObjectClass_Alternative2 or ClientObjectCLass_Alternative3.\nThe figure depicts a 2-10-2-1 XOR notation, which is a mathematical representation of a binary number. The XOR operation is a binary operation that returns the value of the first operand if the second operand is 0, and the value of the second operand if the first operand is 0. The figure is used to illustrate the concept of XOR in binary mathematics.\nFigure 5.2.10.2-1: {xor} notation\nIt has no name so there is no name style.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.11\tLifecycleStatus",
                            "text_content": "Model elements may have a life-cycle. They are created, updated, become obsolete and may be removed. The lifecycleStatus property indicates this. LifecycleStatus is applicable to attributes, data types, IOCs operations and notifications.\nTable 5.2.A.1-1: lifecycleStatus property\n\nWhen removal or a non backwards compatible change is needed for a model element, it shall be kept in the specification as-is but be marked as deprecated for one release. The deprecated element may be removed in the next release.\nA new replacing model element may be defined beside the original. In this case the replacing element shall be indicated in the specification of the old element.\nImplementations of the previous release that now implement the current release shall continue to support usage of the deprecated attributes/classes as well as any new replacing attributes/classes, but not at the same time. As soon as the newer (replacing) attributes/classes are used, it may no longer be possible to also support usage of the deprecated elements or show correct values for the deprecated attributes. (E.g. when the type of an attribute is changed from integer to string). Once the replacing attribute/IOC is used, the old attribute/IOC may lose functionality and should not be used anymore.\nIn case the deprecated or the replacing element was or is intended to have a multiplicity strictly greater than zero (mandatory to configure/report), the model elements should be declared with a multiplicity including zero, as only one of the deprecated and the replacement elements will be used at any one time.\nThe deprecating procedure shall be used between releases. There is no need to follow it during the development of a single release, as long as the release is not yet frozen.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.A.1-1: lifecycleStatus property",
                                    "table number": 7,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "5.3\tStereotype",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.3.0\tDescription",
                            "text_content": "Subclause 5.1 listed the UML defined basic model elements. UML defined a stereotype concept allowing the specification of simple or complex user-defined model elements.\nThis subclause lists all allowable stereotypes for this repertoire.\nThe names of stereotypes shall be chosen such that they do not clash.\nFor each stereotype model element listed, there are three parts. The first part contains its description. The second part contains its graphical notation examples and the third part contains the rule, if any, recommended for labelling or naming it.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.1\t<<ProxyClass>>",
                            "text_content": "It is a form or template representing a number of <<InformationObjectClass>>. It encapsulates attributes, links, methods (or operations), and interactions that are present in the represented <<InformationObjectClass>>.\nThe semantics of a <<ProxyClass>> is that all behaviour of the <<ProxyClass>> is present in the represented <<InformationObjectClass>>. Since this class is simply a representation of other classes, this class cannot define its own behaviour other than those already defined by the represented <<InformationObjectClass>>.\nA particular <<InformationObjectClass>> can be represented by zero, one or more <<ProxyClass>>. For example, the ManagedElement <<InformationObjectClass>> can have MonitoredEntity <<ProxyClass>> and ManagedEntity <<ProxyClass>>.\nThe attributes of the <<ProxyClass>> are accessible by the source entity that has an association with the <<ProxyClass>>.\nThis shows a <<ProxyClass>> named MonitoredEntity. It represents (or its constraints is that it represents) all NRM <<InformationObjectClass>> (e.g. GgsnFunction <<InformationObjectClass>>) whose instances are being monitored for alarm conditions. It is mandatory to use a Note to capture the constraint.\nThe figure depicts a proxy class notation, which is a method used in software development to represent a class in a way that is easy to understand and maintain. The figure shows a class with a name, a type, and a method, with the method being a method of the class. The method is a method of the class, which is a method of the class, and so on. This notation is useful for understanding the structure of a class and for writing code that uses the class.\nFigure 5.3.1.2-1: <<ProxyClass>> notation\nSee Annex A for more examples that use <<ProxyClass>>.\nFor <<ProxyClass>> name, use the same style as <<InformationObjectClass>> (see 5.3.2).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.2\t<<InformationObjectClass>>",
                            "text_content": "The <<InformationObjectClass>> is identical to UML class except that it does not include/define methods or operations.\nA UML class represents a capability or concept within the system being modelled. Classes have data structure and behaviour and relationships to other elements.\nThis class can inherit from zero, one or multiple classes (multiple inheritances).\nSee more on UML class in 10.2.1 of [1].\nThis example shows an AbcFunction <<InformationObjectClass>>.\nThe figure depicts a complex network structure, specifically a 5G network, with various components such as base stations (gNB), user equipment (UE), and scatterers. The diagram illustrates the signal propagation in a 5G network, highlighting the multi-path signal path and beamforming techniques to mitigate interference. The figure also shows the fiber-optic backbone architecture, with core switches, optical line terminals (OLTs), and distributed nodes. The layered design aligns with SDN principles, emphasizing redundancy and failover reliability.\nFigure 5.3.2.2-1: <<InformationObjectClass>> notation\nThe following table captures the properties of this modelled element.\nTable 5.3.2.2-1: <<InformationObjectClass>> properties\n\nThe name shall use UCC style. The name shall end with an underscore if it is an abstract class in the UIM. The name must not end with an underscore if it is a concrete class.\nWKA is treated as a word if used in a name. However, WKA shall be used as is (its letter case cannot be changed) except when it is the first word of the name; and if so, its first letter must be in upper case.\nEmbedded underscore is not allowed except the name is for an Association class (see 5.4.1.)\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.3.2.2-1: <<InformationObjectClass>> properties",
                                    "table number": 8,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.3.3\t<<names>>",
                            "text_content": "The <<names>> is modelled by a composite association where both ends are non-navigable. The source class is the composite and the target class is the component. The target instance is uniquely identifiable, within the namespace of the source entity, among all other targeted instances of the same target class and among other targeted instances of other classes that have the same <<names>> composition with the source.\nThe source class and target class shall each has its own naming attribute.\nThe composite aggregation association relationship is used as the act of name containment providing a semantic of a whole-part relationship between the domain and the named elements that are contained, even if only by name. From the management perspective access to the part is through the whole. Multiplicity shall be indicated at both ends of the relationship.\nA target instance cannot have multiple <<names>> with multiple source instances s, i.e. a target instance can not participate in or belong to multiple namespaces.\nThis shows that all instances of Class4 are uniquely identifiable within a Class3 instance's namespace.\nThe given telecommunication figure, labeled as \"Figure 5.3.3.2-1: <<names>> notation\", depicts a complex network diagram with various elements such as nodes, lines, and symbols. The figure is used to represent the network's structure and components, including the names of the nodes and lines. The \"<<names>>\" notation is used to represent the network's topology, with each node having a unique identifier and line connecting them. The figure is essential for understanding the network's structure and for designing and implementing network protocols.\nFigure 5.3.3.2-1: <<names>> notation\nIt has no name so there is no name style.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.4\t<<dataType>>",
                            "text_content": "It represents an attribute property type (see Table 5.2.1.1-1: Attribute properties).\n\nThis repertoire uses two kinds of data types: predefined data types and user-defined data types. The former is defined in subclause 5.4.3. The latter is defined by the specification by authors using a <<dataType>> model element.\nThe names of predefined data types and user-defined data types must be chosen such that they do not clash.\nUser-defined data types can be simple types containing one or more values of a single simple type like integer or string or they can be structured types containing one or more named attribute fields each having properties similar to an attribute as described in table 5.2.1.1-1. The individual attribute fields may have different property values e.g., different types, multiplicity or supportQualifier. A named attribute field itself can be of a simple or a structured data type.\nStructured data types could be embedded in any depth; however, they should not be embedded more than 3 levels, that is attribute-structuredType-structuredType-structuredType-simpletype. Reasons for avoiding deep embedding of structured types include:\n- Any construct that would be modeled by such deep structures can be modeled partly of fully by IOCs instead, thus avoiding deep structures.\n- It is difficult to understand deep structured types, it is hard to follow their \"type containment\".\n- Addressing in most contexts is based on Distinguished Names which does not allow addressing individual attribute fields.\n- Filtering of attribute fields becomes complex.\n- Usability problems on any human interface (GUI, CLI).\nThe user-defined data types support the modelling of structured data types (see <<dataType>> PLMNId in 5.3.4.2).\nWhen an attribute is of a structured data type, attribute properties may be declared on multiple levels: declared for the attribute as a whole and also for each attribute field. As an attributed field itself may be of a structured data type, properties may be declared on 2, 3 or more levels.\n\"Documentation” is relevant on the attribute or attribute field level where it is declared. Properties \"multiplicity\", \"isOrdered\", \"isUnique\", \"type\" and \"allowedValues\" are always relevant and should be enforced on the attribute or attribute field level where they are declared.\nThe property \"supportQualifier\" always applies to the level where it is declared. However, the support for a model element is always conditional on the support of the higher level. E.g., if an attribute is optional but one of its fields is mandatory, that means the field is mandatory if the attribute itself is supported; if the attribute is not supported this results in none of its fields(subparts) being supported.\nFor properties \"isReadable\", \"isWritable\", \"isNotifyable\" the following rules apply:\n- If a structured attribute specifies the property as False then the False value shall be used for the attribute and all its (descendant) attribute fields (if any).\n- If a structured attribute specifies the property as True then the True value shall be used for the attribute and all its (descendant) attribute fields if and only if True is also specified for all of them.\n- If a structured attribute specifies the property as True then the True value shall be used for the attribute and all its (descendant) attribute fields until a False value is specified for an attribute field. This attribute field and all (descendant) attribute fields shall have a False value.\nFor the \"isInvariant\" property the following rules apply:\n- If a structured attribute specifies the property as True then the True value shall be used for the attribute and all its (descendant) attribute fields (if any).\n- If a structured attribute specifies the property as False then the False value shall be used for the attribute and all its (descendant) attribute fields if and only if False is also specified for all of them.\n- If a structured attribute specifies the property as False then the False value shall be used for the attribute and all its (descendant) attribute fields until a True value is specified for an attribute field. This attribute field and all (descendant) attribute fields shall have a True value.\nIf an attribute has the property lifecycleStatus=Deprecated all its fields are are also deprecated. If a data type has property lifecycleStatus=Deprecated all its fields (subparts) are also deprecated.\nWhen a user-defined or predefined data type is used to apply type (see property named type in Table 5.2.1.1-1: Attribute properties) information to a class attribute, the data type name is shown along with the class attribute. See Example below.\nWhen an attribute/field is defined with a datatype the relationship between them can be optionally established in the UML relationship diagram, e.g. for deeply nested datatypes.  The relationship is shown as a relationship in the diagram between the parent attribute/field name and the datatype.  The line includes the attribute/field.  These diagrams shall be limited to one class and associated datatypes.\nThe following examples are two user-defined data types.\nThe left-most user-defined data type is named PLMNId. It has two attributes. One is the Mobile Country Code (MCC) of predefined data type String. The other is the Mobile Network Code (MNC) of predefined data type String as well.\nThe right-most user-defined data type is named Xyz. It has three attributes. The attribute1 uses predefined data type String. The attribute2 uses predefined data type Integer. The attribute3 uses user-defined data type PLMNId.\n\nThe figure depicts a set of <<dataType>> notations, which are used to represent different types of data in a structured format. The notations are organized in a hierarchical manner, with each type of data represented by a distinct set of symbols. This allows for easy identification and manipulation of the data, making it a valuable tool for data analysis and management.\nFigure 5.3.4.2-1: <<dataType>> notations\nThe following example shows a ZClass which has four attributes. Two attributes (i.e. attribute1, attribute4) use the user-defined data types (i.e. PLMNId, Xyz) and the other two attributes use the predefined data types.\nThe figure depicts a usage example of the <<dataType>>, which is a type of data structure used in the context of the telecommunication industry. The figure illustrates the structure and usage of the <<dataType>>, including its properties and methods.\nFigure 5.3.4.2-2: Usage example of <<dataType>>\nThe third column of the following shows some of the properties of an attribute attribute1 of ZClass. It shows the attribute1 attribute property type is PLMNId, a user-defined data type.\n\nFor <<dataType>> name, use the same style as <<InformationObjectClass>> (see 5.3.2).\nFor <<dataType>> attribute, use the same style as Attribute (see 5.2.1).\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "The third column of the following shows some of the properties of an attribute attribute1 of ZClass. It shows the attribute1 attribute property type is PLMNId, a user-defined data type.",
                                    "table number": 9,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.3.5\t<<enumeration>>",
                            "text_content": "An enumeration is a data type. It contains sets of named literals that represent the values of the enumeration. An enumeration has a name.\nSee 10.3.2 Enumeration of [1].\nThis example shows an enumeration model element whose name is Account and it has four enumeration literals. The upper compartment contains the keyword <<enumeration>> and the name of the enumeration. The lower compartment contains a list of enumeration literals.\nNote that the symbol to the right of <<enumeration>> Account in the figure below is a feature specific to a particular modelling tool. It is recommended that modelling tool features should be used when appropriate.\nThe figure depicts a 5G network with various elements such as base stations (gNB), user equipment (UE), and scatterers. It illustrates the signal propagation in a 5G network, highlighting the importance of beamforming techniques to mitigate interference. The figure also shows the fiber-optic backbone architecture, with core switches, optical line terminals (OLTs), and distributed nodes. The layered design aligns with SDN principles, emphasizing the importance of redundancy and failover reliability.\nFigure 5.3.5.2-1: <<enumeration>> notation\nFor <<enumeration>> name, use the same style as <<InformationObjectClass>> (see 5.3.2).\nFor <<enumeration>> attribute (the enumeration literal), use the following rules:\n\tEnumeration literal is composed of one or more words of upper case characters. Words are separated by the underscore character.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.6\t<<choice>>",
                            "text_content": "The «choice» stereotype represents one of a set of classes (when used as an information model element) or one of a set of data types (when used as an operation model element).\nThis stereotype property, e.g., one out of a set of possible alternatives, is identical to the {xor} constraint (see 5.2.10).\nSometimes the specific kind of class cannot be determined at model specification time. In order to support such scenario, the specification is done by listing all possible classes.\nThe following diagram lists 3 possible classes. It also shows a «choice» named SubstituteObjectClass. This scenario indicates that only one of the three related «InformationObjectClass» named Alternative1ObjectClass, Alternative2ObjectClass, Alternative3ObjectClass shall be realised.\nThe «choice» stereotype represents one of a set of classes when used as an information model element.\nThe figure depicts a simplified information model example using choice notation, illustrating the concept of a choice model. The model includes a set of choices (e.g., \"Option A\" and \"Option B\") and their corresponding outcomes (e.g., \"Option A\" has a probability of 0.5 and \"Option B\" has a probability of 0.5). The figure demonstrates how the outcomes of the choices are related to each other, and how the model can be used to represent complex decision-making processes.\nFigure 5.3.6.2-1: Information model element example using «choice» notation\nSometimes the specific kind of data type cannot be determined at model specification time. In order to support such scenario, the specification is done by listing all possible data types.\nThe following diagram lists 2 possible data types. It also shows a «choice» named ProbableCause. This scenario indicates that only one of the two «dataType» named IntegerProbableCause, StringProbableCause shall be realised.\nThe «choice» stereotype represents one of a set of data types when used as an operations model element.\nThe figure depicts a simplified representation of the operations model element in the OPC UA protocol, specifically focusing on the choice notation. The element is used to specify the choice of a specific operation, which is crucial for defining the behavior of a device or system. The figure includes various elements such as the choice element, the operation element, and the choice element, which are used to define the choice of an operation. The figure also includes a description of the choice element, which is used to specify the choice of an operation. The figure is a useful tool for understanding the OPC UA protocol and its operations model.\nFigure 5.3.6.2-2: Operations model element example using «choice» notation\nFor <<choice>> name, use the same style as <<InformationObjectClass>> (see 5.3.2).\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.4\tOthers",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.4.1\tAssociation class",
                            "text_content": "An association class is an association that also has class properties (or a class that has association properties).\nEven though it is drawn as an association and a class, it is really just a single model element.\nSee 7.3.4 AssociationClass of [2].\nAssociation classes are appropriate for use when an «InformationObjectClass» needs to maintain associations to several other instances of «InformationObjectClass» and there are relationships between the members of the associations within the scope of the \"containing\" «InformationObjectClass». For example, a namespace maintains a set of bindings, a binding ties a name to an identifier. A NameBinding «InformationObjectClass» can be modelled as an Association Class that provides the binding semantics to the relationship between an identifier and some other «InformationObjectClass» such as Object in the figure. This is depicted in the following figure.\nThe figure depicts the association class notation for a 5G network, illustrating the hierarchical structure of the network. It shows the different classes of associations, such as base stations (BSs), user equipment (UE), and scatterers, and their respective roles in the network. The figure also highlights the use of beamforming techniques to mitigate interference and improve signal quality.\nFigure 5.4.1.2-1: Association class notation\nThe name shall use the same style as in <<InformationObjectClass>> (see 5.3.2.3).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.4.2\tAbstract class",
                            "text_content": "It specifies a special kind of <<InformationObjectClass>> as the general model element involved in a generalization relationship (see 5.2.5). An abstract class cannot be instantiated.\nThis modelled element has the same properties as class. See 5.3.2.\nThis shows that Class5_ is an abstract class. It is the base class for SpecializedClass5.\nThe figure depicts abstract class notation, which is a visual representation of the structure and relationships of an abstract class in a programming language. It is used to represent the inheritance hierarchy of classes in an object-oriented programming environment. The figure shows the relationships between classes, such as the relationship between the abstract class and its subclasses, and the relationship between the subclasses themselves. The figure is a useful tool for understanding the structure of an abstract class and its subclasses in a programming context.\nFigure 5.4.2.2-1: Abstract class notation\nFor abstract class name, use the same style as <<InformationObjectClass>> (see 5.3.2) . The name shall be in italics. In the UOM, its last character shall be an underscore\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.4.3\tPredefined data types",
                            "text_content": "It represents the general notion of being a data type (i.e. a type whose instances are identified only by their values) whose definition is defined by this specification and not by the user (e.g. specification authors).\nThis repertoire uses two kinds of data types: predefined data types and user-defined data types.  The latter is defined in 5.3.4 <<dataType>> and 5.3.5 <<enumeration>>.\nThe following table lists the UML data types selected for use as predefined data type.\nTable 5.4.3.1-1: UML defined data types\n\nThe following table lists data types that are defined by this repertoire.\nTable 5.4.3.1-2: Non-UML defined data types\n\nThe figure depicts a comprehensive overview of predefined data types usage in a 5G network, illustrating how various data types are utilized for different purposes, such as data transmission, data storage, and data processing. The figure includes a detailed breakdown of each data type, highlighting its significance in the 5G network architecture.\nFigure 5.4.3.2-1: Predefined data types usage\nNOTE: Use of predefined data types is optional. Use of other means, to specify predefined data types, is allowed.\nIt shall use the UCC style.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.4.3.1-1: UML defined data types",
                                    "table number": 10,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.4.3.1-2: Non-UML defined data types",
                                    "table number": 11,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "title": "6\tQualifiers",
            "description": "This subclause defines the qualifiers applicable for model elements specified in this document, e.g. the IOC (see 5.3.2), the Attribute (see 5.2.1). The possible qualifications are M, O, CM, CO and C. Their meanings are specified in this subclause. This type of qualifier is called Support Qualifier (see supportQualifier of IOC in Table 5.3.2.2-1 and supportQualifier of attribute in Table 5.2.1.1-1).\nThis subclause also defines the qualifiers applicable to various properties of a model element, e.g. see the IOC properties excepting IOC supportQualifier in Table 5.3.2.2-1 and attributes properties excepting attribute supportQualifier in Table 5.2.1.1-1. The possible qualifications are M, O, CM, CO and \" -\" . Their meanings are specified in this subclause. This type of qualifier is simply called Qualifier.\nDefinition of M (Mandatory) qualification:\n\tThe capability (e.g. the Attribute named abc of an IOC named Xyz; the write property of Attribute named abc of an IOC named Xyz; the IOC named Xyz) shall be supported.\nDefinition of O (Optional) qualification:\n\tThe capability may or may not be supported.\nDefinition of CM (Conditional-Mandatory) qualification:\n\tThe capability shall be supported under certain conditions, specifically:\n-\tWhen the qualification is CM, the capability shall have a corresponding constraint defined in the specification. If the specified constraint is met then the capability shall be supported.\n\tDefinition of CO (Conditional-Optional) qualification:\n-\tThe capability may be supported under certain conditions, specifically:\n-\tWhen the qualification is CO, the capability shall have a corresponding constraint defined in the specification. If the specified constraint is met then the capability may be supported.\nDefinition of C (Conditional) qualification:\n-\tUsed for items that has multiple constraints. Each constraint is worded as a condition for one kind of qualification such as M, O or \"-\". All constraints must be related to the same qualification. Specifically:\n-\tEach item having the support qualifier C shall have the corresponding multiple constraints defined in the IS specification. If the specified constraint is met and is related to mandatory, then the item shall be supported. If the specified constraint is met and is related to optional, then the item may be supported. If the specified constraint is met and is related to \"no support\", then the item shall not be supported.\nNOTE: This qualification should only be used when absolutely necessary, as it is more complex to implement.\nDefinition of SS (SS Conditional) qualification:\n\tThe capability shall be supported by at least one but not all solutions.\nDefinition of \" -\"  (no support) qualification:\n\tThe capability shall not be supported.\nNote that, in this clause, the term \"support\" refers to the support of standardized model elements by a specific implementation or instance of an agent. It cannot be assumed that unsupported standardized model elements are known to the agent. How an implementation is expected to treat unsupported standardized model elements is not specified, and the behaviour would likely be same as for other unknown or errant model elements.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "7\tUML Diagram Requirements",
            "description": "Classes and their relationships shall be presented in class diagrams.\nIt is recommended to create:\n\tAn overview class diagram containing all object classes related to a specific management area (Class Diagram).\n\tThe class name compartment should contain the location of the class definition (e.g., \"Qualified Name\")\n\tThe class attributes should show the \"Signature\". (see subclause 7.3.44 of [2] for the signature definition);\n\tA separate inheritance class diagram in case the overview diagram would be overloaded when showing the inheritance structure (Inheritance Class Diagram);\n\tA class diagram containing the user defined data types (Type Definitions Diagram);\n\tAdditional class diagrams to show specific parts of the specification in detail;\n\tState diagrams for complex state attributes.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "A.1\tFirst Example",
            "description": "This shows a <<ProxyClass>> named YyyFunction. It represents all IOCs listed in the Note under the UML diagram. All the listed IOCs, in the context of this example, inherit from ManagedFunction IOC.\nThe use of <<ProxyClass>> eliminates the need to draw multiple UML <<InformationObjectClass>> boxes, i.e. those whose names are listed in the Note, in the UML diagram.\nThe figure depicts a proxy class notation example, showing the structure of a proxy class in the context of a web application. The figure includes a header, a body, and a footer, with the header containing the class name and the body containing the method and parameter definitions. The footer includes the class name, the method name, and the parameter name. The figure is used to illustrate the structure of a proxy class in a web application, providing a clear and concise visual representation of the class's components.\nFigure A.1-1: <<ProxyClass>> Notation Example A.1\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "A.2\tSecond Example",
            "description": "This shows a <<ProxyClass>> named YyyFunction. It represents all IOCs listed in the attached (or associated) Note.  All the listed IOCs, in the context of this example, have link (internal and external) relations.\nThis shows a <<ProxyClass>> InternalYyyFunction. It represents all IOCs listed in the attached (or associated) Note.\nThis shows a <<ProxyClass>> Link_a_z and ExternalLink_a_z. They represent all IOCs listed in the attached (or associated) Note.\nThe figure depicts a proxy class notation example, showing the structure of a proxy class in the context of a web application. The figure includes a diagram of the proxy class, its attributes, and relationships with other classes. The proxy class is a crucial component in web application development, allowing for the creation of dynamic and reusable code.\nFigure A.2-1: <<ProxyClass>> Notation Example A.2\n\n\nTable B.1 shows the impact of the \"isWritable\", \"defaultValue\" and \"multiplicity\" attribute properties on the behavior of managers and agents upon object creation, and on attribute values directly after object creation. See clause 3.1 for decription of manager and agent.\nTable B.1: Attribute properties\n\n",
            "summary": "",
            "tables": [
                {
                    "description": "Table B.1: Attribute properties",
                    "table number": 12,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.1\tIntervening class and Association class",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "C.1.1\tConcept and definition",
                    "description": "",
                    "summary": "",
                    "text_content": "Classes may be related via simple direct associations or via associations with related association classes.\nHowever, in situations where the relationships between a number of classes is complex and especially where the relationships between instances of those classes are themselves interrelated there may be a need to encapsulate the complexity of the relationships within a class that sits between the classes that are to be related. The term “intervening class” is used here to name the pattern that describes this approach. The name “intervening class” is used as the additional class “intervenes” in the relationships between other classes.\nThe “intervening class” differs from the association class as the intervening class does break the association between the classes where as the association class does not but instead sits to one side. This can be seen in the following figure. A direct association between class A and C appears the same at A and C regardless of the presence or absence of an association class where as in the case of the “intervening class” there are associations between A and the “intervening class” B and C and the “intervening class” B.\nThe figure depicts various association forms used in the telecommunication industry, including point-to-point, point-to-multipoint, and point-to-multipoint with a single-hop. It highlights the importance of proper network design and management to ensure efficient and reliable communication.The figure depicts various association forms used in the telecommunication industry, including point-to-point, point-to-multipoint, and point-to-multipoint with a single-hop. It highlights the importance of proper network design and management to ensure efficient and reliable communication.The figure depicts various association forms used in the telecommunication industry, including point-to-point, point-to-multipoint, and point-to-multipoint with a single-hop. It highlights the importance of proper network design and management to ensure efficient and reliable communication.The figure depicts various association forms used in the telecommunication industry, including point-to-point, point-to-multipoint, and point-to-multipoint with a single-hop. It highlights the importance of proper network design and management to ensure efficient and reliable communication.\nFigure C.1.1-1: Various association forms\nThe “intervening class” is essentially no different to any other class in that it may encapsulate attributes, complex behaviour etc.\nThe following figure shows an instance view of both an association class form and an “intervening class” form for a complex interrelationship\nThe figure depicts a class instance view, showing the interception of a class instance by an adversary. The adversary is represented by a red circle, while the class instance is represented by a blue square. The figure illustrates the concept of class instance interception, where an adversary can intercept a class instance by exploiting the class instance's attributes. The figure is a visual representation of the concept, providing a clear and concise explanation of the concept.The figure depicts a class instance view, showing the interception of a class instance by an adversary. The adversary is represented by a red circle, while the class instance is represented by a blue square. The figure illustrates the concept of class instance interception, where an adversary can intercept a class instance by exploiting the class instance's attributes. The figure is a visual representation of the concept, providing a clear and concise explanation of the concept.\nFigure C.1.1-2: Instance view of \"intervening class\"\nThe case depicted above does not show interrelationships between the relationships. A practical case from modeling of the relationships between Termination Points in a fixed network does show this relationship interrelationship challenge. In this case the complexity of relationship is between instances of the same class, the Termination Point (TP). The complexity is encapsulated in a SubNetworkConnection (SNC) class.\nThe figure depicts a network scenario where a SNC (Switching Network Controller) is involved in the TP-TP (Time-Division-Tandem) relationship. The SNC is responsible for managing the network's switching functions, ensuring efficient and reliable communication between different network segments. The figure illustrates the SNC's role in managing the network's switching functions, including the routing of packets, the prioritization of traffic, and the management of network segments. The figure also shows the SNC's interaction with other network components, such as the network manager (NMB) and the network coordinator (NC). Overall, the figure provides a visual representation of the SNC's role in managing the TP-TP relationship within the network.The figure depicts a network scenario where a SNC (Switching Network Controller) is involved in the TP-TP (Time-Division-Tandem) relationship. The SNC is responsible for managing the network's switching functions, ensuring efficient and reliable communication between different network segments. The figure illustrates the SNC's role in managing the network's switching functions, including the routing of packets, the prioritization of traffic, and the management of network segments. The figure also shows the SNC's interaction with other network components, such as the network manager (NMB) and the network coordinator (NC). Overall, the figure provides a visual representation of the SNC's role in managing the TP-TP relationship within the network.\nFigure C.1.1-3: SNC intervening in TP-TP relationship\nThe SNC also encapsulates the complex behaviour of switching and path selection as depicted below.\nThe figure depicts a complex relationship interrelationships, illustrating the intricate connections between various components and their interdependencies.\nFigure C.1.1-4: Complex relationship interrelationships\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "C.1.2\tUsage in the non-transport domain",
                    "description": "",
                    "summary": "",
                    "text_content": "The choice of association class pattern or intervening class pattern is on a case-by-case basis.\nThe transport domain boundary is highlighted in the following figure.\nThe figure depicts a boundary between transport and non-transport domains, highlighting the distinction between the two. The transport domain is characterized by the presence of a transport layer, which is responsible for data transmission and is typically located at the lower layer of the network stack. On the other hand, the non-transport domain is the upper layer of the network stack, where data is processed and stored before being sent to the next layer. This boundary is crucial for ensuring the efficient and reliable operation of the network.\nFigure C.1.2-1: Highlighting the boundary between transport and non-transport domains\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "C.1.3\tUsage in the transport domain",
                    "description": "",
                    "summary": "",
                    "text_content": "The following guidelines must be applied to the models of the “transport domain”.\nWhen considering interrelationships between classes the following guidelines should be applied:\n•\tIf considering all current and recognised potential future cases it is expected that the relationship between two specific classes will be 0..1:0..1 then a simple association should be used\n–\tThis may benefit from an association class to convey rules and parameters about the association behaviour in complex cases.\n•\tIf there is recognised potential for cases currently or in future where there is a 0..*:0..* between two specific classes then intervening classes should be used to encapsulate the groupings etc. so as to convert it to 0..1:n..*.\n–\tNote that the 0..1:n..* association may benefit from an association class to convey rules and parameters about the association behaviour in complex cases but in the instance form this can probably be ignored or folded into the intervening class\n•\tIn general it seems appropriate to use an association class when the properties on the relationship instance cannot be obviously or reasonably folded into one of the classes at either end of the association and when there is no interdependency between association instances between a set of instances of the classes.\nAn example of usage of intervening class is the case of the TP-TP (TerminationPoint) relationship (0..*:0..*) where the SNC (SubNetworkConnection) is added as the intervening class between multiple TPs, i.e. TP-SNC. Note that TP-SNC actually becomes 0..2:n..* due to directionality encapsulation.\nConsidering the case of the adjacency relationship between PTPs it is known that although the current common cases are 1:1 there are some current and many potential future case of 0..*:0..* and hence a model that has an intervening class, i.e. the TopologicalLink, should be used.\nFor a degenerate instance cases of 0..*:0..* that happens to be 0..1:0..1 the intervening class pattern should still be used:\n-\t•\tUsing the 0..1:0..1 direct association in this degenerate case brings unnecessary variety to the model and hence to the behaviour of the application (the 0..1:n..* model covers the 0..1:0..1 case  with one single code form clearly)\n-\t•\tAn instance of the 0..1:0..1 model may need to be migrated to 0..1:n..* as a result of some change in the network forcing an unnecessary administrative action to transition the model form where as in the 0..1:n..* form requires no essential change.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "C.2\tUse of “ExternalXyz” class",
            "description": "This subclause will be completed for the next release.\n\nIt is the descriptor for a set of management capabilities.\nThe <<SupportIOC>> is an extension of UML class. See Annex [F] for the differences between <<InformationObjectClass>> and <<SupportIOC>>.\nSee more on UML class in 10.2.1 of [1].\nThis sample shows an AlarmList <<SupportIOC>>.\n\n<<SupportIOC>> notation\nFor <<SupportIOC>> name, use the same style as <<InformationObjectClass>> (see subclause 5.3.2).\nThe <<InformationObjectClass>> and <<SupportIOC>> are stereotypes.  These two stereotypes serve similar purpose in that each is a named set of network resource properties.  However, their applications, in the context of supporting network management over Itf-N or through the use of management services, can be different.  This Annex highlights their similarities and differences of such application.\n\n\n\n",
            "summary": "",
            "tables": [
                {
                    "description": "The <<InformationObjectClass>> and <<SupportIOC>> are stereotypes.  These two stereotypes serve similar purpose in that each is a named set of network resource properties.  However, their applications, in the context of supporting network management over Itf-N or through the use of management services, can be different.  This Annex highlights their similarities and differences of such application.",
                    "table number": 13,
                    "summary": "",
                    "name": ""
                },
                {
                    "description": "",
                    "table number": 14,
                    "summary": "",
                    "name": ""
                },
                {
                    "description": "",
                    "table number": 15,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        }
    ]
}