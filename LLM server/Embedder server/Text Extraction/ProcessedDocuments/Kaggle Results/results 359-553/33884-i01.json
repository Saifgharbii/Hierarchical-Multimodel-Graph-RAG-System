{
    "document_name": "33884-i01.docx",
    "content": [
        {
            "title": "Foreword",
            "description": "This Technical Report has been produced by the 3rd Generation Partnership Project (3GPP).\nThe contents of the present document are subject to continuing work within the TSG and may change following formal TSG approval. Should the TSG modify the contents of the present document, it will be re-released by the TSG with an identifying change of release date and an increase in version number as follows:\nVersion x.y.z\nwhere:\nx\tthe first digit:\n1\tpresented to TSG for information;\n2\tpresented to TSG for approval;\n3\tor greater indicates TSG approved document under change control.\ny\tthe second digit is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc.\nz\tthe third digit is incremented when editorial only changes have been incorporated in the document.\nIn the present document, modal verbs have the following meanings:\nshall\t\tindicates a mandatory requirement to do something\nshall not\tindicates an interdiction (prohibition) to do something\nThe constructions \"shall\" and \"shall not\" are confined to the context of normative provisions, and do not appear in Technical Reports.\nThe constructions \"must\" and \"must not\" are not used as substitutes for \"shall\" and \"shall not\". Their use is avoided insofar as possible, and they are not used in a normative context except in a direct citation from an external, referenced, non-3GPP document, or so as to maintain continuity of style when extending or modifying the provisions of such a referenced document.\nshould\t\tindicates a recommendation to do something\nshould not\tindicates a recommendation not to do something\nmay\t\tindicates permission to do something\nneed not\tindicates permission not to do something\nThe construction \"may not\" is ambiguous and is not used in normative elements. The unambiguous constructions \"might not\" or \"shall not\" are used instead, depending upon the meaning intended.\ncan\t\tindicates that something is possible\ncannot\t\tindicates that something is impossible\nThe constructions \"can\" and \"cannot\" are not substitutes for \"may\" and \"need not\".\nwill\t\tindicates that something is certain or expected to happen as a result of action taken by an agency the behaviour of which is outside the scope of the present document\nwill not\t\tindicates that something is certain or expected not to happen as a result of action taken by an agency the behaviour of which is outside the scope of the present document\nmight\tindicates a likelihood that something will happen as a result of action taken by some agency the behaviour of which is outside the scope of the present document\nmight not\tindicates a likelihood that something will not happen as a result of action taken by some agency the behaviour of which is outside the scope of the present document\nIn addition:\nis\t(or any other verb in the indicative mood) indicates a statement of fact\nis not\t(or any other negative verb in the indicative mood) indicates a statement of fact\nThe constructions \"is\" and \"is not\" do not indicate requirements.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "1\tScope",
            "description": "The scope of present document is based on the requirements for SNA (TS 22.261 clause 6.10.2) [2] and on the Study on application enablement aspects for subscriber-aware northbound API access (TR 23.700-95) [3].\nThe objective of this study is to:\n1.\tIdentify potential new security requirements related to API invocation (such as user authorization) and define potential solutions to fulfil these requirements. This encompasses:\n-\tWhether and how CAPIF functions can determine the resource owner upon CAPIF invocation.\n-\tWhether and how CAPIF can support obtaining authorization from the resource owner.\n-\tWhether and how CAPIF can support revocation of authorization by the resource owner.\n-\tWhether and how CAPIF can support security procedures with the aim to reduce authorization inquiries for a nested API invocation.\nThe study is not exclusively tailored to CAPIF, but should align with widely deployed authorization frameworks.\n2. \tIdentify potential security requirements for APIs used in SNAAPP and define potential solutions to fulfil these requirements.\nThis objective includes UE-originated API invocation.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "2\tReferences",
            "description": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non-specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\t3GPP TS 22.261: \"Service requirements for the 5G system\".\n[3]\t3GPP TR 23.700-95: \"Study on application enablement aspects for subscriber-aware northbound API access\".\n[4]\tIETF RFC 6749: \"The OAuth 2.0 Authorization Framework\".\n[5]\t3GPP TS 33.122: \"Security aspects of Common API Framework (CAPIF) for 3GPP northbound APIs\".\n[6]\topenID.net: \"OpenID Connect Core 1.0 incorporating errata set 1\". Available at:\n[7]\tIETF RFC 7009: \"OAuth 2.0 Token Revocation\".\n[8]\tIETF RFC 7515: \"JSON Web Signature (JWS)\".\n[9]\tIETF RFC 7636: \"Proof Key for Code Exchange by OAuth Public Clients\".\n[10]\tIETF RFC 7662: \" OAuth 2.0 Token Introspection\".\n[11]\tIETF RFC 7542: \"The Network Access Identifier\".\n[12]\t3GPP TS 23.222: \"Common API Framework for 3GPP Northbound APIs\".\n[13]\tIETF RFC 2617: \" HTTP Authentication: Basic and Digest Access Authentication\".\n[14]\t3GPP TS 33.535: \"Authentication and Key Management for Applications (AKMA) based on 3GPP credentials in the 5G System (5GS)\".\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "3\tDefinitions of terms, symbols and abbreviations",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "3.1\tTerms",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the terms given in TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in TR 21.905 [1].\nAEF\tApplication Exposure Function\nANF\tauthentication function\nAPI\tApplication Programming Interface\nAuthz\tAuthorization\nAZF\tauthorization function\nCAPIF\tCommon API Framework for 3GPP northbound APIs\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.2\tSymbols",
                    "description": "",
                    "summary": "",
                    "text_content": "Void\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.3\tAbbreviations",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the abbreviations given in TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in TR 21.905 [1].\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "5\tKey issues",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "5.1\tKey issue #1: Checking authentication and authorization of invoker",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.1.1\tKey issue details",
                            "text_content": "Only certain invokers are permitted to invoke subscriber aware northbound APIs, Therefore it is necessary to authenticate and authorize these invokers to access the APIs. The requirements for CAPIF apply.\nFor SNAAPP, the API invoker can also reside on a UE.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.1.2\tPotential security requirements",
                            "text_content": "The requirements for the CAPIF-2 interface of 33.122 [5] clause 4.4 shall apply:\n(quoted for convenience)\nThe CAPIF-2/2e reference points between the API invoker and API exposing function shall fulfil the following requirements:\n-\t [CAPIF-SEC-4.4-a] Mutual authentication between the API invoker and the API exposing function shall be supported.\n-\t [CAPIF-SEC-4.4-b] The transport of messages over the CAPIF-2 and CAPIF-2e reference points shall be integrity protected.\n-\t [CAPIF-SEC-4.4-c] The transport of messages over the CAPIF-2 and CAPIF-2e reference points shall be protected from replay attacks.\n-\t [CAPIF-SEC-4.4-d] The transport of messages over the CAPIF-2 and CAPIF-2e reference points shall be confidentiality protected.\n-\t [CAPIF-SEC-4.4-e] Privacy of the 3GPP user over the CAPIF-2 and CAPIF-2e reference points shall be protected.\n-\t [CAPIF-SEC-4.4-f] The API exposing function shall determine whether API invoker is authorized to access service API.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.2\tKey Issue #2: Checking authorization before allowing access",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.2.1\tKey issue details",
                            "text_content": "Resource owners need to be able to control access to their resources. In the use cases described in TR 23.700-95, the resource owner is the UE's user, or the UE's user has been given permission by the subscriber to authorize access to the resource.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.3\tPotential security requirements",
                            "text_content": "-\tAuthn-1-ResOwner: when giving or revoking authorization, the resource owner shall be authenticated.\n-\tAuthz-1-General: Access to resources of the resource owner via the northbound APIs shall only be allowed if the resource owner has authorized it.\n-\tAuthz-2-App: Authorization shall be given to an application. Authentication of applications by the operating system of the UE is out of 3GPP scope.\n-\tAuthz-4-Scope: The 5G system shall be able to limit the scope of API requests to resources owned by a resource owner.\n-\tAuthz-5-Revoke: The resource owner shall be able to revoke authorization at any time. From then on access to resources based on the revoked authorization shall not be allowed.\nPriv-1-MSISDN: The 5G system shall be able to preserve the confidentiality of the UE's external identity (i.e. MSISDN) against a third party.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "6\tProposed solutions",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "6.1\tSolution #1: Resource Owner Authorization in API Invocation using OAuth Token",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.1.1\tIntroduction",
                            "text_content": "This solution addresses the requirement in KI#2.\nThis solution proposes to reuse OAuth 2.0 with authorization code grant model to obtain resource owner's authorization in case that an API invocation of network exposure is to process the resource owner's data.\nNOTE 1: \tHow the API invoker is authenticated to the authorization server is out of scope of this solution.\nNOTE 2: \tHow the Resource owner is authenticated to the authorization server is out of scope of this solution.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.1.2\tSolution details",
                            "text_content": "The figure depicts a simplified architecture for a CAPIF (Centralized Access Point Infrastructure) system, with an emphasis on the use of Software-Defined Networking (SDN) for enhanced network performance. The architecture includes a centralized access point (CAP) and a distributed network access point (D-NAP), both equipped with Software-Defined Networking (SDN) controllers. The figure illustrates the use of SDN to manage network traffic, optimize network resources, and improve network performance.\nFigure 6.1.2.1-1: Architecture for CAPIF with SNA enhancement\nThe architecture is derived from solution 2 in TR 23.700-95 [3]. Definition of the authorization function, CAPIF-8 is the same. Triggerer has the same definition of resource owner client(s).\nIt is proposed that the authorization function is collocated with the CCF.\nHowever, the difference is that CAPIF-9 defined in the TR 23.700-95 [3] is not needed in this solution because there is no communication with AEF, and CAPIF-3 can be reused if API related management is needed.\nCAPIF-10 defined in the TR 23.700-95 [3] is not needed, because API invoker can reuse CAPIF-1 to get access token. A new interface CAPIF-X is introduced between API invoker and Triggers for OAuth 2.0 authorization code grant usage.\nThe figure depicts a step-by-step procedure for obtaining resource owner authorization in a network. It includes the steps to obtain the necessary permissions, such as obtaining the network owner's authorization, obtaining the network owner's network access control list (NACL), and obtaining the network owner's network access control list (NACL) from the network owner. The figure also includes a visual representation of the network owner's network access control list (NACL) and the network owner's network access control list (NACL) from the network owner.\nFigure 6.1.2.2-1: Procedure of Obtaining Resource owner Authorization\nAs shown in the Figure 6.1.2.2-1, the details of obtaining resource owner authorization in API invocation is summarized as following:\n1. API invoker obtains authentication and authorization method (e.g. method 1: TLS-PSK, or method 2: PKI, or method 3: TLS with OAuth token) as specified in clause 6.1 in TS 33.122 [5].\nNOTE 1:\tCCF needs to pre-configure with TLS with OAuth token method.\nNOTE 2: Onboarding procedure is reused.\n2. API invoker discovers service API as specified in clause 6.3.1.3 in TS 33.122 [5].\n3. Resource owner triggers the API invocation. If resource owner authorization is needed for the invoked API and the method 3: TLS with OAuth token is selected, then the API invoker obtains tokenCAPIF via OAuth 2.0 with authorization code grant model as depicted in clause 6.1.2.3.\n4. The API invoker invokes northbound API to the AEF as depicted in clause 6.5.2.1 or 6.5.2.2 in TS 33.122 [5]. The API Invocation message includes tokenCAPIF.\nThe API invoker is pre-configured with a certificate and use TLS to authenticate with AEF.\n5. The AEF verifies the tokenCAPIF in the message, and the profile of this token is depicted in clause 6.1.2.4. The AEF verifies the integrity of tokenCAPIF and checks whether IDs in the scope are align with the IDs in the API invocation message. If the verification is successful, it means the resource owner has authorized the API Invoker to access the API for the resource owned by the resource owner.\nThe figure depicts a procedure for obtaining Resource Owner Authorization (ROA) in a network. It outlines the steps involved in obtaining ROA, including obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the necessary permissions from the network owner, obtaining the\nFigure 6.1.2.3-1: Procedure of Obtaining Resource owner Authorization (from RFC 6749 [4])\nOAuth 2.0 with authorization code grant model is depicted in clause 4.1 in RFC 6749 [4]. In this solution, the API invoker endorses the role of client, the triggerer endorses the role of user-agent. The Authorization Function authenticates the resource owner in step B, which depends on existing mechanism and is out of this solution. The API invoker (i.e. client) retrieves tokenCAPIF from the Authorization function in CCF. The scope of the tokenCAPIF includes API invoker ID, service API ID and resource owner ID (i.e. GPSI).\nAuthorization can be revoked according to mechanism defined in IETF RFC 7009 [7].\nThe resource owner ID is equal to the UE ID in the API invocation message, e.g. GPSI.\nIt takes use case 1 defined in Annex A.1 in TR 23.700-95 [3] as an example. An end user (i.e. resource owner) is playing a time-sensitive game using a game client application (i.e. triggerer) on the end user's UE communicating with a game server (i.e. API invoker), and wants to have a high-quality and low-latency communication for better service experience.\nIn step A, the end user requests the game client application, and the game client application requests game server to try to invoke the QoS API via CAPIF-X. The game server discoveries QoS API, and initiates OAuth procedure by contacting the game client application, and the game client application sends the requests to authorization server via CAPIF-8.\nIn step B, the Authorization Server requests the game client application to do user authentication and authorization via CAIPF-8 following RFC 2617 [13], it is also assumed that the game client application has TLS connection with Authorization Server, the end user may type in his MNO username and password and click \"consent\" for extra charging for QoS enhancement. The MNO user name may be set to the current MSISDN so that the authorization server can retrieve its subscription when the user has multiple subscriptions.\nNOTE 1: \tIt is assumed that authorization server has linkage between resource owner and GPSI.\nIn step C, after successful authentication and authorization, the authorization server provides authorization code to the game client application via CAPIF-8, and the game client application sends the authorization code to the game server via CAPIF-X.\nIn step D, the game server sends authorization code to authorization server via CAPIF-1/CAPIF-1e.\nIn step E, the game server gets tokenCAPIF from authorization server. The game server uses the tokenCAPIF to invoke QoS API via CAPIF-2/CAPIF-2e to modify the end user's QoS.\nNOTE 2:\t The solution does not specify how out-of-scope steps are integrated into the in-scope steps.\nThe tokenCAPIF is protected by the JSON signature profile as specified in IETF RFC 7515 [8].\nThe claim in the tokenCAPIF includes the parameters defined in clause C.2.2 in TS 33.122 [5]. In addition, the \"resource owner ID\" and the resource ID related to the list services are also added in scope. The resource owner ID is equal to the UE ID in the API invocation message, e.g. GPSI.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.1.3\tEvaluation",
                            "text_content": "The solution works when the TLS with OAuth token is selected.\nThis solution assumes that the resource owner is human user.\nThis solution addresses the requirements Authz-1, Authz-2, Authz-3 and Authz-4, but does not address the following requirements in KI#2:\n-\tThis solution does not touch authentication of the resource owner or API invoker by the authorization server, it may be addressed by other solution.\n-\tThis solution does not touch authentication between API invoker and CCF and authentication between API invoker and AEF, it may be addressed by other solution.\n-\tThis solution does not touch revocation of authorization, it may be addressed by other solution.\n-\tThis solution does not touch privacy of the UE's external identity against the third-party, it may be addressed by other solution. This solution does not address a static token claim issue after token revocation.\nNOTE:\tClause 6.1.2.3 has provided mapping to the use case defined in TR 23.700-95 [3].\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.2\tSolution #2: Authentication using OpenID Connect",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.2.1\tIntroduction",
                            "text_content": "Authentication of the UE can be performed by including an OpenID Connect identity token. In OpenID Connect, the authorization server is usually also the OpenID provider. This solution separates these roles into the authorization function (AZF) and the authentication function (ANF).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.2\tSolution details",
                            "text_content": "The figure depicts an OpenID Connect (OIDC) flow for Single Network Access Point (SNAAPP) Access Facilitation Protocols (AFs) in a Software-Defined Networking (SDN) environment. The flow illustrates the authentication and authorization process for network access, with the use of OpenID Connect for Single Sign-On (SSO) and Single Sign-On with Application Programming Interfaces (SSO-API). The figure highlights the use of OpenID Connect for Single Sign-On (SSO) and Single Sign-On with Application Programming Interfaces (SSO-API) in a Software-Defined Networking (SDN) environment.\nFigure 6.2.2-1: OpenID Connect for SNAAPP AFs\nThe flow follows the authorization code flow of OpenID Connect [6]. All communication is over TLS secured connections.\n1.\tPrior to any interaction, AZF should be registered with ANF, giving information that will be provided to the UE when requesting authentication.\n2.\tThe UE accesses the AZF without identity token.\n3.\tThe AZF shall redirect the UE to the ANF_URI, with the type set to code (to indicate authorization code flow), scope set to openid (to indicate that this is an openID request), client_ID set to its own ID, redirect_URI set to the URL to be used in step 8, and may set state to some state that can be used by AZF to reduce its internal state. Because sometimes it is necessary to authenticate the subscriber, and sometimes authentication of user is sufficient, the ANF shall offer separate endpoints for user and for subscriber authentication. The AZF shall be aware of which entity shall be authenticated based on configuration. Which authentication method is then chosen is between negotiated between UE/user and ANF and is out of scope of this solution.\n4.\tThe UE shall access the ANF at the redirected to ANF_URI, including the parameters of step 3.\n5.\tThe ANF shall authenticate the UE. This can be done in the usual way the home network authenticates the user, which may be GBA, AKMA, or using a proprietary method such as username/password.\n6.\tThe ANF should request authorization to release the required personal information to the AZF from the user. In this setup, the ANF presents to the user the information that was made available to the ANF about the AZF in the enrolment.\n7.\tThe ANF shall redirect the UE back to the AZF at the AZF_URI, including as code a single use token, which shall be specific to the AF, and as state the state that was set in step 3.\n8.-9.\tThe AZF shall request the identity token from the ANF at its token endpoint. The ANF shall verify that the identity token is indeed being requested by the correct AZF, and, if correct, return the identity token to the AZF.\n10.\tThe AZF shall verify the validity of the identity token according to RFC 6749, especially Sections 4.1.2 and 10.12.\nThe identity to be used shall be an external identity that the AZF can map to the resource owner's identity (subscriber/UE).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.3\tEvaluation",
                            "text_content": "This solution can be used to address Authn-1-ResOwner.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.3\tSolution #3: UE Originated API invocation using OAuth Client Credential Grant",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.3.1\tIntroduction",
                            "text_content": "According to KI#1 and the requirement referenced in KI#1, a UE shall be able to access a northbound API of the 5G system. The API invocation is triggered by an application, which is not visible to the 5G system.\nTherefore, it is assumed that details of the interface between the application and the API invoker on the UE are out of scope of this solution.\nIt is proposed to use the OAuth client credential grant (specified in clause 4.4. of [4]) as a basis for the solution.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.3.2\tSolution details",
                            "text_content": "The context of the components of the solution is visualized in Figure 6.3.2-1.\nIt is assumed that the application is deployed on the mobile device consisting of the UE. For instance, the application might be an app installed on a smartphone. Note, whether the application is considered being part of the UE or being collocated with the UE on a mobile device is a matter of interpretation and not relevant for the solution.\nNOTE 1: \tIn this solution the UE specific authorization and token claim is added on top of the already existing service authorization.\nThe API Invoker on the UE is taking the role of the OAuth Client. If CAPIF is applied, the Authorization Server is part the CAPIF Core Function. In this case the interface between API Invoker and Authorization Function is part of the CAPIF-1 interface.\nCAPIF onboarding for assignment of Client Id and Client secret is not needed, since Client Id and Client secret can be derived from the 5G key hierarchy as explained in more detail in step 2 of the message flow below.\nThe figure depicts the components of an API invocation using OAuth client credential grant, including the OAuth client, the authorization server, and the client credentials. The OAuth client is responsible for authenticating the user and obtaining the necessary credentials, while the authorization server handles the authorization process and returns the necessary credentials. The client credentials are then used to access the API, ensuring secure and authenticated access.\nFigure 6.3.2-1: Solution components of UE originated API invocation \nusing OAuth client credential grant\nA typical message flow executed for UE originated API invocation is depicted in Figure 6.3.2-2.\nThe figure depicts a message flow used for UE-initiated API invocation using OAuth client credential grant. The flow includes authentication, authorization, and data exchange between the client and the server.\nFigure 6.3.2-2: Message flow used for UE originated API invocation using \nOAuth client credential grant\nThe individual steps are described below:\n1. The flow is triggered by the application sending a request to the API invoker on the UE.\nThe interface between Application and API invoker including the authorization of the Application to use this interface is out of the scope of this solution.\nIt is assumed that this interface can be handled like other internal APIs on a mobile device, like access to cameras or GPS location.\n2. Based on the received Request the API invoker on the UE (acting as an OAuth Client) sends an OAuth Token Request to the Authorization Server with the grant type set to \"client_credentials\".\nThe Token Request is sent as https request. As part of the session establishment the API invoker authenticates the Authorization Server by verifying the Authorization Server's server certificate.\nThe FQDN of the authorization server can be constructed in a way standardized by 3GPP. The operator can obtain a server certificate from one of the CAs, which are trusted by the operating system of the UE and whose root certificate are preinstalled in the operating system of the UE.\nThe scope parameter is set by the API invoker based on the request of the application such that it covers the necessary scope of the subsequent API request in step 5.\nIn line with the SA1 requirement that the Application itself is invisible to the 5G system the token request does not contain information related to the identity of the Application, but the solution introduces a new entity, API invoker, in the UE, which is visible to the 5G system.\nThe Token Request includes the authentication of the API Invoker using the API invoker's client credentials. The circumstance that the API invoker is located and associated with a UE can be exploited for instance by using AKMA\nIn this context the Authorization Server takes the role of the AKMA AF. The https protocol is used as Ua* protocol. Depending on whether the Authorization Server is regarded as trusted the Authorization Server can directly interact with the AAnF or via NEF. Depending on the choice the SUPI or the GPSI can be used as OAuth client Id. The AKMA key KAF can be used as client credential. Thus, the authorization header of the http Token Request sent from the UE to the authorization server can be used for http Basic authentication with A-KID and KAF as username and password, respectively. Alternatively, also http Digest authentication can be used. This can be decided during normative work.\n3. The authorization server is authorizing the request based on the identity of the API Invoker and the requested scope by applying stored policies and permissions.\nNOTE 2: This solution assumes that policies and permissions are pre-arranged at the authorization server. Since the application is not visible, the policies and permissions are in the granularity of UE level, not the application level.\n4. In case of successful authorization the authorization server returns the token to the API invoker. The token includes claims, which reflect the granted scopes and permissions.\nOne of the claims of the issued token includes the identity of the UE.\nNOTE 3: The authorization server knows the identity of the UE from the UE authentication executed in step 2. Whether GPSI or SUPI is used as UE identifier can be decided during normative work.\nNOTE 4: Fine granular authorization scopes on the level of individual resources are not in scope of this solution. The solution assumes that it is sufficient to handle API calls, whose scope is clearly limited to resources owned by a single UE. That is, operations affecting several resources, like adding a UE to a LAN group, are not in scope. Hence, only UE identity is needed.\n5. The API invoker is sending the actual API request to the AEF. The API request contains the token received in the previous step.\nThe API Request is sent as https request. As part of the session establishment the API invoker authenticates the AEF by verifying the Authorization Server's server certificate.\nIf mutual authentication is needed, AKMA can be used between API invoker and AEF (e.g. https digest authentication).\n6. The AEF is validating the incoming request. That is, the AEF verifies the validity of the token, and the AEF verifies that the request is within the scope described by the claims in the token. The AEF especially ensures that the scope of API calls is restricted to resources owned the UE, whose identity is included in the token claims. API calls with a wider scope are rejected by the AEF.\n7. In case of successful validation the AEF is executing the request by involving other NFs (not shown in the signalling diagram)\n8. The AEF returns the result of the API call to the API invoker.\n9. The API invoker completes the flow by sending a response to the application (which is based on and might include results received in the previous step.\nNOTE 5: Authorization from the resource owner (i.e. the user) is not considered as part of the OAuth procedure using Client Credential Grant type.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.3.3\tEvaluation",
                            "text_content": "The presented approach provides a solution for the case that API Invoker is part of the UE and that this API Invoker can be used by applications on a mobile device to utilize 5G northbound APIs. The approach is thus complementary to other solutions which target the case that the API Invoker is part of the third-party application.\nUsage of AKMA guarantees that the client Id of the API Invoker is really bound to the Id of the UE.\nAuthentication of the UE is executed using http authentication mechanism, i.e. as part of the http token request.\nCAPIF onboarding for assignment of Client Id and Client secret is not executed, since Client Id and Client secret can be derived from the 5G key hierarchy\nIn this solution the 5G system only authenticates and authorizes the UE. The 5G system does not authenticate or authorize the (invisible) third party application or a user. That is, the solution assumes that the UE is the resource owner or requesting party.\nIn case of one UE accessing resources of another UE, the subscriber of the second UE is not able to authorize the third-party application used on the first UE. Such scenarios can be avoided, if API calls are restricted to the scope of each UE and API invocation crossing UEs is handled on the application layer.\nThe main changes required for the solution are related to the deployment of the API Invoker on the UE and the definition of interface between API Invoker and the third-party application. However, this interface is out of scope of this solution and out of scope of SA3.\nChanges are also needed with respect to the definition of a new claim in the access token identifying the UE and the ability of the AEF to restrict the scope of API calls to the UE identified in the token claims.\nThis solution cannot authorize the API invoker to access a specific resource (e.g. location information, UE reachability information) of a specific resource owner, but fine granular authorization scopes on the level of individual resources are not in scope of this solution. An API invoker that is authorized to access the one resource (e.g. location information) of the UE could also access other resources of the same UE.\nIn the solution the identity of the UE is not disclosed to a third party.\nNOTE:\t Including of authentication in a http request (like the token request) is very common practice, i.e. http basic or http digest authentication (see for example in clause 4.1.3 in RFC 6749 [4] or the definition of AKMA profile in B.1.2.2 of TS 33.535 [14]).\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.4\tSolution #4: Authenticate and authorize UE in UE originated API invocation",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.4.1\tIntroduction",
                            "text_content": "The solution addresses key issue #1. For originated UE API Invocation, the solution describes how UE (an API Invoker) can be provided with secure access to APIs (e.g. triggered by an application that is not visible to the 5G system), by authenticating and authorizing the UE.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.4.2\tSolution details",
                            "text_content": "The figure depicts the authentication, authorization, and secure connection establishment process of an API Invoker in a 4.2-1 network. It illustrates the process through a flowchart, with steps such as API Invoker authentication, authorization, and secure connection establishment. The figure also includes a visual representation of the network topology, including the network interface controller (NICA), network access control (NAC), and network security manager (NSM).\nFigure 6.4.2-1: UE originated API Invoker authentication, authorization, and secure connection establishment process\nThe steps shown in Figure 6.4.2-1 is described as follows:\nPrecondition: The UE (i.e. an API invoker) can be registered to the network.\nSteps 1-6 API Invoker Onboarding:\nThe UE is provisioned with a CAPIF Core Function (CCF) information such as CCF address/ID (e.g. after a successful primary authentication in any protected message). The UE and the network can derive the onboarding enrolment information such as CAPIF security credentials i.e. a CCF key (based on UE 5G security context e.g. AKMA key/AUSF key). The UE can derive a CCF key (Kccf) and key identifier (Kccf ID) which can be used to authenticate and establish a secure communication (e.g. TLS PSK based on CCF Key) with the CCF during the onboarding process.\nNOTE 1: The 5G security key used to generate CAPIF security key and the input used are up to the normative work.\n1. The API Invoker can send an Onboarding Service request to the CCF which can include Onboarding type (i.e. Subscriber Indication or UE service based), Kccf ID, UE ID (e.g. GPSI).\n2.\tBased on the received Onboarding type, the CCF determines to fetch security context related to the UE. The CCF can send a key request to the Core NF/AF which can include UE ID, and Kccf ID\nFurther the Core NF/AF provides the SUPI, and Kccf to the CCF in a Key Response message.\n3.\tThe CCF stores the CCF key, Kccf ID and UE ID.\n4.\tThe API Invoker and the CCF can perform mutual authentication and establish secure session (e.g. TLS PSK) based on Kccf shared between API Invoker and CCF.\n5.\tWith a secure session established, the API Invoker sends an Onboard API Invoker Request message to the CCF which includes the UE ID (SUPI/GPSI).\n6.\tThe CCF generates an API invoker's profile and onboard secret as specified in TS 23.222 [6]. The AEF Key can be used by the API Invoker to authenticate and establish secure session with the AEF as in TS 33.122 Clause 6.5.2.3 [5]. The AEF key can be derived from Kccf and other input parameters: API Invoker ID, CCF ID, Target AEF ID(s)/information, and Nonce.\nThe CCF on a successful authentication and authorization, it can locally store the API Invoker profile with API Invoker ID, Onboard Secret, AEF key along with Target AEF information.\nThe CCF can respond with an Onboard API invoker response message same as TS 33.122 [5] which can include the CAPIF core function assigned API invoker ID, AEF Authentication, and authorization information, and/or Onboard Secret, along with other information such as nonce, AEF information (Target AEF ID).\nThe API Invoker stores information received from step 6 and the API invoker is onboarded.\nAPI Invoker can perform CAPIF-1 authentication anytime with CCF based on TS 33.122 [5].\nSteps 7-9 Access Token Request/Response:\n7.\tThe API Invoker sends Oauth 2.0 based access token request as in TS 33.122 Clause 6.5.2.3 [5] (i.e. with grant_type client credentials if the API Invoker is the Resource Owner.)\nIf the API Invoker is not a resource owner, for OAuth 2.0 access token request the grant_type may be Authorization Code Grant as described in RFC 6749 [4].\nSimilar to TS 33.122 Clause 6.5.2.3 [5], the API invoker may include the CAPIF core function assigned API invoker ID and the Onboard_Secret in the OAuth access token request message for the CAPIF core function to validate the access token request.\n8. \tThe CCF based on the local policy checks if there exists any related authorization or prior consent information managed in the network related to allowing the API invoker to consume any service API invocation related to the UE.\nNOTE 2: The collection and management of user consent or authorization information related to a service exposure is outside the scope of this solution. It is assumed that the network manages such authorization information in any storage function outside the scope of this solution.\n9. The CCF generates and sends an Oauth access token (based on OAuth 2.0) to be used as AEF Access token. The access token claims can include UE ID and CCF ID along with other claims in TS 33.122 Clause C.2.2 [59.\nSteps 10-15 Service API Invocation:\n10.\tThe API Invoker derives an AEF Key (Kaef) from CCF Key (Kccf) and respective input parameters similar to CCF on a successful CAPIF 1 authentication and authorization. The API Invoker can send Authentication Initiation Request to the AEF, which includes the CCF assigned API invoker ID, and UE ID.\n11.\tThe AEF can send API Invoker ID, and UE ID to request the security information from the CCF. The CCF provides the security information related to the chosen security method (e.g. TLS-PSK: AEFPSK) along with AEF Key, Service API(s) authorization information (can be a list of Service APIs which can be invoked by the API Invoker related to the UE ID), and Oauth access token i.e. AEF Access token (to authorize the API invoker to request the service API invocation from AEF) to the AEF over CAPIF-3 reference point. The CCF can provide the remaining validity timer value for the AEF Key (i.e. AEFPSK) as in TS 33.122 Clause 6.5.2.1 [5].\nAlternatively, the service information and access token sending can be skipped as it can be bound to the access token as claims (later received in step 13a) from the API invoker.\n12. After fetching the relevant AEF Key for the authentication, the AEF can send Authentication Initiation Response message to API invoker to initiate the TLS session establishment. The AEF starts the validity timer based on the value received from the CAPIF core function in step 11.\nThe API Invoker and the AEF can perform mutual authentication using the AEF key and establish TLS session.\n13a. The API invoker can send Invocation service request to the AEF which can include Requested Service API(s) information, API Invoker ID, UE ID, and AEF Access Token (received from CCF).\n13b. The AEF can authorize the API invoker's service API invocation request based on authorization information (i.e. validating the claims in the Oauth based AEF Access Token) obtained from CAPIF core function as specified in subclause 8.16 of TS 23.222 [12].\n14. On a successful access token validation, the AEF considers Invocation service request authorization as successful, execute API request and can send Invocation service response with success indication.\nNOTE 3: According to TS 33.122, API provider domain provides Onboarding enrolment information to the API invoker as a prerequisite to the Onboarding procedure. Therefore, for the UE originated API Invocation case, the solution enables provision of onboarding enrolment information based on UE's established security context as described in steps 1.\nNOTE 4: The user consent information collection and related management is outside the scope of this solution.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.4.3\tEvaluation",
                            "text_content": "The solution addresses KI#1 and enables the following for the case where the API Invoker resides in a UE:\nA CCF key need to be derived and provided to the CCF by a NF or an AF.\nAPI Invoker UE and CAPIF Core Function (i.e. Authorization Function) performs mutual authentication based on a key derived from UE's 5G security context (i.e. AKMA based key or AUSF based Key) and so the AUSF impact applies.\nTLS-PSK based mutual authentication and secure connection establishment between API Invoker UE and the AEF is enabled.\nOAuth 2.0 token based authorization is used for access to service API.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.5\tSolution #5: Resource Owner based authorization for resource access",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.5.1\tIntroduction",
                            "text_content": "The solution addresses Key Issue #2.\nThe solution describes the method to receive and revoke authorization as required from an authenticated Resource owner to control access to resource(s) of a resource owner. Figure 6.5.2-1 shows the resource authorization procedure to allow access to resources.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.5.2\tSolution details",
                            "text_content": "\nFigure 6.5.2-1: Resource authorization procedure to allow access to resources\nThe steps shown in Figure 6.5.2-1 is described as follows:\n1-2. During the primary authentication procedure, the UDM may also indicate to the AUSF whether CAPIF keys need to be generated for the UE (i.e., resource owner). If the CAPIF Indication is included, the UDM may also include GPSI and CAPIF Function information (i.e. ID/address).\n3. \tIf the AUSF receives the CAPIF indication from the UDM, the AUSF and UE following a successful primary authentication can generate CAPIF Key and CAPIF-UE ID (to identify the CAPIF Key for the UE) from the AKMA Key.\nNOTE: \tThe inputs used in the CAPIF key and ID generation can be up to the normative phase.\n4a. The AUSF based on CAPIF Function information, sends resource owner authorization data notification request to the CAPIF function which can include the UE ID (i.e. GPSI), CAPIF key and the ID.\n4b. The CAPIF Function stores the received information and sends a sends resource owner authorization data notification response to the AUSF.\n5. \tThe AUSF sends the CAPIF Function information and GPSI to the AMF and the AMF forwards the information to the UE over the NAS transport.\n6a. The UE initiates a resource owner registration request with CAPIF-UE ID, GPSI and a freshness parameter to the CAPIF function.\nThe CAPIF function verifies if the received CAPIF-UE ID matches with the resource owner authorization data received in step 4a. If the verification is successful, the CAPIF function considers the resource owner registration as successful and it assigns a Resource Owner Identity.\n6b. The CAPIF Function can send a resource owner registration response with nonce. The UE and the CAPIF Function generates a key based on the CAPIF Key, nonce and GPSI, establish a secure session. The CAPIF Function then sends a resource owner ID and lifetime (for the resource owner registration) following a successful resource owner registration.\n7a-c. An API Invoker (e.g. an AF originated API Invocation/ another UE originated API Invocation happens) performs onboarding, mutual authentication (e.g. as in 33.122 and these aspects are related to KI#1) with the CAPIF Function and if the service APIs needs additional resource owner authorization, the authorization code related to the resource owner can be issued to the API Invoker based on the Authorization Code Flow described in RFC 6749, where the CAPIF function authenticates the resource owner (i.e. end user) based on the Resource Owner ID and the associated resource owner key. The CAPIF function and the UE (resource owner) establishes secure connection using the resource owner key generated from the CAPIF Key, the freshness parameter (received in step 7b) and other inputs if required.\n7d. The API Invoker requests access token from the CAPIF Function (i.e. authorization server can be part of the CAPIF Function) related to the resources with GPSI of the resource owner and the code (if step 7a-7c is performed).\n8. \tAlternatively, based on operator implementation, the CAPIF Function can determine to check the resource owner authorization data (if available in the UDM/UDR, i.e. query the UDM/UDR to check the authorization data related to the GPSI for e.g. to check if the resource owner accepts to expose the data associated to it). The resource owner authorization data fetching, and handling can be up to operator implementation.\n9. \tBased on the authorization data fetched, the CAPIF Function provides access token to the API Invoker. The claims used to generate access token are up to normative work.\nFor the case of revocation, the Resource owner can anytime revoke the authorization data issued earlier by establishing a secure connection with the CAPIF Function (e.g. steps 7b initiated by UE and step 7c is performed), else the operator based on implementation can manage the revocation of resource owner authorization data. If an authorization is revoked, the access token request and any related data sharing with AEF is rejected by the CAPIF Function.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.5.3\tEvaluation",
                            "text_content": "The solution addresses Key Issue #2 and enables the following:\nAn application key derived from CAPIF Key related to the Resource Owner is used to establish secure application session with the CAPIF Function.Access to resource of resource owner is allowed based on resource owner specific authorization information (i.e. user consent data) verification by the network.\nThe solution assumes the resource owner as the subscriber. The solution has impacts to AUSF and UDM as it extends AKMA security for resource owner registration and security establishment. The solution requires access to 5G key hierarchy and will only work when the UE is authenticated to 5G network.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.6\tSolution #6: Authorization before allowing access to resources",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.6.1\tIntroduction",
                            "text_content": "This solution addresses the security requirement about authorization by the resource owner before allowing access to resources of the resource owner, which is detailed in key issue #2.\nIt is assumed that authorization information by the resource owner has been received and stored in the authorization server with a method out of the scope of this solution.\nAlso, the consideration whether the resource owner is the subscription user or the subscription owner is out of scope of this solution.\nThe MNO learns the authorization information from the subscription user or from the subscription owner and stores the authorization information, which is bound to the UE identifier, in the PLMN trusted domain. How the MNO authenticates the resource owner and learns the authorization information is out of scope of this solution.\nThis solution covers the case that the API invoker is the AF accessing to resources related to a UE or the API invoker is the application in the UE accessing to resources related to that UE.\nHow the AF maps the target username in the application layer into the UE identifier is out of scope of this solution. The authentication and authorization behind the AF-CAPIF interaction for the triggering UE and user is out of scope.\nThis solution assumes that the authorization server is co-located with the CAPIF Core Function (CCF). This solution does not specify the place where the authorization information is stored. The CCF may store the authorization information in an external storage, and in this case it is assumed that there is a secure channel between the CCF and the external storage.\nThe storage is used to store dynamic authorization information received, from the resource owner, using MNO specific methods. This storage can be co-located with the CCF/authorization server.\nThis solution works as follow for the use case #1 defined in Annex A of TR 23.700-95 [3]. When the user starts a gaming application, the gaming application can check whether there is already a permission for the QoS changes via the gaming server which assumes the API invoker role. If there is no permission and if the gaming application wants to offer a better quality, the gaming application may ask permission for QoS changes. If the user wants to have a better quality, the user can give permission using operator specific mechanisms which can be a web portal or a mobile application of the operator.\nRegarding use case #2 in Annex A of TR 23.700-95 [3], this solution proposes alternative to the flow defined in [3] addressing the following issues in [3], namely if the flow in [3] is applied, the MNO will need to authenticate the mobile application instance running in the UE Y and will also need to ensure that the end user in the UE Y triggers the location tracking. However, the MNO cannot ensure the correctness of the information about the end user of UE Y. Therefore, it seems that the best way to realize this use case is to have the authorization mechanism in the application layer by the application server, which is out of 3GPP scope. Following this motivation, the solution proposes that the UE should only be able to access its own resources. After learning its own location, UE X can share the location information with UE Y directly or via the application server. How this sharing is realized is out of 3GPP scope.\nAlternatively, use case #1 can be used to realize use case #2, as follows: The application server (AF) accesses the location information of UE X on behalf of UE Y; for this to happen the resource owner of UE X needs to authorize the application server to access UE X's location, and the end user of UE X needs to give permission in the application layer for sharing the location information with the user of UE Y.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.6.2\tSolution details",
                            "text_content": "Below describes the steps of the procedure for \"authorization before allowing access to resources\", which is shown in Figure 6.6.2-1.\nThe figure depicts a flowchart illustrating the authorization process before allowing access to resources. It includes steps such as obtaining authorization, verifying identity, and granting access. The flowchart is designed to ensure that only authorized users can access the resources, reducing the risk of unauthorized access and data breaches.\nFigure 6.6.2-1: Authorization before allowing access to resources\nHow the authentication is executed for the API invoker that runs in the UE is out of scope of this solution. In general, the solution does not focus on the authentication of the API invoker.\n1)\tThe API invoker and the CCF execute authentication procedures and establish a secure channel as specified in TS 33.122 [5].\n2)\tThe API invoker request OAuth access token as specified in TS 33.122 [5].\n3)\tThe CCF verifies the request.\n4)\tSteps 4-6 is executed if resource owner authorization check is needed for the API invocation.\n5)\tThe CCF fetches resource owner authorization information from the storage. If the storage is co-located with CCF, there is no need to execute steps 4 and 5, or handling them can be left to implementation.\n6)\tThe storage sends the resource owner authorization information.\nNOTE:\tThe resource owner authorization information stored in the storage can have expiration time (e.g., usual expiration time of a token)\n7)\tThe CCF issues an access token that includes an indication for the resource owner authorization. The CCF sends the issued token to the API invoker.\n8)\tThe API invoker and API exposing function establish a secure channel.\n9)\tThe API invoker sends the token to the API Exposing Function.\n10)\tThe API Exposing Function verifies the token and checks the resource owner authorization information before allowing access to the resources related to the subscription.\n11)\tThe API Exposing Function returns the API invocation response to the API invoker.\nFor the UE originated API invocation case where the application on the UE triggers the API invocation by the application in the operating system in the UE or directly invokes the API, this solution assumes that an authorization in the granularity of application level is executed by a mechanism, like allowing users in the mobile phones to control the permission of application to access resources such as microphone of the mobile phone, provided by the operating system, which is out of scope of this solution. To give the access control power to the MNO considering the permission from the user or subscriber, the MNO needs to retrieve the permission/authorization information from the subscriber or user and store it in the authorization server/storage with an out of scope mechanism. This solution applies to the specific case where the application is accessing to the resources of the UE on which the application is running. The case of accessing resource of other UEs by the UE is not covered in this solution.\nIf near real time authorization is needed for two scenarios (AF originated and UE originated API invocation), some application layer procedures which are out of 3GPP scope can be applied. The following gives an example for such procedures. For the AF originated API invocation, when there is a need for authorization from the user or subscriber, the AF informs the application client (e.g., gaming application) on the UE by sending MNO backend server endpoint information. The application client redirects the user to the MNO backend server so that the user configures authorization information using the MNO backend server and then continue to use the application (e.g., gaming application). The above procedures are executed to invoke the API. For the UE originated API invocation, if the application knows the MNO backend server endpoint information, the application can redirect the user to the MNO backend server system. If there is no such information, the application informs the user for such an authorization need and the user can use one of the alternatives to access the MNO backend server, for example, by using the web portal or mobile application of the MNO.\nThe following procedure, depicted in Figure 6.6.2-2, shows how revocation of authorization by the resource owner can be handled.\nThe figure depicts a revocation of resource owner authorization, which is a crucial step in the process of revoking access to a resource. The figure shows a user attempting to access a resource, with a red circle indicating the resource owner's authorization status. The user is shown as a red circle, indicating that they are not authorized to access the resource. The figure also includes a green circle, which represents the resource owner's authorization status. The figure is a visual representation of the revocation process, which is an important step in ensuring that only authorized users have access to resources.\nFigure 6.6.2-2: Revocation of resource owner authorization\n1)\tResource owner authorization is revoked.\n2)\tThe CCF informs the AEF about the revocation by sending the revoked token identifier. (It is assumed that the AEF has subscribed to the CCF event exposure service).\n3)\tThe API invoker and AEF executes some authentication and establish a secure channel using TLS.\n4)\tThe API invoker sends the access token in the NB API call.\n5)\tThe AEF verifies the access token, checks the resource owner authorization. Since the resource owner authorization has been revoked, the AEF rejects the request.\n6)\tThe AEF sends the rejection response to the API invoker.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.6.3\tEvaluation",
                            "text_content": "The solution addresses the following cases:\n-\tThe AF accesses resources related to a UE\n-\tThe application in the UE is accessing the resources related to that UE.\nThe solution assumes that there is a mechanism in the UE for authorization in the application-level granularity.\nThis solution is a future proof solution considering possible extension of the definition of resource owner to cover the subscribers in addition to the users.\nThis solution assumes that the API invoker application in the operating system of the UE is authenticated and authorized by a method out of scope.\nThis solution is very similar to the existing mechanism for the AF originated API invocation case where the AF is outside of the UE. In the existing mechanism, the CCF has the authorization information that indicates whether the AF is allowed to consume the service API. The enhancement in this solution is that the CCF also checks the authorization information that indicates whether the AF is allowed to access the resources of the UE.\nConsidering the legacy mechanisms, this solution introduces a new claim in the token to inform the AEF that the user authorization has been checked by the CCF.\nThis solution requires CCF to have storage capability to store resource owner authorization information. In the existing CAPIF mechanism, CCF has already storage capability for preconfiguration of authorization information. This solution proposes to use existing mechanism about storage. How the authorization information is received from and updated by the MNO backend system is out of scope of this solution.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.7\tSolution #7: Authorizing UE originated API invocation with PKCE flow",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.7.1\tIntroduction",
                            "text_content": "In case the API invocation can be initiated by an application on the UE without making use of a unique CAPIF client agent per UE, the UE application might not be able to securely store a client credential. For this case, there is the Authorization Code Flow with Proof Key for Code Exchange defined in RFC 7636 [9].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.7.2\tSolution details",
                            "text_content": "The solution uses the PKCE protocol flow with the following mapping: the client in RFC 7636 [9] is the application on the UE. The authorization server in RFC 7636 is the authorization function in the network.\nThe following figure gives an example PKCE flow to help understanding the concept of the PKCE flow. This flow could look different for a different authentication mechanism.\nThe figure depicts a PKCE flow, which is a key component in 5G network architecture. It illustrates the process of packet classification, keying, encryption, and key exchange (PKCE) in a 5G network. The flow is shown in a flowchart format, with key steps such as packet classification, keying, encryption, and key exchange. The figure is used to understand the flow of data in a 5G network and to ensure the security and reliability of the network.\nFigure 6.7.2-1: Example PKCE flow\nNote:\tThe solution description does not detail which parts need to be specified in stage 2.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.7.3\tEvaluation",
                            "text_content": "PKCE flow is a standard IETF flow to allow a resource owner to provide authorization to a resource consumer. There is user interaction required for the PKCE flow.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.8\tSolution #8: Validation of OAuth Token",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.8.1\tIntroduction",
                            "text_content": "If an OAuth token used for authorization, the API exposing function needs to verify the validity of the token. In this solution, this is done by token introspection RFC 7662 [10]. The revocation procedure between authorization server and resource owner is out of scope of this solution.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.8.2\tSolution details",
                            "text_content": "The figure depicts a visual representation of the OAuth 2.0 token validation process, showing the steps involved in verifying the authenticity of an OAuth 2.0 token. The figure includes a series of steps, such as selecting the token, validating the token, and verifying the token's validity. The steps are clearly labeled and visually represented, making it easy to understand the process.\nFigure 6.8.2-1: Validation of OAuth 2.0 token\nAll messages containing a tokens shall be protected using TLS. The API invoker shall authenticate the API exposing function by verifying the API exposing function's certificate. The API exposing function shall authenticate the authorization function by validating the authorization function's certificate.\nNote: contents of the certificates and which CAs are acceptable are not defined in this solution. The oAuth access token shall contain:\n-\ta unique random string,\n-\twhich API the token applies to (the scope),\n-\twho is the resource owner,\n-\tthe API invoker ID, and\n-\texpiry time.\nNote 1: \tHow that information is encoded in the OAuth access token is for stage 3.\n1. \tThe API call shall contain the OAuth access token.\n2.\tThe API exposing function shall verify that the access token is applicable to the desired API call and if yes, send the access token to the authorization function for validation. Otherwise the API call shall fail and a new authorization may be requested.\n3.\tThe authorization function shall verify the validity of the access token and return whether the token is valid.\n4. \tIf the access token is valid, the API exposing function shall execute the API call.\nThe API exposing function may cache the result of validation. In that case, the API exposing function shall subscribe to receive a notification in case the token is revoked. This subscription may be included in step 2, e.g. by accessing a different endpoint for validate and subscribe than for validate only.\nThe authorization function shall offer a notification service to inform the API exposing function of revocation of a token. Subscription shall be on a per token basis.\nThe authorization function may store information about validity of tokens locally.\nNote 2:\tWhether caching is required is has not been studied in the present document.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.8.3\tEvaluation",
                            "text_content": "This solution addresses Authz-4-Scope and Authz-5-Revoke. This solution deviates from the existing CAPIF solution in clause 6.5.2.3 in TS 33.122 [5]. It can avoid the impact of signature generation and verification and of relying on synchronized time and short lived tokens at the expense of backend communication between AEF and authorization function.\nDetermining the benefits of token introspection over signature verification will need to be done in deployment can be revisited at a later time.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.9\tSolution #9: OAuth 2.0 based API invocation procedure",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.9.1\tIntroduction",
                            "text_content": "This solution addresses the key issue #1 and key issue #2 in terms of API invoker UE authorization.\n-\tIn this solution, API invoker may request authorization for service API and resource. And only one access token is provided to the API invoker for service API and resource authorization. Resource owner can authorize API invoker for resources via the UE. The resource owner can authorize the API invoker to access its resources in synchronous and asynchronous manner.\n-\tCAPIF core function can authorize API invoker for services and service operations.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.9.2\tSolution details",
                            "text_content": "The figure depicts a flowchart illustrating the OAuth 2.0-based API invocation process, with steps such as authorization, client credentials, and API access. It highlights the use of OAuth 2.0 for secure and authenticated API access, emphasizing the importance of user authentication and authorization in modern web services.\nFigure 6.9.2-1: OAuth 2.0 based API invocation.\n1.API invoker and UE controlled by the resource owner do the mutual authentication. Resource owner agent is a part of the UE.\nFor the case that API invoker is the UE, the mutual authentication can be realized based on certificates. For the case that API invoker is the AF, the mutual authentication can be realized based on GBA-based authentication mechanism, AKMA-based authentication mechanism or certificate-based authentication mechanism. A secure connection between API invoker and resource owner is established after the mutual authentication. The secure connection can be established via TLS.\nNOTE 1: \tTo ensure the authorization code is provided to the correct API invoker, this solution requires the UE and API invoker do mutual authentication.\n2. The API invoker sends authorization request to the UE controlled by the resource owner.\nIn case API invoker has obtain the authorization of service API and service operation, the request includes the identity (e.g. GPSI, IMPI or application layer ID) of the API invoker, the identity (e.g. GPSI, IMPI or application layer ID) of target UE, the target resource (e.g. location of UE, QoS of the UE).\nIn case API invoker has not obtain the authorization of service API and service operation, the request includes the identity (e.g. GPSI, IMPI or application layer ID) of the API invoker, the identity (e.g. GPSI, IMPI or application layer ID) of target UE, the target resource (e.g. location of UE, QoS of the UE), human-readable operations (e.g. update the QoS of the resource owner). The service identifier/service operation identifier indicates the service/service operation that can be performed on the target resource.\nNOTE 2:\tIn this solution, the API invoker will send the requested human-readable operations (e.g. update the QoS of the resource owner) to the CAPIF core function/authorization function via the UE controlled by the resource owner. Therefore, the CAPIF core function/authorization function can generate the access token containing 3GPP services/service operations.\n3. CAPIF core function/authorization function and UE controlled by the resource owner should do the mutual authentication.\nFor the case of CAPIF core function, resource owner can authenticate CAPIF core function via certificate. Then CAPIF core function can authenticate resource owner using GBA-based authentication mechanism, AKMA-based authentication mechanism or certificate-based authentication mechanism. And CAPIF core function may generate certificate and OAuth 2.0 token for the resource owner after the authentication.\nFor the case of authorization function, resource owner can authenticate authorization function via certificate. Then authorization function can authenticate resource owner using TLS-PSK, OAuth token, GBA-based authentication mechanism, AKMA-based authentication mechanism or certificate-based authentication mechanism, in which the certificate can be assigned by the CAPIF core function.\nA secure connection between resource owner and CAPIF core function/authorization function is established after the mutual authentication. The secure connection can be established via TLS.\nCAPIF core function and resource owner should also do the mutual authentication. Details on the authentication procedure is out of scope of 3GPP.\n4. The resource owner may timely and synchronously grant the authorization request for the resource via the UE. And the UE controlled by the resource owner sends the authorization request and grant information to the CAPIF core function/authorization function to request the authorization code.\nThe resource owner may asynchronously grant the authorization request for the resource based on the local pre-generated profile. And the resource owner sends the authorization request and grant information to the CAPIF core function/authorization function to request the authorization code.\nIf the resource owner previously sends the pre-generated profile to the CAPIF core function/authorization function, the resource owner sends the authorization request to the CAPIF core function/authorization function to request the authorization code. CAPIF core function/authorization function can authorize the authorization request for the resource based on the pre-generated profile.\nThe authorization request in step 4 is identical to the one sent by the API invoker.\nIf the API invoker has obtained the authorization of service API and service operation, the CAPIF core function/authorization function generates the authorization code for the API invoker when API invoker is authorized to request the resource.\nIf the API invoker has not obtained the authorization of service API and service operation, the CAPIF core function/authorization function should translate the application level human-readable operation in authorization request to 3GPP level service/service operation identifiers. Then the CAPIF core function/authorization function checks if API invoker is authorized to invoke the 3GPP services/service operations based on pre-configured policies. If the API invoker is authorized to invoke the service API, service operation, and the resource, the CAPIF core function/authorization function generates authorization code for the API.\n5. CAPIF core function/authorization server sends the authorization code to the UE controlled by the resource owner.\n6. The UE controlled by the resource owner sends the authorization code to the API invoker.\n7. CAPIF core function/authorization function and API invoker should do the mutual authentication.\nFor the case of CAPIF core function, API invoker can authenticate CAPIF core function via certificate. Then CAPIF core function can authenticate API invoker using GBA-based authentication mechanism, AKMA-based authentication mechanism or certificate-based authentication mechanism. And CAPIF core function may generate certificate and OAuth 2.0 token for the API invoker after the authentication.\nFor the case of authorization function, API invoker can authenticate authorization function via certificate. Then authorization function can authenticate API invoker using TLS-PSK, GBA-based authentication mechanism, AKMA-based authentication mechanism or certificate-based authentication mechanism, in which the certificate can be assigned by the CAPIF core function.\nA secure connection between API invoker and CAPIF core function/authorization function is established after the mutual authentication. The secure connection can be established via TLS.\n8. The API invoker sends the authorization code to the CAPIF core function/authorization function.\n9. The CAPIF core function/authorization function sends the refresh token/access token to the API invoker. The API invoker can send the refresh token to CAPIF core function/authorization function to obtain access token.\nThe access token includes CAPIF core function identity (e.g. NF instance ID, NF ID), authorization function identity (e.g. NF instance ID, NF ID), AEF identity (e.g. NF instance ID, NF ID), service identifier (optional), 3GPP service /service operation (optional), API invoker identity (e.g. GPSI, IMSI, application layer ID), resource owner identity (e.g. GPSI, IMSI), user resource identifier (e.g. location), expire time.\n10. API Exposing function (AEF) and API invoker should do the mutual authentication.\nAPI invoker and API Exposing function can do mutual authentication based on TLS-PSK, OAuth token, GBA-based authentication mechanism, AKMA-based authentication mechanism, or certificate-based authentication mechanism.\nA secure connection between API invoker and API Exposing function is established after the mutual authentication. The secure connection can be established via TLS.\n11. The API invoker sends service API invocation request to the AEF. The request includes the API invoker identity, the resource owner identity, the service API that needs to be invoked, the user resource identifier that the API invoker needs to access, and the access token.\n12. The AEF authorize the request based on the token.\n13. The AEF sends response to the API invoker.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.9.3\tEvaluation",
                            "text_content": "Benefits:\n-\tIn this solution, authorization code grant type of OAuth 2.0 is employed to authorize both the request for both the resources (KI#2) and the request for services/service operations (KI#1).\nImpacts:\n-\tThe CAPIF core function/authorization function should be able to generate tokens containing authorization information with resource owner identity (e.g. GPSI, IMSI), and user resource identifier (e.g. location).\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.10\tSolution #10: UE credential based API invocation procedure",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.10.1\tIntroduction",
                            "text_content": "This solution addresses the key issue key issue #1 and #2 in terms of API invoker UE authorization.\nIn this solution, CAPIF core function/authorization function can authorize API invoker UE to access resources based on the verified UE identity in step 1.\nThe API invoker UE credential can be certificate or secrets shared among API invoker UE and CAPIF core function/authorization function.\nThe shared secrets among UE and CAPIF core function can be shared keys related to AKMA and GBA methods.\nThe shared secrets among UE and authorization function can be shared keys related to AKMA method, GBA method, and CAPIF onboarding procedure.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.10.2\tSolution details",
                            "text_content": "It is assumed that the API invoker is an UE in SNA scenarios.\nThe figure depicts a simplified API invocation procedure for a UE credential-based authentication system. It illustrates the steps involved in obtaining an API key from the UE, including the authentication process, the authorization request, and the response from the API server. The figure is a visual representation of the system's architecture, highlighting the key components such as the UE, the API server, and the authentication process.\nFigure 6.10.2-1: UE credential based API invocation procedure.\n1.\tThe API invoker and authorization function/CAPIF core function do the mutual authentication.\nFor the case of CAPIF core function, the API invoker can authenticate CAPIF core function via a certificate. Then the CAPIF core function can authenticate the API invoker using GBA-based authentication mechanism, AKMA-based authentication mechanism or certificate-based authentication mechanism. And the CAPIF core function may generate a certificate for the API invoker after the API invoker onboarding procedure.\nFor the case of authorization function, the API invoker can authenticate the authorization function via a certificate. Authorization function can authenticate the API invoker UE based on its credential (e.g. KAF). In specific, the authorization function can authenticate API invoker using GBA-based authentication mechanism, AKMA-based authentication mechanism or certificate-based authentication mechanism, in which the certificate can be assigned by the CAPIF core function. API invoker and authorization function may do the mutual authentication based on methods that are defined in clause 6.5.2 of TS 33.122 [5].\nA secure connection between the API invoker and authorization function/CAPIF core function is established after the mutual authentication. The secure connection can be established via TLS.\n2. \tThe API invoker sends a token request to the CAPIF core function/authorization function. The request includes the identity (e.g. IMPI, GPSI) of the API invoker, the identity (e.g. IMPI, GPSI) of the resource owner, the target resource (e.g. location of UE, QoS of the UE), and the target service API.\n3. \tThe CAPIF core function/authorization function sends the token to the API invoker if the verified identity of UE in step 1 is authorized to request the target resource of the resource owner.\nThe authorization can be realized based on policies provided by the resource owner. In some cases, the policies are application level policies.\nTo authorize the API invoker, the CAPIF core function function/authorization function may need to translate the application level policies (e.g. human-readable policies) into 3GPP level service/service operation identifiers.\nThe type of token can be refresh token or access token. To access the service API via the API exposing function, the API invoker UE needs to send the refresh token to the CAPIF core function/authorization function to obtain the access token when the CAPIF core function/authorization function sends the refresh token to the API invoker UE. The token shall include the CAPIF core function/authorization function FQDN (issuer), API invoker identity (subject), expected service API (Scope), target resource (Scope), identity of resource owner (Scope), API exposing function FQDN (audience), expiration time (expiration). Details on token, refresh token, and access token are given in RFC 6749 [4].\n4. \tThe API invoker and API exposing function do the mutual authentication. The API invoker can authenticate the authorization function via certificate. Then the authorization function can authenticate the API invoker using GBA-based authentication mechanism, AKMA-based authentication mechanism or certificate-based authentication mechanism, in which the certificate can be assigned by the CAPIF core function. API invoker and API exposing function may do the mutual authentication based on methods that are defined in clause 6.5.2 of TS 33.122 [5].\nA secure connection between API invoker and API exposing function is established after the mutual authentication. The secure connection can be established via TLS.\n5. \tThe API invoker sends a service API request to the API exposing function along with the access token.\n6. \tThe API exposing function needs to reject the request when the API invoker sends the service API invocation request without the token. The API exposing function authorizes the request based on the token. The API exposing function can verify the integrity of the token using the public key of the CAPIF core function. The API exposing function can terminate the procedure if the token is modified. Otherwise, the API exposure can check the service API invocation request against the token. The API exposing function should reject the service API request if the request cannot fulfil the requirements of the token. The procedure goes to step 7 if the request fulfils the requirements of the token.\n7. \tThe API exposing function sends the service API invocation response to the API invoker.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.10.3\tEvaluation",
                            "text_content": "Benefits:\n-\tThis solution can authorize API invoker for both resources (KI#2) and services/service operations (KI#1).\n-\tThe CAPIF core function/authorization function can authorize the API invoker based on policies provided by the resource owner.\n-\tBefore offering the token to the API invoker, the identity of the API invoker is authenticated by the CAPIF core function/authorization function using the certificate or shared key related to AKMA/GBA/API invoker onboarding procedure.\nImpacts:\n-\tThis solution requires the resource owner to configure policies to the CAPIF core function/authorization function.\n-\tTo authorize the API invoker, CAPIF core function function/authorization function may need to translate the application level policies (e.g. human-readable policies) to 3GPP level service/service operation identifiers.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.11\tSolution #11: Providing and Revoking Resource Owner Authorization using OAuth 2.0 Authorization Code Grant",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.11.1\tIntroduction",
                            "text_content": "This solution addresses Key Issue #2 \"Checking authorization before allowing access\".\nThis solution proposes to use OAuth 2.0 Authorization Code Grant as specified in clause 4.1 of RFC 6749 [4], in which the resource owner can be authenticated by the resource owner's 3GPP credentials.\nUE, API Invoker, and Authorization Function in this solution performs the role of User-Agent, Client, and Authorization server in RFC 6749 [4], respectively.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.11.2\tSolution details",
                            "text_content": "The figure depicts a complex network architecture for a communication platform, specifically a CAPIF (Communication Access Platform Infrastructure) system. It includes various components such as core switches, optical line terminals (OLTs), and distributed nodes. The architecture is designed to ensure redundancy and failover reliability, aligning with the principles of Software-Defined Networking (SDN).\nFigure 6.11.2.1-1: Architecture for CAPIF with SNA enhancement\nThis solution uses an architecture proposed in solution #2 of TR 23.700-95 [3]. As defined in TR 23.700-95 [3], the Resource owner client is an application client used by end-user or subscriber of the API provider domain's service provider.\nPre-requisite:\n1.\tDuring the primary authentication, AUSF receives SNAAPPY Indication from UDM, which indicates that the AUSF and the UE need to generate the following pre-requisite 2.\n2.\tAfter the primary authentication, UE and AUSF generate SNAAPPY Key Identifier (S-KID) and KSNAAPPY from KAUSF as detailed in 6.11.2.3 and 6.11.2.4 of the present document, respectively. After the S-KID and KSNAAPPY are generated, AUSF sends the KSNAAPPY, S-KID, and SUPI to Authorization Function. The Authorization Function stores this information sent by the AUSF. If there were KSNAAPPY and S-KID corresponding to the same SUPI, they are overridden by the new KSNAAPPY and S-KID.\nThe figure depicts a procedure for resource owner authorization based API invocation, illustrating the steps involved in obtaining authorization for a specific resource. The figure includes a flowchart with various stages, such as obtaining the resource owner's consent, validating the request, and handling exceptions. The visual elements, such as the flowchart and the labels, help to clearly communicate the process and ensure that the user can understand the steps involved.\nFigure 6.11.2.2-1: Procedure for resource owner authorization based API invocation\n1.\tAfter API Invoker performs onboarding procedure to CAPIF core function as specified in clause 6.1 of TS 33.122 [5], the API Invoker mutually authenticates with the CAPIF core function as specified in clause 6.3 of TS 33.122 [5].\n2.\tAPI Invoker performs mutual authentication with API exposing function and gets an authorization to invoke a service API using one of three methods specified in clause 6.5 of TS 33.122 [5].\n3.\tFor a service API which needs a resource owner's authorization, the API Invoker shall get an authorization from the resource owner in addition to the authorization that was obtained in step 2.\n4.\tThe API Invoker obtains Authorization Code via OAuth 2.0 Authorization Code Grant as specified in RFC 6749 [4]. While the API Invoker redirects the UE to the Authorization Function, the API Invoker includes requested scope (e.g. modify QoS, location etc.) and the UE sends a challenge_UE, S-KID, and SNAAPPY indicator, which indicates that the UE supports the resource owner authentication with KSNAAPPY, to the Authorization Function. If the Authorization Function decides to authenticate the resource owner using KSNAAPPY, the Authorization Function generates authentication material (e.g. MAC generated using the challenge_UE and KSNAAPPY which the Authorization Function can find based on the S-KID), and sends a challenge_AF and the authentication material to the UE. After UE verifies the authentication material the Authorization Function sent, UE responds with authentication material (e.g. MAC generated using the challenge_AF and KSNAAPPY). The Authorization Function verifies the authentication material using KSNAAPPY. In addition to the authentication, the Authorization Function obtains authorization from the resource owner by showing the requested scope that the API Invoker sent and API Invoker information (e.g. API Invoker identity) before sending Authorization Code to the API Invoker.\nNOTE 1:\tAlthough the Authorization Function is illustrated as a separate entity from CAPIF core function in Figure 6.11.2.2-1, it may be deployed within the CAPIF core function according to the decision in SA3.\nNOTE 2: \tOther authentication method between the resource owner and the Authorization Function can be additionally performed before the Authorization Function obtains authorization from the resource owner.\nNote 3: Which entity in the UE executes step 4 is not specified in the present document.\n1.\tThe Authorization Function generates an OAuth 2.0 token, TokenSNAAPPY. The TokenSNAAPPY conveys the S-KID or GPSI which is not MSISDN and the generated time of the TokenSNAAPPY, in addition to the token claims specified in Annex C.2.2 of TS 33.122 [5].\n2.\tThe API Invoker requests the TokenSNAAPPY from the Authorization Function by presenting the Authorization Code sent by the Authorization Function in step 4.\n3.\tThe Authorization Function sends the TokenSNAAPPY to the API Invoker.\n4.\tThe API Invoker performs the service API invocation by presenting the TokenSNAAPPY.\n5.\tAPI exposing function checks whether the API Invoker is authorized to invoke the service API based on the selected authorization method in step 2. If the API Invoker requested a service API that needs resource owner's authorization, API exposing function shall check whether the API Invoker presented a TokenSNAAPPY. If the API Invoker performed the service API invocation without TokenSNAAPPY in step 8, the API exposing function shall reject the request. If the verification of the TokenSNAAPPY is successful, API exposing function identifies the UE using the S-KID or GPSI which is included in the TokenSNAAPPY, possibly by communicating with the Authorization Function that stored the S-KID and SUPI.\n6.\tAPI Invoker receives the service API invocation response from the API exposing function.\n7.\tIf the resource owner does not want for the API Invoker to invoke the service API, the resource owner can revoke the TokenSNAAPPY at anytime even before the validity time of the TokenSNAAPPY.\n8.\tThe UE requests the API Invoker to revoke the TokenSNAAPPY for the service API. This step is performed when e.g. the resource owner uninstalls the application on the UE or logouts from the application as described in RFC 7009 [7], or the resource owner clicks a revocation button on the application.\n9.\tThe API Invoker requests the Authorization Function to revoke the TokenSNAAPPY for the service API as specified in RFC 7009 [7].\n10.\tIf the Authorization Function receives a revocation request for TokenSNAAPPY,\na)\tThe Authorization Function responds to the revocation request. The response includes revocation time and the TokenSNAAPPY with MAC which the Authorization Function generates using the TokenSNAAPPY, revocation time, and KSNAAPPY; and\nb)\tThe Authorization Function notifies the API exposing function of the revocation of the TokenSNAAPPY, with the revocation time. After the API exposing function receives the revocation notification of the TokenSNAAPPY, the API exposing function shall reject the API invocation from the API Invoker if the API Invoker invokes the service API with TokenSNAAPPY of which the generated time is prior to the revocation time.\n11.\t The UE verifies the MAC using KSNAAPPY. The UE may inform the resource owner of the revocation result based on the verification.\nS-KID is in NAI format as specified in clause 2.2 of IETF RFC 7542 [11], i.e. username@realm. The username part includes SNAAPPY Temporary UE Identifier (S-TID), and the realm part includes Home Network Identifier or Authorization Function Address.\nWhen deriving S-TID from KAUSF, the following parameters shall be used to form the input S to the KDF:\n-\tFC = 0xXX;\n-\tP0 = \"S-TID\";\n-\tL0 = length of \"S-TID\";\n-\tP1 = SUPI;\n-\tL1 = length of SUPI.\nThe input key KEY shall be KAUSF.\nNOTE:\tFC value to be determined during normative phase.\nWhen deriving KSNAAPPY from KAUSF, the following parameters shall be used to form the input S to the KDF:\n-\tFC = 0xYY;\n-\tP0 = \"Authorization\";\n-\tL0 = length of \"Authorization\";\nThe input key KEY shall be the KAUSF.\nNOTE:\tFC value to be determined during normative phase.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.11.3\tEvaluation",
                            "text_content": "This solution addresses KI#2.\nThis solution uses OAuth 2.0 Authorization Code Grant model where mutual authentication between UE and Authorization Function is performed using the key derived from 3GPP credential after API Invoker redirects the UE to the Authorization Function.\nThis solution introduces a new mechanism for the revocation check of OAuth 2.0 token by including the token generation time in the OAuth 2.0 token and sending the token revocation time from Authorization Function to API exposing function.\nThis solution prevents the API Invoker from acting like the token, which the resource owner requested to revoke, is revoked by sending the revoked token with MAC, which is generated using KSNAAPPY, from Authorization Function to the UE via API Invoker.\nThis solution requires access to the 5G key hierarchy and will only work with a 5G authenticated UE.\nImpact on AUSF exists, i.e. AUSF generates a new key (KSNAAPPY) with corresponding identifier (S-KID) and sends them to Authorization Function.\nThe resource owner cannot enforce a malicious API invoker to actually revoke a token.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.12\tSolution #12: Providing and Revoking Resource Owner Authorization",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.12.1\tIntroduction",
                            "text_content": "This solution addresses Key Issue #2 \"Checking authorization before allowing access\".\nThis solution proposes to use a resource owner's 3GPP credentials for UE to generate a token, which is used to validate an API Invoker accessing the resource owner's resources.\nA resource owner in this solution is an end-user who is using the UE.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.12.2\tSolution details",
                            "text_content": "The figure depicts a complex network architecture for a communication platform called CAPIF, which stands for Centralized Access Point Infrastructure. The architecture includes a combination of wired and wireless components, with a focus on enhancing the security and performance of the network. Key components include the access point (AP), which serves as the central point of communication, and the wireless access points (WAPs), which provide wireless connectivity to the users. The figure also includes a set of security measures, such as encryption and authentication protocols, to ensure the confidentiality and integrity of the data transmitted over the network. Overall, the architecture is designed to provide a robust and secure communication platform for users.\nFigure 6.12.2.1-1: Architecture for CAPIF with SNA enhancement\nThis solution uses an architecture proposed in solution #2 of TR 23.700-95 [3]. As defined in TR 23.700-95 [3], the Resource owner client is an application client used by end-user or subscriber of the API provider domain's service provider.\nPre-requisite:\n-\tDuring the primary authentication, AUSF receives Routing Indicator for Authorization Function from UDM.\n-\tAfter the primary authentication, UE and AUSF generate S-KID (SNAAPPY Key Identifier) and KAuz from KAUSF as detailed in clauses 6.12.2.3 and 6.12.2.4 of the present document, respectively. After the key material is generated, AUSF selects the Authorization Function based on the Routing Indicator and sends the KAuz, S-KID, and SUPI to the Authorization Function. The Authorization Function stores the latest information sent by the AUSF.\n-\tInformation on Authorization Function (e.g. address, Routing Indicator, etc.) which holds the KAuz is provisioned to the UE (e.g. during registration procedure).\n-\tAPI Invoker knows which APIs require a resource owner's authorization.\nThe figure depicts a procedure for resource owner authorization based API invocation, illustrating the steps involved in obtaining authorization for a specific resource. The figure includes a flowchart with arrows indicating the sequence of actions, a list of steps, and a legend to clarify the meaning of each step. The figure is designed to be easily understood and follows a standard format for API documentation, making it a useful tool for developers and administrators to understand the process of obtaining authorization for a specific resource.\nFigure 6.12.2.2-1: Procedure for resource owner authorization based API invocation\n1.\tIf API Invoker does not have TokenAuz for service API invocation which requires the resource owner's authorization, API Invoker needs to request resource owner's authorization for the API invocation even if the API invocation is authorized from API exposing function as defined in TS 33.122 [5].\n2.\tAPI Invoker requests resource owner's authorization for the API invocation. The request message includes Service API name (e.g. QoS API, location API, etc.) and API Invoker Information (e.g. API Invoker identity which is provided from CAPIF Core Function).\n3.\tWhen the resource owner decides to give an authorization on the Service API name to the API Invoker (e.g. using GUI), UE generates an authorization token (TokenAuz). The claims of the TokenAuz include service API name, S-KID (SNAAPPY Key Identifier), API Invoker Information, \"Authorized\", generated time, and validity time. TokenAuz contains the claims (TokenAuz, claim) and the verification information (TokenAuz, verify). Details of S-KID and the corresponding key KAuz are specified in clauses 6.12.2.3 and 6.12.2.4 of the present document, respectively. TokenAuz, verify is generated as detailed in clause 6.12.2.5 by using the claims and the key KAuz.\nNote: \tWhich entity in the UE executes step 3 is not addressed in the present document.\n4.\tIf the resource owner gives the authorization for the API invocation, UE responds with the TokenAuz. Upon receiving the response, the API Invoker stores the TokenAuz with UE ID (e.g. application layer ID or GPSI or SUPI). The API Invoker can use the TokenAuz for the API invocation until the TokenAuz is expired by an expiration time or revoked by the resource owner, even when there is no online connection between the API Invoker and the UE.\n5.\tAPI Invoker performs the service API invocation with the TokenAuz.\n6.\tAPI exposing function requests token verification to Authorization Function, via CAPIF-9 interface.\n7.\tAuthorization Function finds KAuz matched to S-KID which is included in TokenAuz, claim and verifies the TokenAuz using KAuz.\n8.\tAuthorization Function responds with the verification result and UE ID (SUPI or GPSI).\n9.\tIf the verification result of the TokenAuz is successful, API exposing function stores the TokenAuz with UE ID (SUPI or GPSI). Until API exposing function receives a revocation notification for the service API invocation or the TokenAuz is expired by an expiration time, API exposing function uses the stored TokenAuz for authorizing the API Invoker without performing token verification request to Authorization Function.\n10.\tAPI Invoker receives the service API invocation response.\n11.\tIf the resource owner does not want for the API Invoker to invoke the service API, the resource owner can revoke the TokenAuz anytime before the validity time of the TokenAuz by using resource owner client. When the resource owner decides to revoke the TokenAuz for the service API, UE generates a revocation token (TokenRev). The claims of TokenRev include service API name, A-KID, API Invoker information, \"Not authorized\", generated time. TokenRev contains the claims (TokenRev, claim) and the verification information (TokenRev, verify). TokenRev, verify is generated as detailed in clause 6.12.2.5 by using the claims and the key KAuz.\n12.\tUE and Authorization function perform mutual authentication based on TLS-PSK as specified in clause 6.5.2.1 in TS 33.122, where PSK can be derived from KAuz. The TokenRev is transmitted to Authorization Function via CAPIF-8 interface with revocation request message.\n13.\tAuthorization Function finds KAuz by using S-KID which is included in the TokenRev, claim. Authorization Function verifies the TokenRev using KAuz.\n14.\tAuthorization Function notifies the revocation on the API Invoker's service API invocation. The revocation notification includes the TokenRev and UE ID.\n15.\tFor the same UE ID stored at step 9 and received at step 14, API exposing function finds the TokenAuz which has same service API name and API Invoker information as the TokenRev. If the generated time of the TokenAuz is prior to that of the TokenRev, API exposing function revokes the TokenAuz and stores the TokenRev. After this, if the API Invoker performs service API invocation using the revoked TokenAuz, API exposing function shall reject the API invocation request by noticing that the generation time in the TokenAuz is prior to the generation time in the TokenRev.\n16.\tAPI exposing function notifies the revocation of the token.\nS-KID is in NAI format as specified in clause 2.2 of IETF RFC 7542 [11], i.e. username@realm. The username part includes the Routing Indicator for Authorization Function and S-TID (SNAAPPY Temporary UE Identifier), and the realm part includes Home Network Identifier.\nWhen deriving S-TID from KAUSF, the following parameters shall be used to form the input S to the KDF:\n-\tFC = 0xXX;\n-\tP0 = \"S-TID\";\n-\tL0 = length of \"S-TID\";\n-\tP1 = SUPI;\n-\tL1 = length of SUPI.\nThe input key KEY shall be KAUSF.\nNOTE:\tFC value to be determined during normative phase.\nWhen deriving KAuz from KAUSF, the following parameters shall be used to form the input S to the KDF:\n-\tFC = 0xYY;\n-\tP0 = \"Authorization\";\n-\tL0 = length of \"Authorization\";\nThe input key KEY shall be the KAUSF.\nNOTE:\tFC value to be determined during normative phase.\nWhen deriving the verification information (TokenAuz, verify or TokenRev, verify) from KAuz, the following parameters shall be used to form the input S to the KDF.\n-\tFC = 0xZZ;\n-\tP0 = TokenAuz, claim or TokenRev, claim;\n-\tL0 = length of TokenAuz, claim or TokenRev, claim;\nThe input key KEY shall be KAuz.\nThe verification information is identified with the 128 least significant bits of the output of the KDF.\nNOTE:\tFC value to be determined during normative phase.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.12.3\tEvaluation",
                            "text_content": "This solution addresses KI#2.\nThis solution uses similar mechanism as users of mobile phone giving a permission to application for access to resources such as phonebook, microphone, camera, etc. When the resource owner authorizes an API Invoker, UE uses KAuz, which the API Invoker cannot obtain, to generate an authorization token (TokenAuz) sends the token to API Invoker. After verifying the token that API Invoker presented, API exposing function responds to API invocation request from API Invoker.\nThis solution does not use OAuth 2.0 procedure.\nThis solution introduces a new mechanism for the revocation check of a token by including the token generation time in an authorization token and the token revocation time in a revocation token.\nImpact on AUSF exists, i.e. AUSF generates a new key (KAUZ) with corresponding identifier (S-KID) and sends them to Authorization Function.\nThe solution requires the UE to be authenticated to a 5G core.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.13\tSolution #13: Resource owner policies based authorization mechanism",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.13.1\tIntroduction",
                            "text_content": "This solution addresses the key issue #1 and key issue #2 in terms of API invocation authorization.\nIn this solution, authorization mechanisms in TS 33.122 [5] are reused.\nThe API invoker can be authorized by the AEF without using the OAuth 2.0 token.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.13.2\tSolution details",
                            "text_content": "The resource owner provisions policies to the CAPIF core function/authorization function via the UE.\nThe authentication and authorization to resource owner (i.e. the human who uses the UE) is left to implementation.\nBy reusing the authorization mechanism in clauses 6.5.2.1 and 6.5.2.2 of TS 33.122 [5], the AEF can obtain resource owner related policies from the CAPIF core function/authorization function and authorize the API invoker to request resources belonging to the owner.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.13.3\tEvaluation",
                            "text_content": "This solution requires no additional specification.\nThis solution does not detail how the resource owner is authenticated.\nThis solution does not detail how the resource owner provides authorization.\nAuthorization needs to be provided in advance of calling the API.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.14\tSolution #14: Reusing CAPIF core function initiated revocation procedure to enable user authorization revocation",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.14.1\tIntroduction",
                            "text_content": "This solution addresses the key issue #2 in terms of authorization revocation.\nThe CAPIF core function/authorization function reuses clause 8.23.4 of TS 23.222 [12] to complete the revocation procedure.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.14.2\tSolution details",
                            "text_content": "It is assumed that the API invoker is an UE/AF in SNA scenarios.\nThe figure depicts a user authorization revocation process for API invocation procedures, illustrating the steps involved in revoking access to an API. The figure includes a flowchart with arrows indicating the sequence of actions, a list of steps, and a legend to clarify the meaning of each step. The figure is a visual representation of the process, making it easier to understand and follow.\nFigure 6.14.2-1: User authorization revocation for API invocation procedure.\n0.\tThe API invoker obtains the service API invocation authorization from the resource owner. Specifically, the resource indicates the location information, QoS information, etc. And the API invoker is an UE/AF.\n1.\tIt is assumed that the authorization is revoked.\nAccording to clause 8.23.3 of TS 23.222 [12], the CAPIF core function can run Revoke_Authorization.\nThe UE/resource owner client can reuse the Revoke_Authorization API to provide revocation information to the CAPIF core function/authorization function.\nThen the CAPIF core function/Authorization function contains the revocation information.\nThe revocation information includes the identity (e.g. GPSI, IMPI) of the API invoker, the identity (e.g. GPSI, IMPI) of the resource owner, the target resource identifier (e.g. location, QoS), and the target service API.\n2.\tThe CAPIF core function/authorization function reuses the procedures in clause 8.23.4 of TS 23.222 [12] to complete the authorization revocation.\nThe CAPIF core function should send revocation information, which is received from the resource owner, to the AEF.\nThe AEF invalidates the authorization based on the revocation information.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.14.3\tEvaluation",
                            "text_content": "This solution reuses the authorization revocation mechanism defined in clause 8.23.4 of TS 23.222 [12].\nThe impacts of the solution are given as follows.\nThe authorization revocation mechanism defined in clause 8.23.4 of TS 23.222 [12] is reused with the following modifications:\n-\tThe revocation information/polices stored in CAPIF core function/Authorization function include the identity (e.g. GPSI, IMPI) of the resource owner and the target resource identifier (e.g. location, QoS).\n-\tRevocation information/polices received by the AEF include the identity (e.g. GPSI, IMPI) of the resource owner and the target resource identifier (e.g. location, QoS).\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.15\tSolution #15: Authorization revocation to undo API invocation",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.15.1\tIntroduction",
                            "text_content": "The oAuth view of authorization revocation and the user's view of authorization revocation may differ. Revocation of an oAuth token will ensure no unauthorized calls to an API after the authorization has been revoked. However, a user may expect that the effects of a previous API call would also be reverted.\nFor example: if a user gives permission to a game to upgrade the QoS of the game's bearer (potentially incurring additional cost), the user would expect that after revocation of the authorization, the game's bearer stop incurring additional cost (and fall back to the regular QoS).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.15.2\tSolution details",
                            "text_content": "When an authorization is revoked, the authorization function shall notify the API exposing function. The API exposing function then shall revert the resources inside the network according to the content of the notification (e.g. reverting the QoS).\nThe figure depicts a resource reversal after token revocation, which is a critical security measure in 5G networks. It shows how the network reroutes traffic to a different path to prevent unauthorized access. The figure illustrates the process with a red arrow indicating the reversal, and the text below provides a detailed explanation of the security mechanism.\nFigure 6.15.2-1: Resource reversal after token revocation\n1.\tThe API exposing function shall subscribe at the authorization function to token revocation. This could be for all tokens relating to a particular authorization, or for specific tokens after they are encountered first.\n2.\tAt some time, the resource owner decides to revoke authorization. The procedure to do this is out of scope of this solution (and could be left to implementation).\n3.\tThe authorization function shall notify the subscribed API exposing function of the token revocation.\n4.\tThe API exposing function shall determine whether resources need to be reverted, e.g. QoS, subscription to network events, etc.) Subsequently, the API exposing function shall revert the resources in the network.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.15.3\tEvaluation",
                            "text_content": "This solution allows the AEF to ensure that persistent changes can be undone after authorization revocation. It partly addresses Authz-5-revoke.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.16\tSolution #16: Token Revocation using Short-lived Token",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.16.1\tIntroduction",
                            "text_content": "This solution addresses the requirement Authz-5-Revoke in KI#2.\nThis solution proposes to use a short-lived token for an issued token. The authorization can be revoked automatically if an API invoker does not refresh the issued token. There is no impact on the AEF.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.16.2\tSolution details",
                            "text_content": "The figure depicts a procedure for revoking OAuth authorization, which is a crucial step in ensuring secure access to a user's data. The figure shows a flowchart with various steps, including obtaining the user's consent, validating the user's identity, and revoking the authorization. The steps are clearly labeled and visually represented, making it easy to understand the process.\nFigure 6.16.2-1: Procedure of Revocation of OAuth Authorization\n0. It is assumed that requirement for revocation is received in CCF.\n1. The API Invoker sends the Token Request to the CCF to retrieve a token to access the discovered API.\n2. The CCF issues a token with a short expiry time when receiving the requirement for revocation, e.g. 1 hour.\n3. The CCF sends the Token Response to the API Invoker. The message includes the issued token. Once revocation is required by the resource owner, e.g. to log out, the API invoker stops refreshing the token, which will be revoked within the short expiry time.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.16.3\tEvaluation",
                            "text_content": "This solution partially addresses the requirement Authz-5-Revoke in KI#2, i.e. using a short-lived token instead of revoking explicitly at any time.\nThe solution has impact on CCF/authorization function.\nThe authorization is revoked implicitly and has less impact for the network system, i.e. the solution has no impact on the AEF.\nThe solution does not detail how to revoke effects of previous API calls.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "7\tConclusions",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "7.0\tHigh level conclusions",
                    "description": "",
                    "summary": "",
                    "text_content": "This conclusions are for enhancing CAPIF regarding resource owner awareness. Existing mechanisms without resource owner awareness are still available.\n-\tAuthorization function is part of CCF.\n-\thttps is used as protocol between OAuth client and authorization server on the CCF.\nUse case A: AF outside of UE is API invoker\n-\tFor mutual authentication of API invoker AF and API exposing function in this use case, TS 33.122 [5] is reused.\n-\tFor mutual authentication of API invoker AF and CCF in this use case, TS 33.122 [5] is reused.\n-\tFor authorization, the OAuth2.0 Framework is used. The API invoker has the role of the OAuth client.\n-\tThe SNA token can contain the resource owner identity claim and other claims. AEF should do the authorization check to the API invocation request containing the token against the claims including the resource owner identity.\n-\tAuthorization code flow, PKCE flow and client credential flow provide a different user experience and support different application needs. Thus these three flows are candidates to be considered as options for normative work.\n-\tThe claim in the token includes resource owner identity, thus there is no need for additional UE authentication in API invocation.\n-\tFor Authorization Code Flow and PKCE, authentication between CCF/AUF and UE should be performed after API Invoker redirects the UE to CCF/AUF.\n- \tBased on the operator's policy, mutual authentication between resource owner and CCF/AUF can be performed.\n-\tthe authentication method is up to operator policy (e.g. an already deployed mechanism, or AKMA, or GBA) and therefore no additional specification is foreseen for the authentication method.\nUse case B: API invoker residing on UE accessing its own resources\nConclusions applicable to both Subcase B.i) and B.ii) below:\nThe conclusions for case A also apply to Subcases B.i) and B.ii) with the following differences:\n-\twhether API invoker onboarding needs to be specified is left to the normative phase\n-\twhether and howAPI invoker needs to be authenticated is left to the normative phaseSubcase B.i) API invoker part of third party application (e.g. single page application)\nSubcase B.ii) API invoker part of UE accessing its own resources\nGeneral open issues:\nUE A accessing resource of UE B is out of scope of the present document.\nSubscriber vs UE as resource owner:\n-\tRegulatory requirements can affect whether UE user or subscriber is considered resource owner. Therefore, it is left to configuration or implementation in the authorization function (i.e. CCF) whose authentication (subscriber or UE) is required for authorizing access to a specific resource.\n-\tWithin the token, GPSI is used as identifier. GPSI needs to be different from MSISDN, SUPI etc.  How to identify the resources is left for stage 3 work. The token should be able to restrict the API invoker to a specific resource (e.g., location, QoS, PDN connectivity status).\nConclusion for revocation:\n-\tOne or multiple revocation mechanisms are required.\n-\tAPI Exposing Function needs to be informed about revocation if this is necessary to ensure correct handling of revocation. Details how to minimize AEF impacts will be handled in the normative phase.\n\n\n\n",
                    "tables": [
                        {
                            "description": "",
                            "table number": 3,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        }
    ]
}