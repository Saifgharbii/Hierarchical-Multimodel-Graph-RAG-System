{
    "document_name": "33122-i20.docx",
    "content": [
        {
            "title": "Foreword",
            "description": "This Technical Specification has been produced by the 3rd Generation Partnership Project (3GPP).\nThe contents of the present document are subject to continuing work within the TSG and may change following formal TSG approval. Should the TSG modify the contents of the present document, it will be re-released by the TSG with an identifying change of release date and an increase in version number as follows:\nVersion x.y.z\nwhere:\nx\tthe first digit:\n1\tpresented to TSG for information;\n2\tpresented to TSG for approval;\n3\tor greater indicates TSG approved document under change control.\ny\tthe second digit is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc.\nz\tthe third digit is incremented when editorial only changes have been incorporated in the document.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "1\tScope",
            "description": "The present document specifies the security architecture i.e., the security features and the security mechanisms for the common API framework (CAPIF) as per the architecture and procedures defined in 3GPP TS 23.222 [3].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "2\tReferences",
            "description": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non-specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\t3GPP TS 33.310: \"Network Domain Security (NDS); Authentication Framework (AF)\".\n[3]\t3GPP TS 23.222: \"Common API Framework for 3GPP Northbound APIs\".\n[4]\tIETF RFC 6749: \"The OAuth 2.0 Authorization Framework\".\n[5]\tIETF RFC 6750: \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\".\n[6]\tIETF RFC 7519: \"JSON Web Token (JWT)\".\n[7]\tIETF RFC 7515: \"JSON Web Signature (JWS)\".\n[8]\t3GPP TS 33.220: \"Generic Authentication Architecture (GAA); Generic Bootstrapping Architecture (GBA)\".\n[9]\tVoid\n[10]\t3GPP TS 33.210: \"3G security; Network Domain Security (NDS); IP network layer security\".\n[11]\tIETF RFC 7636: \" Proof Key for Code Exchange by OAuth Public Clients\".\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "3\tDefinitions, symbols and abbreviations",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "3.1\tDefinitions",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the terms and definitions given in 3GPP TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [1].\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.2\tSymbols",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the following symbols apply:\nAEFPSK\tPre-Shared Key for AEF\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.3\tAbbreviations",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [1].\nAEF\tAPI Exposing Function\nAPI\tApplication Programming Interface\nCAPIF\tCommon API Framework\nJSON\tJavaScript Object Notation\nJWT\tJSON Web Token\nKDF\tKey Derivation Function\nPKI\tPublic Key Infrastructure\nPSK\tPre-Shared Key\nRNAA\tResource owner-aware northbound API access\nTLS\tTransport Layer Security\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "4\tSecurity requirements",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "4.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "Architectural requirements pertaining to CAPIF security are found in 3GPP TS 23.222 [3]. The following are CAPIF derived security requirements.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.2\tCommon security requirements",
                    "description": "",
                    "summary": "",
                    "text_content": "Security requirements that are applicable to all CAPIF entities are:\n-\t[CAPIF-SEC-4.2-a] The CAPIF shall provide mechanisms to hide the topology of the PLMN trust domain from the API invokers accessing the service APIs from outside the PLMN trust domain.\n-\t[CAPIF-SEC-4.2-b] The CAPIF shall provide mechanisms to hide the topology of the 3rd party API provider trust domain from the API invokers accessing the service APIs from outside the 3rd party API provider trust domain.\n-\t[CAPIF-SEC-4.2-c] The CAPIF shall provide authorization mechanism for service APIs from the 3rd party API providers.\n-\t[CAPIF-SEC-4.2-d] The CAPIF shall support a common security mechanism for all API implementations to provide confidentiality and integrity protection.\n-\t[CAPIF-SEC-4.2-e] API invoker authentication and authorization shall support all deployment models listed in 3GPP TS 23.222 [3].\n-\t[CAPIF-SEC-4.2-f] The API invoker and CAPIF should enforce the result of the authentication for the duration of communications (e.g. by integrity protection or implicit authentication by encryption with a key that is derived from the authentication and is unknown to the adversary).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.3\tSecurity requirements on the CAPIF-1/1e reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "The CAPIF-1/1e reference points between the API invoker and the CAPIF core function shall fulfil the following requirements:\n-\t[CAPIF-SEC-4.3-a] Mutual authentication between the API invoker and the CAPIF Core function shall be supported.\n-\t[CAPIF-SEC-4.3-b] The transport of messages over the CAPIF-1 and CAPIF-1e reference points shall be integrity protected.\n-\t [CAPIF-SEC-4.3-c] The transport of messages over the CAPIF-1 and CAPIF-1e reference points shall be protected from replay attacks.\n-\t [CAPIF-SEC-4.3-d] The transport of messages over the CAPIF-1 and CAPIF-1e reference points shall be confidentiality protected.\n-\t [CAPIF-SEC-4.3-e] Privacy of the 3GPP user over the CAPIF-1 and CAPIF-1e reference points shall be protected.\n-\t [CAPIF-SEC-4.3-f] The CAPIF core function shall authorize the API invoker prior to the API invoker accessing the AEF.\n-\t [CAPIF-SEC-4.3-g] The CAPIF core function shall authorize the API invoker prior to accessing the discover service API.\n-\t [CAPIF-SEC-4.3-h] The CAPIF core function shall authenticate the API invoker's onboarding request.\n-\t [CAPIF-SEC-4.3-i] The CAPIF core function shall authenticate the API invoker's offboarding request.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.4\tSecurity requirements on the CAPIF-2/2e reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "The CAPIF-2/2e reference points between the API invoker and API exposing function shall fulfil the following requirements:\n-\t [CAPIF-SEC-4.4-a] Mutual authentication between the API invoker and the API exposing function shall be supported.\n-\t [CAPIF-SEC-4.4-b] The transport of messages over the CAPIF-2 and CAPIF-2e reference points shall be integrity protected.\n-\t [CAPIF-SEC-4.4-c] The transport of messages over the CAPIF-2 and CAPIF-2e reference points shall be protected from replay attacks.\n-\t [CAPIF-SEC-4.4-d] The transport of messages over the CAPIF-2 and CAPIF-2e reference points shall be confidentiality protected.\n-\t [CAPIF-SEC-4.4-e] Privacy of the 3GPP user over the CAPIF-2 and CAPIF-2e reference points shall be protected.\n-\t [CAPIF-SEC-4.4-f] The API exposing function shall determine whether API invoker is authorized to access service API.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.5\tSecurity requirements on the CAPIF-3/4/5 reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "The security requirements for CAPIF-3/4/5 reference points are:\n-\t [CAPIF-SEC-4.5-a] The transport of messages over the CAPIF-3/4/5 reference points shall be integrity protected.\n-\t [CAPIF-SEC-4.5-b] The transport of messages over the CAPIF-3/4/5 reference points shall be confidentiality protected.\n-\t [CAPIF-SEC-4.5-c] The transport of messages over the CAPIF-3/4/5 reference points shall be protected from replay attacks.\n-\t [CAPIF-SEC-4.5-d] The CAPIF core function shall be able to authenticate the service API publishers to publish and manage the service API information.\n-\t [CAPIF-SEC-4.5-e] The CAPIF core function shall be able to authorize the service API publishers to publish and manage the service API information.\n-\t [CAPIF-SEC-4.5-f] The CAPIF core function shall be able to request explicit grant of new API invoker’s onboarding.\n-\t[CAPIF-SEC-4.5-g] The CAPIF core function shall be able to authenticate the API Management function’s registration request for API Provider domain functions.\n-\t[CAPIF-SEC-4.5-h] The CAPIF core function shall be able to authenticate the API Management function’s registration update request for API provider domain functions.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.6\tSecurity requirements on the CAPIF-3e/4e/5e reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "The security requirements for CAPIF-3e/4e/5e reference points are:\n-\t [CAPIF-SEC-4.6 -a] The transport of messages over the CAPIF-3e/4e/5e reference points shall be integrity protected.\n-\t [CAPIF-SEC-4. 6 -b] The transport of messages over the CAPIF-3e/4e/5e reference points shall be confidentiality protected.\n-\t [CAPIF-SEC-4. 6 -c] The transport of messages over the CAPIF-3e/4e/5e reference points shall be protected from replay attacks.\n-\t [CAPIF-SEC-4. 6 -d] The CAPIF core function shall be able to authenticate the service API publishers to publish and manage the service API information.\n-\t [CAPIF-SEC-4. 6 -e] The CAPIF core function shall be able to authorize the service API publishers to publish and manage the service API information.\n-\t [CAPIF-SEC-4. 6 -f] The CAPIF core function shall be able to request explicit grant of new API invoker’s onboarding.\n-\t[CAPIF-SEC-4.6-g] The CAPIF core function shall be able to authenticate the API Management function’s registration request for API Provider domain functions.\n-\t[CAPIF-SEC-4.6-h] The CAPIF core function shall be able to authenticate the API Management function’s registration update request for API provider domain functions.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.7\tSecurity requirements on the CAPIF-7/7e reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "The security requirements for CAPIF-7/7e reference points are:\n-\t[CAPIF-SEC-4.7-a] The transport of messages over the CAPIF-7 and CAPIF-7e reference points shall be integrity protected.\n-\t[CAPIF-SEC-4.7-b] The transport of messages over the CAPIF-7 and CAPIF-7e reference points shall be protected from replay attacks.\n-\t[CAPIF-SEC-4.7-c] The transport of messages over the CAPIF-7 and CAPIF-7e reference points shall be confidentiality protected.\n-\t[CAPIF-SEC-4.7-d] Privacy of the 3GPP user over the CAPIF-7 and CAPIF-7e reference points shall be protected.\n-\t[CAPIF-SEC-4.7-e] The API exposing function (destination AEF handling service API) shall determine whether AEF that is topology hiding entity, is authorized to access service API.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.8\tSecurity requirements on the CAPIF-8reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "CAPIF-8 interface is not in scope of 3GPP. Nevertheless, integrity and confidentiality protection, protection against replay attacks, privacy of the resource owner, authentication between the resource owner and the CCF need to be addressed by mechanism(s) which are out of 3GPP scope.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "5\tFunctional security model",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "5.1\tGeneral functional security model",
                    "description": "",
                    "summary": "",
                    "text_content": "Figure 5.1-1 shows the functional security model for the CAPIF architecture. The interfaces CAPIF-1, CAPIF-1e, CAPIF-2, CAPIF-2e, CAPIF-3, CAPIF-4, CAPIF-5, CAPIF-3e, CAPIF-4e, CAPIF-5e, CAPIF-7 and CAPIF-7e are defined in 3GPP TS 23.222 [3] and support the CAPIF functionality defined in 3GPP TS 23.222 [3]. CAPIF-1, CAPIF-2, CAPIF-3, CAPIF-4, CAPIF-5 and CAPIF-7 are interfaces that lie within the PLMN trust domain while the CAPIF-1e, CAPIF-2e, CAPIF-3e, CAPIF-4e, CAPIF-5e and CAPIF-7e interfaces are CAPIF core and AEF access points for API Invokers outside of the PLMN trust domain.\nSecurity for the CAPIF-1, CAPIF-2, CAPIF-3, CAPIF-4, CAPIF-5 and CAPIF-7 interfaces support TLS and are defined in subclauses 6.2, 6.4 and 6.6 of the present document. Security for the CAPIF-1e, CAPIF-2e and CAPIF-7e interfaces support TLS, and are defined in subclause 6.3, subclause 6.5, and subclause 6.9 respectively.\nSecurity for the CAPIF-3e, CAPIF-4e and CAPIF-5e interfaces support NDS/IP security to secure communication between different IP security domains. This avoids multiple secure connections between API provider domain and CAPIF core domain by leveraging the NDS/IP security procedures specified in TS 33.210 [2].\nAuthentication and authorization are required for both API invokers that lie within the PLMN trust domain and API invokers that lie outside of the PLMN trust domain. For an API invoker that is outside of the PLMN trust domain, the CAPIF core function in coordination with the API exposing function utilizes the CAPIF-1e, CAPIF-2e and the CAPIF-3 interfaces to onboard, authenticate and authorize the API invoker prior to granting access to CAPIF services. Security flow diagrams for onboarding security, CAPIF-1e security and CAPIF-2e security can be found in Annex B. When the API invoker is within the PLMN trust domain, the CAPIF core function in coordination with the API exposing function perform authentication and authorization of the API invoker via the CAPIF-1, the CAPIF-2 and the CAPIF-3 interfaces prior to granting access to CAPIF services. Authentication and authorization of API invokers (both internal and external to the PLMN trust domain) is specified in clause 6 of the present document.\nThe figure depicts the functional security model of the CAPIF (Common Access Identity Framework), which is a key component of the 5G network. It illustrates the various security mechanisms and protocols that are used to protect the network from unauthorized access and ensure the security of the network. The figure includes key elements such as authentication, authorization, and access control, as well as the use of encryption and other security measures. The model is designed to be modular and flexible, allowing for the addition of new security mechanisms as needed.\nFigure 5-1: CAPIF functional security model\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "5.2\tFunctional security model supporting RNAA",
                    "description": "",
                    "summary": "",
                    "text_content": "Figure 5.2-1 shows the functional security architecture of CAPIF framework when RNAA is supported. The resource owner can be the user of the UE or the owner of the subscription depending on the use case and regulations.\nThe resource owner client (ROC) may be deployed on the UE.\nThe authorization function is a part of the CCF The API invoker is the OAuth client.. The OAuth client and the CCF shall communicate using https.\nDifferent functional security models can be envisioned for API invoker in relation to the ROC:\n-\tAPI invoker can be part of the UE and located on the device;\n-\tAPI invoker can be independent from the UE but still located on the device (e.g., deployed by a third party);\n-\tAPI invoker can be independent from the UE and located outside of the device (e.g., a game server).\n\n\nThe figure depicts a simplified representation of the CAPIF (Capability-based Information Flow Interchange Framework) supporting the RNAA (Network-based Authentication and Authorization) functional security model. The framework is designed to facilitate secure communication between different network layers, ensuring the integrity and confidentiality of data. The figure illustrates the flow of information, with the CAPIF acting as a bridge between the different network layers, facilitating the exchange of data and ensuring the security of the network.\nFigure 5.2-1: CAPIF supporting RNAA functional security model\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "6\tSecurity procedures",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "6.1\tSecurity procedures for API invoker onboarding",
                    "description": "",
                    "summary": "",
                    "text_content": "The API invoker and the CAPIF core function shall follow the procedure in this subclause to secure and authenticate the onboarding of the API invoker to the CAPIF core function. The API invoker and the CAPIF core function shall establish a secure session using TLS. Security profiles for TLS implementation and usage shall follow the provisions given in TS 33.310 [2], Annex E .\nWith a secure session established, the API Invoker sends an Onboard API Invoker Request message to the CAPIF core function. The Onboard API Invoker Request message carries an onboard credential obtained during pre-provisioning of the onboard enrolment information, which may be an OAuth 2.0 [4] access token. When the OAuth 2.0 token based mechanism is used as the onboarding credential, the access token shall be encoded as JSON web token as specified in IETF RFC 7519 [6], shall include the JSON web signature as specified in IETF RFC 7515 [7], and shall be validated per OAuth 2.0 [4], IETF RFC 7519 [6] and IETF RFC 7515 [7]. Other credentials may also be used (e.g. message digest).\nFigure 6.1-1 details the security information flow for the API invoker onboarding procedure. The OAuth 2.0 token based authentication credential is shown in this example.\n\nThe figure depicts a security procedure for API invoker onboarding, illustrating the steps involved in ensuring the security of the API invoker during the onboarding process. The figure includes a diagram of the security procedure, with arrows indicating the flow of information and the steps involved. The figure is labeled with the figure name \"Figure 6.1 -1: Secur ity procedure for API invoker onboarding,\" which provides a clear and concise title for the figure.\nFigure 6.1-1: Security procedure for API invoker onboarding\n1.\tAs a prerequisite to the onboarding procedure, the API invoker obtains onboarding enrolment information from the API provider domain. The onboarding enrolment information is used to authenticate and establish a secure TLS communication with the CAPIF core function during the onboarding process. The enrolment information includes details of the CAPIF core function (Address, and Root CA certificate) and includes an onboarding credential (the OAuth 2.0 [4] access token).\nNOTE 1:\tThe procedure used to obtain the enrolment information by the API invoker is out of scope of the present document.\n2.\tThe API invoker and CAPIF core function shall establish a secure session based on TLS (Server side certificate authentication). The API invoker shall use the enrolment information obtained in step 1 to establish the TLS session with the CAPIF core function.\n3.\tAfter successful establishment of the TLS session, the API invoker shall send an Onboard API invoker request message to the CAPIF core function along with the enrolment credential (OAuth 2.0 [4] access token). The API invoker generates the key pair {Private Key, Public key} and provides the public key along with the Onboard API invoker request.\n4.\tThe CAPIF core function shall validate the enrolment credential (OAuth 2.0 [4] access token). If validation of the credential (the OAuth 2.0 [4] access token in this example) is successful, the CAPIF core function shall generate an API invoker's profile as specified in TS 23.222 [3] which may contain the selected method for AEF authentication and authorization between the API Invoker and the AEF (see subclause 6.5.2). The CAPIF core function may generate API invoker's certificate on its own, for the assigned API invoker identity and public key. This certificate shall be used by the API invoker for subsequent authentication procedures with the CAPIF core function and may be used for establishing a secure connection and authentication with the API Exposing Function. The CAPIF core function may optionally generate an Onboard_Secret if the subscribed Service API uses Method 3 (as specified in clause 6.5.2.3 of the present document) for CAPIF-2e security. The Onboard_Secret value remains the same during the lifetime of the onboarding, and shall be bound to the CAPIF core function specific API Invoker ID.\nNOTE 2:\tWhen API invoker's client certificate is issued by the third party, then in Step 3 the API invoker can additionally include the certificate in Onboard API Invoker request message. If the CAPIF core function trusts the issuer of the API invoker's client certificate, then the CAPIF Core Function includes the provided certificate in the API invoker's profile, in step 4. It is up to the CAPIF domain policy to accept the client certificates issued by third party.\n5.\tThe CAPIF core function shall respond with an Onboard API invoker response message. The response shall include the CAPIF core function assigned API invoker ID, AEF Authentication and authorization information (if generated in step 4), API invoker's certificate and the API invoker Onboard_Secret (if generated by the CAPIF core function).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.2\tSecurity procedures for CAPIF-1 reference point",
                    "description": "",
                    "summary": "",
                    "text_content": "TLS shall be used to provide integrity protection, replay protection and confidentiality protection. The support of TLS is mandatory and optional to use based on the domain administrator's policy to protect interfaces within the trusted domain.\nThe procedure in subclause 6.3 of the present document shall be followed unless the security of CAPIF-1 reference point is provided by other means.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.3\tSecurity procedures for CAPIF-1e reference point",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.3.1\tAuthentication and authorization",
                            "text_content": "For authentication of the CAPIF-1e reference point, mutual authentication based on client and server certificates shall be performed between the CAPIF core function and the API invoker, using TLS.\nCertificate based authentication shall follow the profiles given in 3GPP TS 33.310 [2], subclauses 6.1.3a and 6.1.4a. The structure of the PKI used for the certificate is out of scope of the present document.\nTLS [9] shall be used to provide integrity protection, replay protection and confidentiality protection for CAPIF-1e interface. The support of TLS on CAPIF-1e interface is mandatory. Security profiles for TLS implementation and usage shall follow the provisions given in TS 33.310 [2], Annex E.\nThe API invoker and the CAPIF core function shall negotiate a security method that shall be used by the API invoker and the API exposing function for CAPIF-2e interface authentication and protection. After successful mutual authentication on CAPIF-1e interface, based on the API invoker's subscribed service APIs, access scenarios (whether the API invoker access the AEF prior to service API invocation or upon the service API invocation) and AEF capabilities, the CAPIF core function shall choose the security method and sends the chosen security methods along with the information required for authentication of the API invoker at the AEF to the API invoker. The information may include the validity time of the CAPIF-2e credentials. This is depicted in figure 6.3.1-1.\nPre-conditions:\n1.\tThe API invoker is onboarded with the CAPIF core function.\nThe figure depicts a selection of security methods to be used in the CAPIF-2/2e reference point, with various options presented for evaluation.\nFigure 6.3.1-1: Selection of security method to be used in CAPIF-2/2e reference point\n1.\tMutual authentication based on client and server certificates shall be established using TLS between the API invoker and the CAPIF core function. The client certificate that was provided to the API invoker as the result of successful onboarding is used based on the description in subclause 6.1 of the present document.\n2.\tThe API invoker may send CAPIF-2/2e security capability information to the CAPIF core function in the Security Method Request message, indicating the list of security methods that the API invoker supports over CAPIF-2/2e reference point for each AEF.\n3.\tThe CAPIF core function shall select a security method to be used over CAPIF-2/2e reference point for each requested AEF, taking into account the information from the API invoker in step 2, access scenarios and AEF capabilities.\n4.\tThe CAPIF core function shall send Security Method Response message to the API invoker, indicating the selected security method for each AEF, any security information related to the security method. The API invoker shall use this method in the subsequent communication establishment with the API exposing function over CAPIF-2/2e reference point, as described in subclause 6.5 of the present document.\nAfter successful authentication between API invoker and CAPIF core function, the CAPIF core function shall decide whether the API invoker is authorized to perform discovery based on API invoker ID and discovery policy.\nWhen topology hiding is enabled, the CAPIF core function shall respond to service APIs discovery requests with AEF information, which exposes the service API and acts as topology hiding entity.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.4\tSecurity procedures for CAPIF-2 reference point",
                    "description": "",
                    "summary": "",
                    "text_content": "TLS shall be used to provide integrity protection, replay protection and confidentiality protection. The support of TLS is mandatory and optional to use based on the domain administrator's policy to protect interfaces within the trusted domain.\nThe procedure in subclause 6.5 of the present document shall be followed unless the security of CAPIF-2 reference point is provided by other means.\nIf the domain administrator's policy to authorize the API invoker's service API invocation requests is set, the API invoker's authorization shall be performed according to the authorization mechanisms specified for CAPIF-2e reference point in subclause 6.5 of the present document.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.5\tSecurity procedures for CAPIF-2e reference point",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.5.1\tGeneral",
                            "text_content": "Based on the selected security method by the CAPIF Core Function (c.f., subclause 6.3.1), one of the methods specified in subclause 6.5.2 shall be used between the API invoker and a 3GPP defined API exposing function for CAPIF-2e interface authentication and protection.\nNOTE: The security methods for the AEFs not defined by 3GPP are out of scope of the present document.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.5.2\tAuthentication and authorization",
                            "text_content": "The API invoker and the API exposing function shall follow the procedure in this sub-clause to establish dedicated secure session using TLS connection based on Pre-Shared Key (PSK). CAPIF-1e authentication shall be used to bootstrap a Pre-Shared key for authenticating a TLS connection for CAPIF-2e. It is assumed that both the API invoker and the CAPIF core function are pre-provisioned with certificates. The TLS profile as specified in Annex E of TS 33.310 [2] shall be used.\nFigure 6.5.2.1-1 details the message flow between the API invoker, the CAPIF core function and the API exposing function, to establish secure CAPIF-2e interface using a pre-shared key for authentication.\nThe figure depicts a 5G network's CAPIF-2e interface authentication and protection using TLS-PSK. It illustrates the use of TLS (Transport Layer Security) for secure communication between the network and the user equipment (UE). The figure shows the interface's physical layout, including the physical interface, the physical security layer (PSL), and the physical access layer (PAL). The figure also includes the authentication and protection mechanisms, such as the use of TLS-PSK for secure communication.\nFigure 6.5.2.1-1: CAPIF-2e interface authentication and protection using TLS-PSK\n1.\tCAPIF-1e authentication and secure session is established as specified in subclause 6.3.1 of the present document. The CAPIF core function shall provide the validity timer value for the key AEFPSK.\n2.\tAfter successful establishment of TLS on CAPIF-1e, the API invoker and the CAPIF core function shall derive the key AEFPSK.\nThe Key AEFPSK shall be bound to an AEF and shall be derived as specified in Annex A. The API invoker and the CAPIF core function starts the validity timer for the key AEFPSK.\n3. The API Invoker shall send Authentication Initiation Request to the AEF, including the CAPIF core function assigned API invoker ID.\nSteps 1 and 2 of this procedure may be skipped if the API invoker is already in possession of a valid key AEFPSK. In this case, the API invoker begins the procedure at step 3.\n\nNOTE: \tVoid.\n4. The AEF shall request for security information from the CAPIF Core Function to perform authentication and secure interface establishment with the API invoker, if the AEF does not have a valid key. The CAPIF Core Function provides the security information related to the chosen security method (TLS-PSK: AEFPSK) to the AEF over CAPIF-3 reference point. The CAPIF core function shall provide the remaining validity timer value for the key AEFPSK.\n5. After fetching the relevant security information (AEFPSK) for the authentication, the AEF shall send Authentication Initiation Response message to API invoker to initiate the TLS session establishment. The AEF starts the validity timer based on the value received from the CAPIF core function in step 4.\n6. The API Invoker and the AEF shall perform mutual authentication using the key AEFPSK and establish TLS session over the CAPIF-2e.\nAfter successful establishment of TLS on CAPIF-2e reference point, the API exposing function shall authorize the API invoker's service API invocation request based on authorization information obtained from CAPIF core function as specified in subclause 8.16 of TS 23.222 [3].\nThe API invoker and the API exposing function shall follow the procedure in this subclause to establish dedicated secure session over CAPIF-2e using TLS based on certificate based mutual authentication. It is assumed that both API invoker and API exposing function are pre-provisioned with certificates.\nFigure 6.5.2.2-1 details the message flow between the API invoker, the CAPIF core function and the API exposing function related to this security method.\nThe figure depicts a 5G network's CAPIF-2e interface authentication and protection mechanism, which utilizes certificate-based mutual authentication to ensure secure communication. The authentication process involves the use of a certificate, which is a digital signature that verifies the identity of the sender. This method is crucial for preventing unauthorized access and ensuring the integrity of the network. The protection aspect of the CAPIF-2e interface is also highlighted, with the use of mutual authentication to safeguard against potential threats.\nFigure 6.5.2.2-1: CAPIF-2e interface authentication and protection using certificate based mutual authentication\n1. The API invoker shall send Authentication Initiation Request to the AEF, including API invoker ID.\n2. The AEF shall request for security information from the CAPIF Core Function to perform authentication and secure interface establishment with the API invoker. The CAPIF Core Function provides the security information related to the chosen security method (TLS-PKI) to the AEF over CAPIF-3 reference point. CAPIF core function may return API invoker's root CA certificate for the AEF to validate the API invoker's certificate.\n3. After fetching the relevant security information for the authentication, AEF shall send Authentication Initiation Response message to API invoker to initiate the TLS session establishment procedure.\n4. Then the API Invoker and the AEF shall perform mutual authentication using certificates and establish TLS session over the CAPIF-2e. Certificate based authentication shall follow the profiles given in 3GPP TS 33.310 [2], clauses 6.1.3a and 6.1.4a. The structure of the PKI used for the certificate is out of scope of the present document.\nAfter successful establishment of TLS on CAPIF-2e reference point, the API exposing function shall authorize the API invoker's service API invocation request based on authorization information obtained from CAPIF core function as specified in subclause 8.16 of TS 23.222 [3].\nThis method details establishment of secure channel over CAPIF-1e, CAPIF-2e reference points, and uses the OAuth 2.0 [4] token based mechanism to authorize and honour API invoker's northbound API invocations to the API exposing function. Figure 6.5.2.3-1 details security information flows between the API invoker, the CAPIF core function and the API exposing function. It is assumed that the API invoker, the CAPIF core function and the AEF are pre-provisioned with the appropriate credentials and related information to establish a secure session.\nAs per OAuth 2.0 [4], the CAPIF core function shall perform the functionality of the authorization server and provide the token endpoint, the API invoker shall perform the function of the client functionality, while the API exposing function shall perform the resource server functions. The API invoker client (client endpoint) shall be registered as a confidential client type with an authorization grant type of 'client credentials'. The authorization shall be previously arranged in the CAPIF core function. The access token shall follow the profile described in annex C.\nNOTE: How the authorization is pre-arranged (pre-configured) with the CAPIF core function is out of scope of the present document\n\nThe figure depicts a 5G network's CAPIF-2e interface authentication and protection mechanism, showcasing the use of Access Tokens for secure communication. The authentication process involves the use of a unique token that is generated and stored on the network. The protection mechanism ensures that only authorized users can access the network, preventing unauthorized access and potential security breaches.\nFigure 6.5.2.3-1: CAPIF-2e interface authentication and protection using Access Tokens\n1. CAPIF-1e authentication and secure session establishment is performed as specified in subclause 6.3.1.\n2. After successful establishment of TLS session over CAPIF-1e, as described in subclause 6.3.1 of the present document, the API invoker shall send an Access Token Request message to the CAPIF core function as per the OAuth 2.0 [4] specification.\n3. The CAPIF core function shall verify the Access Token Request message per OAuth 2.0 [4] specification.\n4. If the CAPIF core function successfully verifies the Access Token Request message, the CAPIF core function shall generate an access token specific to the API invoker and return it in an Access Token Response message.\nSteps 1 to 4 of this procedure may be skipped if the API invoker is already in possession of a valid OAuth access token. In this case, the API invoker begins the procedure at step 5.\nNOTE 1:\tThe API invoker may include the CAPIF core function assigned API invoker ID and the Onboard_Secret in the OAuth access token request message for the CAPIF core function to validate the access token request.\nNOTE 2: Void.\n5. On CAPIF-2e, the API invoker authenticates to the AEF by establishing a TLS session with the API exposing function based on the authentication and authorization method (i.e. Server (AEF) side certificate authentication or certificate-based mutual authentication) as indicated by CAPIF core function. The following procedure shall be performed prior to establishment of TLS session.\nThe API invoker shall send Authentication Initiation Request to the AEF, including API invoker ID.\nThe AEF shall request for security information from the CAPIF Core Function to perform authentication and secure interface establishment with the API invoker. The CAPIF Core Function provides the security information related to the chosen security method (TLS with OAuth token) to the AEF over CAPIF-3 reference point. The CAPIF core function may return API invoker's root CA certificate for the AEF to validate the API invoker's certificate.\nAfter fetching the relevant security information for the authentication, the AEF shall send Authentication Initiation Response message to API invoker to initiate the TLS session establishment procedure.\n6. With successful authentication to the AEF on CAPIF-2e, the API invoker shall initiate invocation of a 3GPP northbound API with the AEF. The access token received from the CAPIF core shall be sent along with the northbound API invocation request as per OAuth 2.0 [4].\n7. The API exposing function shall validate the access token. The AEF verifies the integrity of the access token by verifying the CAPIF core function signature If validation of the access token is successful, the AEF shall verify the API invoker's Northbound API invocation request against the authorization claims in access token, ensuring that the API Invoker has access permission for the requested service API.\n8. After successful verification of the access token and authorization claims of the API invoker, the requested northbound API shall be invoked and the appropriate response shall be returned to the API invoker.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.5.3\tAuthentication and authorization for RNAA",
                            "text_content": "The authorization function shall obtain the necessary permission from the resource owner for allowing the API invoker to access a northbound API.\nRNAA shall use token-based authorization using OAuth 2.0 framework with the following roles:\n-\tThe API invoker has the role of the OAuth 2.0 client.\n-\tThe CCF has the role of the OAuth 2.0 authorization server, i.e., providing the access token used for RNAA.\n-\tThe AEF has the role of the resource server.\nThe access tokens used for RNAA shall contain the resource owner  ID.\nThe resource owner, but the resource owner ID is specified as the GPSI of the corresponding UE if the resource is related to a UE.\nNOTE: The present document does not specify the resource owner.\nThe access token shall include the resource owner ID and the API invoker ID. The resource owner ID is GPSI . The API invoker ID binds the token to the API invoker. To avoid privacy issues, GPSI should  be different from MSISDN, SUPI etc.\nEditor's Note: The details of access tokens used for RNAA need to be aligned with stage 3 (e.g., claim versus scope).\nAEF shall do the authorization check of the API invocation request for accessing the resources of the resource owner. AEF checks the request against the token, including\n1) checking the token integrity and\n2) checking whether the GSPI (if present) in the API invocation request is compliant with the resource owner ID in the access token. As the token includes resource owner ID, there is no need for additional UE authentication in API invocation. Moreover, the token should be able to restrict the API invoker to a specific resource (e.g., location, QoS, PDN connectivity status) of the resource owner.\nFor OAuth flows involving redirection, authentication between CCF/AUF and UE should be performed after API Invoker redirects the UE to CCF/AUF.\nIn case of an external AF (i.e., not the application on the UE) being the API invoker, for mutual authentication of API invoker AF and API exposing function, the authentication methods of clause 6.4 and clause 6.5.2 are reused.\nFor authorization, the following flows may be used:\n-\tClient credential flow (according to RFC 6749 [4]),\n-\tAuthorization code flow (according to RFC 6749 [4]), or\n-\tAuthorization code flow with PKCE (according to RFC 7636 [11]).\n\nCCF shall indicate the supported flows to the API invoker.\nCCF shall give service authorization which subscribers or users can use RNAA.\nNOTE: In tthe present document, only a UE accessing its own resources is considered if the API invoker is on a UE.\nIf client credential flow is used for authorization of the API invoker by the AEF, the procedures in RFC 6749 [4] shall be followed with the following profile:\n-\tThe access token request message may include the resource owner ID.\nNOTE 1: If the API invoker is on a UE, the CCF obtains its GPSI during authentication.\nEditor’s note: the mapping of API Invoker ID and GPSI is left for stage 3.\n-\tThe CCF shall check whether the API invoker is entitled to consume the API and allowed to access the resources of the resource owner, by using authorization information available in the CCF.\n-\tIf the API invoker is on a UE, the CCF shall check that the UE is accessing its own resources. If the API invoker is an AF not on a UE, the check is omitted.\n\nEditor's Note: Further details of the token are left for stage 3, this includes how to differentiate RNAA and legacy tokens\nNOTE 2: How to get the authorization from the resource owner and store it in the CCF is out of scope of the present document.\nIf authorization code flow, optionally with PKCE, is used by the AEF for authorization of the API invoker, the procedures in RFC 6749 [4] and optionally RFC 7636 [11] shall be followed, with the following profile:\n-\tThe authorization token and/or authorization request may include the resource owner ID.\nEditor’s Note: Whether and how the token and/or authorization request can include resource owner ID is left to stage 3.\nNOTE: If the API invoker is on a UE, the CCF obtains its GPSI during authentication.\nEditor's note: the mapping of API Invoker ID and GPSI is left for stage 3.\n-\tThe resource owner dynamically authorizes the API invoker to access the resource owner's resources as described in RFC 6749 [4] and optionally RFC 7636 [11].\n-\tIf the API invoker is on a UE, the CCF shall check that the UE is accessing its own resources. The access token shall contain the resource owner ID (i.e. GPSI) and the API invoker ID. If the API invoker is an AF not on a UE, the check is omitted.\nEditor's Note: further details of the token are left for stage 3, this includes how to differentiate RNAA and legacy tokens\nAPI Exposing Function needs to be informed about revocation if this is necessary to ensure correct handling of revocation.\nEditor's note: this clause describes the revocation procedure, unless this is taken care of by SA6 as it is for non RNAA use cases.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.6\tSecurity procedures for CAPIF-3/4/5 reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "To ensure security of the interfaces between CAPIF entities within a trusted domain, namely CAPIF-3, CAPIF-4, CAPIF-5:\n-\tTLS shall be used to provide integrity protection, replay protection and confidentiality protection. The support of TLS is mandatory. Security profiles for TLS implementation and usage shall follow the provisions given in TS 33.310 [2], Annex E.\n-\tCertificate based mutual authentication shall be performed between the CAPIF entities using TLS. Certificate based authentication shall follow the profiles given in 3GPP TS 33.310 [2], subclauses 6.1.3a and 6.1.4a. The structure of the PKI used for the certificate is out of scope of the present document.\nNOTE:\tIt is up to the domain administrator's policy to protect interfaces within the trusted domain.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.7\tSecurity procedures for updating security method",
                    "description": "",
                    "summary": "",
                    "text_content": "As specified in TS 23.222 [3], the CAPIF core function shall receive updates to AEF authentication and authorization method from API publishing function. In case that the AEF updates its authentication and authorization method and API invoker uses the old authentication and authorization method to invoke the service API, the AEF shall send a failure response to the API invoker with an indicator that indicates the authentication and authorization method used by the API invoker is incorrect. The API invoker shall contact the CAPIF core function to get the updated authentication and authorization method. Then the API invoker shall invoke the service API using the updated authentication and authorization method.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.8\tSecurity procedure for API invoker offboarding",
                    "description": "",
                    "summary": "",
                    "text_content": "Pre-conditions:\n1.\tThe API invoker has been onboarded successfully.\nThe figure depicts an 8-1 security procedure for API invoker offboarding, illustrating the steps involved in the process. The figure includes a flowchart, a list of steps, and a table with relevant information. The table lists the steps, their corresponding conditions, and the corresponding actions. The flowchart shows the sequence of events, while the table provides a structured representation of the information. This figure is crucial for understanding the security procedure and ensuring that API invoker offboarding is carried out correctly.\nFigure 6.8-1: Security procedure for API invoker offboarding\n0.\tTLS session is established successfully between the CAPIF core function and the API invoker.\n1.\tAn event occurs within the API invoker to trigger the offboarding action.\nNOTE:\tThe definition of events that trigger offboarding is outside the scope of the present document.\n2.\tThe API invoker shall send Offboard API invoker request message to the CAPIF core function, including the CAPIF core function specific API invoker ID which was assigned by the CAPIF core function during the onboarding procedure.\n3.\tThe CAPIF core function shall verify the API invoker ID received in step 2 and check that the corresponding profile exists for this API invoker. With successful verification of the API invoker ID and its profile, the CAPIF core function shall cancel the enrolment of the API invoker and delete the API invoker profile. This includes deletion of API invoker certificate, service API authentication and authorization information, and onboard secret (if applicable). Depending on the operator policy, the CAPIF core function may retain the information of the offboarded API invoker.\n4.\tThe CAPIF core function sends Offboard API invoker response message, indicating the successful offboarding of the API invoker.\n5.\tThe API invoker shall delete the information, such as API invoker ID, Service API authentication / authorization information, API invoker certificate, Onboard_Secret (if applicable).\n6.\tThe CAPIF core function shall tear down the TLS session with the API invoker.\n7.\tThe CAPIF core function shall send Event notification message to the API exposing function to indicate that this API invoker is no longer valid.\n8.\tThe API exposing function shall delete the security related information associated with this API invoker depending on the method that was used previously to authenticate the API invoker, e.g. AEFPSK (TLS-PSK method as described in subclause 6.5.2.1), root certificate to validate the API invoker certificate (PKI method as described in subclause 6.5.2.2), access token (OAuth 2.0 method as described in subclause 6.5.2.3 of the present document, respectively).\n9.\tThe API exposing function shall tear down the TLS connection with the API invoker.\n10.\tThe API exposing function shall return Event notification acknowledge message to indicate that the security related information associated with this API invoker is successfully deleted and thus the API invoker no longer an acknowledged user.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.9\tSecurity procedures for CAPIF-7/7e reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "To ensure security of the interfaces between API Exposing functions (Topology hiding entities and destination AEF handling service APIs), namely CAPIF-7 and CAPIF-7e:\n-\tSecurity procedures as specified in clause 6.4 of this specification for CAPIF-2 reference point shall be used for secure communication, authentication and authorization, between the AEFs belonging to same trust domain over CAPIF-7 reference point.\n-\tSecurity procedures as specified in the clause 6.5 of this specification for CAPIF-2e reference point shall be used for secure communication, authentication and authorization, between the AEFs belonging to different trust domains over CAPIF-7e reference point.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.10\tSecurity procedures for CAPIF-3e/4e/5e reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "To ensure security of the interfaces between CAPIF entities between different trusted domains (CCF domain and API Provider Domain), namely CAPIF-3e, CAPIF-4e, and CAPIF-5e:\n-\t3GPP TS 33.210 [10] shall be applied to secure messages on the reference points specified otherwise; and\n-\t3GPP TS 33.310 [2] may be applied regarding the use of certificates with the security mechanisms of 3GPP TS 33.210 [X] unless otherwise specified in the present document.\nSEG as specified in 3GPP TS 33.210 [10] may be used in the trusted domain to terminate the IPsec tunnel.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "A.1\tAEFPSK derivation function",
            "description": "AEFPSK key derivation shall be performed using the key derivation function (KDF) specified in TS 33.220 [8]. This subclause specifies how to construct the input string, S, to the KDF (which is input together with the relevant key).\nThe FC number space is controlled by TS 33.220 [8].\nAEFPSK shall be derived by the API invoker and the CAPIF core function based on Service API interface information and CAPIF-1e TLS session parameters. Length and format of TLS session parameters used for key derivation are as specified in TLS. Security profiles for TLS implementation and usage shall follow the provisions given in TS 33.310 [2], Annex E.\nThe following parameters shall be used to form the input S to the KDF.\nFC = 0x7A\nP0 = Service API interface information\nL0 = Length of Service API interface information\nP1 = CAPIF-1e TLS session's Session ID, generated as part of TLS full Handshake.\nL1 = Length of TLS Session ID\nThe input key shall be equal to CAPIF-1e TLS session's Master Secret.\nNOTE:\tService API interface information is as specified in TS 23.222 [3].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.1 \tOnboarding",
            "description": "Figure B.1-1 shows the functional security flow for online onboarding. Offline onboarding is out of scope for the present document.\nThe figure depicts the onboarding security flow, illustrating the various stages involved in the security process. It includes the initial authentication, user authorization, and data encryption, all of which are crucial for ensuring the security of sensitive information during the onboarding process.\nFigure B.1-1: Onboarding security flow\nAs a pre-requisite to onboarding, the API Invoker and the CAPIF are provisioned with the necessary onboarding enrolment information for the API Invoker. The method to do this is out of scope for the present document.\nInitially, the API Invoker attempts to establish a secure connection with the CAPIF core. If the onboarding session cannot be secured, the session is released and the onboarding flow ends.\nIf the session is secured, the API Invoker requests onboarding using the Onboard API Invoker Request message defined in clause 8.1 of 23.222 [3]. The API Invoker includes an onboarding credential in the Onboard API Invoker Request message. The CAPIF core receives the Onboard API Invoker request message and validates the onboarding credential. If the onboarding credential is valid, the CAPIF core creates and returns an Onboard API Invoker Response message defined in clause 8.1 of 23.222 [3], which contains the API Invoker profile and includes the API Invoker ID. Security information for CAPIF-1 or CAPIF-1e authentication and (optionally) security information for CAPIF-2 or CAPIF-2e is also transferred to the API Invoker as part of the onboarding response. If the CAPIF core cannot validate the onboarding credentials, then an Onboard API Invoker response message containing an error response is returned to the API Invoker instead.\nFollowing the return of an Onboard API Invoker response message (either successful or unsuccessful), the secure session is torn down and the onboarding security flow ends.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.2 \tAuthentication and authorization",
            "description": "CAPIF authentication and authorization consists of CAPIF-1e authentication and CAPIF-2e authentication and authorization. Figure B.2-1 shows the functional security flow for CAPIF-1e authentication while Figure B.2-2 shows the functional security flow for CAPIF-2e authentication and authorization.\nPrior to starting the security flow for either CAPIF-1e or CAPIF-2e authentication and authorization, successful onboarding of the API Invoker has taken place.\nIn figure B.2-1, the security flow starts with the API Invoker establishing a TLS connection to the CAPIF core over the CAPIF-1e interface per clause 6.3. Successful TLS establishment results in the opportunity for the CAPIF core to transfer CAPIF-2e AEF authentication and authorization information to the API invoker. After transfer of the CAPIF-2e AEF authentication and authorization information to the API invoker, the TLS session is released and the CAPIF-1e security flow ends.\nIn the case that either the CAPIF-1e TLS session or API invoker authentication procedure fails, the API Invoker authentication is rejected, AEF authentication and authorization information is not transferred to the API Invoker, and the TLS session with the API Invoker is closed.\nThe figure depicts a simplified representation of the CAPIF-1e authentication process, which is a key component in the authentication process of the CAPIF protocol. The figure shows the various stages of the authentication process, including the input data, encryption, and decryption, as well as the output data. The figure is a visual aid to understand the complexity and importance of the CAPIF-1e authentication process in the context of the CAPIF protocol.\nFigure B.2-1: CAPIF-1e authentication\nFigure B.2-2 shows the security flow for the CAPIF-2e interface. Successful CAPIF-1e authentication and AEF authentication information (as a minimum) is needed for the API invoker to communicate with the AEF.\nThe security flow begins when the API Invoker makes an authentication request to the AEF. The AEF receives the request and attempts to authenticate the API Invoker. If the AEF does not possess the authentication information to authenticate the API invoker, the AEF can query the CAPIF core for it. If authentication of the API invoker is successful, then a TLS session is established. If authentication of the API invoker fails, the security flow ends.\nIf authentication of the API invoker is successful, then based on the interested service API, the API Invoker makes a northbound API request.\nThe AEF attempts to validate the northbound API request. If the AEF does not possess the authorization information for the requested service API, the AEF can query the CAPIF core for it. If validation of the northbound API request is successful, the northbound API is serviced.\nUpon completion of the northbound API action(s), the secure session is torn down and the security flow ends.\nIf the AEF cannot validate the northbound API request, the AEF rejects the northbound API request, tears down the secure session, and ends the security flow.\nThe figure depicts a simplified representation of CAPIF-2e authentication and authorization, which is a key component of the CAPIF (Central Authentication Processing Infrastructure) system. The figure shows the authentication and authorization process, with the authentication process involving a user's identity and the authorization process involving the user's access rights. The figure is a simplified representation, and the actual CAPIF system may have more complex components and processes.\nFigure B.2-2: CAPIF-2e authentication and authorization\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.1\tGeneral",
            "description": "Editor’s Note:  Clarification between access tokens used for existing CAPIF implementations and access tokens used for northbound CAPIF implementations are FFS.\nThe information in this annex provides a description of the access token used in the ‘Method 3 – TLS with OAuth token’ authentication and authorisation method (see clause 6.5.2.3) and access token used in RNAA (see clause 6.5.3). Characterization of the access token, how to obtain the access token, how to validate the access token, and how to refresh the access token is explained.\nAn ‘Method 3 – TLS with OAuth token’ access token has the following chanracterics:\n-\tShall be encrypted when transported over the CAPIF 1/1e and CAPIF 2/2e interfaces (e.g. using TLS);\n-\tShall be a bearer type as specified in IETF RFC 6750 [5];\n-\tShall be encoded as a JSON Web Token as specified in IETF RFC 7519 [6];\n-\tShall be protected by the JSON signature profile as specified in IETF RFC 7515 [7]; and,\n-\tShall be validated per OAuth 2.0 [4], IETF RFC 7519 [6] and IETF RFC 7515 [7].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.2\tAccess token profile",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "C.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "The ‘Method–3 - TLS with OAuth token’ access token contains the token claims described in C.2.2.  Token claims are provided by the CAPIF Core Function and contain authentication and authorization information about the API Invoker.  Token claims are used by the API Exposing Function for authorization of API Invoker northbound API requests.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "C.2.2\tToken claims",
                    "description": "",
                    "summary": "",
                    "text_content": "The CAPIF ‘Method–3 - TLS with OAuth token’ access token shall convey the following claims as defined in IETF RFC 7519 [6] and IETF RFC 6749 [4].\nTable C.2.2-1: Access token standard claims\n\nIf the token is used for RNAA (see clause 6.5.3), resource owner ID(s) needs to be specified.\nThe ‘exp’and ‘scope’ parameters of the access token shall be determined by the CAPIF core function based upon the client_id of the API Invoker provided in the Access Token Request message.\nThe scope parameter ‘List of Services per AEF’ shall contain a full or partial list of services which the API Invoker is permitted to access at each AEF.\n",
                    "tables": [
                        {
                            "description": "Table C.2.2-1: Access token standard claims",
                            "table number": 1,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "C.3\tObtaining tokens",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "C.3.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "Once an API Invoker has successfully performed onboarding with the CAPIF Core Function, the API Invoker may request access tokens using ‘Method 3 – TLS with OAuth token’ defined in clause 6.5.2.3.  Figure C.3.1-1 shows the access token request and access token response message exchange.\nThe figure depicts a request for an access token in a communication system, illustrating the process of obtaining authorization to access a system or network. The figure shows a user interface with various options for requesting an access token, such as \"Requesting an access token\" and \"Requesting an access token for a specific user.\" The figure also includes a button labeled \"Request access token\" for users to initiate the process. The figure is designed to be user-friendly and intuitive, making it easy for users to understand the process and request an access token.\nFigure C.3.1-1: Requesting an access token\nNOTE 1: Implementation of the OAuth 2.0 token and authorization endpoints within the CAPIF Core Function are out of scope of this document.\nNOTE 2: As described in IETF RFC 6749 [4] clause 4.4, the client authentication is used as the authorization grant, therefore no additional authorization request is needed.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "C.3.2\tAccess token request",
                    "description": "",
                    "summary": "",
                    "text_content": "To obtain an access token, the API Invoker makes a request to the CAPIF Core Function by sending an Access Token Request message with the following parameters using the \"application/x-www-form-urlencoded\" format, with a character encoding of UTF-8 in the HTTP request entity-body. The access token request parameters are shown in table C.3.2-1.\nTable C.3.2-1: Access token request message parameters\n\nIf the token is used for RNAA (see clause 6.5.3), resource owner ID needs to be specified.\n",
                    "tables": [
                        {
                            "description": "Table C.3.2-1: Access token request message parameters",
                            "table number": 2,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "C.3.3\tAccess token response",
                    "description": "",
                    "summary": "",
                    "text_content": "If the access token request (i.e. the client credential) is valid and authorized by the CAPIF Core Function, the CAPIF Core Function then returns an access token to the API Invoker in an access token response message; otherwise it will return an error.\nThe access token response parameters are shown in table C.3.3-1.\nTable C.3.3-1: Access token response message parameters\n\nUpon receiving the access token reponse message, the API Invoker may now use the access token to make authorized northbound API requests to API Exposure Functions as described in clause 6.5.2.3 or clause 6.5.3.\n",
                    "tables": [
                        {
                            "description": "Table C.3.3-1: Access token response message parameters",
                            "table number": 3,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "C.4\tRefreshing an access token",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "C.4.1\tClient Credentials Grant",
                    "description": "",
                    "summary": "",
                    "text_content": "To protect against leakage or other compromise, an access token includes an expiration time. If the API Invoker determines that its access token has expired or if the API Invoker receives an indication from the AEF that a fresh access token is needed, the API Invoker shall return to the CAPIF Core Function and repeat the procedure defined in C.3.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "C.4.2\tAuthorization code grant and PKCE",
                    "description": "",
                    "summary": "",
                    "text_content": "If the API Invoker determines that its access token has expired or if the API Invoker receives an indication from the AEF that a fresh access token is needed, the API Invoker may use the refresh_token to get a refresh access token as depicted in clause 6 in RFC 6749 [4].\nThe API Invoker may determine to repeat the procedure defined in C.3 to get a new refresh token and access token.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "C.5\tUsing the token to access API exposing functions",
            "description": "Access tokens of type \"bearer\" shall be communicated from the API Invoker to AEF by including the access token in the HTTP Authorization Header, per IETF RFC 6750 [5].\nThe access token is opaque to the API Invoker, meaning that the API Invoker does not have any specific knowledge of the access token itself. The API Invoker shall use the ‘expires_in’ parameter from the access token response message to determine whether the access token is valid so that it does not send an expired access token to AEFs. If the access token is presented to an AEF and the token is expired or revoked, the AEF should return an error message indicating such to the API Invoker.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.6\t\tToken revocation",
            "description": "In order to limit the time validity of a token, the \"exp\" and \"expires_in\" parameters shall be used as a method of access token revocation.\nWithin the claims of a ‘Method 3 - TLS with OAuth token’ access token, the \"exp\" parameter shall be used by the AEF to determine whether or not the token has expired.  If the current time is beyond the time specified by the \"exp\" parameter, the associated token shall no longer be considered valid and any requests made with an expired token shall be rejected by the AEF.\nWithin the claims of an access token response message, the \"expires_in\" parameter shall be used by the API Invoker to determine validity of the associated token.  If the current time is beyond the time specified by the \"expires_in\" parameter, the associated access token shall no longer be considered valid and no northbound API requests shall be made using the expired access token. The procedure defined in C.3 shall be used to obtain a new access token.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.7 \tToken validation",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "C.7.1\tAccess token validation",
                    "description": "",
                    "summary": "",
                    "text_content": "A non-RNAA access token, i.e. ‘Method 3 – TLS with OAuth token’ access token shall be validated according to IETF RFC 7519 [6].\n\n\n\n\n\n",
                    "tables": [
                        {
                            "description": "",
                            "table number": 4,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        }
    ]
}