{
    "document_name": "26857-i00.docx",
    "content": [
        {
            "title": "Foreword",
            "description": "This Technical Report has been produced by the 3rd Generation Partnership Project (3GPP).\nThe contents of the present document are subject to continuing work within the TSG and may change following formal TSG approval. Should the TSG modify the contents of the present document, it will be re-released by the TSG with an identifying change of release date and an increase in version number as follows:\nVersion x.y.z\nwhere:\nx\tthe first digit:\n1\tpresented to TSG for information;\n2\tpresented to TSG for approval;\n3\tor greater indicates TSG approved document under change control.\ny\tthe second digit is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc.\nz\tthe third digit is incremented when editorial only changes have been incorporated in the document.\nIn the present document, modal verbs have the following meanings:\nshall\tindicates a mandatory requirement to do something\nshall not\tindicates an interdiction (prohibition) to do something\nThe constructions \"shall\" and \"shall not\" are confined to the context of normative provisions, and do not appear in Technical Reports.\nThe constructions \"must\" and \"must not\" are not used as substitutes for \"shall\" and \"shall not\". Their use is avoided insofar as possible, and they are not used in a normative context except in a direct citation from an external, referenced, non-3GPP document, or so as to maintain continuity of style when extending or modifying the provisions of such a referenced document.\nshould\tindicates a recommendation to do something\nshould not\tindicates a recommendation not to do something\nmay\tindicates permission to do something\nneed not\tindicates permission not to do something\nThe construction \"may not\" is ambiguous and is not used in normative elements. The unambiguous constructions \"might not\" or \"shall not\" are used instead, depending upon the meaning intended.\ncan\tindicates that something is possible\ncannot\tindicates that something is impossible\nThe constructions \"can\" and \"cannot\" are not substitutes for \"may\" and \"need not\".\nwill\tindicates that something is certain or expected to happen as a result of action taken by an agency the behaviour of which is outside the scope of the present document\nwill not\tindicates that something is certain or expected not to happen as a result of action taken by an agency the behaviour of which is outside the scope of the present document\nmight\tindicates a likelihood that something will happen as a result of action taken by some agency the behaviour of which is outside the scope of the present document\nmight not\tindicates a likelihood that something will not happen as a result of action taken by some agency the behaviour of which is outside the scope of the present document\nIn addition:\nis\t(or any other verb in the indicative mood) indicates a statement of fact\nis not\t(or any other negative verb in the indicative mood) indicates a statement of fact\nThe constructions \"is\" and \"is not\" do not indicate requirements.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "Introduction",
            "description": "In recent studies and specification work, it was identified that 5G Media functions and 5G System functions need to be made attractive for third-party applications, in particular those that include media delivery. Hence, it is important that these functions are accessible to third-party applications independent of a 3GPP service. For this purpose, it is considered to introduce normative specifications in 3GPP SA4 that are\n-\tmore than just a core functionality, e.g. a codec, without any connection to a service or application\n-\tless than a full service that includes all aspects of session establishment, delivery, codecs, rendering and a full user experience\nSuch new specifications are referred to 5G \"Media Service Enablers\".\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "1\tScope",
            "description": "The present document introduces and defines the concept of Media Service Enablers which includes among others:\n-\tDefinition of the principal properties of Media Service Enablers.\n-\tDefinition of minimum and typical functionalities of Media Service Enablers.\n-\tDefinition of a specification template for Media Service Enablers.\n-\tIdentification of possibly relevant stage-2 and stage-3 work for Media Service Enablers.\n-\tCollection of a set of initially relevant Media Service Enablers for normative work.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "2\tReferences",
            "description": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non-specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\tISO/IEC 23090-8:2020: \"Information technology — Coded representation of immersive media — Part 8: Network based media processing\".\n[3]\t3GPP TS 26.346: \"Multimedia Broadcast/Multicast Service (MBMS); Protocols and codecs\".\n[4]\t3GPP TS 26.347: \"Multimedia Broadcast/Multicast Service (MBMS); Application Programming Interface and URL\".\n[5]\t3GPP TS 26.479, \"UE MBMS APIs for Mission Critical Services\".\n[6]\t3GPP TS 26.511, \"5G Media Streaming (5GMS); Profiles, codecs and formats\".\n[7]\t3GPP TS 26.512, \"5G Media Streaming (5GMS); Protocols\".\n[8]\t3GPP TS 23.434: \"Service Enabler Architecture Layer for Verticals (SEAL); Functional architecture and information flows\".\n[9]\tThe Khronos Group, \"The OpenXR Specification\",\n[10]\tW3C: \"Media Capabilities\", Working Draft, 3 August 2022,\n[11]\t3GPP TS 26.238: \"Uplink Streaming\".\n[12]\tMission Critical Open Platform,\n[13]\t3GPP TS 26.501, \"5G Media Streaming Architecture\".\n[14]\tISO/IEC 23000-19: Information technology — Multimedia application format (MPEG-A) — Part 19: Common media application format (CMAF) for segmented media.\n[15]\tISO/IEC 23009-1: \" Information technology — Dynamic adaptive streaming over HTTP (DASH) — Part 1: Media presentation description and segment formats\".\n[16]\t3GPP TS 29.501, \"5G System; Principles and Guidelines for Services Definition; Stage 3\".\n[17]\tW3C Process Document,\n[18]\tCTA WAVE-5000, \"Web Media API Snapshot\"\n[19]\tCTA WAVE-5003, \"Device Playback Capabilities\"\n[20]\tRyan Pavlik, Kaye Mason, Jon Leech, Tobias Hector: \"Open XR Style Guide\", https://registry.khronos.org/OpenXR/specs/1.0/styleguide.html\n[21]\tDan Allen, Sarah White: \"AsciiDoc Language Documentation\",\n[22]\t3GPP TS 26.502, \"5G Multicast-Broadcast User Service Architecture\".\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "3\tDefinitions of terms, symbols and abbreviations",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "3.1\tTerms",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the terms given in TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in TR 21.905 [1].\nMedia Service Enabler: a set of functions to support third-party applications to make use of advanced functionalities provided by the 5G System, combined with additional well-defined client and network functionalities for a media service\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.2\tAbbreviations",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the abbreviations given in TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in TR 21.905 [1].\nAPI\tApplication Programming Interface\nAR\tAugmented Reality\nASCII\tAmerican Standard Code for Information Interchange\nCMAF\tCommon Media Application Format\nCTA\tConsumer Technology Association\nDASH\tDynamic Adaptive Streaming over HTTP\nEME\tEncrypted Media Extension\nFLUS\tFramework for Live Uplink Streaming\nHLS\tHTTP Live Streaming\nHTML\tHyperText Markup Language\nHTTP\tHyperText Transfer Protocol\nIDL\tInterface Description Language\nJSON\tJavaScript Object Notation\nKPI\tKey Performance Indicator\nMBMS\tMultimedia Broadcast Multicast Services\nMBS\tMulticast Broadcast Services\nMCA\tMSE Configuration API\nMDD\tMSE Description Document\nMPD\tMedia Presentation Description\nMPEG\tMoving Pictures Expert Group\nMR\tMixed Reality\nMRP\tMarket Representation Partner\nMSE\tMedia Service Enabler\nMSH\tMedia Session Handler\nNBMP\tNetwork-Based Media Processing\nRTP\tReal-time Transport Protocol\nSDK\tSoftware Development Kit\nSEAL\tService Enabler Architecture Layer for Verticals\nUDP\tUser Datagram Protocol\nUPF\tUser Plane Function\nURL\tUniversal Resource Locator\nWAVE\tWeb Application Video Ecosystem\nVAL\tVertical Application Layer\nVR\tVirtual Reality\nXR\teXtended Reality\nYAML\tYet Another Markup Language\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "4\tMotivation for Media Service Enablers",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "4.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "In recent studies and specification work, it was identified that 5G Media functions and 5G System functions need to be made attractive for third-party applications, in particular those that include media delivery. Examples for such approaches are MBMS or 5G Media Streaming. Hence, it is important that these functions are accessible to third-party applications independent of a 3GPP service. For this purpose, it is considered to introduce normative specifications in 3GPP that are:\n-\tMore than just a core functionality, e.g. a codec, without any connection to a service or application.\n-\tLess than a full service that includes all aspects of session establishment, delivery, codecs, rendering and a full user experience.\nThe specification should also not only address a pure textual description but provide additional functionalities such as test and validation tools.\nSeveral examples of specifications at least partially addressing such needs are provided in the remainder of this clause, both 3GPP internal specifications in clause 4.2 and external specification in clause 4.3.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.2\tExamples in 3GPP",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.2.1\tMBMS Client",
                            "text_content": "An example for the definition of an API-centric component in a 3GPP specification is one that serves the MBMS Client. The detailed procedures of the MBMS Client are defined in TS 26.346 [3] and TS 26.347 [4] according to Figure 4.2.1-1.\nThe figure depicts a MBMS client application and network reference points, illustrating the various APIs and their respective use cases.\nFigure 4.2.1-1: MBMS Client – Application and Network reference Points an APIs\nIn particular, TS 26.347 defines the following aspects:\n1.\tA set of service APIs for different application user services. The definition provides the ability to independently develop MBMS-Aware Applications and MBMS Client implementations, even for different operating systems and execution environments, but relies on the service APIs to communicate with the MBMS Client and to make use of the MBMS functionalities. These APIs are referred to as MBMS-API-C.\n2.\tA set of interface options between the MBMS Client and the application to support the transfer of user data. The primary focus is on the communication through network interfaces, for example the usage of IP sockets or HTTP-based requests. These APIs are referred to as MBMS-API-U.\nAdditionally, For Mission Critical (MC) purposes and direct access to MBMS bearer contents, an integration API is specified by the Mission Critical Open Platform [12]. 3GPP also specifies the MC MBMS API in TS 26.479 [5] based on the same objective.\nThe APIs defined in TS 26.347 address the following aspects:\n-\tA client state model in relation to the application. Examples for state are IDLE, REGISTERED, ACTIVE, etc. State changes may occur through MBMS-API-C or by information received through the network interface.\n-\tA set of client internal parameters that are changed based on either configuration or API calls through MBMS-API-C or by information received through the network interface.\n-\tA reference description of the operation of the MBMS client in different states, based on through MBMS-API-C or by information received through the network interface\n-\tDifferent methods that allow the application to communicate with the MBMS client. For each method, the following information is provided:\ni)\tA high-level description of the method.\nii)\tAn example call flow illustrating usage of the method.\niii)\tA list of input and output parameters that are exchanged as part of the method invocation.\niv)\tA description of the usage of the method by the application.\nv)\tthe MBMS Client actions in response to the invocation of the method, including pre- and post-conditions.\nThe equivalent Android APIs for MBMS-API-C are defined in the developer framework of Android:\n-\tDownload Session:\n-\tGroup Call Session:\n-\tStreaming Session:\n-\tMBMS API documentation: https://developer.android.com/reference/android/telephony/mbms/package-summary\nFinally, TS 26.347 also defines interfaces between the MBMS Client and the application for data exchanges. While the MBMS-API-C provides all methods to find and establish these interfaces, MBMS-API-U provides requirements on the data interfaces, for example for copying files, for requesting files through HTTP, for using specific methods based on an application such as DASH or HLS, or for accessing interfaces that provide RTP packets, UDP datagrams or packet data.\nAn example usage of the abovementioned Android APIs to support accessing MBMS services through Mission Critical functions is provided in Listing 4.2.1-1 using a reception feature activation.\nListing 4.2.1-1 Example usage of the Android APIs to support accessing MBMS services through Mission Critical functions\nprivate MbmsGroupCallSessionCallback groupCallSessionCallback;\nprivate MbmsGroupCallSession mbmsGroupCallSession;\nprivate String mbmsInterfaceName;\n/**\n * Activate MBMS reception\n */\npublic void enableMBMS() {\n\n    groupCallSessionCallback = new MbmsGroupCallSessionCallback() {\n\n        @Override\n        public void onServiceInterfaceAvailable(@NonNull String interfaceName, int index) {\n            Log.e(TAG, \"service interface for MBMS Reception \" + interfaceName);\n            mbmsInterfaceName = interfaceName;\n        }\n\n    };\n\n    //Enabling MBMS reception\n     mbmsGroupCallSession = MbmsGroupCallSession.create(this.getApplicationContext(), 1, this.getMainExecutor(), groupCallSessionCallback);\n    \n}\n\nReception of data from an MBMS bearer is triggered following the code in Listing 4.2.1-2.\nListing 4.2.1-2 Reception of data from an MBMS bearer using Android APIs\nprivate GroupCall groupCall;\n/**\n * Starting the reception of a MBMS bearer\n * @param tmgi the Temporary Multicast Group Identifier of the MBMS Bearer\n */\npublic void startReceptionMBMSBearer(long tmgi) {\n    GroupCallCallback myCallBack = new GroupCallCallback() {\n        @Override\n        public void onGroupCallStateChanged(int state, int reason) {\n            switch (state) {\n                case  GroupCall.STATE_STARTED:\n                    Log.i(TAG, \"MBMS bearer reception is started\");\n                    break;\n\n                case  GroupCall.STATE_STALLED:\n                    Log.e(TAG, \"onGroupCallStateChanged: stalled reason \" + reason);\n                    break;\n\n                case  GroupCall.STATE_STOPPED:\n                    Log.e(TAG, \"onGroupCallStateChanged: stopped reason \" + reason);\n                    break;\n      } } };\n    //List of Service Area Identifiers and frequencies, may be left empty\n    List<Integer> sais = new ArrayList<Integer>();\n    List<Integer> frequencies = new ArrayList<Integer>();\n    groupCall = mbmsGroupCallSession.startGroupCall(tmgi, sais, frequencies, executor, myCallBack);\n\nFinally, the multicast packet data is accessed by the execution shown in Listing 4.2.1-3.\nListing 4.2.1-3 Multicast packet data access using Android APIs\n/**\n * Access to the multicast IP packets \n * @param multicastAddress String representation of the multicast IP address to join\n * @param destinationPort destination port\n * @throws Exception\n */\npublic void receive(String multicastAddress, int destinationPort) throws Exception {\n    NetworkInterface ni = NetworkInterface.getByName(mInterfaceName);\n\n    //open a multicast socket\n    MulticastSocket mSocket = new MulticastSocket(destinationPort);\n    SocketAddress socketAddress =\n                new InetSocketAddress(multicastAddress, destinationPort);\n\n    //join the multicast group on a given network interface\n    mSocket.joinGroup(socketAddress, ni);\n\n    while (true) {\n        byte[] buf = new byte[1500];\n        DatagramPacket recv = new DatagramPacket(buf, buf.length);\n        mSocket.receive(recv);\n\n        //TODO process the received datagram\n        }\n}\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.2\tMedia Session Handler in 5GMS",
                            "text_content": "Another example enabling function relevant to 5G media delivery is the Media Session Handler defined in TS 26.501 [13] (stage-2) and TS 26.512 [6] (stage-3). The Media Session Handler is a function on the UE that communicates with the 5GMSd AF in order to establish, control and support the delivery of a media session, and may perform additional functions such as the collection and reporting of consumption and QoE metrics. The Media Session Handler exposes APIs that can be used by the 5GMSd-Aware Application. An overview is provided in Figure 4.2.2-1.\nThe figure depicts a media session handler application and network reference points, which are crucial for managing media sessions in a 5G network. The application and network reference points are essential for managing media sessions, ensuring efficient communication between different devices and services.\nFigure 4.2.2-1: Media Session Handler– Application and Network reference Points an APIs\n(Reproduced from TS 26.512 [6])\nThe Media Session Handler deals with three sets of APIs and reference points:\n-\tM5d (Media Session Handling API): APIs exposed by a 5GMSd AF to the Media Session Handler for media session handling, control, reporting and assistance that also include appropriate security mechanisms, e.g. authorization and authentication.\n-\tM6d (UE Media Session Handling APIs): APIs exposed by a Media Session Handler to the Media Player for client-internal communication and exposed to the 5GMSd-Aware Application enabling it to make use of 5GMS functions.\nNOTE:\tThe M6d APIs are not yet fully specified in TS 26.512 [6].\n-\tM7d (UE Media Player APIs): APIs exposed by a Media Player to the 5GMSd-Aware Application and Media Session Handler to make use of the Media Player.The APIs for M6d and M7d are defined in an abstract manner at this stage.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.3\tMedia Player in 5GMS",
                            "text_content": "Downlink 5G Media Streaming specifies the use of segment formats that are based on the Common Media Application Format (CMAF) in ISO/IEC 23000-19 [14]. By using this format, 5G Media Streaming is compatible with a broad set of segment-based streaming protocols including Dynamic Streaming over HTTP (DASH) and HTTP Live Streaming (HLS). For example, ISO/IEC 23009-1 [15] defines a detailed DASH profile for delivering CMAF content within a DASH Media Presentation using a converged format for segmented media content.\nThe figure depicts a 5G Media Downlink Streaming Architecture, illustrating the various components and their roles in the system. The architecture includes media playback, media processing, and media storage, all of which are crucial for delivering high-quality video and audio content to users. The figure also highlights the use of SDN principles, which are essential for managing and optimizing the network's performance.\nFigure 4.2.3-1: Media Playback in 5G Media Downlink Streaming Architecture\n(reproduced from TS 26.511 [7])\nAccording to TS 26.511 [7], TS 26.512 [6] and Figure 4.2.3-1 above, the Media Player is further decomposed into an Access Client and a Media Playback Platform. Several APIs are identified for the Media Player:\n-\tM4d (Media Streaming APIs): APIs exposed by a 5GMSd AS to the Media Player to stream media content.\n-\tM6d (UE Media Session Handling APIs): APIs exposed by a Media Session Handler to the Media Player for client-internal communication and exposed to the 5GMSd-Aware Application enabling it to make use of 5GMS functions.\n-\tM7d (UE Media Player APIs): APIs exposed by a Media Player to the 5GMSd-Aware Application and Media Session Handler to make use of the Media Player.\n-\tA set of internal Media Player APIs that deals with providing accessed data to the Media Playback Platform. These closely follow the W3C APIs for HTML-5 based media playback and the Media Source Extensions.\nMost relevant in the discussion is the M7d API provided by the Access Client (see clause 13 of TS 26.512 [6]) defining:\n1)\tMethods to interact with the Access Client of the Media Player,\n2)\tNotification and Error Events sent to the Media Session Handler and 5GMSd-Aware Application,\n3)\tConfiguration and Settings methods,\n4)\tStatus Information.\nThe initial API has largely been designed based on the dash.js API documented here: , but they are abstract.\nFor the Media Player, different states are defined, depending on actions received from any of the APIs.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.4\tFLUS sink capability discovery",
                            "text_content": "TS 26.238 [11] defines a set of protocols for uplink media streaming. This specification includes a method for describing the processing capabilities of the entity (known as FLUS sink) that receives the uplink stream. In this specification, these capabilities are described as a list. Each entry in the list includes a scheme identifier, the location for the description of the scheme, and a URL where the specific capability can be accessed. The FLUS sink capabilities description can be retrieved from the sink or it can be found in a sink directory.\nThe advantage of the FLUS sink capabilities description is its simplicity. However, since each item in the capabilities list has its own scheme, it does not provide much interoperability for describing the available functions and their detailed features, since each function defines its own scheme for describing its capabilities.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.5\tService Enabler Architecture Layer (SEAL) for Verticals",
                            "text_content": "SA6 defines several Application Frameworks, for example Service Enabler Architecture Layer for Verticals (SEAL). TS 23.434 [8] specifies the functional architecture of the Service Enabler Architecture Layer (SEAL) and the procedures, information flows and APIs for each service within SEAL in order to support vertical applications over the 3GPP system. To ensure efficient use and deployment of vertical applications over 3GPP systems [8] includes the group management, configuration management, location management, identity management, key management and network resource management. Figure 4.2.5-1 illustrates the generic on-network functional model for SEAL.\nThe figure depicts a generic on-network functional model for SEAL (see TS 23.434, Figure 6.2-1), illustrating the various components and their interconnections. The model includes a base station (BS), a user equipment (UE), and a network element (NE), with a focus on the role of the network element in the overall system. The figure also includes a visual representation of the network topology, highlighting the importance of network elements in the network's functionality.\nFigure 4.2.5-1: Generic on-network functional model for SEAL (see TS 23.434, Figure 6.2-1)\nIn the vertical application layer (VAL), the VAL client communicates with the VAL server over reference point VAL-UU. This supports both unicast and multicast delivery modes, but is otherwise out of scope of SEAL.\nThe SEAL functional entities on the UE and the server are grouped into SEAL client(s) and SEAL server(s) respectively. The SEAL consists of a common set of services (e.g. group management, location management) and reference points. The SEAL offers its services to the vertical application layer (VAL). The functionalities and reference points of the vertical application layer are out of scope of SEAL.\n-\tEach SEAL client communicates with its SEAL server over reference point SEAL-UU.\n-\tThe SEAL client provides the service enabler layer support functions to the VAL client over reference point SEAL-C.\n-\tEach VAL server communicates with its SEAL server over reference point SEAL-S.\nA SEAL server may communicate with the underlying 3GPP network system using the Network interfaces provided by the 5G System (labelled 3GPP network system). The specific SEAL client(s) and the SEAL server(s), along with their specific instantiations of reference point SEAL-UU and the specific network interfaces of the 3GPP network system used, are described in the respective on-network functional model for each SEAL service.\nFor each such service, TS 23.434 [8] defines the functional model, procedures and information flows, as well as the APIs. The focus in [8] is on stage-2; detailed stage-3 is not defined.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.3\tExternal Specifications",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.3.1\tGeneral",
                            "text_content": "This clause provides an overview of existing specifications that provide specifications similar to what is envisioned as Media Service Enabler specifications.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.2\tW3C HTML-5 APIs for Media",
                            "text_content": "According to the W3C Process Document [17], W3C Working Groups create specifications and guidelines to complete the scope of work envisioned by a Working Group's charter. These technical reports undergo cycles of revision and review as they advance towards W3C Recommendation status. Once review suggests the Working Group has met their requirements for a new standard, including wide review, a Candidate Recommendation phase allows the Working Group to formally collect implementation experience to demonstrate that the specification works in practice. At the end of the process, the Advisory Committee reviews the mature technical report, and if there is support from its Membership, W3C publishes it as a Recommendation.\nIn summary, the W3C Recommendation Track consists of:\n- \tPublication of the First Public Working Draft.\n-\tPublication of zero or more revised Working Drafts.\n-\tPublication of one or more Candidate Recommendations.\n-\tPublication of a Proposed Recommendation.\n-\tPublication as a W3C Recommendation.\nA key issue in the process is \"adequate implementation experience\" that is summarized as follows in [17]. Implementation experience is required to show that a specification is sufficiently clear, complete, and relevant to market needs, to ensure that independent interoperable implementations of each feature of the specification will be realized. While no exhaustive list of requirements is provided here, when assessing that there is adequate implementation experience the following may be considered:\n- \tis each feature of the current specification implemented, and how is this demonstrated?\n- \tare there independent interoperable implementations of the current specification?\n-\tare there implementations created by people other than the authors of the specification?\n-\tare implementations publicly deployed?\n-\tis there implementation experience at all levels of the specification’s ecosystem (authoring, consuming, publishing…)?\n-\tare there reports of difficulties or problems with implementation?\nPlanning and accomplishing a demonstration of (interoperable) implementations can be very time consuming. Groups are often able to work more effectively if they plan how they will demonstrate interoperable implementations early in the development process; for example, developing tests in concert with implementation efforts.\nA set of developer tools for W3C specification development is provided here: .\nFor media streaming media consumption using web-based end points, CTA WAVE has developed several specifications that define and develop test regimes on how to use web-based APIs. For this purpose, requirements and related tests are defined for media playback APIs in particular in CTA WAVE 5000 [18], the WAVE Web Media API Snapshot, and CTA WAVE 5003 [19], the Device Playback Capabilities Specification provide detailed requirements and are supported by test suites for user agent and device tests.\nThe W3C Media Capabilities API [10] is designed to query a W3C user agent (such as a web browser) with regard to its media decoding and encoding capabilities. The intent is to provide a replacement for the HTML5 canPlayType() method and the Media Source Extension isTypeSupported() method that more accurately reflects the user agent’s media encoding and decoding capabilities.\nThe API supports decoding from a file, from Media Source Extension (MSE), or from WebRTC, and also encoding to media chunks that can be stored in a file or transmitted as a WebRTC stream.\n-\tThe video and audio configuration objects define the general characteristics of the video and audio configuration.\n-\tThe key system configuration object defines the key configuration for the encrypted media (EME).\nFor a given encoding or decoding configuration, the API returns a binary flag for each of the following values: supported, smooth, or power-efficient. It seems the logic is very similar to canPlayType(), but the configuration can be described in more detail and the result is more accurate.\nThe specification is characterised as follows:\n1.\tIt limits the expression of capabilities to video and audio encoding/decoding and key configuration for decryption. It doesn’t support other media types such as subtitles, images, or graphics.\n2.\tIt doesn’t define a general language to define the capabilities of various media functions other than video/audio decoding.\n3.\tIt seems various encoding configurations (e.g. motion estimation, bit rate control modes, number of reference frames, etc) cannot be described or set as the desired configuration.\n4.\tThe API for querying the functionality i still based on a binary pass/fail result (similar to canPlayType()), presumably to reduce the risk of fingerprinting the device, and therefore, it is not possible to get an expressive list of supported features.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.3\tKhronos OpenXR",
                            "text_content": "OpenXR [9] is an API (Application Programming Interface) for XR applications. It sits between an application and an in-process or out-of-process \"XR runtime system\" (just \"runtime\" hereafter). The runtime may handle such functionality as frame composition, peripheral management, and raw tracking information.\nThe OpenXR specification is intended to satisfy the needs of both programmers and runtime implementors:\n-\tTo the application programmer, OpenXR is a set of functions that interface with a runtime to perform commonly required operations such as accessing controller/peripheral state, getting current and/or predicted tracking positions, and submitting rendered frames.\n-\tTo the runtime implementor, OpenXR is a set of functions that control the operation of the XR system and establishes the lifecycle of an XR application.\nHowever, the specification does not necessarily provide a model for implementation. A runtime implementation is expected to produce results conforming with those produced by the specified methods, but may carry out particular procedures in ways that are more efficient than the one specified.\nA few fundamentals on API definitions:\n-\tVersion numbers 64 bit major, minor, patch.\n-\tThreading, multiprocessing, runtime.\n-\tExtensions.\n-\tAPI Layering, which means that a user or application may insert API layers between the application and the runtime implementation.\n-\tReturn codes.\n-\tHandles and Object Handling.\n-\tTiming.\n-\tColors.\n-\tCoordinate Systems.\n-\tEvents.\nThe specification is also supported by API Reference Pages [9] which are generated by automatic extraction from the specification source and document commands, object handles, structures, enumerations, flags, other types and all extensions.\nFor each command, the following information is provided:\n-\tName.\n-\tC function call specification.\n-\tParameter descriptions.\n-\tValid usage.\n-\tReturn codes.\n-\tReference to OpenXR specification.\nOpenXR is an extensible API and the optional functions are call extensions. Since the extensions are options, only a subset of runtimes may implement a particular extension. Therefore, an application may first query which extensions are available from its underlying runtime. Open XR permits extensions to be defined by OpenXR or by external parties. The function  [9] provides the list of available extensions in the current runtime. Each extension is identified by a unique name and an extension version, and by the type of the extension.\nFor the specification itself, the document sources are marked up in Asciidoctor format (https://asciidoctor.org/). Asciidoctor and related toolchain components are used to generate the output documents. A full overview of how the specification is developed is provided here: .\nKhronos has also released a Conformance Test Suite for OpenXR, published the tests as open source software on GitHub (https://github.com/KhronosGroup/OpenXR-CTS), and launched the OpenXR 1.0 Adopters Program so that implementations can be officially conformant for the first time. Any OpenXR implementer – Khronos member or not – is welcome to become an OpenXR Adopter and submit conformance test results for Working Group review and approval. If their implementation is approved as conformant, they will be able to use the OpenXR trademark on their implementation.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.4\tMPEG Network-Based Media Processing (NBMP) media function description",
                            "text_content": "ISO/IEC 23090-8 [2] is a specification for describing media functions and workflows as microservices running in the cloud. The specification defines the data structures for describing workflows and methods for managing them. The framework enables dynamic creation of media processing pipelines, as well as access to processed media data and metadata in real time or in a deferred way. The media and metadata formats used between the media source, workflow manager, and media processing entities in a media processing pipeline are also specified.\nEach function in a media processing pipeline is specified using a JSON object called a function description that describes the functionality, the inputs, outputs, processing characteristics, and configuration parameters, as well as the processing requirements. The function description can also describe events, and even how to set up notifications, reporting, and monitoring for that function if it is deployed as a microservice. More complex functions can be described also as a composite of simpler functions. Finally, the function description JSON object can also be used programmatically to instantiate a task or microservice that performs the function it describes.\nThe NBMP function description has the advantage of describing being able to describe a function with identifiers as well as a detailed description of a function. The optional parameters of an implementation of a generic function can be described using this approach.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "5\tConsidered MSE frameworks",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "5.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "This clause collects some proposed and considered MSE frameworks. A discussion on the different framework proposals is provided in clause 5.4.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "5.2\tMSE framework proposal #1",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.2.1\tArchitecture",
                            "text_content": "Figure 4.4.1.1-1 shows a possible framework for Media Service Enablers. The MSE framework consists of two parts: the MSE specification (on the left of the figure) and the MSE implementation (on the right).\nFigure 5.2.1-1. Media Service Enablers Framework\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.2\tMSE Specification",
                            "text_content": "An MSE Specification (a) defines:\n1.\tMedia aspects\na.\tFunctional description of the MSE including the mandatory and optional features.\nb.\tThe control interfaces such as provisioning, authentication that is used by the application, and other functions to interact with this MSE.\nc.\tThe media interfaces that includes all inputs and outputs format and protocols.\nd.\tNetwork interface including system and radio network.\ne.\tEvent, notifications, reporting, and monitoring.\nf.\tError handling.\n2.\tMSE Configuration\na.\tAn MSE Description Document (MDD) that describes an implementation’s functional support in a standardised way, including:\n1.\tFunctions supported by an MSE implementation and their configuration parameters.\n2.\tOptionally the performance/cost metrics for the different features/options.\nb.\tAn MSE Configuration API (MCA) abstraction for:\n1.\tOptionally retrieving the MSE Description Document.\n2.\tConfiguring the MSE instantiation.\n3.\tOptionally retrieving the state and status of the MSE instantiation.\nc.\tA service API for the MSE Configuration API.\nMedia aspects (1) are usually covered by SA4 specifications. However, the MSE Configuration (2) is absent from current SA4 specifications and is what the MSE Specification adds. The value of this is that, for any SDK or service that is conforming to the MSE specification, a description of the features and their configuration parameters can be described using a standard document format. Furthermore, this description can be retrieved through the configuration API if supported by the implementation. Additionally, the external function or service can set a specific configuration for running that SDK. Furthermore, the state and status of the running SDK can be retrieved at any time.\nThe language and syntax of the MSE Description Document and the general framework of the MSE Configuration API can be defined uniformly for all SA4 Media Service Enabler specifications and only specific codepoints are defined in that specification. An external function or application understanding the MSE Description Document syntax, as well as supporting the MSE Configuration API, can retrieve the information from an MSE implementation. If it recognizes the MSE Specification identifier, it can parse and process the MSE Description Document and its configuration parameters.\nAn example of an MSE Description Document can be found in ISO/IEC 23090-8 [2]. The function description document is a JSON document that describes the functionalities and features that a function provides as well as its configuration parameters.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.3\tMSE implementation",
                            "text_content": "An MSE implementation may consist of up to three aspects:\n1.\tThe MSE SDK abstraction (c), an abstract SDK definition intended to be realized as a Software Development Kit, which includes the followings:\ni.\tMedia aspects conforming to the MSE specification.\nii.\tMSE Description Document and MSE Configuration API.\n2.\tThe MSE SDK instantiation (d) which is an SDK implementation in a specific environment and conforms to the following:\ni.\tMedia aspects conforming to the MSE Specification.\nii.\tMSE Description Document and a specific implementation of the MSE Configuration API.\n3.\tThe MSE service (b) which is the MSE implementation as a service, i.e with APIs that are platform-independent (such as web-based APIs) and conforms to the following:\ni.\tMedia aspects conforming to the MSE Specification.\nii.\tMSE Description Document and a platform-independent implementation of the MSE Configuration API.\nAs shown in Figure 4.4.1.1-1, while the MSE SDK abstraction and the MSE Service are platform-independent, the MSE SDK is an instantiation of the MSE SDK abstraction for a specific platform/environment.\nAn MSE Specification does not required to include all three aspects. For instance, if an MSE is only intended to be realized as a software development kit, then its specification would include specifications for the SDK abstraction and one or more SDK instantiation.\nNote that in the cases of MSE SDK abstract SDK (c) and MSE SDK (d), the MDD may not be retrievable through the MSE configuration APIs. In these cases, MDD is a side document, describing the features supported by the SDK.\nTable 5.2.4-1 summarizes the above features.\nTable 5.2.4-1. Summary of MSE features for various components of Figure 5.2.4-1\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.2.4-1. Summary of MSE features for various components of Figure 5.2.4-1",
                                    "table number": 3,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.2.4\tExample",
                            "text_content": "As shown in figure 5.2.1-1, the MSE Specification can be deployed in two different ways: as an SDK for running on devices or as a microservice running on an Application Server. To demonstrate converting an existing 3GPP specification to an MSE specification, we use the 5GMS Media Session Handler defined in TS 26.501 [13], shown in figure 5.2.4-1.\nThe figure depicts a Media Session Handler (MSH) as defined in the 26.501 standard, which is a crucial component in the design of a 5G network. The MSH is responsible for managing the media access control (MAC) and session management functions, ensuring efficient and secure communication between the network and the user equipment (UE). The figure illustrates the MSH's components, such as the Media Access Control (MAC) and Session Control (SC) functions, as well as the signaling and control plane. The figure also highlights the importance of the MSH in ensuring the smooth operation of the 5G network.\nFigure 5.2.4-1. Media Session Handler as defined in 26.501\nThe figure depicts a media session handler as an abstract class in the Media Session Handler (MSE) SDK, with multiple instantiations and MSE services. The MSE SDK abstracts the media session handling process, allowing developers to focus on the application logic.\nFigure 5.2.4-2. Media Session Handler as MSE SDK abstraction, MSE SDK instantiations, and MSE service\nThe MSE Specification for the Media Session Handler (MSH) shown in Figure 5.2.4-2 describes the following:\n1.\tMedia aspects:\na.\tFunctional description of:\ni.\tService Access Information.\nii.\tConsumption Reporting.\niii.\tMetrics Reporting.\niv.\tDynamic policies.\nv.\tNetwork Assistance.\nb.\tM5d, M6d, M7d API definitions:\ni.\tM5d as is already defined.\nii.\tM6d and M7d as abstract APIs.\niii.\tM6d and M7d as service APIs.\n2.\tMSE Configuration\na.\tAn MSE Description Document which describes:\ni.\tAn identifier that shows this MSE conforms to (1).\nii.\tOptional features of (1a) and (1b) with their configuration parameters.\niii.\tOptionally the performance/cost metrics for the different features/options.\nb.\tAbstract API definitions for:\ni.\tRetrieving the MSE Description Document (2a).\nii.\tConfiguring the MSE instantiation.\niii.\tRetrieving the state and status of the MSE instantiation.\nc.\tA service API for the abstract API (2b).\nAnd MSE SDK implementation of the above specification for Android should support the following:\n3.\tMedia aspects conforming to (1), including a specific implementation of the M6d and M7d service APIs.\n4.\tThe MSE Description Document (2a) and a specific implementation of the abstract APIs (2b).\nThe MSE Description Document describes the features implemented by the MSE. The abstract APIs allow an external Android process to retrieve this document and configure the SDK with a set of configurable parameters that are described in the MSE Description Document. They also allow it to interrogate the state and status of the running SDK.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.5\tBenefits",
                            "text_content": "The benefits of the above approach are the following:\n1.\tThe MSE specification defines all mandatory and optional features in a single document, the MDD, with references to the specific relevant clause(s).\n2.\tThe MSE specification also optionally defines the MSE Configuration APIs for managing and retrieving information from an implementation.\n3.\tAn implementer can use the MSE specification’s MDD as a feature checklist.\n4.\tAn implementer can use the MSE Configuration API to implement the API for MSE services.\n5.\tThe SDK instantiation of an MSE specification includes a side MDD describing the features supported by the SDK and the optional configurations it may have.\n6.\tThe MSE service instantiation of an MSE specification includes an MSE configuration API conforming to the one defined in the MSE specification that can be used for retrieving and configuring the service.\n7.\tThe MSE service instantiation provides an MDD (as a side or as part of retrieval through MSE configuration API) that provides the supported features of the MSE service instantiation.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.3\tMSE framework proposal #2",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.3.1\tOverview",
                            "text_content": "The proposal follows existing practices in 3GPP for device and network APIs, as introduced in clause 4.2, and extends the documentation with best practices identified in other organizations as introduced in clause 4.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.2\tArchitecture",
                            "text_content": "The basic concept of the Media Service Enabler is to support third-party media delivery over the 5G System. Figures 5.3.2-1 and 5.3.2-2 provide an overview for an application that is deployed on top of a 5G System. In this case, the Application Provider is operating an external DN and connects to the 5G System using N6 for data delivery and possibly N33 to use specific 5G network services. A UE-resident application makes use of device functions (for example hardware and software exposed through APIs) and connects to the Application Provider.\nThe figure depicts a 5G System architecture, showcasing the various components and their interconnections. It highlights the role of third-party applications, such as IoT devices and edge computing, in enhancing the overall functionality of the 5G network. The architecture is designed to support a wide range of applications, including remote monitoring, smart city solutions, and industrial automation.\nFigure 5.3.2-1: Third-party application on top of 5G System – 5G System Architecture\nThe figure depicts a third-party application on top of the 5G System, specifically focusing on interfaces. It illustrates the various interfaces used for communication, such as the 5G Core, the 5G Core Radio Interface (C-RPI), and the 5G Core Radio Interface (C-RPI), as well as the 5G Core Radio Interface (C-RPI) and the 5G Core Radio Interface (C-RPI). The figure also highlights the 5G Core Radio Interface (C-RPI) and the 5G Core Radio Interface (C-RPI) and the 5G Core Radio Interface (C-RPI).\nFigure 5.3.2-2: Third-party application on top of 5G System – Interfaces\nFigure 5.3.2-3 now extends the above basic architecture to provide to the Application Provider a set of  3GPP-specified functions, possibly both on UE and network side, in order to simplify operations. These functions are bundled as a Media Service Enabler (MSE) and offered to the Application Provider as follows:\n-\tThe service may be provisioned on the network side using an MSE Application Function. The provisioning reference point is summarized as MSE-1.\n-\tUser plane data may be exchanged with the Application Provider using an Ingest/Egest interface, MSE-2. Generally, this is a generic IP-based interface that directly uses N6 and the UPF. However, the MSE may offer specific Application Server functions at MSE-2.\n-\tOn the UE side, the functions of an MSE Client are accessed through a well-defined client API, MSE-6, that is aligned with other device APIs. The MSE Client may make use of other device functions that are expected to be accessible via existing device APIs.\n-\tThe MSE Client may be decomposed into Core Functions defined in the relevant Media Service Enabler specification, and External Device Reference Functions that are accessed through well-defined APIs MSE-7.\n-\tThe MSE Client connects to the 5G network and may make use of Application Functions associated with this Media Service Enabler. Those functions are exposed through MSE-5.\n-\tUser data is exchanged with the MSE Application Server (if any) through MSE-4, which may define specific requirements on the usage of protocols, codecs, formats etc.\nThe figure depicts a 5G-based media delivery system, showing the addition of Mean Square Error (MSE) to the existing 4G system. MSE is a measure of the average error in the received signal, which can be used to improve the quality of the signal. The figure illustrates the process of adding MSE to the 4G system, which involves adjusting the signal processing algorithms and the network architecture to minimize the MSE. This can lead to improved signal quality and reduced latency for media delivery.\nFigure 5.3.2-2: Addition of MSE to 5G-based media delivery\nProviding a Media Service Enabler in this form has several benefits:\n-\tThe Application Provider has a set of functions that can be easily accessed in the same way that device functions are accessed today, namely through well-defined device APIs. The Application Provider can also use regular IP connectivity to operate its application.\n-\tFor the MSE developer, the focus is on providing a well-defined set of functions that are exposed to the application through MSE-1 and MSE-2 on the network side, and via MSE-6 on the UE device side.\n-\tThe MSE developer may provide the MSE Application Function and Application Server as well as the MSE Client. In this case, the primary interoperability aspects are at reference points MSE-1 and MSE-6.\nIn another case, the network functions for MSE may be provided by a 5G System operator. In this case the MSE Client and MSE AF are expected to also implement the functions and interoperability defined at reference points MSE-4 and MSE-5.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.3\tFunctions and reference points",
                            "text_content": "The following functions are defined:\n-\tApplication: A downloadable or installed application in a UE that makes use of the MSE to provide a Media Service to a user.\n-\tMSE Client: A UE-internal function dedicated to a specific Media Service Enabler. The MSE Client is a logical function and its subfunctions may be distributed within the UE according to implementation choice. For example, it may define new core functions as well as referencing existing functions that are required to complete the expected functions.\n-\tMSE Application Function: An Application Function similar to that defined in clause 6.2.10 of TS 23.501 [2], dedicated to a specific Media Service Enabler.\n-\tMSE Application Server: An Application Server dedicated to a specific Media Service Enabler.\nThe following reference points, interfaces and APIs are defined:\n-\tMSE-1 (MSE Provisioning API): External API, exposed by the MSE AF, which enables the Application Provider to provision the usage of the MSE.\n-\tMSE-2: (MSE Ingest/Egest API): Optional external API exposed to the Application Provider by the MSE AS and used when the MSE AS in the trusted DN is selected to process content for the MSE.\nNOTE:\tMSE-3 may be used for communication between MSE AS and MSE AF, but is not considered relevant.\n-\tMSE-4: (MSE User Plane interface): Interface used by an MSE Client to exchange user data with an MSE AS.\n-\tMSE-5: (MSE Control API): APIs exposed by an MSE AF to the MSE Client to configure and control MSE functions.\n-\tMSE-6: (MSE Client APIs): APIs exposed by the MSE to the Application for client-internal communication to make use of MSE functions\n-\tMSE-7: (External Device API): APIs exposed by the UE device to the MSE to make use of resident client functions such as rendering, playback, etc.\n-\tMSE-8: (Application APIs): Interface used for information exchange between the Application and the Application Provider.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.4\tSpecification",
                            "text_content": "Media Service Enabler specifications do not attempt to define an entire service, but only a subset of small defined functions. Hence, it is essential to understand that whatever is not defined to complete a service does not need to be documented. An MSE specification is a bottom-up specification: it specifies what is needed and does not address what is not needed.\nAn MSE specification is proposed to include the following information:\n1.\tPre-requisites and Assumptions (Highly recommended): Pre-requisites document what is expected to be available either from the 5G System (i.e. certain functionalities of the 5G System) or from implementation (for example functions available on the device). These pre-requisites may be considered to be part of the specification (as reference to an external specification), but it is important to identify this separately in order to clearly demarcate the boundaries of the MSE with respect to other functions. Example for pre-requisites include, but are not limited to:\na)\tExisting and required device functions and the corresponding APIs defined as MSE-7.\nb)\tExisting and required 5G System functions.\n2.\tOverall specification of the function, including a specific architecture (Highly recommended). This includes:\na)\tInstantiations of the MSE reference points and functions.\nb)\tA typical call flow.\n3.\tSpecification of the MSE Client functions and the corresponding MSE-6 APIs (Highly recommended). This typically includes functionalities such as configuration, settings, notifications, events, data and status query as well as functional methods. It includes:\na)\tDefinition of the internal functions itself.\nb)\tDefinition of how to use existing and required device functions.\nc)\tStrict definition of the API methods with details such as name, pseudo code, functions. As a common language IDL or C is proposed to be used.\n4.\tControl Plane API and network/MSE Application Function (Highly recommended)\na)\tDefinition of the internal functions of the AF, using common practices of a RESTful API\nb)\tAlignment with 5G Media Streaming functionalities as defined at reference point M5 of TS 26.501 [13] and TS 26.511 [6], using OpenAPI/YAML.\n5.\tUser plane reference point and network/MSE Application Server (Optional but recommended)\na)\tDefinition of internal functions of the Application Server, based on common Internet protocols, preferably by reference to external specifications (IETF, MPEG, etc.)\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.5\tImplementation support beyond specification",
                            "text_content": "Beyond the specification, it is proposed to document guidelines and additional support material for developers. The following aspects are considered:\n1.\tGuidelines for application developers (Highly Recommended)\n-\tProviding guidance on how an application developer can make use of the Media Service Enabler.\n-\tThis is preferably done by providing examples and implementation hints.\n2.\tGuidelines for MSE implementers (Optional):\n-\tProviding guidance to an implementer of an MSE Client and/or AF in order to support implementation. Such guidelines may also be provided in line with the specification text.\n-\tIf provided, the guidelines are preferably separated in style and form from the main specification text. For example, this may be added in a specific \"box\" or \"frame\" that identifies this as an informal implementation hint.\n3.\tConsiderations on device API implementations (Recommended)\n-\tThe device APIs MSE-6 and MSE-7 are typically only documented on a conceptual level.\n-\tConsiderations on the specifics for implementing the APIs, for example in Android as RESTful APIs in devices, is relevant.\n4.\tConsiderations of a Conformance Test Suite (Optional, but expected to be at least considered):\n-\tA Conformance Test Suite is a collection of tests covering the breadth of the MSE functions. The tests include the definition of test cases, the definition of test assets as well as the success criteria to pass the tests. A typical figure for a test application to test the implementation of the MSE Client is shown in Figure 5.3.5-1.\n-\tThe considerations documented are expected to allow third parties to implement a full Conformance Test Suite in order to test the 3GPP-defined APIs and conformance for correct implementation. Follow-up such as adopter programs may be considered.\n-\tThe Conformance Test Suites and adopter program may be provided by external organizations, for example 3GPP market representation partners (MRPs).\nThe figure depicts a test framework for MSE (Mean Squared Error) client implementation, illustrating the steps involved in implementing a Mean Squared Error (MSE) client in a test environment. The framework includes various components such as the MSE client, the test environment, and the test data. The figure provides a clear and concise representation of the test framework, making it easy to understand and follow.\nFigure 5.3.5-1: Test Framework for MSE Client Implementation\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.6\tStyle and documentation guidelines",
                            "text_content": "The primary goal is to achieve consistency across the API, as well as across all specifications. Consistency makes it easier for developers, editors, reviewers, and users of the documentation to understand and modify it. While each organization and specification may and should have its own look and feel, it is considered appropriate to establish a style guide convention. The Style Guide of the OpenXR Documentation has been branched from the Vulkan documentation and is hence considered a broadly adopted and established convention. In addition, 3GPP uses OpenAPI for the API definition towards the network.\nHence, it is proposed to align with the style guide and documentation conventions from OpenXR as well as OpenAPI as follows:\n1.\tDevelop APIs for the relevant reference points in a Github- or gitlab-based environment and only port agreements or full specifications to 3GPP specifications. The development of the formal APIs is done in a git-based environment.\n2.\tFor device-internal API definitions, align with the OpenXR style guide https://registry.khronos.org/OpenXR/specs/1.0/styleguide.html as follows:\n-\tUse Asciidoc  to the extent possible to define formal APIs.\nNOTE:\tReferences to the Asciidoctor User Manual are to sections in the document at\n-\tFor API naming conventions, it is proposed that the rules defined in  apply with the following adaptation:\n-\tEach MSE is assigned a prefix (for example MSE). In similar way as XR is used in the OpenXR spec, an equivalent usage of MSE is expected for an MSE spec.  This prefix is used as XR is used in the description above.\n-\tPrefixes are used in the API to denote specific semantic meaning of MSE names, or as a label to avoid name clashes, and are explained here:\n-\tMSE/Mse/mse\n-\tAll types, commands, enumerates and C macro definitions in the specification are prefixed with these characters, according to the rules defined above.\n-\tFor the markup style, it is proposed that the ETSI/3GPP documentation rules as well as the rules defined in https://registry.khronos.org/OpenXR/specs/1.0/styleguide.html#markup apply. In particular, section 5.7 on writing reference pages is expected to apply:\n-\tProvide reference pages for the MSE according to the OpenXR principle https://registry.khronos.org/OpenXR/specs/1.0/man/html/openxr.html\n3.\tFor the network-based APIs and reference points, define RESTful APIs and use the conventional OpenAPI rules as defined by 3GPP in TS 29.501 [16].\n4.\tFor regular data communication reference to existing protocols and formats.\nNOTE: Processes and tools according to W3C as provided in clause 4.3.2 can be added as well.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.7\tExamples",
                            "text_content": "Based on the specification template in clause 5.3.5 and the style guidelines in clause 5.3.6, table 5.3.7-1 provides a potential mapping of the MBMS Client function, as introduced in clause 4.2.1, to the MSE concept.\nTable 5.3.7.1-1 Mapping of MBMS Client to MSE concept\n\nIn summary, the MBMS Client, as currently specified by 3GPP, quite closely follows the definition of an MSE. Because the MBMS Client and the APIs were developed in stages, the documentation is not consistent in one specification, but rather is spread over several documents. However, most of the considered information is present. An improved overall documentation process, more style guidelines and so on would be needed.\nBased on the specification template in clause 5.3.5 and the style guidelines in clause 5.3.6, table 5.3.7.2-1 provides a potential mapping of the DASH Player function, as introduced in clause 4.2.2, to the MSE concept.\nTable 5.3.7.2-1 Mapping of DASH Player to MSE concept\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.3.7.1-1 Mapping of MBMS Client to MSE concept",
                                    "table number": 4,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 5.3.7.2-1 Mapping of DASH Player to MSE concept",
                                    "table number": 5,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "5.4\tDiscussion on different MSE framework proposals",
                    "description": "",
                    "summary": "",
                    "text_content": "Two different approaches for an MSE framework are provided in clause 5. The approaches share many similarities, in particular:\n-\tDefining the key concepts of MSE\n-\tFunctional definitions of the Media Service Enabler.\n-\tMedia Service enabler is a set of mandatory and possibly optional set of functionalities\n-\tDefinition of device-internal APIs and network interfaces.\n-\tSupport of specification and implementations\n-\tEasily mapped to SDK implementation\nHowever, there are also complementary aspects:\n-\tApproach 1, as proposed in clause 5.2, addresses the following additional aspects\n-\tA document for cataloging a MSE specification’s features and their options.\n-\tConfiguration of the Media Service Enabler by supplying configuration parameters as needed by the user of the MSE\n-\tcapability discovery within the Media Service Enabler. This may include aspects that are binary (supported, not supported), but could also be more nuanced, and/or optionally cataloguing the subset of the specification features supported by an implementation in a document and their implemented options.\n-\tApproach 2, as proposed in clause 5.3, addresses the following additional aspects\n-\tReference architecture for MSE based on 5GMS architecture\n-\tTemplate for Media Service Enabler specification drafting\n-\tAddressing aspects beyond specification, namely test, reference implementations, as well as conformance considerations\n-\tTooling, style and documentation guidelines\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "6\tMSE Specification Framework",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "6.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "This clause provides an MSE Specification framework based on the examples and framework considerations in clause 4 and 5, respectively.\nBased on the analysis in clause 5.4, it is considered that the approach in clause 5.3 is used as the baseline for the MSE specification initial framework, but the concepts for 5.3 are beneficially enhanced adding the complementary concepts of the approach in 5.2.  Possible extensions of the framework to provide more consistent deployments can be considered later.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.2\tInitial MSE framework",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.2.1\tGeneral Concepts",
                            "text_content": "The basic concept of the Media Service Enabler is to support third-party applications to make use of advanced functionalities provided by the 5G System, combined with additional well-defined client and network functionalities for media services: an MSE enables improved media services.\nIn implementations and deployments, such packaged functions are typically referred to as a Software Development Kit (SDK) and they are usable by applications through well-defined APIs. A few potential properties of a Media Service Enabler are provided:\n-\tA set of functions that may be used to deploy applications that can make simple use of 5G System functionalities.\n-\tA set of robust features and functionalities which reduce the complexity of developing applications.\n-\tFunctions to leverage system and radio optimizations as well as features defined in 5G System (5G Core Network and 5G NR).\n-\tUsability of the set of functions by well-defined and well-documented device APIs.\n-\tProvision of network interfaces to connect to the 5G System.\n-\tA testable set of functions. Testing and conformance may be addressed outside 3GPP, for example by a Market Representation Partner (MRP) such as 5G-MAG or by an industry forum.\n-\tGuidelines and examples to make use of the set of functionalities provided by an MSE.\nA general initial idea on how to define Media Service Enablers is documented below:\n-\tCombine functions defined in 3GPP (for example a codec) and/or reference technologies defined outside 3GPP, for example in MPEG or Khronos, and provide relevant subsets and profiles of these.\n-\tInclude mandatory, recommended and optional functions.\n-\tDefine signaling and capability negotiation for all functions.\n-\tSpecify requirements for client and network functions, as needed.\n-\tInclude relevant functions such as QoE metrics and KPIs.\nProviding a Media Service Enabler in this form has several benefits:\n-\tThe Application Provider has a set of functions that can be easily accessed in the same way that device functions are accessed today, namely through well-defined device APIs. The Application Provider can also use regular IP connectivity to operate its application.\n-\tFor the MSE developer, the focus is on providing a well-defined set of functions that are exposed to the application through MSE-1 and MSE-2 on the network side, and via MSE-6 on the UE device side.\n-\tThe MSE developer may provide the MSE Application Function and Application Server as well as the MSE Client. In this case, the primary interoperability aspects are at reference points MSE-1 and MSE-6.\n-\tIn another case, the network functions for MSE may be provided by a 5G System operator. In this case the MSE Client and MSE AF are expected to also implement the functions and interoperability defined at reference points MSE-4 and MSE-5.\nIn the remainder of this clause, an MSE reference architecture is provided and functions and interfaces are defined.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.2\tMSE Reference Architecture",
                            "text_content": "The basic concept of the Media Service Enabler is to support third-party delivery of media over the 5G System. Figure 6.2.2-1 provides the Application Provider with a set of 3GPP-specified functions, possibly both on UE and network side, in order to simplify operations. These functions are bundled as a Media Service Enabler (MSE) and offered to the Application Provider as follows:\n-\tThe service may be provisioned on the network side using an MSE Application Function. The provisioning reference point is summarized as MSE-1.\n-\tUser plane data may be exchanged with the Application Provider using an Ingest/Egest interface, MSE-2. Generally, this is a generic IP-based interface that directly uses N6 and the UPF. However, the MSE may offer specific Application Server functions at MSE-2.\n-\tOn the UE side, the functions of an MSE Client are accessed through a well-defined client API, MSE-6, that is aligned with other device APIs. The MSE Client may make use of other device functions that are expected to be accessible via existing device APIs.\n-\tThe MSE Client may be decomposed into Core Functions defined in the relevant Media Service Enabler specification, and External Device Reference Functions that are accessed through well-defined APIs MSE-7.\n-\tThe MSE Client connects to the 5G network and may make use of Application Functions associated with this Media Service Enabler. Those functions are exposed through MSE-5.\n-\tUser data is exchanged with the MSE Application Server (if any) through MSE-4, which may define specific requirements on the usage of protocols, codecs, formats etc.\nThe figure depicts various media service enablers in 5G systems, including the role of the 5G core network, the role of the 5G network slicing, and the role of the 5G network slicing in enabling various media services.\nFigure 6.2.2-1: Media Service Enablers in 5G Systems\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.3\tFunctions and reference points",
                            "text_content": "The following functions are defined:\n-\tApplication: A UE-resident function that uses the Media Service Enabler to create a service or a user experience\n-\tMSE Client: A UE-internal function dedicated to a specific Media Service Enabler. The MSE Client is a logical function and its subfunctions may be distributed within the UE according to implementation choice. For example, it may define new core functions as well as referencing existing functions that are required to complete the expected functions.\n-\tMSE Application Function: An Application Function similar to that defined in clause 6.2.10 of TS 23.501 [2], dedicated to a specific Media Service Enabler.\n-\tMSE Application Server: An Application Server dedicated to a specific Media Service Enabler.\nThe following reference points, interfaces and APIs are defined:\n-\tMSE-1 (MSE Provisioning API): External API, exposed by the MSE AF, which enables the Application Provider to provision the usage of the MSE.\n-\tMSE-2: (MSE Ingest/Egest API): Optional external API exposed to the Application Provider by the MSE AS and used when the MSE AS in the trusted DN is selected to process content for the MSE.\nNOTE:\tMSE-3 may be used for communication between MSE AS and MSE AF, but is not considered relevant.\n-\tMSE-4: (MSE User Plane interface): Interface used by an MSE Client to exchange user data with an MSE AS.\n-\tMSE-5: (MSE Control API): APIs exposed by an MSE AF to the MSE Client to configure and control MSE functions.\n-\tMSE-6: (MSE Client APIs): APIs exposed by the MSE to the Application for client-internal communication to make use of MSE functions\n-\tMSE-7: (External Device API): APIs exposed by the UE device to the MSE to make use of resident client functions such as rendering, playback, etc.\n-\tMSE-8: (Application APIs): Interface used for information exchange between the Application and the Application Provider.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.3\tMSE specification Template",
                    "description": "",
                    "summary": "",
                    "text_content": "The following is a template for a Media Service Enabler specification.\n1\tScope\n2\tReferences\n3\tTerms and abbreviations\n4\tGeneral\n4.1\tOverview\n-\tMotivation and scope for the MSE.\n-\tApplied MSE principles.\n-\tOverview of specification.\n-\tAddressed functionalities.\n4.2\tTypical Use Cases and applications\n-\tUse Cases that may be addressed with the MSE.\n-\tApplications benefitting from the MSE.\n5\tReference architecture and procedures\n5.1\tReference Architecture\n-\tInstantiation of the general MSE architecture.\n-\tProviding the defined APIs and reference points.\n5.2\tCore functions and extensions\n-\tCore functions are all functions that need to be implemented to support the MSE (required).\n-\tExtensions define a set of functions that are only required for certain use cases (optional).\n-\tConfiguration parameters for the core functions and extensions\n-\tCapability options for the core functions and in particular for the extensions\n5.3\tProcedures and call flows\n-\tHigh-level call flows and procedures for the most common use cases.\n-\tSummary of specified reference points and procedures in this specification pa.\n6\tPrerequisites\n6.1\t5G System functionalities\n-\tFunctionalities required of the 5G System with reference.\n-\tMay address requirements dependent on core functions or as part of an extension only.\n6.2\tDevice APIs and functionalities\n-\tRequirements and functionalities needed from the device.\n-\tDefinition of reference point MSE-7 requirements, i.e. reference APIs and functionalities.\n7\tMSE Application Function specification\n7.1\tOverview of the MSE API calls\n7.2\tFunctionality\n-\tDefines states of the MSE AF in relation to the MSE client. Examples for state are IDLE, REGISTERED, ACTIVE, etc.\n7.3 MSE AF API methods and parameters\n-\tRESTful APIs.\n-\tMSE-5 is defined.\n-\tMSE-1 may be defined.\n8\tMSE user plane specification\n8.1\tOverview\n-\tDefinition of MSE-4 interface.\n-\tProtocol Stack.\n8.2\tUser plane configuration protocols\n8.4\tContent delivery protocols\n8.3\tFormats and Codecs\n8.4\tQoS considerations\n8.5\tSecurity considerations\n9\tMSE Client specification\n9.1\tOverview of the MSE API Calls\n9.2\tFunctional description\n-\tUses reference pre-requisites, user plane functionality, control plane, and client API.\n-\tDefines states of the MSE client in relation to the application. Examples for state are IDLE, REGISTERED, ACTIVE, etc. State changes may occur through or by information received through MSE-6 the network interface.\n-\tA set of client-internal reference parameters that are changed based on either configuration or API calls through MSE-6 or by information received through the network interface MSE-4 or MSE-5.\n-\tMetrics, data and KPI collections, for example to be provided to analytics servers.\n9.3 MSE Client API methods and parameters\n-\tDifferent methods that allow the application to communicate with the MSE client. For each method, the following information is provided:\n-\tA high-level description of the method.\n-\tAn example call flow.\n-\tThe parameters that are exchanged as part of the API call.\n-\tThe usage of the API by the application.\n-\tThe MSE Client actions, including pre and post conditions.\n-\tConfiguration\n-\tCapabilities\nThis API typically includes functionalities such as configurations, settings, notifications, events, data and status query as well as functional methods. As an example, the API may provide the ability to query metrics and KPIs,\n-\tOptional capability discovery: discovery of the capabilities supported by an implementation including the additional configuration parameters specific to that MSE implementation\n-\tSpecification using a well-defined language, for example C or IDL,\nAnnex A (informative): Implementation guidelines\nA.1\tGuidelines for application developers\n-\tUse Case mapping.\nThe guidelines are expected to provide guidance how an application developer can make use of the MSE. This is preferably done by providing examples and implementation hints.\nA.2\tGuidelines for MSE implementers and reference implementations\n-\tThe guidelines are expected to provide guidance to an MSE Client and/or AF implementor in order to support implementation.\n-\tA reference implementation of the MSE may be considered.\nAnnex B (informative): Considerations on conformance testing\nB.1\t\tOverview\n-\tA Conformance Test Suite is a collection of tests covering the breadth of the MSE functions. The tests include the definition of test cases, the definition of test assets as well as the success criteria to complete the tests.\nB.2\t\tPotential testing framework\nB.3\t\tPotential test cases\nB.4\t\tPotential conformance testing procedures\nAnnex C (normative): API Reference Pages\nAnnex D (informative): Considerations on API Instantiations\n-\tThe device API implementations MSE-6 and MSE-7 are typically only done on a conceptual level.\n-\tConsiderations on specifics for the instantiations of the APIs, for example in Android or in web browsers.\nAnnex E (informative): Attachments and online repositories\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.4\tBeyond the MSE Specification – guidelines, tests and reference implementations",
                    "description": "",
                    "summary": "",
                    "text_content": "Beyond the MSE specification, and as indicated in clause 6.3, the following aspects are considered in the annexes for the specification template:\n-\tGuidelines for application developers.\n-\tGuidelines for MSE implementers and reference implementations.\n-\tDevice API instantiations.\n-\tConformance Test Suite.\nSuch efforts are not necessarily suitable for 3GPP working processes. Hence, collaboration with other organizations, such 3GPP market representation partners (MRPs) or open-source projects may be considered. The annexes indicated above may initially contain only considerations that can be used by third parties in order to develop their own implementations, guidelines, test frameworks and reference implementations.\nAs an example, the development of a reference implementation of MSE Client and network functions can support developers and Application Providers to quickly gain access to newly defined functionalities. This is, for example, shown in figure 6.4-1 for which reference implementations of the MSE are used as part of a reference, demonstration or production application. In this case, the reference implementation makes use of existing device functions and 5G System functions. As an example, the 5G-MAG reference tools  provide an approach to developing such reference implementations.\nThe figure depicts a reference implementation of Mean Squared Error (MSE) for a 5G network, illustrating the process of calculating MSE for different scenarios. The MSE is a common metric used to evaluate the performance of a network, and this figure provides a visual representation of the calculation process.\nFigure 6.4-1: MSE Reference Implementation\nAs another example to support the specification development, a conformance test suite may be developed in order to test the 3GPP-defined APIs and conformance for correct implementation. A framework for this is provided in figure 6.4-2.\nThe figure depicts a test/conformance framework for MSE (Minimum System Efficiency) client implementation, illustrating the steps involved in ensuring the system meets specified performance and efficiency requirements. The framework includes a series of test cases, each representing a different scenario, and a conformance test that validates the system's performance against predefined standards. The figure provides a clear and organized approach to testing and ensuring the efficiency of the MSE client implementation.\nFigure 6.4-2: Test/Conformance Framework for MSE Client Implementation\nIn this case, a test framework is developed in order to test the functionality of the MSE Client implementation. If all tests are passed, the MSE Client may be considered conformant to the specification. Such an approach may be even extended to create an adopter program, i.e. providing a process that allows an MSE implementation to officially claim support of the MSE specification by having verified that the all tests have been passed.\nWhile 3GPP is not in a position to mandate such a conformance regime, it is highly recommended to consider the potential benefits of supporting third parties in developing suitable test and conformance programs.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "7\tWriting MSE Specifications: Style Guides and Tools",
            "description": "The primary goal is to achieve consistency across the API, as well as across all specifications. Consistency makes it easier for developers, editors, reviewers, and users of the documentation to understand and modify it. While each organization and specification may and should have its own look and feel, it is considered appropriate to establish a style guide convention. As an example, the Style Guide of the OpenXR Documentation has been branched from the Vulkan documentation and is hence considered a broadly adopted and established convention. In addition, 3GPP uses OpenAPI for the API definition towards the network.\nHence, it is proposed to align with the following style guide and documentation conventions:\n1.\tDevelop APIs for the relevant reference points in an Internet-accessible source code repository (e.g. 3GPP Forge) and only port agreements or full specifications to 3GPP specifications. The development of the formal APIs is also done in an Internet-accessible source code repository.\n2.\tFor device-internal API definitions, align with the OpenXR style guide [20] as follows:\na)\tUse Asciidoc [21] to the extent possible to define formal APIs.\nb)\tFor API naming conventions, it is proposed that the rules defined in  apply with the following adaptation:\n-\tEach MSE is assigned a prefix (for example MSE). In similar way as XR is used in the OpenXR specification, an equivalent usage of MSE or an equivalent prefix is expected for an MSE specification. Prefixes are used in the API to denote specific semantic meaning of MSE names, or as a label to avoid name clashes as follows:\nMSE/Mse/mse\n-\tAll types, commands, enumerates and C macro definitions in the specification are prefixed with these characters, according to the rules defined above.\nc)\tFor the mark-up style, it is proposed that the ETSI/3GPP documentation rules as well as the rules defined in section 4 of [20] apply. In particular, section 5.7 of [20] on writing reference pages is expected to apply.\nd)\tProvide reference pages for the MSE according to the OpenXR principle https://registry.khronos.org/OpenXR/specs/1.0/man/html/openxr.html\n3.\tFor the network-based APIs and reference points, define RESTful APIs using OpenAPI YAML according to the rules and conventions defined by 3GPP in TS 29.501 [16].\n4.\tFor regular User Plane data communication reference existing protocols and formats.\nNOTE:\tSupport for workflows and automation is considered by providing a workflow and tools based on the Khronos OpenXR specification [9].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "8\tPotentially Relevant 5G Media Service Enablers",
            "description": "The media service enabler concepts may be applied to existing functions or to future ones.\nExisting functions that may be converted and updated to MSE:\n- \tMBMS Client as defined in TS 26.346 [3] and TS 26.347 [4]. The MBMS client already uses most of the MSE principles in the way it is defined in TS 26.347 [4].\n- \tMBS Client as defined in TS 26.502 [22].\n- \tMedia Session Handler as defined in TS 26.512 [7]. This is a candidate for MSE, but not consistently as it is not explicitly serving application but is more considered a background service. Certain aspects of MSE may be applied, but not all.\nOther potential MSE candidates:\n-\tSplit Rendering functionality\n-\tAI/ML functions\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "9\tConclusions and Recommendations",
            "description": "The Technical Report introduces and defines the concept of Media Service Enablers. In recent studies and specification work, it was identified that 5G Media functions and 5G System functions need to be made attractive for third-party applications, in particular those that include media delivery. Hence, it is important that these functions are accessible to third-party applications independent of a 3GPP service. For this purpose, it is considered to introduce normative specifications in 3GPP SA4 that are\n- \tmore than just a core functionality, e.g. a codec, without any connection to a service or application\n- \tless than a full service that includes all aspects of session establishment, delivery, codecs, rendering and a full user experience\nSuch new specifications are referred to 5G \"Media Service Enablers\".\nThis document includes, among others:\n-\tDefinition of the principal properties of Media Service Enablers.\n-\tExamples for similar concepts in 3GPP and external specifications\n-\tConsiderations on an appropriate Media Service Enabler Framework\n-\tDefinition of a specification template for Media Service Enablers.\n-\tIdentification of possibly relevant stage-2 and stage-3 work for Media Service Enablers.\n-\tCollection of a set of initially relevant Media Service Enablers for normative work\nThe technical report is supported by appropriate tools and style guides to write good MSE specifications.\nIt is recommended that device centric media-related functions defined in 3GPP follow the specification principles defined in\n-\tClause 6 MSE Specification Framework\n-\tClause 7 Writing MSE Specifications: Style Guides and Tools\nInitial candidates for MSE Specifications are provided in clause 8.\n\nA software management tool is expected to be used. Details are for further study.\n\n\n",
            "summary": "",
            "tables": [
                {
                    "description": "",
                    "table number": 6,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        }
    ]
}