{
    "document_name": "33180-i00.docx",
    "content": [
        {
            "title": "Foreword",
            "description": "This Technical Specification has been produced by the 3rd Generation Partnership Project (3GPP).\nThe contents of the present document are subject to continuing work within the TSG and may change following formal TSG approval. Should the TSG modify the contents of the present document, it will be re-released by the TSG with an identifying change of release date and an increase in version number as follows:\nVersion x.y.z\nwhere:\nx\tthe first digit:\n1\tpresented to TSG for information;\n2\tpresented to TSG for approval;\n3\tor greater indicates TSG approved document under change control.\ny\tthe second digit is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc.\nz\tthe third digit is incremented when editorial only changes have been incorporated in the document.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "1\tScope",
            "description": "The present document specifies the security architecture, procedures and information flows needed to protect the mission critical service (MCX). The architecture includes mechanisms to protect the Common Functional Architecture and security mechanisms for mission critical applications. This includes Push-To-Talk (MCPTT), Video (MCVideo) and Data (MCData). Additionally, security mechanisms relating to on-network use, off-network use, roaming, migration, interconnection, interworking and multiple security domains are described.\nThis specification complements the Common Functional Architecture defined in TS 23.280 [36], the functional architecture for MCPTT defined in 3GPP TS 23.379 [2], the functional architecture for MCVideo defined in TS 23.281 [37], the functional architecture for MCData defined in TS 23.282 [38] and mission critical services using 5GS in TS 23.289 [54].\nThe MC service can be used for public safety applications and also for general commercial applications e.g. utility companies and railways. As the security model is based on the public safety environment, some MC security features may not be applicable for commercial purposes.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "2\tReferences",
            "description": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non-specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".\n[2]\t3GPP TS 23.379: \"Functional architecture and information flows to support Mission Critical Push To Talk (MCPTT); Stage 2\".\n[3]\t3GPP TS 22.179: \"Mission Critical Push To Talk (MCPTT); Stage 1\".\n[4]\t3GPP TS 33.210: ''3G security; Network Domain Security (NDS); IP network layer security''.\n[5]\t3GPP TS 33.310: \"Network Domain Security (NDS); Authentication Framework (AF)\".\n[6]\t3GPP TS 33.203: \"3G security; Access security for IP-based services\".\n[7]\t3GPP TS 33.179 Release 13: \"Security of Mission Critical Push To Talk (MCPTT) over LTE\".\n[8]\t3GPP TS 33.328: ''IP Multimedia Subsystem (IMS) media plane security''.\n[9]\tIETF RFC 6507: ''Elliptic Curve-Based Certificateless Signatures for Identity-Based Encryption (ECCSI)''.\n[10]\tIETF RFC 6508: ''Sakai-Kasahara Key Encryption (SAKKE)''.\n[11]\tIETF RFC 6509: ''MIKEY-SAKKE: Sakai-Kasahara Key Encryption in Multimedia Internet KEYing (MIKEY)''.\n[12]\tIETF RFC 3550: ''RTP: A Transport Protocol for Real-Time Applications''.\n[13]\tIETF RFC 3711: \"The Secure Real-time Transport Protocol (SRTP)\".\n[14]\t3GPP TS 33.401: \"3GPP System Architecture Evolution (SAE); Security architecture\".\n[15]\t3GPP TS 23.228: \"IP Multimedia Subsystem (IMS); Stage 2\".\n[16]\t3GPP TS 33.222: \"Generic Authentication Architecture (GAA); Access to network application functions using Hypertext Transfer Protocol over Transport Layer Security (HTTPS)\".\n[17]\t3GPP TS 33.220: \"Generic Authentication Architecture (GAA); Generic Bootstrapping Architecture (GBA)\".\n[18]\tNIST FIPS 180-4: \"Secure Hash Standard (SHS)\".\n[19]\tIETF RFC 6749: \"The OAuth 2.0 Authorization Framework\".\n[20]\tIETF RFC 6750: \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\".\n[21]\tOpenID Connect 1.0: \"OpenID Connect Core 1.0 incorporating errata set 1\", .\n[22]\tIETF RFC 3830: \"MIKEY: Multimedia Internet KEYing\".\n[23]\tIETF RFC 3602: \"The AES-CBC Cipher Algorithm and Its Use with IPsec\".\n[24]\tIETF RFC 4771: \"Integrity Transform Carrying Roll-Over Counter for the Secure Real-time Transport Protocol (SRTP)\".\n[25]\tIETF RFC 6043: \"MIKEY-TICKET: Ticket-Based Modes of Key Distribution in Multimedia Internet KEYing (MIKEY)\".\n[26]\tIETF RFC 7714: ''AES-GCM Authenticated Encryption in the Secure Real-time Transport Protocol (SRTP)''.\n[27]\tW3C: \"XML Encryption Syntax and Processing Version 1.1\", .\n[28]\tW3C: \"XML Signature Syntax and Processing (Second Edition)\", .\n[29]\tIETF RFC 5905: \"Network Time Protocol Version 4: Protocol and Algorithms Specification\".\n[30]\tIETF RFC 5480: \"Elliptic Curve Cryptography Subject Public Key Information\".\n[31]\tIETF RFC 6090: \"Fundamental Elliptic Curve Cryptography Algorithms\".\n[32]\tIETF RFC 7519: \"JSON Web Token (JWT)\".\n[33]\tIETF RFC 7662: \"OAuth 2.0 Token Introspection\".\n[34]\tIETF RFC 3394: \"Advanced Encryption Standard (AES) Key Wrap Algorithm\".\n[35]\tIETF RFC 7515: \"JSON Web Signature (JWS)\".\n[36]\t3GPP TS 23.280: \"Common functional architecture to support mission critical services; Stage 2\".\n[37]\t3GPP TS 23.281: \"Functional architecture and information flows for mission critical video; Stage 2\".\n[38]\t3GPP TS 23.282: \"Functional model and information flows for Mission Critical Data\".\n[39]\t3GPP TS 23.002: \"Network Architecture\".\n[40]\tIETF RFC 2045: \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\".\n[41]\tIETF RFC 2392: \"Content-ID and Message-ID Uniform Resource Locators\".\n[42]\tNIST Special Publication 800-38D: \"Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC\".\n[43]\tIETF RFC 5116: \"An Interface and Algorithms for Authenticated Encryption\".\n[45]\tIETF RFC 7521: \"Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants\".\n[46]\tIETF RFC 7523: \"JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants\".\n[47]\t3GPP TS 22.280: \" Mission Critical Services Common Requirements; Stage 1\".\n[48]\t3GPP TS 23.283: \" Mission Critical Communication Interworking with Land Mobile Radio Systems; Stage 2\".\n[49]\t3GPP TS 24.379: \"Mission Critical Push To Talk (MCPTT) call control; Protocol specification.\"\n[50]\t3GPP TS 24.282: \"Mission Critical Data (MCData) signalling control; Protocol specification. \"\n[51]\tIETF RFC 3711 Errata ID 3712, .\n[52]\tIANA: \"Multimedia Internet KEYing (MIKEY) Payload Name Spaces\", .\n[53]\tIETF RFC 7636: \"Proof Key for Code Exchange by OAuth public clients\".\n[54]\t3GPP TS 23.289: \"Mission Critical services over 5G System; Stage 2\".\n[55]\t3GPP TS 33.501: \"Security architecture and procedures for 5G System\".\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "3\tDefinitions and abbreviations",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "3.1\tDefinitions",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the terms and definitions given in 3GPP TR 21.905 [1] and the following apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [1].\nAuthorised Identity: An application identity given to an authorised user or network entity (e.g. MC Service ID) containing authorisation information.\nExternal KMS: The KMS which is the root of trust for a specific External Security Domain.\nExternal Security Domain: A security domain that the user is not a member of, but with which the user may communicate.\nFloor: Floor(x) is the largest integer smaller than or equal to x.\nHome KMS: The KMS that is the root of trust of the Home Security Domain.\nHome Security Domain: The MCX user's primary security domain.\nIdentity Management Domain: The MC clients and MC functions that share an Identity Management Server (IdMS). To be specific, the MC clients request access tokens from the same primary IdMS, and the MC functions accept access tokens from this IdMS.\nKMS Certificate: A certificate containing the security parameters for a security domain. This is required to support identity-based cryptography and differs from X.509 certificates used for traditional PKI. See Annex D.3.1 for details.\nKMS URI: A unique identifier for a security domain, or equivalently, a logical KMS.\nMCX:  Mission critical services where “MCX” may be substituted with the term “MCPTT”, “MCVideo”, “MCData”, or any combination thereof.\nMigration KMS: The KMS that is the root of trust of a specific Migration Security Domain.\nMigration Security Domain: A security domain that a user is a (temporary) member of, and may be keyed to use, but is not the user's Home security domain.\nPartner domain:  A secondary MC domain which may support MC services for MC users who are home to a different MC domain.  See also External Security Domain.\nPrimary domain:  The “home” MC domain where MC users receive their primary identity management and MC services.  See also Home Security Domain.\nPrivileged signalling: Signalling which is performed by an authorised user and allows the authorised userto cause an intrusive action on a target client without the target user’s permission.\nSecurity Domain: A security domain is a group of MCX users who share common security requirements and policies for their communications. From a technical perspective, users within a security domain share a KMS and KMS certificate. MCX users may be members of one or more security domains.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.2\tAbbreviations",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [1] and the following apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [1].\nCMS\tConfiguration Management Server\nCS\tCrypto Session\nCSB-ID\tCrypto Session Bundle Identifier\nCSC\tCommon Services Core\nCSK\tClient-Server Key\nCSK-ID\tClient-Server Key Identifier\nDPCK\tMCData Payload Cipher Key\nDPPK\tMCData Payload Protection Key\nDPPK-ID\tMCData Payload Protection Key Identifier\nGBA\tGeneric Bootstrapping Architecture\nGMK\tGroup Master Key\nGMK-ID\tGroup Master Key Identifier\nGMS\tGroup Management Server\nGUK-ID\tGroup User Key Identifier\nIdM\tIdentity Management\nIdMS\tIdentity Management Server\nInK\tIntegrity Key\nInK-ID\tIntegrity Key Identifier\nInterKMRec\tInterworking Key Management Record\nInterKMRec-ID\tInterworking Key Management Record Identifier\nInterSD\tInterworking Security Data\nIWF\tInterWorking Function\nJSON\tJavaScript Object Notation\nJWS\tJSON Web Signature\nJWT\tJSON Web Token\nKDF\tKey Derivation Function\nKFC\tKey For Control Signalling\nKFC-ID\tKey for Floor Control Identifier\nKMS\tKey Management Server\nMBCP\tMedia Burst Control Protocol\nMCData\tMission Critical Data\nMCPTT\tMission Critical Push to Talk\nMCVideo\tMission Critical Video\nMCX\tMission Critical Services\nMKFC\tMulticast Key for Floor Control\nMSCCK\tMBMS subchannel control key\nMSRP\tMessage Session Relay Protocol\nMuSiK\tMulticast Signalling Key\nMKI\tMaster Key Identifier\nNTP\tNetwork Time Protocol\nNTP-UTC\tNetwork Time Protocol – Coordinated Universal Time\nOIDC\tOpenID Connect\nPCK\tPrivate Call Key\nPCK-ID\tPrivate Call Key Identifier\nPKCE\tProof Key for Code Exchange\nPSK\tPre-Shared Key\nSEG\tSecurity Gateway\nSeGy\tSecurity Gateway\nSPK\tSignalling Protection Key\nSRTCP\tSecure Real-Time Transport Control Protocol\nSRTP\tSecure Real-Time Transport Protocol\nSSRC\tSynchronization Source\nTBCP\tTalk Burst Control Protocol\nTGK\tTraffic Generating Key\nTrK\tKMS Transport Key\nTrK-ID\tKMS Transport Key Identifier\nUID\tUser Identifier for MIKEY-SAKKE (referred to as the 'Identifier' in RFC 6509 [11])\nXPK\tXML Protection Key\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "4\tOverview of Mission Critical Security",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "4.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "The mission critical security architecture defined in this document is designed to meet the security requirements defined in Annex A. The security architecture provides signalling and application plane security mechanisms to protect metadata and communications used as part of the MC service. The following signalling plane security mechanisms are used by the MC service:\n-\tProtection of the signalling plane used by the MC Service, defined in clause 6.1 and 6.2.\n-\tProtection of inter/intra domain interfaces, defined in clause 6.3.\nThe following application plane security mechanisms are used by the MC service:\n-\tAuthentication and authorisation of users to the MC Service, defined in clause 5.1.\n-\tProtection of sensitive application signalling within the MC Service, defined in clause 9.\n-\tSecurity of RTCP (e.g. floor control, transmission control) within the MC Service, defined in clause 9.\n-\tSecurity of data signalling within the MCData Service, defined in clause 8.\n-\tEnd-to-end security of user media within the MC Service. Defined in clause 7 for MCPTT and MCVideo services and defined in clause 8 for the MCData service.\nSecurity mechanisms in the signalling and application plane are independent of each other, but may both be required for a secure MC system.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.2\tSignalling plane security architecture",
                    "description": "",
                    "summary": "",
                    "text_content": "Within a MC system, signalling plane security protects the interfaces used by the MC application. Figure 4.2-1 provides an overview of these interfaces.\nThe figure depicts a signalling plane security architecture, illustrating the various security measures and protocols in place to protect the communication system. Key components include encryption, authentication, and access control, ensuring the confidentiality, integrity, and availability of data transmitted over the network.\nFigure 4.2-1: Signalling plane security architecture\nSignalling from the MC client is passed over both HTTP and SIP. The signalling plane security mechanisms for client to server interfaces and between network elements are defined in clause 6.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.3\tMC system security architecture",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.3.1\tGeneral",
                            "text_content": "The MC system security architecture provides protection both between MC clients, between the MC client and the MC domain, and also between MC domains. MC system security on the client is bound to the MC user associated with the client and not to the MC UE. Consequently, user authentication and authorisation to the MC domain is required prior to access to the majority of MC services.\nApplication plane signalling security allows protection of MC-specific signalling from all entities outside of the MC system (potentially including the SIP core). Application plane signalling security is applied from the MC client to the client's primary MC domain. It may also be applied between MC domains.\nMedia security allows protection of MC media within the MC system. It is applied end-to-end between MC clients or in some cases from the MC client to the MCX server (e.g. One-to-server video push or one-from-server video pull). Under normal operation however, MC network entities such as the MCX Servers are typically unable to decrypt the media.\nAdditionally, signalling plane protection is applied to all HTTP and SIP connections into the MC domain. While signalling plane protection and signalling plane entities are not shown in this subclause, including the SIP core and HTTP proxy, it is assumed that signalling plane protection mechanisms are in use.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.2\tUser authentication and authorisation",
                            "text_content": "Prior to connecting to the MC domain, the MCX user application requires a 'token' authorising its access to MC services. To obtain authorisation token(s), the MCX user application authenticates the MC user to an Identity Management Server which provides the authorisation token.\nThe authorisation token is provided to MCX network entities, such as the MCX Server, over an MCX signalling interface (either a HTTP interface or SIP interface). The MCX network entity will provide access to MCX services based upon the token provided.\nThe architecture for user authentication and authorisation is shown in Figure 4.3.2-1.\nThe figure depicts a user authentication and authorisation system, with various components such as user authentication, user authorization, and user management. The system uses biometric and behavioral data to verify user identity and grant access to authorized applications.\nFigure 4.3.2-1: User authentication and authorisation\nWhile the HTTP proxy and SIP core is not shown in Figure 4.3.2-1, authorisation occurs over HTTP or SIP and hence uses signalling plane protection to encrypt authorisation requests carried over HTTP to a HTTP proxy and authorisation requests carried in SIP messages through the SIP core to the MCX domain.\nThe mechanism to perform user authentication and authorisation is defined in clause 5.1.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.3\tIdentity keying of users and services",
                            "text_content": "Once a MC client has obtained user authorisation to access the MCX domain, the client may obtain key material associated with the user's identity using the authorisation token. Identity keys are required to support key distribution for application signalling, floor control, transmission control and media. Identity key material is obtained via an HTTP request to a Key Management Server as shown in Figure 4.3.3-1.\nIdentitiy keying is repeated periodically (e.g. monthly). This ensures that user identities are regularly verified and that users that are no longer part of the MCX domain are removed from the system.\nThe figure depicts the identity keying of MC entities in a 3GPP standard, illustrating the use of a 128-bit key for each entity, which is a significant improvement over previous 16-bit key systems. This keying scheme ensures secure communication and is a key component of 3GPP's efforts to enhance the security of mobile communication networks.\nFigure 4.3.3-1: Identity keying of MC entities\nWhile not shown in Figure 4.3.3-1, the UE connection to the KMS is over HTTP and hence is secured using TLS directly between the MC client and KMS or between the MC client and the HTTP proxy or directly to the KMS. When the HTTP proxy is in the path between the MC client and the KMS, key material is wrapped using a transport key (TrK) distributed out-of-band (reference clause 5.3.2).  The TrK or a shared Integrity key (InK) may be used to sign the key material.\nA number of MC network entities also require identity key material including the MCX Server and Group Management Server. This key material is obtained via the same HTTP interface.\nThe mechanism to perform identity keying is defined in clause 5.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.4\tProtection of application plane signalling",
                            "text_content": "Application plane signalling security protects application signalling between the MC client and the MCX server. Initial key distribution for application signalling is performed by sending a client-server key (CSK) from the MC client to the MCX Server over the SIP interface. The key is secured using the identity key material provisioned by the Key Management Server.  Following initial key distribution, the MCX server may perform a ‘key download' procedure to update key material, and to key the client to allow multicast signalling to be protected.\nThere are a variety of types of application plane signalling, including:\n-\tXML signalling within SIP payloads\n-\tControl signalling (e.g. RTCP for floor control or transmission control).\n-\tMCData signalling payloads within SIP payloads.\nIn each case, the same root key material is used to protect the signalling when the signalling is unicast on the uplink or downlink. Should the signalling be multicast on the downlink, the MCX Server will distribute key material for this purpose and use this key material to protect multicast signalling.\nThe security architecture is shown in Figure 4.3.4.1-1.\nThe mechanisms to provide application plane signalling security are defined in clause 9.\nThe figure depicts a layered architecture of application plane signalling security, illustrating the various components and their interconnections. The application layer includes the application layer protocol (ALP), the application layer security (ALS), and the application layer security (ALS) protocol. The figure also shows the application layer security (ALS) protocol, which is a key component of the application layer security (ALS) protocol. The figure also includes the application layer security (ALS) protocol, which is a key component of the application layer security (ALS) protocol. The figure also includes the application layer security (ALS) protocol, which is a key component of the application layer security (ALS) protocol. The figure also includes the application layer security (ALS) protocol, which is a key component of the application layer security (ALS) protocol. The figure also includes the application layer security (ALS) protocol, which is a key component of the application layer security (ALS) protocol. The figure also includes the application layer security (ALS) protocol, which is a key component of the application layer security (ALS) protocol. The figure also includes the application layer security (ALS) protocol, which is a key component of the application layer security (ALS) protocol. The figure also includes the application layer security (\nFigure 4.3.4.1-1: Application plane signalling security\nApplication plane signalling security can also be applied between MCX servers. In this case the MCX servers are keyed manually. While not shown in Figure 4.3.4-1, application plane signalling uses SIP and HTTP and hence is also secured up to the SIP core and HTTP proxy respectively.\nClause 4.3.4.1 describes the application plane signalling security functions between the MC client and MCX Servers and between MCX Servers. These security functions can be enforced by the MCX Servers themselves as described in Clause 4.3.4.1.\nHowever, in some scenarios, there may be value in applying application plane signalling security at the edge of the MC Domain. This deployment option involves moving security functions out of the MCX Servers and into Signalling Proxies at the edge of the MC Domain as shown in Figure 4.3.4.2-1.\n\nThe figure depicts a simplified representation of signalling proxies in a 4G network, illustrating their role in the communication process.\nFigure 4.3.4.2-1: Signalling Proxies\nThere are two types of Signalling Proxy:\n-\tClient Signalling proxy (CS Proxy), which controls security towards the MC clients.\n-\tInterconnection Signalling Proxy (IS Proxy), which controls security towards other MC Domains.\nFull details of both types of Signalling Proxy are provided in Annex I. The use of signalling proxies has the following advantages:\n-\tThe mission critical core network architecture is not exposed to Mission Critical clients or other external entitites. The client no longer needs to know the SIP URI of each distinct MCX Server.\n-\tIntrusion detection within the XML signalling link is possible at the network edge.\n-\tPolicies can be assigned to signalling on entry to the Mission Critical network.\n-\tThe number of signalling protection keys required by the client and the MC Domain are reduced.\n-\t Multicast bearers can be shared across multiple MCX Servers.\nEffectively, for XML-protected application signalling, the Signalling Proxy is able to perform equivalent functions to a Session Border Controller (as defined in RFC 5853 [24]), or IMS IBCF (as defined in Annex I of 3GPP TS 23.228 [23]).\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.5\tMedia security",
                            "text_content": "Media security establishes an end-to-end security context between MC users to support group communications and private communications for the MCPTT, MCVideo or MCData services. The intention is for media to be able to be encrypted end-to-end between MC clients, irrespective of whether the media is routed unicast via the media distribution server, multicast via the media distribution server, or transmitted over a direct or IOPS connection.\nKey distribution for groups is performed by the Group Management Server. Key distribution for private calls is performed by the initiating MC client. Once a security context is established, the media is protected using the distributed key material. Aditionally, when MC UEs are off-network, the security context that is used to protect media security is also used to protect control signalling (e.g. RTCP).\nMedia security for groups is secured by establishing a shared group security context between group members. Key distribution for the group security context is performed by a Group Management Server. The Group Management Server creates and sends group keys and group security parameters over SIP as part of group management.\nGroup keys and security parameters are encrypted by the Group Management Server to the identity of the individual MC users that are members of the group.. MC users and MCX servers require identity keying by a KMS prior to performing group management.\nFigure 4.3.5.2-1 provides an overview of the group keying process. Details of the process may be found in clause 5.7.\n\nThe figure depicts a group keying scheme for media security, illustrating the use of a group keying matrix to generate secure key pairs for communication. The matrix is composed of a 3x3 matrix, with each row representing a different group of users, and each column representing a different group of media. The matrix is then multiplied by a key matrix to generate the secure key pairs. The figure also includes a visual representation of the matrix, allowing for easy understanding of the group keying scheme.\nFigure 4.3.5.2-1: Group keying for media security\nOnce a group key has been shared with MC users, keys are derived from that group key to protect media (and control signalling when the UE is off-network).\nFor MCPTT and MCVideo (specifically RTP), key derivation is based on the MCPTT or MCVideo user's identity, hence every member of the group encrypts media using a different key. Media is encrypted using the SRTP protocol in this case. For MCData, the user-specific key derivation is not required. Media is encrypted within a MCData data payload in this case.\nWhen the MC UE has a network connection the encrypted media is routed to other MC clients via the media distribution function in the MCX Server. Media from an MC client is distributed to group members by the MCX Server over either unicast or multicast. When the MC UE is off-network, the encrypted media is routed directly to MC clients on other MC UEs. The security procedure for protecting media is the same in either case. Details of media encryption are provided in clause 7 for MCPTT and MCVideo, and clause 8 for MCData.\nUnlike media, control signalling (such as floor control or transmission control) is protected differently when the UE has a network connection and when it is off-network. When the UE has a network connection, control signalling traffic is encrypted to the identity of the MC Domain. When it is off-network, control signalling is encrypted directly to UEs using a key derived from the root key for the group or private communication. Details of control signalling encryption is provided in clause 9.4.\nFigure 4.3.5.2-2 provides an overview of how media is protected for group communications.\n\nThe figure depicts a group media protection system, illustrating the various components and their interconnections. The system includes a group of media protection devices (MPDs) and a group media protection controller (GMPC), which are responsible for managing and monitoring the protection of group media. The GMPC is equipped with advanced protection algorithms and monitoring tools, ensuring the protection of group media in real-time.\nFigure 4.3.5.2-2: Group media protection\nAs part of setting up a private call, the call initiator provides the session key to the terminating client. The key is encrypted to the MC user that is currently registered on the terminating client. As a result, MC users require identity keying by a KMS prior to performing private communications.\nThe figure depicts a media security system for private calls, illustrating various components such as encryption, authentication, and access control. It highlights the importance of secure communication in today's digital world, where sensitive information is transmitted over public networks.\nFigure 4.3.5.3-1: Media security for private calls\nFigure 4.3.5.3-1 provides an overview of media protection for private calls. For clarity, MC network entities do not have access to the private call key material and hence are not able to decrypt the media for the private call communication (unless the monitoring function is specifically authorised for either user).\nDetails of private call key distribution are provided in clause 5.6, specific MCPTT and MCVideo procedures are described in clause 7 and specific MCData procedures are in clause 8.\nOnce private call key distribution has been completed, control signalling and application signalling are used to setup and control the media transport of a private communication. Media will be routed via the media distribution function in the MCX Server when the UE is online, and directly when the UE is off-network. Details of media protection are found in clauses 7 and 8, control signalling protection is found in clause 9.4 and application signalling protection is found in clause 9.3.\nThe media security context shall also be used to protect control signalling (e.g. floor control) when the MC UE is off-network.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "5\tCommon mission critical security framework",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "5.1\tUser authentication and authorization",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.1.1\tGeneral",
                            "text_content": "The generic steps for MCX user authentication and authorisation is shown in figure 5.1.1-1.\n\nFigure 5.1.1-1 illustrates the MC X authentication and authorisation process, which is crucial for secure communication in a 5G network. MC X stands for Multi-Factor Authentication, and it involves the use of multiple factors to verify the identity of the user. This process ensures that only authorized users can access sensitive data, reducing the risk of unauthorized access and data breaches. The figure shows the various components involved in the authentication process, including the user's identity, the authentication factor, and the authorization factor. The use of MC X ensures that only authorized users can access the network, protecting sensitive data and preventing unauthorized access.\nFigure 5.1.1-1: MCX authentication and authorisation\nAt UE power-on, the MCX UE performs EPS UE authentication as specified in TS 33.401 [14] or 5GS UE authentication as specified in TS 33.501 [55], depending on the system. The MCX UE then performs the following steps to complete authentication of the user, authorisation of the user, MCX service registration, and identity binding between signalling layer identities and the MC service ID(s).\n-\tA: MCX user authentication.\n-\tB: SIP Registration and Authentication.\n-\tC: MCX Service Authorization.\nThese procedures are described in more detail in subsequent clauses.\nSteps A and B may be performed in either order or in parallel. For scenarios where this order has an impact on the identity bindings between signalling layer identities and the MC service ID(s), a re-registration (Step B) to the SIP Core may be performed to update the registered signalling layer identity.\nIf an MCX UE completes SIP registration in Step B prior to performing MCX user authentication in Step A and MCX user service authorization as part of Step C, the MCX UE shall be able to enter a 'limited service' state. In this limited state, where the MCX user is not yet authorized with the MCX service, the MCX UE shall be able to use limited MCX services (e.g. an anonymous MCX emergency communication). The MCX Server is informed of the registration of the MC UE with the SIP core though Step B-2.\nAdditionally, an HTTP-1 authentication mechanism is used.\nNOTE:\tMechanisms for confidentiality and integrity protection (not defined in this clause) may be combined only with certain authentication procedures.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.1.2\tUser authentication",
                            "text_content": "The mission critical Identity Management functional model is shown in figure 5.1.2.1-1 and consists of the identity management server located in the MCX common services core and the identity management client located in the MCX UE. The IdM server and the IdM client in the MCX UE establish the foundation for MCX user authentication and user authorization.\nNote that use of the term \"IdM client\" in this document is generically used to represent any identity management service endpoint within an MC UE that communicates with the IdM Server (authorization endpoint or token endpoint) over the CSC-1 reference point for MC identity management services. It does not imply any specific client implementation of the client-side identity management service.\nThe CSC-1 reference point, between the IdM client in the UE and the Identity Management server, provides the interface for user authentication. CSC-1 is a direct HTTP interface between the IdM client in the UE and the IdM server and shall support OpenID Connect 1.0 ([19], [20] and [21]).\nThe OpenID Connect profile for MCX shall be implemented as defined in annex B. MCX user authentication, MCX user service authorization, OpenID Connect 1.0, and the OpenID Connect profile for MCX shall form the basis of the identity management architecture.\nIn alignment with the OpenID Connect 1.0 [21] and OAuth 2.0 standards [19] and [20], CSC-1 shall consist of two identity management interfaces; the authorization endpoint and the token endpoint.  These endpoints are separate and independent from each other, requiring separate and independent IP addressing.  The authorization endpoint server and the token endpoint server may be collectively referred to as the IdM server in this document.\nThe HTTP connection between the Identity Management client and the Identity management server shall be protected using HTTPS.\n\nThe figure depicts a functional model for MC Identity Management, illustrating the various components and their interactions within the system. It includes a user interface (UI), a server, a database, and a security layer. The model demonstrates how the system manages user identities, ensuring secure access to resources.\nFigure 5.1.2.1-1: Functional Model for MC Identity Management\nTo support MCX user authentication, the IdM server (IdMS) shall be provisioned with the user's MC ID and MC service IDs (the MC service ID may be the same as the MC ID). A mapping between the MC ID and MC service ID(s) shall be created and maintained in the IdMS. When an MCX user wishes to authenticate with the MCX system, the MC ID and credentials are provided via the UE IdM client to the IdMS (note that the primary authentication method used to obtain the MC ID and credentials is out of scope of the present document). The IdMS receives and verifies the MC ID and credentials, and if valid returns an ID token, refresh token, and access token to the UE IdM client specific to the credentials. The MCX client learns the user's MC service ID(s) from the ID token. Table 5.1.2.1-1 shows the MCX tokens and their usage.\nTable 5.1.2.1-1: MC tokens\n\nIn support of MCX user authorization, the access token(s) obtained during user authentication is used to gain MCX services for the user.  MCX user service authorisation is defined in clause 5.1.3.\nTo support the MCX service identity functional model, the MC service ID(s) shall be:\n-\tProvisioned into the IdM database and mapped to MC IDs.\n-\tProvisioned into the KMS and mapped to identity associated keys.\n-\tProvisioned into the MCX user database and mapped to a user profile; and\n-\tProvisioned into the GMS(s) and mapped to Group IDs.\nFurther details of the user authorization architecture are found in clause 5.1.3.\nThe framework utilises the CSC-1 reference point as depicted in Figure 5.1.2.2-1.\n\nThe MC X User Authentication Framework is a comprehensive solution for secure user authentication in a 5G network. It utilizes a combination of encryption, authentication, and authorization techniques to ensure the confidentiality and integrity of user data. The framework is designed to be modular and scalable, allowing for easy integration with existing 5G network infrastructure.\nFigure 5.1.2.2-1: MCX User Authentication Framework\nThe User Authentication procedure in Step A of Figure 5.1.1-1 is further detailed into 3 sub steps that comprise the MCX user authentication framework:\n-\tA-1 - Establish a secure tunnel between the MCX UE and Identity Management (IdM) server. Subsequent steps make use of this tunnel.\n-\tA-2 - Perform the User Authentication Process (User proves their identity).\n-\tA-3 - Deliver the credential(s) that uniquely identifies the MCX user to the IdM client.\nFollowing step A-3, the MCX client uses the credential(s) obtained from step A-3 to perform MCX user service authorization as per procedure C in figure 5.1.1-1.\nThe framework supporting steps A-2 and A-3 shall be implemented using OpenID Connect 1.0 ([19], [20] and [21]).\nNOTE:\tMCX service authorization in step C of Figure 5.1.1-1 is outside the scope of the User Authentication framework.\nFigure 5..1.2.3.1-1 describes the MCX User Authentication Framework using the OpenID Connect protocol. Specifically, it describes the steps by which an MCX user authenticates to the Identity Management server (IdMS), resulting in a set of credentials delivered to the UE uniquely identifying the MC service ID(s). The means by which these credentials are sent from the UE to the MCX services are described in clause 5.1.3. The authentication framework supports extensible user authentication solutions based on the MCX service provider policy (shown in step 3), with username/password-based user authentication as a mandatory supported method. Other user authentication methods in step 3 (e.g. biometrics, secureID, etc.) are possible but not defined here. A detailed OpenID Connect flow can be found in annex C.\nThe figure depicts the flow of OpenID Connect (OIDC) authentication in a multi-tenant environment, specifically for a user authentication system. It illustrates the steps involved in the authentication process, including the use of OpenID Connect, OAuth 2.0, and the use of a token endpoint. The flow is designed to support multiple tenants, ensuring that each tenant has its own unique identity.\nFigure 5.1.2.3.1-1: OpenID Connect (OIDC) flow supporting MCX user authentication\nStep 1:\tUE establishes a secure tunnel with the Identity Management server (IdMS).\nStep 2:\tUE sends an OpenID Connect Authentication Request to the IdMS. The request may contain an indication of authentication methods supported by the UE.\nStep 3:\tUser Authentication is performed.\nNOTE:\tThe primary credentials for user authentication (e.g. biometrics, secureID, OTP, username/password) are based on MCX service provider policy. The method chosen by the MCX service provider is neither defined nor limited by the present document.\nStep 4:\tIdMS sends an OpenID Connect Authentication Response to the UE containing an authorization code.\nStep 5:\tUE sends an OpenID Connect Token Request to the IdMS, passing the authorization code.\nStep 6:\tIdMS sends an OpenID Connect Token Response to the UE containing an ID token and an access token (each which uniquely identify the user of the MCX service). The ID token is consumed by the UE to personalize the MCX client for the MCX user, and the access token is used by the UE to communicate the identity of the MCX user to the MCX server(s).\nFigure 5.1.2.3.2-1 shows the OIDC flow when Username/Password is used as the user authentication method.\nThe figure depicts an example of OpenID Connect (OIDC) using a username/password example. It illustrates the authentication process using a username and password, with the user's identity being verified by the server. The figure shows the user's credentials, the server's response, and the server's response to the user's request.\nFigure 5.1.2.3.2-1: OpenID Connect (OIDC) Example Using Username/Password\nStep 1:\tUE establishes a secure tunnel with the Identity Management server (IdMS).\nStep 2:\tUE sends an OpenID Connect Authentication Request to the IdMS. The request may contain an indication of authentication methods supported by the UE.\nStep 3a:\tIdMS sends an HTML form to UE prompting the user for their username & password.\nStep 3b:\tUE sends the username & password (as provided by the user) to the IdMS.\nStep 4:\tIdMS sends an OpenID Connect Authentication Response to the UE containing an authorization code.\nStep 5:\tUE sends an OpenID Connect Token Request to the IdMS, passing the authorization code.\nStep 6:\tIdMS sends an OpenID Connect Token Response to the UE containing an ID token and an access token (each which uniquely identify the user of the MCX service). The ID token is consumed by the UE to personalize the MCX client for the MCX user, and the access token is used by the UE to communicate the identity of the MCX user to the MCX server(s).\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 5.1.2.1-1: MC tokens",
                                    "table number": 1,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "5.1.3\tMCX user service authorisation",
                            "text_content": "This clause expands on the MCX user service authorization step shown in figure 5.1.1-1 step C.\nMCX User Service Authorization is the function that validates whether or not a MCX user has the authority to access certain MCX services. In order to gain access to MCX services, the MCX client in the UE presents an access token (acquired during user authentication as described in subclause 5.1.2) to each service of interest (i.e. Key Management, MCX server, Configuration Management, Group Management, etc.). If the access token is valid, then the user is granted the use of that service. Figure 5.1.3.1-1 shows the flow for user authorization which covers key management authorization, MCX user service authorization, configuration management authorization, and group management authorization.\nNOTE:\tAll HTTP traffic between the UE and HTTP proxy, and all HTTP traffic between the UE and KMS (if not going through the HTTP proxy) is protected using HTTPS.\nFor key management authorization, the KM client in the UE presents an access token to the KMS over HTTP. The access token shall be scoped for key management services as defined in annex B.4.2.2. The KMS validates the access token and if successful, provides one or more sets of user specific key material back to the UE KM client based on the MC service ID(s) present in the access token (MCPTT ID, MCVideo ID and/or MCData ID). User specific key material includes identity based key information for media and signalling protection.  If an interworking key management record (InterKMRec) exists and is associated to the requesting MC service ID (see clause 11.2.3), the KMS shall also provide the InterKMRec.  This key management authorisation may be repeated for each KM service the user is authorised to use (MCPTT, MCVideo, MCData). In order to secure the transfer of user specific key material from the KMS to the KM client when using the TrK and InK, the KM client includes the TrK-ID and the InK-ID in the key management authorization request.\nFor MCPTT user service authorization, the MCPTT client in the UE presents an access token to the MCPTT server over SIP. The access token shall be scoped for MCPTT services as defined in annex B.4.2.2. The MCPTT server validates the access token and if successful, authorizes the user for full MCPTT services and sends an acknowledgement back to the MCPTT client. The MCPTT server then maps and maintains the IMPU to MCPTT ID association. The MCPTT ID to IMPU association shall only be known to the application layer. The SIP message used to convey the access token from the MCPTT client to the MCPTT server may be either a SIP REGISTER or SIP PUBLISH message.\nFor MCVideo service authorization, the MCVideo client in the UE presents an access token to the MCVideo server over SIP. The access token shall be scoped for MCVideo services as defined in annex B.4.2.2. The MCVideo server validates the access token and if successful, authorizes the user for full MCVideo services and sends an acknowledgement back to the MCVideo client. The MCVideo server then maps and maintains the IMPU to MCVideo ID association. The MCVideo ID to IMPU association shall only be known to the application layer. The SIP message used to convey the access token from the MCVideo client to the MCVideo server may be either a SIP REGISTER or SIP PUBLISH message.\nFor MCData user service authorization, the MCData client in the UE presents an access token to the MCData server over SIP. The access token shall be scoped for MCData services as defined in annex B.4.2.2. The MCData server validates the access token and if successful, authorizes the user for full MCData services and sends an acknowledgement back to the MCData client. The MCData server then maps and maintains the IMPU to MCData ID association. The MCData ID to IMPU association shall only be known to the application layer. The SIP message used to convey the access token from the MCData client to the MCData server may be either a SIP REGISTER or SIP PUBLISH message.\nThe UE can now perform configuration management authorization and download the user profile for the service(s) (MCPTT, MCVideo, MCData). Following the flow described in subclause 10.1.4.3 of 3GPP TS 23.280 [36] \"MC service user obtains the MC service user profile(s) from the network\", the Configuration Management (CM) client in the UE sends an access token in the user profile query to the Configuration Management server over HTTP. The access token shall be scoped for configuration management services as defined in annex B.4.2.2. The CM server receives the request and validates the access token, and if valid, the CM server uses the identity from the access token (MCPTT ID, MCVideo ID, MCData ID) to obtain the user profile from the MCX user database. The CM server then sends the user profile back to the CM client over HTTP.  This configuration management authorisation may be repeated for each CM service the user is authorised to use (MCPTT, MCVideo, MCData).\nUpon receiving each user profile, the Group Management (GM) client in the UE can now perform group management authorization. The GM client obtains the user's group membership information from the user profile, and following the flow shown in clause 10.1.5.2 of 3GPP TS 23.280 [36] \"Retrieve group configurations at the group management client\", the Group Management (GM) client in the UE sends an access token in the Get group configuration request to the host GM server of the group membership over HTTP. The access token shall be scoped for group management services as defined in annex B.4.2.2. The GM server validates the access token, and if valid, completes the flow. As part of group management authorization, group key information is provided as per subclause 5.7 of the present document.  This group management authorisation may be repeated for each GM service the user is authorised to use (MCPTT, MCVideo, MCData).\nFor MC UEs that support mission critical location services, authorization is accomplished by including an access token in each location message (i.e. location information report, location reporting trigger, etc.) sent by the location management client to the location management server.  The access token shall be scoped for location management services as defined in annex B.4.2.2.  The location management server validates the access token and (if successful) processes the message (e.g. accepts and stores the location information report).  If an access token cannot be validated, local policy may dictate an action to be taken within the location management server with regards to the received location message (e.g. the local policy may require storage of the location information report as an emergency provision).\n\n\nThe figure depicts a user service authorization process in a mobile communication network, specifically focusing on the MC X user service authorization. The process involves the authentication of the user, the authorization of the service, and the provisioning of the service. The figure illustrates the flow of information, with the user initiating the authorization process, the service provider verifying the user's identity, and the service provider provisioning the service. The figure also includes a visual representation of the authorization process, with the user's credentials and the service provider's response.\nFigure 5.1.3.1-1: MCX user service authorization\nThe user authorization procedure in Step C of Figure 5.1.1-1 is further detailed into 5 sub steps that comprise the MCX user service authorization process:\nStep C-1a:\tIf not already done, establish a secure HTTP tunnel using HTTPS between the MCX UE and MCX proxy server. Subsequent HTTP messaging makes use of this tunnel .\nStep C-1b:\tWhen required by the MCX system, establish a secure HTTP tunnel using HTTPS between the MCX KM client and the KMS. When supported, subsequent HTTP messaging between the MCX KM client and the KMS makes use of this tunnel in lieu of the tunnel set up in Step C-1a.\nStep C-2:\tThe KM client in the MCX UE presents an access token to the KMS over HTTP. The KMS authorizes the user for key management services based upon the MC service ID(s) provided and replies to the client with identity specific key information. This step may be repeated to authorise the user with additional KM services (MCPTT, MCVideo, MCData) as necessary.\nStep C-3:\tThe MCX client in the UE presents an access token to the MCX server over SIP as defined in clause 5.1.3.2 of the present document.  This step may be repeated to authorise the user with additional MCX services (MCPTT, MCVideo, MCData) as necessary.\nStep C-4:\tThe CM client in the UE follows the \"MCX user obtains the user profile (UE initiated)\" flow from clause 10.1.4.3 of 3GPP TS 23.280 [36], presenting an access token in the Get MCX user profile request over HTTP. If the token is valid, then the CM server authorizes the user for configuration management services. Completion of this step results in the CM server providing the user's profile to the CM client. This step may be repeated as necessary to obtain the user profile for additional services (MCPTT, MCVideo, or MCData).\nStep C-5:\tThe GM client in the UE follows the \"Retrieve group configurations at the group management client\" flow as shown in clause 10.1.5.2 of 3GPP TS 23.280 [36], presenting an access token in the Get group configuration request over HTTP. If the token is valid, the GMS authorizes the user for group management services. Completion of this step results in the GMS sending the user's group policy information and group key information to the GM client.  This step may be repeated to authorise the user for additional group services (MCPTT, MCVideo, MCData) as necessary.\nDepending on implementation, MCX user service authorization may be performed by sending the access token to the MCX server over the SIP-1 and SIP-2 reference points using either a SIP REGISTER message or a SIP PUBLISH message. Clause 5.1.3.2.2 describes how to use the SIP REGISTER message to transport the access token to the MCX server and clause 5.1.3.2.3 describes how to use the SIP PUBLISH message to transport the access token to the MCX server.\nDuring initial SIP registration, the SIP REGISTER message shall not be delayed for lack of an access token. If an access token is not available then SIP registration shall proceed without the inclusion of the access token and the access token shall be transmitted to the MCX server as per Step C-3 in figure 5.1.3.1-1.\nIf an access token is available before SIP registration, or if the UE becomes de-registered and a SIP re-registration is required, the SIP REGISTER message may include the access token without requiring the user to re-authenticate.\nThe access token may be sent over SIP to the MCX server to re-bind an IMPU and MC service ID (MCPTT ID, MCVideo ID or MCData ID) if either have changed (e.g. IMPU is different due to SIP deregistration/SIP re-registration, or user logs out and another user logs onto the same UE).\nThe use of a SIP REGISTER message to provide the access token to the MCX server is shown in figure 5.1.3.2.2-1. The inclusion of an access token in any particular SIP REGISTER message is optional.\n\nThe figure depicts a user service authorization process using the SIP REGISTER message, which is a method of requesting a user service. The process involves the user service provider (USP) sending a REGISTER message to the user service provider (USP) to request the user service. The USP then sends a REGISTER response to the USP, indicating that the request has been received and processed. The figure provides a visual representation of the process, allowing users to understand the steps involved in the authorization process.\nFigure 5.1.3.2.2-1: MCX User Service Authorization using SIP REGISTER message\nStep 5 of figure 5.1.3.2.2-1 shows the access token message passed to the SIP core in a SIP REGISTER. Upon successful SIP authentication, the SIP core forwards the access token to the MCX server in the third part registration request message (Step 9).\nIn Steps 9 through 11, the MCX server receives the third part registration request message, validates the access token, binds the IMPU and MC service ID (MCPTT ID, MCVideo ID or MCData ID) if the access token is valid, and responds to the 3rd party registration message.\nThe use of a SIP PUBLISH message to provide the access token to the MCX server is shown in figure 5.1.3.2.3-1. The inclusion of an access token in any particular SIP PUBLISH message is optional.\n\nThe figure depicts a user service authorization process using the SIP PUBLISH message, illustrating the steps involved in authorizing a user service. The process includes the creation of a user service, the sending of a PUBLISH message to the user service, and the subsequent receipt of a PUBLISH message from the user service. The figure provides a visual representation of the communication flow and the steps involved in the authorization process.\nFigure 5.1.3.2.3-1: MCX User Service Authorization using SIP PUBLISH message\nAs shown in Step 1 of figure 5.1.3.2.3-1, the SIP PUBLISH message carries the access token through the SIP core to the MCX server.\nIn Steps 2 and 3, the MCX server receives the SIP PUBLISH message, validates the access token, binds the IMPU and MC service ID (MCPTT ID, MCVideo ID or MCData ID) if the access token is valid, and responds to the SIP PUBLISH message.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.1.4\tInter-domain MC user service authorization",
                            "text_content": "When a MC User requires service authorisation to a service that is located in a different Identity Management Domain, coordination between the identity management services of the primary Identity Management Domain and the partner Identity Management Domain is required.  For example, a MC User from Identity Management Domain A may be a member of a group that is home to Identity Management Domain B within the same system or an MC user may migrate from their primary MC domain to a partner MC domain.\nWhile inter-domain user service authorisation is not used for authorising users to services across interconnected MC systems (MC clients always connect directly to MC servers in their primary system with interconnection services provided via MC server to MC server communications), inter-domain user service authorisation shall be used for authorising migration of MC users.\nThis sub-clause shall be used for authenticating and authorizing a user that is home to Identity Management Domain A with a group service that is located in Identity Management Domain B or when a user from Identity Management Domain A migrates to a MC domain within Identity Management Domain B..\nThe inter-domain identity management functional model is shown in Figure 5.1.4.2-1.\nThe figure depicts a functional model for inter-domain identity management in a telecommunications network. It illustrates the various components involved in managing user identities across different domains, such as the user's identity in the network, the network's identity in the network, and the network's identity in the network. The model includes a user's identity in the network, a network's identity in the network, and a network's identity in the network. The figure also includes a user's identity in the network, a network's identity in the network, and a network's identity in the network. The figure also includes a user's identity in the network, a network's identity in the network, and a network's identity in the network. The figure also includes a user's identity in the network, a network's identity in the network, and a network's identity in the network. The figure also includes a user's identity in the network, a network's identity in the network, and a network's identity in the network. The figure also includes a user's identity in the network, a network's identity in the network, and a network's identity in the network. The figure also includes\nFigure 5.1.4.2-1: Functional Model for Inter-Domain Identity Management\nIn Figure 5.1.4.2-1, the IdMS located in the primary Identity Management Domain (MC Domain A) is the home identity management server for the user.  The partner IdMS is located in a second Identity Management Domain (MC Domain B) and provides identity mangement services for the primary user when authorising to partner group services or when the MC user is attempting to migrate.\nThe CSC-1 reference point between the UE IdM client and the partner IdM server endpoints shall be a direct connection and shall be protected with HTTPS (TLS).\nThe primary IdMS certificate(s) used to validate the user credentials at the partner IdMS are provisioned into the partner IdMS using an out of band mechanism beyond the scope of this document.\nAs defined in Clause 5.1.2 an access token is required for user service authorisation.  The same principle applies for inter-domain user service authorisation, in that the MC client must present a valid access token issued from the partner IdMS in MC Domain B for authorisation to services located in MC Domain B.\nThe inter-domain identity management procedure shall be triggered when an MC client, after performing user service authorisation within the primary Identity Management Domain, determines that the user is a member of a group service that is located in a partner IdMS domain (as indicated in the user profile).\nAdditionally, the inter-domain identity management procedure shall be triggered when a user attempts to migrate from their primary MC system to a partner MC system.\nIn order for the MC client to obtain the MC Domain B authorisation access token(s), the token exchange procedure with the primary IdM service (MC Domain A) shall be used to obtain a security token that identifies the user to the partner IdM service.  This security token shall be specific to the partner IdM service and signed by the primary IdM service per IETF RFC 7515 [35].  Upon validation of the security token, the partner IdM service shall provide the access token(s) to the MC client specifically scoped for that user.  The access token(s) shall provide the user with authorisation to the service(s) in the partner Identity Management Domain (MC Domain B) which may include services related to migration.\nFigure 5.1.4.2-2 shows the token exchange and authentication procedure.\n\nThe figure depicts a token exchange procedure in a blockchain network, illustrating the process of transferring tokens between nodes. Nodes exchange tokens through a consensus mechanism, ensuring the integrity and security of the network.\nFigure 5.1.4.2-2:  Token exchange procedure\nThe token exchange profile for accessing the partner identity management service (steps 1-5 in Figure 5.1.4.2-2) shall consist of [45] and [46] and shall be profiled as defined in Annex B.7.\nNOTE:\tA specific and independent security token is required for each partner identity management domain.\nWithin a single MC System with interconnected MC domains, once the MC client obtains the access token specific to the partner group service(s) (step 5 in Figure 5.1.4.2-2), the MC client shall follow the user service authorisation procedure defined in clause 5.1.3 to access the group service(s) within the partner domain.\nFor migration of an MC user from their primary MC domain to a partner MC domain, once the MC client obtains the access token specific to the partner MC system (step 5 in Figure 5.1.4.2-2), the MC client shall follow the user service authorisation procedure defined in clause 5.1.5.\nThe token exchange procedure shall be repeated for each partner identity management domain where the MC client requires access and authorisation to group service(s) within that partner MC domain or when the user migrates from their primary MC system to a partner MC system.\nAnnex C.2 shows the detailed flow for inter-domain MC user service authorization using the OAuth 2.0 token exchange procedure.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.1.5\tMC user migration service authentication and authorisation",
                            "text_content": "When an MC user migrates from their primary MC domain to a partner MC domain, MC user migration service authentication and MC user migration service authorisation shall be carried out prior to the migrated MC user receiving services at the partner MC domain.\nFigure 5.1.5-1 shows the MC user migration service authentication and authorisation procedure.\n\nThe figure depicts a service authorization process for migrating to a partner MC system. It illustrates the steps involved in obtaining authorization from the partner MC system, including obtaining necessary permissions, verifying the system's readiness, and ensuring compliance with partner policies. The figure also includes a flowchart to guide the process, with arrows indicating the sequence of actions.\nFigure 5.1.5-1\tService authorization for migration to partner MC system\n1-5.\tMC user migration service authentication shall be the inter-domain identity management steps 1-5 in Figure 5.1.4.2-2 of clause 5.1.4.2.\n6.\tUpon receiving a successful Token Response message, the MC client shall initiate the ‘Service authorisation for migrating to a partner MC system’ procedure as shown in Figure 5.1.5-2.\n7.\tFollowing successful execution of step 6, service authorisation to services in the migration partner MC system shall be performed as defined in clause 5.1.3.\nFigure 5.1.5-2 shows the ‘Service authorisation for migrating to a partner MC system’ procedure.  Details of this procedure can be found in clause 10.6.3 of 23.280 [36].\nThe figure depicts a service authorization process for migrating to a partner MC system. It illustrates the steps involved in obtaining authorization from the partner MC system, including obtaining necessary permissions, verifying the system's readiness, and ensuring compliance with partner policies. The figure also includes a flowchart to guide the process, with arrows indicating the sequence of actions.\nFigure 5.1.5-2\tService authorization for migration to partner MC system\n1.\tThe ‘Migration service authorization request’ message is sent by the MC service client to the partner MC service server and includes the access token obtained in step 5 of Figure 5.1.5-1.\n2.\tThe partner MC service server performs an initial authorization check to verify that the MC service user is permitted to migrate to the partner MC system.  This step includes validation of the access token received in step 1 and shall be performed as defined in Annex B.11.\n3-11.\tThese steps are as defined in clause 10.6.3 of 23.280 [36].\nNOTE:\tAn access token is neither required nor provided in steps 3-11.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.2\tKey management common elements",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.2.1\tOverview of key management",
                            "text_content": "This clause details the key management procedures for MCX users. It allows entities in MCX systems to establish a security association to support future communications.\nThe primary purpose of these procedures is to allow MCX entities to communicate with each other using end-to-end security. End-to-end security provides assurance to MCX users that no unauthorized access to communications is taking place within the MCX network. End-to-end communication security may be applied to media when operating on-network and media, floor control, transmission control, and media control when operating off-network.\nA security domain is managed by a Key Management Server (KMS). The KMS is a component of the Common Services Core within the MCX system architecture. For any end-point to use or access end-to-end secure communications, it needs to be provisioned with key material associated to its identity by the KMS. Through the use of the KMS, MC administrators are able to manage the use of, and access to, secure communications within the MCX network.\nKey provisioning for groups is performed by a Group Management Server (GMS), authorized and provisioned by the KMS. The Group Management Server is responsible for distributing the key material to MCX users within the group. This establishes a group security context. With the group security context established, MCX users can communicate using end-to-end security.\nPrior to protecting group communications during off-network operation, the UE shall acquire the necessary group key material either while operating on-network or through off-network provisioning.\nNOTE:\tVoid\nKey provisioning for private communications is performed by the initiating UE as the communication is setup. This creates an end-to-end security context that is unique to the pair of users involved in the call. With a security context established, it may be used to encrypt media when on-network and, when off-network, media, floor control, transmission control, and media control traffic between the end-points.\nPrior to protecting private calls during off-network operation, the UE shall acquire the necessary individual key material either while operating on-network or through off-network provisioning.\nThe key provisioning procedures described in this specification use common security methodologies for key distribution.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.2\tCommon key distribution",
                            "text_content": "The security mechanism described in this clause allows a key, K, to be distributed from an initiating party to a receiving party. It provides confidentiality of the key, and integrity and authenticity of the payload. It is used within a number of different security procedures in this specification.\nThe key, K, is distributed encrypted specifically to the receiving entity and signed by the initiating entity. Prior to call commencement, both MCX UEs shall be provisioned by the KMS with time-limited key material associated with the MCX entity's URI. The key is distributed with a 32-bit Key Identifier (K-ID). This payload is a MIKEY-SAKKE I_MESSAGE, as defined in IETF RFC 6509 [11], which ensures the confidentiality of the key, plus integrity and authenticity of the payload.\nThe key is encrypted to the user identity (UID) associated to the receiving MCX entity using the security domain parameters provided in the public values in the certificate received from the KMS. The UID used to encrypt the data is derived from the receiving entity's URI (e.g. sip:user.002@mcptt.example.org) and a time-related parameter (e.g. the current year and month). The terminating entity's URI is added to the recipient field (IDRr) of the message.\nThe payload includes the encrypted key and the key identifier (K-ID). The key is unique within the MC domain. On creating the key, the initiator generates a 32-bit key identifier (K-ID). The 4 most significant bits of the K-ID shall indicate the purpose of the key, the other 28-bits shall be randomly generated. The key identifier (K-ID) is stored in the CSB-ID field of the MIKEY I_MESSAGE.\nThe payload is signed using (the KMS-provisioned key associated to) the identity of the initiating entity. The UID used to sign the data is derived from the initiating entity's URI (e.g. sip:user.001@mcptt.example.org) and a time-related parameter (e.g. the current year and month). The initiating entity's URI is added to the initiator field (IDRi) of the message.\nNOTE:\tThis solution is for the end-to-end protection of keys and does not protect the identities transmitted. Identities may be masked by transmitting the UID within the MIKEY ID fields as described in Annex E.7.\nThe security processes are summarized in figure 5.2.2-1.\nThe figure depicts a common key distribution mechanism in a 5G network, illustrating how keys are transmitted over a wireless channel. The diagram shows the key distribution process, including the use of key distribution nodes (KDNs) and key distribution points (KDPs). Key distribution is an essential component of 5G security, ensuring that only authorized users can access the network.\nFigure 5.2.2-1: Common key distribution mechanism\nVia this mechanism, the key distribution is confidentiality protected, authenticated and integrity protected.\nIt is possible that the key has been distributed using an unacceptable KMS, either for the initiator's KMS or for the receiver's KMS. This is particularly likely for communications being sent across multiple MC Systems (where KMS information may not have been shared prior to beginning the key distribution procedure). In this case, a KMS Redirect Response (KRR) may be sent back to the initiator. The KRR provides the initiator with information about which KMS may be acceptable. KRR procedures are described in clause 5.2.8.\nAssuming that acceptable KMS(s) have been used, the I_MESSAGE will be processed by the receiving entity. The initiating entity's URI is extracted from the initiator field (IDRi) of the message. This is converted to a UID and used to check the signature on the MIKEY-SAKKE I_MESSAGE. If valid, the UE extracts and decrypts the encapsulated key, K, using the (KMS-provisioned) entity's UID key. The MCX entity also extracts the K-ID. This process is shown in figure 5.2.2-2.\nThe figure depicts a common key extraction mechanism, illustrating the process of extracting a key from a document or a database. The key extraction is a crucial step in data security, ensuring that only authorized users can access sensitive information. The figure shows a key extraction process with a key being extracted from a document, and the extraction process is depicted in a step-by-step manner. The key extraction is performed using a key extraction algorithm, which is a mathematical or computational process that transforms the key into a numerical value. The figure also includes a key extraction tool, which is a device or software that performs the key extraction process. The key extraction process is depicted in a step-by-step manner, with each step being labeled and explained in detail. The key extraction process is performed using a key extraction algorithm, which is a mathematical or computational process that transforms the key into a numerical value. The key extraction process is depicted in a step-by-step manner, with each step being labeled and explained in detail. The key extraction process is performed using a key extraction algorithm, which is a mathematical or computational process that transforms the key into a numerical value. The key extraction process is depicted in a step-by-step manner, with each step being labeled and explained in detail. The\nFigure 5.2.2-2: Common key extraction mechanism\nWith the key successfully shared between the two MCX entities, the entities are able to use the shared security context to protect communications.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.3\tKey distribution with end-point diversity",
                            "text_content": "The security mechanism described in this clause extends that defined in clause 5.2.2 to provide end-point key diversity. The mechanism is identical to that described in clause 5.2.2, except for the distribution of K-ID. Contrary to clause 5.2.2, the key is distributed with an end-point-specific key identity (UK-ID) (e.g. a GUK-ID) derived from the key id (K-ID). This allows the receiving entity of the key distribution to diversify the shared key for end-point-specific use.\nSpecific types of key require use of end-point key diversity. The type of key is defined by the 'purpose tag' within the key identifier stored in the CSB-ID field of the MIKEY payload. Hence on receipt of a key, the contents of the CSB-ID field instruct the receiving entity whether end-point diversity should be applied to the key.\nThe key, K, is distributed encrypted specifically to the receiving entity and signed by the initiating entity as described in clause 5.2.2. The key is distributed with a 32-bit entity-specific Key Identifier (UK-ID) derived from a common key id (K-ID) and a salt (which is derived from the receiving entity's MCX URI). The security domain parameters are provided in the public values in the certificate received from the KMS.\nThe payload includes the entity-specific Key Identifier (UK-ID) within the CSB-ID field. The key, K, is identified by a Key Identifier (K-ID) from which the UK-ID is derived. On creating the key, K, the initiating entity generates a K-ID as follows. The 4 most significant bits of the K-ID is the 'purpose tag' which defines the purpose of the key. The 28 least significant bits of the K-ID is a 28-bit randomly-generated value.\nFor each receiving entity, the initiating entity creates a 28-bit Salt by hashing the receiving entity's URI through a KDF using the key, K, as the key (as defined in Annex F.1.3). The Salt is xor'd with the 28 least-significant bits of the K-ID to create the 32-bit UK-ID.\nNOTE:\tKnowledge of the UK-ID, K-ID and Salt does not reveal the receiving entity URI to those without the key K.\nThe process for generating the UK-ID is summarized in figure 5.2.3-1.\nThe figure depicts a 3D representation of the UK-ID, a key component in the UK's National Health Service (NHS) network. The figure illustrates the network's architecture, including the distribution of nodes, the use of optical fibers, and the interconnection of different services. The UK-ID is a unique identifier for each patient, ensuring secure and efficient communication within the NHS network.\nFigure 5.2.3-1: Generating the UK-ID\nThe UK-ID is placed in the CSB ID field within the header of the I_MESSAGE. The security processes are summarized in figure 5.2.3-2.\nFigure 5.2 illustrates the common key distribution mechanism with end-point diversity, showcasing how keys are distributed among multiple end-points to ensure secure communication. Key distribution is crucial in 5G networks, as it helps to mitigate the risk of eavesdropping and unauthorized access. The figure highlights the use of end-point diversity, which involves distributing keys across multiple devices to increase the security of the communication.\nFigure 5.2.3-2: Common key distribution mechanism with end-point diversity\nAt the receiving MCX entity, the initiating entity's URI is extracted from the initiator field (IDRi) of the message. Along with the time, this is used to check the signature on the payload. If valid, the receiving entity extracts and decrypts the encapsulated key, K, using the (KMS-provisioned) entity's UID key.\nThe receiving MCX entity also extracts UK-ID from the CSB-ID field of the I_MESSAGE. If the 'purpose tag' of the UK-ID indicates that end-point diversity is applied, the receiving entity generates the Salt using its URI and the decrypted key, K. The receiving entity xors the UK-ID and Salt together to obtain the K-ID. The K-ID and UK-ID are stored.\nThe extraction procedure is described in figure 5.2.3-3.\nThe figure depicts a common key extraction mechanism with end-point diversity, illustrating the process of extracting keys from a network. The key extraction is performed at the end-point, which is a key point in the network, and the diversity is achieved by using multiple end-points to extract the key. This mechanism is crucial for ensuring the security and integrity of the network.\nFigure 5.2.3-3: Common key extraction mechanism with end-point diversity\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.4\tKey distribution with associated parameters",
                            "text_content": "The key distribution mechanisms described in Clause 5.2.2 and clause 5.2.3 may be extended to include data associated with the key in the MIKEY I_MESSAGE. This data is stored within a format known as 'associated parameters' and defined in Annex E.6.\nThe associated parameters are encrypted using K, the key distributed within the MIKEY I_MESSAGE. The security mechanism is summarised in Figure 5.2.4-1.\nThe figure depicts a common key distribution mechanism with associated parameters, illustrating the key distribution process in a 5G network. Key distribution is a critical component of 5G networks, ensuring secure and efficient communication. The figure shows the key distribution process, including the key distribution point (KDP), key distribution node (KDN), and key distribution path (KDP). Key distribution is a key component of 5G networks, ensuring secure and efficient communication. The figure shows the key distribution process, including the key distribution point (KDP), key distribution node (KDN), and key distribution path (KDP). Key distribution is a key component of 5G networks, ensuring secure and efficient communication.\nFigure 5.2.4-1: Common key distribution mechanism with associated parameters\nAt the receiving MCX entity, the initiating entity's URI is extracted from the initiator field (IDRi) of the message. Along with the time, this is used to check the signature on the payload. If valid, the receiving entity extracts and decrypts the encapsulated key, K, using the (KMS-provisioned) receiving entity's decryption key.\nThe receiving MCX entity also extracts 'associated parameters' payload from the I_MESSAGE. The receiving entity uses the decrypted key, K, to decrypt these associated parameters. The receiving entity stores these parameters with the distributed key, K. If the Status field within the ‘associated parameters' payload indicates the key has been revoked, the distributed key, K, and the K-ID shall not be used. If the decryption process for the encapsulated associated parameters fails, the key is rejected.\nThe security mechanism is summarised in Figure 5.2.4-2.\nThe figure depicts a common key extraction mechanism with associated parameters, illustrating the process of extracting keys from a database. The diagram shows the key extraction process, including the extraction key, the associated parameters, and the output.\nFigure 5.2.4-2: Common key extraction mechanism with associated parameters\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.5\tKey distribution with SAKKE-to-self payload",
                            "text_content": "The key distribution mechanism defined in clauses 5.2.2, 5.2.3 and 5.2.4 may be extended to allow the initiating entity to be able to decrypt the distributed key, K contained within the payload.\nNOTE:\tWhere the initiating entity is an MCX user logged into multiple devices, this extension is necessary to allow all devices to obtain the key, K and decrypt any subsequent communication.\nIn addition to encrypting the key, K, to the receiving entity, the key is also encrypted to the initiating entity. The UID used to encrypt the data is derived from the initiating entity's URI (e.g. sip:user.002@mcptt.example.org) and a time-related parameter (e.g. the current year and month). The encapsulated key is added to a SAKKE-to-self payload within the MIKEY I_MESSAGE. No other payloads (e.g. IDRr) are affected.\nThe figure depicts a common key distribution mechanism with SAKKE-to-self payload, illustrating the key distribution process in a 5G network. Key distribution is a critical component of 5G, ensuring secure communication and data integrity. The figure shows the key distribution process, including the use of SAKKE (Secure Key Distribution Key Exchange) to distribute keys securely. The figure also shows the self-payload, which is a key distribution mechanism that allows the key to be distributed to the receiver without the need for a central authority. This ensures that the key is distributed securely and is not susceptible to interception or tampering.\nFigure 5.2.5-1: Common key distribution mechanism with SAKKE-to-self payload\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.6\tKey distribution with identity hiding",
                            "text_content": "The key distribution mechanism defined in clauses 5.2.2, 5.2.3, 5.2.4 and 5.2.5 may be extended to allow identities to be masked within the MIKEY payload. This is achieved by adding the UID, rather than the URI to the payload as described in Annex E.7 and shown in figure 5.2.6-1.\nThe figure depicts a common key distribution mechanism with identity hiding, illustrating how keys are distributed among multiple nodes to ensure secure communication.\nFigure 5.2.6-1: Common key distribution mechanism with identity hiding\nOn receipt of a MIKEY payload with identities hidden, the receiving entity should recognise the receiver UID in the packet. If not, the I_MESSAGE shall be rejected. Based on the initiator UID, the receiver checks the validity of the I_MESSAGE signature. At this point the initiator is anonymous to the receiver. If this check fails, the I_MESSAGE shall be rejected. The receiver then extracts the key K. This may be used to decrypt other parts of the packet and extract the initiator URI. Once the initiator URI is extracted, this shall be used to generate the initiator UID and check that it is the one provided in the I_MESSAGE. If not, the I_MESSAGE shall be rejected. This procedure is shown in figure 5.2.6-2\nThe figure depicts a common key extraction mechanism with identity hiding, illustrating the process of extracting a key from a database while maintaining the identity of the user. The diagram shows the key extraction process, with the key being extracted from a database and the identity of the user being hidden.\nFigure 5.2.6-2: Common key extraction mechanism with identity hiding\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.7\tKey distribution across multiple security domains",
                            "text_content": "To support multiple security domains, the security domain used by each user is recorded alongside the user's MC Service ID within configuration parameters in the MC system. Furthermore, the security domain of the GMS is recorded alongside the GMS FQDN and the security domain of the MCX Server is recorded alongside the MCX Server FQDN. Security domains are identified by a unique identifier, the 'KMSUri'. Specifically, the following describes the situations where security domain information is needed:\n1)\tThe MCX Server(s) requires knowledge of the security domain (KMSUri) of users connected to the server.\n2.1)\tOn initiating a MCPTT private call, the initiating UE requires knowledge of the security domain (KMSUri) of the receiving user.\n2.2)\tOn receiving a MCPTT private call, the receiving UE requires knowledge of the security domain (KMSUri) of the initiating user.\n3.1)\tOn initiating a MCVideo private call, the initiating UE requires knowledge of the security domain (KMSUri) of the receiving user.\n3.2)\tOn receiving a MCVideo private call, the receiving UE requires knowledge of the security domain (KMSUri) of the initiating user.\n4.1)\tOn initiating a MCData one-to-one SDS or file transfer, the initiating UE requires knowledge of the security domain (KMSUri) of the receiving user.\n4.2)\tOn receiving a MCData one-to-one SDS or file transfer, the receiving UE requires knowledge of the security domain (KMSUri) of the initiating user.\n5)\tThe Group Management Server requires knowledge of the security domain (KMSUri) of each member of the group.\n6)\tGroup members require knowledge of the security domain (KMSUri) of the group management server.\n7)\tMC users require knowledge of the security domain (KMSUri) of the MCX Server(s) to which they connect.\nNOTE:\tIn most cases, the required security domain will be the Home security domain, meaning that the required KMSUri will be the user's Home KMSUri. It may be more space efficient to only keep a record where the KMSUri is not the Home KMSUri.\nOn encrypting to an entity within the MC System using an I_MESSAGE, the client shall lookup the KMSUri from the appropriate configuration data, then lookup the appropriate KMS Certificate with that KMSUri from the certificate cache downloaded from it's home KMS. The security parameters within the KMS Certificate are used to perform encryption. The KMSUri is added to the I_MESSAGE within the IDRkmsr field.\nEquivalently, when verifying a received I_MESSAGE, the receiving client shall extract the KMSUri from the I_MESSAGE (if present) and check this matches the KMSUri from the appropriate configuration data. The client shall then lookup the appropriate KMS Certificate with that KMSUri from the certificate cache downloaded from it's home KMS. The security parameters within the KMS Certificate are used to perform verification.\nShould a matching certificate not be found, the client may request the certificate based on the KmsUri from it's home KMS using an appropriate KMS Cert request, as defined in Clause D.2.6.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.8\tKMS Redirect Responses (KRRs)",
                            "text_content": "The purpose of KMS Redirect Response procedures is to allow key distribution where the KMS used by the receiver is not known. It also allows policy to be applied to ensure the KMS used by the receiver and initiator is acceptable along the path of the communication.\nThe key message is a KMS Redirect Response (KRR) which conveys KMS policy to the initator. The initiator could be a MC client or GMS. Sometimes multiple MIKEY messages and KRR exchanges will be required to establish a suitable choice of (KMS initiator, KMS receiver) pair. It is also possible that there is no acceptable choice, and as a result of the process the communication fails.\nThe partner (external) security domains (KMS URIs) and certificates are typically provisioned to the UE by the user's Home KMS (see Annex D). The KRR procedure does not provision KMS certificates, but shares information about which KMS may be used with the target key management client.\nThe following scenarios may trigger a KRR procedure in order to communicate KMS information to the initiating entity:\n-\tThe KMS URI (IDRkmsr) used in the MIKEY message may be incorrect for the target; or\n-\tWhile the specified KMS URI may be correct for the receiver, the primary or partner application server may for various reasons still disallow communications with the target entity using the specified receiver KMS URI (IDRkmsr); or\n-\tWhile the specified KMS URI may be correct for the receiver, the primary or partner application server may for various reasons still disallow communications with the receiver using the specified initiator KMS URI (IDRkmsi);\nThe KRR procedure may be initiated by application servers in the signalling path or it may be initiated by the terminating MCX entity. Client shall support receipt of KRRs, and may process or ignore the KRR based on local policy.\nThe KMS URI is the URI used to identify a logical KMS. This represents a security domain of users with shared trust. A logical KMS supports exactly one security domain, hence there is a one-to-one correspondence between KMS URIs, security domains and logical KMSs.\nThe types and uses of KMSs are described in Clause 5.3.\nThe KMS Redirect Response (KRR) contains a list of KMS URIs for both the initiator and the receiver. Both the initiator list and receiver list is an ordered list, with the preferred KMS URIs first. The KMS URI list can also be 'Any' meaning that any KMS is acceptable.\nThe content of a KRR is:\n-\tAn identifier for this type of response.\n-\tThe date and time.\n-\tThe identity of the KRR creator.\n-\tThe MIKEY initiating identity used within the MIKEY message (IDRi).\n-\tThe MIKEY initiator's KMS URI used within the MIKEY message (IDRkmsi).\n-\tThe MIKEY receiving identity used within the MIKEY message (IDRr).\n-\tThe MIKEY receiving's KMS URI used within the MIKEY message (IDRkmsr).\n-\tThe initiator list containing a list of acceptable KMS URIs (List of IDRkmsi options).\n-\tThe receiver list containing a list of acceptable KMS URIs (List of IDRkmsr options).\n-\tAn embedded received KRR (if this KRR is generated as a result of a received KRR).\n-\tA signature (using the originating identity) over the entire message (optional, but recommended).\nAll fields, except for the signature, are required content.\nThe KRR initiator and receiver lists (as defined in clause 5.2.8.2.1) are populated based on the received MIKEY message from the initiator. The message contains an initiating KMS URI (IDRkmsi) and receiving KMS URI (IDRkmsr).\n1)\tThe KRR initiator list is populated as follows:\na)\tIf this is the first received MIKEY message from the initiator, the receiver may respond with a preferred list of KMS URIs based on local policy. If IDRkmsi corresponds to one of the receiver's External KMSs, the initiator list shall contain, at minimum, the IDRkmsi.\nb)\tOtherwise, the IDRkmsi does not correspond to one of the receiver's External KMSs, and a list of KMS URIs corresponding to External KMSs is provided based on local policy (not all KMS URIs need be included).\n2)\tThe KRR receiver list is populated as follows:\na)\tIf this is the first received MIKEY message from the initiator, the receiver may respond with a preferred list of KMS URIs based on local policy. If the IDRkmsr corresponds to one of the receiver's Home KMS or a provisioned Migration KMS, the receiver list shall include, at a minimum, the IDRkmsr.\nb)\tOtherwise, the IDRkmsr does not correspond to one of the receiver's Home KMS or a provisioned Migation KMS, and a list of KMS URIs corresponding to the Home KMS and Migration KMSs is provided based upon local policy (not all KMS URIs need be included).\nA MCX Server or Signalling proxy can create a KRR on receipt of a MIKEY message from the initiator en route to the receiver. The message contains an initiating KMS URI (IDRkmsi) and receiving KMS URI (IDRkmsr). A KRR is created under the following conditions.\nCase A:\tFor MIKEY messages entering from a MC client (inbound CS Proxy), a KRR is created if the IDRkmsi is not acceptable. This could be either that the KMS is not supported within the domain, or that the KMS is not supported for the user given the user's current state, location or juristriction. In this case:\n1.\tthe initiator KMS URI list contains a list of acceptable KMS URIs supported by the domain for the user based on the user's current state.\n2.\tthe receiver KMS URI list shall be 'ANY'.\nCase B:\tFor MIKEY messages entering/leaving a domain (IS Proxy), if the initiating user (IDRi) relates to this domain and the IDRkmsi is not acceptable then:\n1.\tthe initiator KMS URI list contains a list of acceptable Home and Migration KMS URIs used by the IDRi for this domain..\n2.\tthe receiver KMS URI list is 'ANY'.\nNOTE 1:\tThis case is primarily used where the initiator has migrated out of the domain, meaning that the user's traffic is transiting the domain, but ultimately enters/exits the domain via an IS Proxy.\nCase C:\tFor MIKEY messages entering/leaving a domain (IS Proxy), if the receiving user (IDRr) relates to this domain and the IDRkmsr is not acceptable then:\n1.\tthe initiator KMS URI list is 'ANY'.\n2.\tthe receiver KMS URI list contains a list of acceptable Home and Migration KMS URIs used by the IDRr for this domain.\nNOTE 2:\tThis case is primarily used where the receiver has migrated out of the domain, meaning that the user's traffic is transiting the domain, but ultimately enters/exits the domain via an IS Proxy.\nCase D:\tFor MIKEY messages exiting towards a MC client (outbound CS Proxy), a KRR is created if the IDRkmsr is not acceptable. This could be as the KMS is not supported given the user's current state, location or juristriction. In this case:\n-\tthe initiator KMS URI list shall be 'ANY'\n-\tthe receiver KMS URI list contains a list of acceptable KMS URIs supported by the domain based on the user's (IDRr) current state.\nShould any network entity create a KRR, the network entity shall drop the received MIKEY message. Entities in the path receiving a KRR shall forward the KRR towards the initiating IDRi.\nA MCX Server or Signalling proxy can create a new KRR on receipt of a KRR. The content of the KRR is based on local policy of which KMSs are supported within the domain. A new KRR is created under the following conditions:\nCase A:\tFor KRRs entering the domain from a MC client (inbound CS Proxy), a new KRR is created if the contents of the receiver KMS URI list contains a KMS URI that is not acceptable. This could be as the KMS is not supported given the user's current state, location or juristriction. Within the new KRR in this case:\n1.\tthe initiator list is unchanged.\n2.\tthe receiver list is reduced to remove the unacceptable KMS URIs. If the list is empty, an empty list is returned within the KRR (and consequently, the communication will fail).\nCase B:\tFor KRRs entering/existing the domain towards another domain (IS Proxy), a new KRR is created if the receiving user (IDRr) relates to this domain and the receiver list contains a KMS that is not acceptable then within the new KRR:\n1.\tthe initiator list is unchanged.\n2.\tthe receiver list is reduced to remove the unacceptable KMS URIs. If the list is empty, an empty list is returned within the KRR (and consequently, the communication will fail).\nCase C:\tFor KRRs entering/exiting the domain from another domain (inbound IS Proxy), a new KRR is created if the initiating user (IDRi) relates to this domain and the initiator list contains a KMS that is not acceptable then within the new KRR:\n1.\tthe initiator list is reduced to remove the unacceptable KMS URIs. If the list is empty, an empty list is returned within the KRR (and consequently, the communication will fail).\n2.\tthe receiver list is unchanged.\nCase D:\tFor KRRs exiting the domain towards a MC client domain (outbound CS Proxy), a new KRR is created if the contents of the initiator KMS URI list contains a KMS URI that is not acceptable. This could be as the KMS is not supported given the user's current state, location or juristriction. Within the new KRR in this case:\n1.\tthe initiator list is reduced to remove the unacceptable KMS URIs. If the list is empty, an empty list is returned within the KRR (and consequently, the communication will fail).\n2.\tthe receiver list is unchanged.\nShould the network entity create a new KRR, the received KRR is dropped and the new KRR is forwarded to the initiator. Entities in the path receiving a KRR shall forward the KRR towards the initiating IDRi.\nThe new KRR contains the received KRR. Consequently, the KRR could contain multiple sub-KRRs. It is recommended that a maximum of 5 sub-KRRs are supported.\nWhere the initiator is distributing a key to a receiver (e.g. at the beginning of a private call) it is possible that a KMS selection procedure needs to be performed by the initiator. The KMS selection procedure results in the choice of an initiator and receiver KMS (IDRkmsi and IDRkmsr) for the MIKEY message.\nThe KMS selection procedure is only required in two situations:\n-\tInitial distribution of a key where the receiver's KMS is not known (e.g. the receiver's KMS is not listed in the user profile, the group document, or known due to previous communication).\n-\tUpon receipt of a KRR due to a previous attempt to distribute a key.\nIn the first case, (ANY, ANY) is used as the initiator KMS list and receiver KMS list pair. Otherwise the initiator KMS list and receiver KMS list is provided within the KRR.\nUsing the provided initiator KMS list and receiver KMS list, the initiator shall select the initiator KMS and receiver KMS based on the following procedure:\n1.\tFor the initiator KMS list, the initiator shall:\na.\tIf the initiator KMS list is 'ANY' the initiator shall populate the KMS list with the Home KMS and with all provisioned Migration KMSs.\nb.\tIf the KMS list is not empty, the initiator shall create a reduced list of all KMS URIs that do not belong to the initiator's Home KMS or to a provisioned Migration KMS. If the reduced list still contains at least one KMS URI; then:\ni.\tThe initiator may apply local policy to select a KMS URI from the reduced list; the initiator shall use the selected KMS (to sign the MIKEY message); else\nii.\tIf the KMS list contains the initiator's Home KMS URI; the initiator shall use the Home KMS (to sign the MIKEY message); else\nii.\tThe initiator shall select the first KMS URI from the list. The initiator shall use the selected KMS (to sign the MIKEY message);\nd.\tIf the reduced list contains no KMS URIs, then the communication fails.\n2.\tFor the receiver KMS list, the initiator shall:\na.\tIf the receiver KMS list is 'ANY' the initiator shall populate the receiver KMS list with the initiator's Home KMS, with all provisioned Migration KMSs and with all provisioned External KMSs.\nb.\tIf the receiver KMS list is not empty, the initiator shall create a reduced list of all KMS URIs that do not belong to the initiator's Home KMS, to a provisioned Migration KMSs or to an External KMS. If the reduced list still contains at least one KMS URI; then:\ni.\tThe initiator may apply local policy to select a KMS URI from the reduced list; the initiator shall use the selected KMS (to encrypt the MIKEY message); else\nii.\tIf the KMS list contains the initiator's Home KMS URI; the initiator shall use the Home KMS (to encrypt the MIKEY message); else\nii.\tThe initiator shall select the first KMS URI from the list. The initiator shall use the selected KMS (to encrypt the MIKEY message);\nd.\tIf the reduced list contains no KMS URIs, then the communication fails.\nIf an initiating and receiving KMS has been successfully selected, the initiator shall send a new MIKEY message using the selected KMSs. If not, the communication fails.\nThe purpose of KMS Discovery / Redirection procedures is to allow session key distribution where the KMS used by the receiver is not known. It also allows policy to be applied to ensure the KMS used by the receiver and initiator is acceptable along the path of the communication.\nThe key message is a KMS Redirect Response (KRR) which conveys KMS policy to the initator. The initiator could be a MC client or GMS. Sometimes multiple messages and KRR exchanges will be required to establish a suitable choice of (KMS initiator, KMS receiver) pair. It is also possible that there is no acceptable choice, and as a result of the process the communication fails.\nThe KMS Redirect Response (KRR) procedure allows for MC Services to negotiate and inform an MCX entity about which security domains (KMS URIs) are acceptable for an MCX session.\nPrior to beginning this process, it is assumed that:\n-\tThe initiating user has been provisioned by its Home KMS with some information on the permitted external security domains, including the KMS certificate of External KMSs.\n-\tThe terminating user has been provisioned by its Home KMS with some information on the permitted external security domains, including the KMS certificate of External KMSs.\nA user shall only communicate with its Home KMS. External KMS Certificates shall be manually loaded onto the Home KMS and distributed to the user as part of the KMS's user key management processes.\nThe procedure for security domain redirection is shown in Figure 5.2.8.3-1.\n\nThe figure depicts a security domain redirection system, illustrating the process of redirecting traffic from one network to another. The system is designed to ensure the security of the network by redirecting traffic from the primary network to a secondary network, which can be a different network or a different network within the same network. This is achieved by using a set of security domains, each with its own set of rules and policies. The figure shows the flow of traffic, with the primary network traffic being directed to the secondary network, and the secondary network traffic being directed to the primary network. The figure also shows the use of security domains, which are used to control the flow of traffic and ensure that only authorized traffic is allowed to pass through.\nFigure 5.2.8.3-1: Security domain redirection\nThe procedures in Figure 5.2.8.3-1 are now described in detail. Where the security domains (KMS URIs) used by the initiating client are acceptable to the MC Service(s) and terminating client, communication proceeds as normal. However, where the initiating client uses security domain(s) (KMS URIs) that are rejected along the signalling path or by the terminating client, the following procedures take place:\nThe initiating client or function initiates a session with a user or function. It is assumed that the receiver's KMS is not known (not listed in the initiator's user profile or group document and there has not been a previous successful communication), hence the the client performs the procedure in clause 5.2.8.2.5 to select the KMS URIs to use in the MIKEY message.\n1.  The initiating client sends the communication request to the initiating application server. Under normal conditions the server routes the request on the normal signalling path.\n1a.\tShould the incorrect security domain(s) (KMS URIs) be used (based on local policy or the policies of the terminating security domain), the server will not forward on the request and may send a KRR message back to the client using the procedures in clause in 5.2.8.2.3.\n2.\tIf the communication request is forwarded on the normal signalling route, the other application server should receive the request.\n2a. Should an unacceptable security domain(s) be used (based on local policy or the policies of the terminating security domain), the other application server shall not forward on the request and may send a KRR message to the initiating application server using the procedures in clause in 5.2.8.2.3.\n2b. Upon receiving a KRR message from the other application server, the application server may replace the 'security domain redirect response' message with another KRR message using the procedures in clause 5.2.8.2.4, before forwarding the message down the normal signalling path.\n3.\tShould the request be forwarded on the normal signalling route to the terminating client or function, the terminating MCX entity should receive the request.\n3a. The terminating client may determine that the security domains used by the initiating client are not permitted. In this case, the terminating client may send a KRR message containing permitted security domains back to the initiating client using the procedures in clause 5.2.8.2.2.\n3b. Upon receiving a KRR message and based on local policy, the other application server may replace the KRR message using the procedures in clause 5.2.8.2.4, before forwarding the message down the normal signalling path to the initial application server.\n3c. Upon receiving a KRR message and based on local policy, the initial application server may replace the KRR using the procedures in clause 5.2.8.2.4, before forwarding the message down the normal signalling path to the client.\n4.\tOn receiving a KRR, the initiator will perform the procedures in clause 5.2.8.2.5, and may repeat the above procedure from step 1. Upon next connection to the Home KMS, the initiating client should upload the received KRR message to allow fraud detection.\nA MC client shall only accept external security domains that have been permitted by the home security domain and provisioned by the Home KMS. The Home KMS may also provision policy around the use of external security domains, see clause 5.2.8.5.\nNOTE 1:\tIt is possible that the MC client receives a KRR either unsigned or signed using a KMS URI that is not recognised/provisioned. In this case, it is subject to policy (determined by the Home KMS) whether the redirect is accepted, see clause 5.2.8.5.\nNOTE 2:\tUnder the most stringent policy, the KMS a policy may be implemented that requires the client to hold the communication until the Home KMS has responded with notification that the redirect is acceptable, see clause 5.2.8.5.\nDomain administrators should only allow users to communicate with trusted external security domains. Should an external security domain be misused, it is possible that users could be impersonated within the MCX system (in the same way that misuse of a CA compromises communications that trust that CA). To allow such misuse to be detected, and the associated KMS certificates to be revoked, clients should report the use of external security domains to the Home KMS.\nThe following are policies that the Home KMS may apply around the use of external security domains.\n-\tAllow KRRs (yes/no). If no, all KRRs shall be ignored.\n-\tReport KRRs to the Home KMS (yes/no).\n-\tRequire signed KRRs (yes/no). If no, all unsigned KRRs shall be ignored.\n-\tRequest unknown KMS certificates (yes/no). If yes, should an unknown external KMS certificate be in the list of receiving KMS URI(s) in the KRR, the client shall request this certificate from the Home KMS as defined in Annex D.\n-\tHold communication until KMS acceptance (yes/no). If yes, the client will not act upon any KRRs until the Home KMS has provided a notification that the redirect is acceptable (or otherwise), as defined in Annex D.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.3\tUser key management",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.3.1\tKey Management Server (KMS)",
                            "text_content": "",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.1.1\tGeneral",
                            "text_content": "To be able to be involved in end-to-end communication security the MC user requires key material to be provisioned from their Home Key Management Server (KMS). In addition, management entities which setup or control the end-to-end communication, such as the MCX Server and Group Management Server, will also require provisioning of key material.\nNOTE:\tFor clarity, an MC KMS provides different functionality to a MIKEY-TICKET KMS defined in 3GPP TS 33.328 [8].\nIn this clause, the 'user' could be a GMS, MCX Server, Signalling Proxy or any other entity containing a Key Management (KM) client.\nFrom the perspective of a user (KM client), there are three types of KMS:\n-\tThe Home KMS.\n-\tMigration KMSs.\n-\tExternal KMSs.\nA user has exactly one Home KMS, zero or more Migration KMSs and zero or more External KMSs. The relationship between the KMSs is shown in Figure 5.3.1.1-1.\nThe figure depicts various types of Key Management Services (KMS) used in the telecommunication industry, including Key Distribution Service (KDS), Key Encapsulation Service (KES), Key Distribution Point (KDP), and Key Encapsulation Point (KEP). Each type is represented by a distinct icon and a brief description, illustrating the key features and functionalities of these services. The figure serves as a visual aid to understand the various components and their roles in the telecommunication network.\nFigure 5.3.1.1-1: Types of KMS\nThe Home KMS is the KMS trusted by the user (KM client) to manage the user's primary security domain. The Home KMS controls the use of media security for users (KM clients) within the primary security domain and is the source of KMS certificates for users or groups home to partner (i.e. external) MC domains.\nThe Home KMS shall provide the following to KM clients:\n-\tThe Home KMS Certificate.\n-\tPolicy around the use of provisioned key material.\n-\tUser key material for the authenticated user's identity.\n-\tA list of permitted Migration KMSs and their addresses.\n-\tA list of permitted External KMSs, and their KMS certificates.\nKM clients may provide the following to their Home KMS:\n-\tReceived KMS Redirect Responses (KRRs).\nA Migration KMS is the KMS of a migration MC domain that controls media security of users (KM clients) while those users are authorised members of that migration MC domain.\nNOTE 1:  A Home KMS is able to continue to support a user with primary KMS certificates and key material while the user is migrated.\nA Migration KMS may provide the following to KM clients:\n-\tThe Migation KMS Certificate.\n-\tUser key material for the authenticated user's identity while a member of the migration MC domain.\nNOTE 2:\tA Migration KMS may also support revocation of key material issued by a Home KMS (e.g. due to compromise), while still allowing communication using (uncompromised) key material  provisioned by the Migration KMS.\nKM clients may provide the following to their Migration KMS:\n-\tKMS Redirect Responses (KRRs).\nExternal KMSs serve partner security domains with which the user is able to communicate. To communicate with the partner security domain, the user (KM client) requires the External KMS certificate. External KMS certificates are provided by the user's Home KMS. In this way, the Home KMS maintains control of external communications.\nThe user (KM client) never connects to an External KMS.\nNOTE 1:\tWithout provisioning the KMS certificate of an External KMS, secure communication with users and groups home to the corresponding partner security domain is not possible.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.2\tFunctional model for key management",
                            "text_content": "Within the mission critical architecture, the Key Management Server (KMS) provisions key material associated with a specific MC identity (e.g. MCPTT ID). The KMS has interfaces with the key management clients. A key management client is responsible for making requests for identity-specific key material. Key provisioning clients are located in the MC UE, in the MCX Server(s) and in the Group Management Server(s).\nThe reference points for the KMS are shown in figure 5.3.2-1.\n\nThe figure depicts reference points for key management servers in a 5G network, illustrating the importance of these servers in ensuring network reliability and security. Key management servers are responsible for managing network resources, such as network slices, and ensuring that they are allocated efficiently. The figure shows the locations of these reference points, which are crucial for network configuration and troubleshooting.\nFigure 5.3.2-1: Reference Points for Key Management Server\nFigure 5.3.2.1-1 shows the CSC-8, CSC-9 and CSC-10 reference points for the Key Management Server within a MC domain.\nThe KMS may or may not be located within the Common Services Core (CSC) of the MC domain and may or may not make use of the HTTP proxy.\nIf the KMS does not make use of the HTTP proxy, then a secure HTTP connection (HTTPS) shall be established directly between the KMS and the KM client. In this case, each of CSC-8, CSC-9 and CSC-10 is a direct HTTP connection between the KMS and KM client in the MC UE, MCX Server or GMS (resp). The use of the TrK as defined in clause 9.3.3 may be used to protect the key material content in this configuration, and the InK may be used to integrity protect the key material content.\nIf the KMS does connect to and employ the use of the HTTP proxy, then for public safety users the TrK shall be used as defined in clause 9.3.3 to protect the key material content and the InK should be used for integrity protection. In this case, each of CSC-8, CSC-9 and CSC-10 uses HTTP-1 and HTTP-2 between the KMS and KM client in the MC UE, MCX Server or GMS (resp).\nWhen a TrK is used to protect the transfer of key material between the KM client and KMS, the MC UE TrK identifier (TrK-ID) shall be provided by the KM client to the KMS during user KM authorization. If the InK-ID is not provided in the same user authorization request, then the TrK shall be used for integrity protection. If the InK-ID is provided in the same user authorization request, then the InK shall be used for integrity protection.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.3\tSecurity procedures for key management",
                            "text_content": "The procedure for the provision of identity-specific key material when the HTTP proxy is supported between the KMS and the KM client is described in figure 5.3.3-1. The procedure is the same whether the key management client in the MC UE, an MCX Server or a Group Management Server is making the request.\nThe figure depicts a provisioning process for key material via the HTTP proxy, illustrating the use of a web-based interface for managing and provisioning resources. The figure shows a web-based interface with a user-friendly interface for managing and provisioning resources, such as provisioning of key material via the HTTP proxy.\nFigure 5.3.3-1: Provisioning of key material via the HTTP proxy\nThe procedure in figure 5.3.3-1 is now described step-by-step.\n0)\tThe key management client establishes a connection to the KMS. As with other elements in the Common Services Core, the connection is routed via, and secured by, the HTTP Proxy. The message flow below is within this secure connection.\nNOTE:\tAdditionally, the connection between the KMS and the HTTP Proxy is secured according to clause 6.1.\n1)\tThe key management client makes a request for user key material from the KMS. The request contains an access token to authenticate the user as defined in clause 5.1. The request shall also contain the TrK-ID and may contain the InK-ID. There are the followingtypes of request (as defined in Annex D):\na)\tKMSInit Request. This request is the first request sent to the KMS to setup the user. This type of request is permitted to the Home KMS or to Migration KMSs.\nb)\tKMSKeyProv Request: This request is to obtain new key material from the KMS. The request may contain details of a specific identity (e.g. MCPTT ID) required for key management, and may contain a specific time for which the key material is required. This type of request is permitted to the Home KMS or to Migration KMSs.\nc)\tKMSCertCache Request: This request is to obtain external KMS certificates associated with external security domains (managed by another KMS). The request may contain details of the latest version of the cache received by the client. This type of request shall only be made to the Home KMS.\nd)\tKMS Redirect Response (KRR) upload: This procedure uploads a KRR received by the client to the Home KMS. This type of message shall only be sent to the Home KMS.\ne)\tKMS Cert Request: This request is to obtain a single KMS certificate based on a provided KMS URI.\nf)\tKMS Lookup: This message is to lookup the external KMS that should be used for a provided SIP URI.\ng)\tKMS Redirect Upload: This message is to upload a received discovery request response to the KMS for audit purposes.\n2)\tThe KMS provides a response based upon the authenticated user and the user's request. For public safety use, the key material itself shall be encrypted using a 256-bit transport key (TrK). The response may also be signed by the TrK or the InK. The TrK and InK are initially distributed via an out-of-band mechanism along with their 32-bit identifiers, the TrK-ID and InK-ID, respectively. The responses are:\na)\tKMSInit Response. This response contains domain parameters and optionally, a new TrK and/or a new InK.\nb)\tKMSKeyProv Response: This response provides new key material to the user and optionally, a new TrK and/or a new InK.\nc)\tKMSCertCache Response: This response contains new or updated home KMS certificates and/or external KMS certificates required by the user for communications with external security domains.\nd)\tKMS Cert Response: This response is a KMSCertCache Response containing a single KMS Certificate (or an error message).\ne)\tKMS Lookup Response: This response is a to provide the client with information related to a Discovery Lookup request. Either the KMS URI that should be used for a user is provided, or permission is provided to use a specific External KMS.\nThe procedure for the provisioning of identity-specific key material when the HTTP proxy is not used between the KMS and the KM client is as described in Figure 5.3.3-2.\nThe figure depicts a scenario where a key material is provisioned without a proxy, illustrating the importance of having a reliable and efficient provisioning process in a network.\nFigure 5.3.3-2: Provisioning of key material without a proxy\nThe procedure in Figure 5.3.3-2 is now described step-by-step:\n0)\tThe key management client establishes a direct HTTPS connection to the KMS. The following message flow is within this secure connection.\n1)\tThe key management client makes a request to the KMS. The request may contain the TrK-ID and may contain the InK-ID. The same requests can be made as defined above with a proxy.\n2)\tThe KMS provides a response based upon the authenticated user and the user's request. Optionally, the key material itself may also be encrypted using a 256-bit transport key (TrK). The response may also be signed using the TrK or the InK. The TrK and InK are initially distributed via an out-of-band mechanism along with their 32-bit identifiers (TrK-ID and InK-ID respectively).\nAs a result of this procedure, the key management client has securely obtained key material for use within the MC system.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.4\tProvisioned key material to support end-to-end communication security",
                            "text_content": "End-to-end communication security for either group or private calls requires the provisioning of key material from the KMS. The key material provisioned to each user is listed below:\n-\tA KMSInit Response contains the KMS Certificate (domain specific key material associated to the KMS), and may contain:\n-\tAn updated TrK for the user (to replace the off-network-provisioned, bootstrap TrK).\n-\tPolicy around the use of KMS key material (Home KMS only)\n-\tAddress to which ‘KMSCertCache' requests should be sent.\n-\tAddress to which ‘KRRupload' messages should be sent.\n-\tA KMSKeyProv Response contains zero, or more, KMSKeySets and may contain:\n-\tAn updated TrK for the user (to replace existing TrK).\n-\tA KMSCertCache Response may contain:\n-\tThe KMS's Certificate(s) (current, updated or future).\n-\tMigration KMSs (KMS URIs, access addresses, provisional TrKs).\n-\tExternal KMS Certificates. This is domain specific key material associated with other KMSs. It is required to enable secure communications across security domains.\n-\tA KMSCert Response may contain:\n-\tAn External KMS Certificate. This is domain specific key material associated with the requested KMS URI. It is required to enable secure communications across security domains.\n-\tA KMS Lookup Response does not contain key material, but may contain KMS URIs.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.5\tKMS Certificate",
                            "text_content": "A KMS Certificate is defined in Annex D.3.2. A KMS Certificate contains the following:\n-\tA Role of 'Home' or 'External', depending on whether the certificate is the issuing KMS's or is provided by another external KMS.\n-\tThe KMS Public Authentication Key (KPAK in IETF RFC 6507 [9]).\n-\tThe KMS Public Confidentiality Key (Z_T in IETF RFC 6508 [10]).\n-\tThe UID conversion (as described below).\n-\tChoice of cryptographic domain parameters (such as those listed in IETF RFC 6509 [8]).\n-\tThe time period for which this information is valid.\nCertificates are identified by the KMS (KMSUri) and a unique identifier (CertUri). A (logical) KMS should only have a single KMS certificate active at any one time (based upon the KMSUri). Certificates may be updated using the CertURI. Should a client receive a certificate with a CertURI of an existing certificate, the client shall replace this existing certificate with the newly provisioned certificate.\nThe UID conversion mechanism defines how UIDs are generated. Using this information a MC client can take a user identifier (e.g. an MCPTT ID), and the current time, (e.g. the year and month) and convert these to a UID.\nEXAMPLE:\tUID = Hash (MCPTT ID, KMS URI, validity period info).\nAs a consequence, there is a one-to-one correspondence between MC Service IDs and UIDs during each time period.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.6\tKMS provisioned Key Set",
                            "text_content": "KMSKeySet(s) are defined in Annex D.3.3.2 and contain the following:\n-\tA user signing key for each UID for the current time period (SSK and PVT in IETF RFC 6507 [9]).\n-\tA user decryption key for each UID for the current time period (RSK in IETF RFC 6508 [10]).\n-\tThe key period number associated with the current keys.\n-\tOptionally, the time period, for which the user key material is valid (e.g. month).\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.4\tKey management from MC client to MC server (CSK upload)",
                    "description": "",
                    "summary": "",
                    "text_content": "The key (CSK) is distributed from the MCX client to the MCX Server(s) using the ‘CSK upload' procedure. The procedure shall use the common key distribution mechanism described in clause 5.2.2, transported over the SIP bearer. Identity hiding may be supported as defined in clause 5.2.6. The MCX Server may respond with a KMS Redirect Response (KRR) as described in clause 5.2.8 (e.g. if the MC client has migrated or is roaming).\nThe initiating entity of the CSK upload procedure shall be the MCX UE and the receiving entity shall be the MCX Server. With respect to the common key distribution procedure, the initiating entity URI shall be the MCX Service user ID of the user andthe receiving entity URI shall be the MCX Server Domain Security Identifier (MDSI). The MDSI is added to the recipient field (IDRr) of the message. The distributed key, K, shall be the CSK and the distributed identifier K-ID shall be the CSK-ID.\nClause E.4 provides MIKEY message structure for CSK distribution.\nBefore the CSK upload procedure can be used by the client to securely share the encryption key, the MC user shall first be authorized by KMS for key management services. Once the MC user is authorized, the KMS distributes the user's key material to the client as specified in clause 5.3.3.\nThe server receives the SIP message with the protected CSK and retrieves it from the message. It associates the MC User's SIP Core identity (IMPU), MC Service user ID (e.g. MCPTT ID) and the received CSK. Identity binding is used to uniquely identify the CSK used in protection of the SIP payload in subsequent SIP messages sent by both the client and the servers within a MC domain.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "5.5\tKey management between MCX servers (SPK)",
                    "description": "",
                    "summary": "",
                    "text_content": "Floor control, transmission control, and media control between MCX servers may need to be protected. Additionally, certain values and identifiers transferred in the signalling plane between servers within an MC domain, or between MC domains, may be treated as sensitive by public safety users and therefore may also require protection.\nTo protect information from all other entities outside of the MC domain(s), a shared 128-bit Signalling Protection Key (SPK) needs to be established between the servers. The SPK is provided along with a 32-bit identifier, the SPK-ID and 128-bit random value SPK-RAND. The most significant four bits of the identifier (the Purpose Tag) of the SPK-ID shall be '3' to denote the purpose of the SPK is for signalling protection, as described in Annex G.\nThe SPK and associated values shall be directly provisioned into the communicating servers, along with the SPK-ID. With the SPK provisioned, RTCP and XML content (within SIP) may be protected.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "5.6\tKey management for one-to-one (private) communications (PCK)",
                    "description": "",
                    "summary": "",
                    "text_content": "The purpose of this procedure is to allow two MCP UEs to create an end-to-end security context to protect an MCX private communication. To create the security context, the initiating MCX UE generates a Private Communication Key (PCK) and securely transfers this key, along with a key identifier (PCK-ID), to the terminating MCX UE. Prior to key distribution, both MCX UE shall be provisioned by the Key Management Server (KMS) with time-limited key material associated with the MCX user as described in clause 5.3.\nThe PCK is distributed between the MCX clients using the security mechanism described in clause 5.2.2, transported over the SIP bearer within the SDP content of a SIP INVITE (or within the SDP content of a SIP MESSAGE message when used for MCData SDS). The SAKKE-to-self extension may be included as defined in clause 5.2.5. Identity hiding may be supported as defined in clause 5.2.6. The receiving MCX client and any MCX Server through which the SIP INVITE is routed, may respond with a KMS Redirect Response (KRR) as described in clause 5.2.8.\nThe initiating entity shall be the initiating MCX user. The initiating entity URI shall be the MCX service ID of the initiating user. The receiving entity shall be the terminating MCX user. The receiving entity URI shall be the MCX service ID of the terminating user.  The distributed key, K, shall be the PCK and the distributed identifier K-ID shall be the PCK-ID.\nClause E.2 provides MIKEY message structure for PCK distribution.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "5.7\tKey management for group communications (GMK)",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.7.1\tGeneral",
                            "text_content": "To create the group's security association, a Group Master Key (GMK) and associated identifier (GMK-ID) is distributed to MCX UEs by a Group Management Server (GMS). The GMK is distributed encrypted specifically to a user and signed using an identity representing the Group Management Server. Prior to group key distribution, each MCX UE within the group shall be provisioned by the MCX Key Management Server (KMS) with time-limited key material associated with the MCX user as described in clause 5.3. The Group Management Server shall also be provisioned by the MCX KMS with key material for the GMS's identity (the GMS Server URI).\nThe GMK is distributed from the GMS to a MCX client using the security mechanism described in clause 5.2.2, transported over the SIP bearer. For GMKs, end-point diversity is required and hence the extension in clause 5.2.3 is applied. Additional parameters may be included as defined in clause 5.2.4. The SAKKE-to-self extension may be included as defined in clause 5.2.5. Identity hiding may be supported as defined in clause 5.2.6. The receiving MCX client and any MCX Server through which the SIP INVITE is routed, may respond with a KMS Redirect Response (KRR) as described in clause 5.2.8.\nGMKs may be managed individually per Group ID or the same GMK may be assigned to multiple MC Group IDs (using the MIKEY general extension payload defined in Clause E.6). This means that each specified MC Group ID in the MIKEY general extension payload shall use this GMK for group communications.  Assigned MC Group IDs may include any combination of MCPTT Group IDs, MCData Group IDs or MCVideo Group IDs.  Assigning the same GMK to multiple Group IDs does not prevent individual key management at a later time or vice versa.\nAn MC client may have multiple active GMKs associated with a Group ID. When this occurs, the MC client shall use the active GMK with the most recent Activation Time (as defined in Clause E.6.4) when encrypting group media.\nThe initiating entity shall be the initiating GMS. The initiating entity URI shall be the URI of the GMS (e.g. sip: gp.manager@mcptt.example.org). The receiving entity shall be the terminating MCX user. The receiving entity URI shall be the MCX service ID of the terminating user.  The distributed key, K, shall be the GMK, the key identifier K-ID shall be the GMK-ID and the end-point-specific key identifier, UK-ID shall be the GUK-ID.\nClause E.3 provides MIKEY message structure for GMK distribution.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.7.2\tSecurity procedures for GMK provisioning",
                            "text_content": "This procedure uses a MIKEY payload to distribute a GMK from the GMS to the MC UEs within the group. The payload is transported as part of the 'Notify group configuration request' message defined in clause 10.1.2.7 of 3GPP TS 23.280 [36].\nFigure 5.7.2-1 shows the security procedures for creating a security association for a group.\nThe figure depicts a security configuration for groups, with various security settings and options for managing user access and permissions.\nFigure 5.7.2-1: Security configuration for groups\nA description of the procedures depicted in figure 5.7.2-1 follows. For clarity, figure 10.1.5.3-2 in clause 10.1.5.3 of 3GPP TS 23.280 [36] is referenced.\n0)\tPrior to beginning this procedure the MC client shall be provisioned with identity-specific key material by a MC KMS as described in clause 5.3. The GMS shall also be securely provisioned with identity-specific key material for the GMS's Server URI.\n1)\tThe GMS shall send a MIKEY payload to MC clients within the group within a 'Notify group configuration request' message. The message shall encapsulate a GMK for the group. The payload shall be encrypted to the user identity (MCX service user ID) associated to the MC client and shall be signed by the GMS. The message shall also provide the GUK-ID. Parameters associated with the GMK shall be encrypted using the GMK, and sent in the MIKEY payload together with the encapsulated GMK. This process is shown in Figure 5.2.4-1.\na)\tIf the choice of initiator KMS (IDRkmsi) or receiver KMS (IDRkmsr) within the MIKEY message is unacceptable, a KMS Redirect Response may be returned to the GMS providing KMS information. In this case, the GMS may re-attempt the above procedures.\n2)\tOn receipt of a MIKEY message, the MC client shall check the signature on the payload, extract the GMK, GUK-ID and GMK-ID and check that the GMK-ID is not a duplicate for an existing GMK. The MC client shall also extract the group identity, activation time and text from the encapsulated associated parameters in the payload using the GMK, and check that decryption is successful. The MC client shall lookup the Group ID in its user profile data and verify that the GMS identity corresponds with the Server URI for that Group ID. This process is shown in Figure 5.2.4-2. Should any of these checks fail, an error shall be returned to the GMS. Upon successful receipt and processing, the MC UE shall store the GMK, GMK-ID, GUK-ID and associated parameters, and respond to the GMS with a 'Notify group configuration response' message.\nIt is recommended that a mechanism is used to ensure that no two Group IDs from different servers collide.\nTo revoke a security context, the group management server repeats the above steps with the Status field of the GMK parameters indicating that the GMK has been revoked.\nIt is possible that an MC user in the group may be represented by an MC Security Gateway (as defined in Annex L), rather than using full end-to-end security. In this case, the user's KMS Certificate will have the ‘IsSecurityGateway' attribute set to ‘true' (see clause D.3.2.2). Should any client in the group be represented by an MC Security Gateway, the GMS shall indicate to all users that the GMK is shared with an MC Security Gateway. This is achieved by setting the ‘Security Gateway' bit in the ‘Status' field of the GMK's key parameters (see clause E.6.9).\nShould an MC client receive a GMK with the ‘Security Gateway' bit set, the initiating MC client shall warn the MC user that an MC Security Gateway is in use during the group's comunications.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.7.3\tGroup member GMK management",
                            "text_content": "In some situations, the membership of a group may be modified whereby an MC user may be added to or removed from an MCX group.  Users are alerted to these changes by a user profile update from the CMS for which they are subscribed.  The updated user configuration profile indicates the group ID to which the group membership change is associated.\nWhen the user configuration record indicates the user has been added to a new or existing group, the user shall be authorised for group management services to the GMS followed by the client subscribing to group updates from the GMS.  The user shall be authorised for group management services and the subscription shall be validated before the GMS provides group management records and the GMK.  Once the user is authorised and the subscription processed by the GMS, the GMS sends the group management record and the GMK to the UE.  The user may then join in on the group communication immediately after receiving the group update and GMK.\nWhen a user is removed from a group, the UE receives a user profile update from the CMS indicating the user is no longer a member of the specified group ID(s).  Upon receiving the user profile update, ending of any group communication(s) associated with that group, and if the GMK associated with the group ID is not associated with another group that the user remains a member, the UE shall immediately and securely delete the GMK associated with that group ID.  If the group ID is associated to more than one service (i.e. MCPTT, MCData and/or MCVideo) then upon the ending of any group communication(s) associated with that group ID, and if the GMKs associated with that group ID is not associated with another group that the user remains a member, the GMKs associated with that group ID shall be immediately and securely deleted.\nWhen a user is removed from the group, the Group Management Server may choose to update the GMK associated with the group ID (depending on the security profile of the group).\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.8\tKey management from MC server to MC client (Key download)",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.8.1\tGeneral",
                            "text_content": "The 'key download' procedure is used to send keys from the MCX server to the MC client. It is used to distribute Multicast Signalling Keys (MuSiKs) to the MC clients, and it is used to update both the CSKs and MuSiKs.\nWithin the 'key download' procedure, keys (CSK or MuSiKs) are encrypted specifically to the MC user and signed using an identity representing the MC Server. Prior to group key distribution, each MC client shall be provisioned by the KMS with time-limited key material associated with the MC User as described clause 5.3. The MC Server shall also be provisioned by the MC KMS with key material for an identity which is authorised to act as an MCX Server.\nThe key (CSK or MuSiK) is distributed from the MCX Server to a MC client using the security mechanism described in clause 5.2.2, transported over the SIP bearer. End-point diversity is not required as end-points do not encrypt data, hence the extension in clause 5.2.3 is not applied. Additional parameters may be included as defined in clause 5.2.4. The SAKKE-to-self extension may be included as defined in clause 5.2.5. Identity hiding may be supported as defined in clause 5.2.6.\nThe initiating entity shall be the initiating MCX Server and the receiving entity shall be the terminating MC user. The initiating entity URI shall be the FQDN of the MCX Server (e.g. MDSI of the MC Domain) and the receiving entity URI shall be the MC Service ID of the terminating user.  The distributed key, K, shall be the CSK or MuSiK and the key identifier K-ID shall be the CSK-ID or MuSiK-ID (respectively).\nAs a result of this 'key download' mechanism, the MC clients receive a new signalling key, CSK or MuSiK, identified by the 4 most significant bits of the key ID.\nThe MCData Service server may use the Key Download procedure to indicate or modify the algorithm used to protect the MCData signalling fields (i.e. MCData signaling parameters, Data signaling payload and End to end security parameters) by including a ‘signalling algorithm’ parameter. The ‘signalling algorithm’ to be used shall be selected by the MCData Service server based on the local policy and/or regional regulatory requirement (for example, to enforce use of 128-bits or 256-bits key length). Based on the selected algorithm, the key used shall be derived as described in Annex F.1.5. The ‘signalling algorithm’ parameter is described in clause 8.5.4.1.  The available algorithms shall be as defined in clause 8.5.4.2.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.8.2\t‘Key download' procedure",
                            "text_content": "The procedure for key download is described in figure 5.8.2-1:\nFigure 5.8.2-1: Procedures for key download\n0.\tThe MCX UE has been provisioned by a KMS with key material associated with the MC user. The MC UE has also registered with an MCX Server. As a consequence of this registration, the MC UE is subscribed to key download notifications from the MCX Server.\n1.\tThe MCX Server sends a key download message (SIP NOTIFY or SIP MESSAGE) to the MC UE. The MC UE extracts the signalling key from the key download message.\n2.\tUpon successful extraction of the signalling key, the MC UE returns a key download success message (200 OK response) to the MCX Server. Upon receipt of a notification of success, the MCX Server is able to begin to use the key for protection of signalling traffic.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.9\tKey management during MBMS bearer announcement",
                            "text_content": "The MBMS bearer announcement message is used to distribute a MSCCK as described in Annex H.\nThe security procedures for key distribution via an MBMS bearer announcement message are identical to those used for 'key download' messages, described in clause 5.8.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.10\tVoid",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.10.1\tVoid",
                            "text_content": "",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.10.2\tVoid",
                            "text_content": "",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.10.3\tVoid",
                            "text_content": "",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.10.4\tVoid",
                            "text_content": "",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.11\tUE key storage and key persistence",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.11.1\tKey storage",
                            "text_content": "To prevent the exposure of mission critical keys and key material, the following guidelines shall be followed to ensure that mission critical keys and key material are protected within the UE.  Persistence of keys and key material through transistional states of the UE are defined in clause 5.11.2.\nAll long term keys and private certificates used to establish secure communications with MC domain servers such as the IdMS, KMS, and MC domain proxies (e.g. CS proxies and MC domain proxies) shall be stored in a protected state within the UE while not actively in use.  The method used to protect these keys and certificates is out of scope of this document.  These long term keys and key material include, but are not limited to the TrK, InK, and TLS private certificates.\nCSK(s), GMK(s) and MuSiK(s) shall be stored in a protected state within the UE while not actively in use.  The method used to protect these keys is out of scope of this document.\nIdentity based key material, e.g. KMS Key Set(s), shall be stored in a protected state within the UE while not actively in use.  The method used to protect these keys is out of scope of this document.\nIdentity based tokens, such as the ID token, access token(s), refresh token(s), and security token(s) shall be stored in a protected state within the UE while not actively in use.  The method used to protect these tokens is out of scope of this document.\nDynamic keys used for MCPTT, MCData and MCVideo signalling and media protection such as the MKFC, MSCCK and PCK and any derived keys (e.g. DPCK, SRTP Master Keys, XML keys, AES keys) should be securely stored as dictated by the operational needs of these keys and shall be securely deleted when these keys are no longer operationally needed.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.11.2\tKey persistence",
                            "text_content": "Static and semi-static keys and key material such as CSK(s), GMK(s), TrK, InK, TLS private certificates, IPsec private certificates, KMS Key Sets, ID token, access token(s), refresh token(s), and security token(s) shall be securely stored and maintained through UE power cycles.  These static and semi-static keys and key material shall also be maintained through user log-off and log-on cycles.  This ensures that the UE maintains the credentials, keys and key material for the user through various UE transitional states including on-network to off-network transitions.  This is especially critical for identity based key material and GMK(s) that are used for off-network communications.\nWhen the current user logs off and a different user logs onto the UE, all keys and key material associated to the previous user shall either be securely deleted from the UE or alternatively, a method to securely partition user's keys and key material from other users shall be implemented.  Keys and key material that remain in the UE through log-off and log-on cycles and during usage by mulitiple users shall be securely stored and accessible only to the user to which the keys and key material are associated.  The method used to securely partition user's keys and key material is out of scope of this document.\nDynamic keys for MCPTT, MCData and MCVideo media and signalling protection such as the MKFC, MSCCK, and PCK and any derived keys (e.g. DPCK, SRTP Master Keys, XML keys, AES keys) shall be securely deleted from the UE at UE power down, log off of the current user, expiry of any associated access tokens (for technical or authentication reasons), or as dictated by the operational needs of these keys.  Dynamic keys and tokens may be renegotiated during establishment of follow-on communications.\nWhen an access token expires because the IdMS cannot or will not refresh the existing access token for technical or authentication reasons, the following mission critical static, semi-static and dynamic keys shall be securely deleted from the UE; CSK(s), GMK(s), MuSiK, MKFC, MSCCK, KFC, DPPK, PCK, and identity based tokens (i.e. access tokens, refresh tokens, and security tokens).  Expired access tokens, refresh tokens or security tokens may require re-authentication of the user with the IdM services and MC domain.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "6\tSupporting security mechanisms",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "6.1\tHTTP",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.1.1\tAuthentication for HTTP-1 interface",
                            "text_content": "For authentication of the HTTP-1 reference point, one of the following authentication mechanisms shall be performed between the HTTP client in the MC UE and the HTTP server endpoint (HTTP proxy, IdM server or KMS):\n-\tone-way authentication of the HTTP server endpoint based on the server certificate;\n-\tmutual authentication based on client and server certificates;\n-\tmutual authentication based on pre-shared key.\nCertificate based authentication shall follow the profiles given in 3GPP TS 33.310 [5], clauses 6.1.3a and 6.1.4a. The structure of the PKI used for the certificate is out of scope of the present document. Guidance on certificate based mutual authentication is provided in 3GPP TS 33.222 [16], annex B.\nThe usage of Pre-Shared Key Ciphersuites for Transport Layer Security (TLS-PSK) is specified in the TLS profile given in 3GPP TS 33.310 [5], annex E.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.1.2\tHTTP-1 interface security",
                            "text_content": "The support of Transport Layer Security (TLS) on HTTP-1 is mandatory. The profile for TLS implementation and usage shall follow the provisions given in 3GPP TS 33.310 [5], annex E.\nIf the PSK TLS based authentication mechanism is supported, the HTTP client in the MC UE and the HTTP Proxy shall support the TLS version, PSK ciphersuites and TLS Extensions as specified in the TLS profile given in 3GPP TS 33.310 [5], annex E. The usage of pre-shared key ciphersuites for TLS is specified in the TLS profile given in 3GPP TS 33.310 [5], annex E.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.1.3\tHTTP-3 interface security",
                            "text_content": "The support of Transport Layer Security (TLS) on HTTP-3 is recommended between HTTP proxies. Where used, the profile for TLS implementation and usage shall follow the provisions given in 3GPP TS 33.310 [5], annex E.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.2\tSIP",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.2.1\tAuthentication for SIP core access",
                            "text_content": "This clause specifies the mutual authentication between the UE and the SIP core.\nIMS AKA authentication shall be performed as specified in  TS 33.203 [6] for SIP core access. IMS AKA authentication mechanism as specified in  TS 33.203 [6] shall be performed irrespective of whether SIP core architecture is compliant with  TS 23.228 [15] or not.\nAuthentication related information shall be provided by SIP database that may be part of the HSS or may be part of the MC service provider's SIP database depending on the SIP core deployment scenarios specified in  TS 23.280 [36] .\nImplementation options and requirements on the ISIM or USIM application to support SIP core access security are specified in  TS 33.203 [6].\nMC UEs accessing MCX services over non-3GPP accesses (e.g., control room) may consider other authentication mechanisms that are specified in Annex N/O of 33.203 [6] for SIP Core access authentication. For such use cases, interface security is provided according to NDS/IP as specified in TS 33.210 [4], unless security is provided by other means. e.g., physical security.\nAlternatively non-3GPP-only MC UEs not equipped with UICC may consider the IMC mechanism that is specified in clause 9 in 33.203 [6] for SIP Core access authentication.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.2\tSIP-1 interface security",
                            "text_content": "The security mechanisms as specified in 3GPP TS 33.203 [6] for Gm interface shall be used to provide confidentiality and integrity of signalling on SIP-1 interface.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "6.3\tNetwork domain security",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.3.1\tEPS-LTE/5GS-NR access authentication and security",
                            "text_content": "An MC UE shall perform the authentication and security mechanisms as specified in 3GPP TS 33.401 [14] for EPS-LTE and as specified in 3GPP TS 33.501 [55] for 5GS-NR network access security.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.3.2\tInter/Intra domain interface security",
                            "text_content": "To ensure security of the interfaces between network elements within a trusted domain and between trusted domains, namely HTTP-2, HTTP-3, SIP-2 and SIP-3:\n-\t3GPP TS 33.210 [4] shall be applied to secure signalling messages on the reference points unless specified otherwise; and\n-\t3GPP TS 33.310 [5] may be applied regarding the use of certificates with the security mechanisms of 3GPP TS 33.210 [4] unless specified otherwise in the present document.\nNOTE:\tFor the case of an interface between two network elements in the same trusted domain, 3GPP TS 33.210 [4] does not mandate the protection of the interface by means of IPsec. However, it is up to the domain administrator's policy to also protect interfaces within the same trusted domain.\nSEG as specified in 3GPP TS 33.210 [4] may be used in the trusted domain to terminate the IPsec tunnel.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "7\tMCPTT and MCVideo",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "7.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "This clause described the security procedures for both MCPTT and MCVideo.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "7.2\tPrivate communications",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "7.2.1\tKey management",
                            "text_content": "",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.2.2\tSecurity procedures (on-network)",
                            "text_content": "The following private communication security procedures provide a mechanism for establishing a security context as part of the Private Call Request sent from the initiating UE to the terminating UE.\n3GPP TS 23.379 [2] describes manual and automatic commencement for private MCPTT communications in both a single MC system and across multiple MC systems, while 3GPP TS 23.281 [37] describes manual and automatic commencement for private MCVideo communications within a single MC system.\nSecuring of on-network private MCPTT or MCVideo communications is summarized in the following sub clauses and applies to the aforementioned MCPTT and MCVideo private call use cases.\nThe private call setup message used to establish these security procedures may be pre-generated to increase the efficiency of the communication.  Additionally, the MC UE may attach a second SAKKE component which encrypts the PCK to the initiating user (in addition to the terminating user) for use in the ‘SAKKE-to-self' procedure.\nThe security procedure for an on-network MCPTT or MCVideo private call within a single MC system is summarized in figure 7.2.2-1,  The security procedure for securing an on-network MCPTT private call between multiple MC systems is summarized in figure 7.2.2-2. The intent of these on-network security procedures is to transfer a PCK and PCK-ID to the terminating UE in order to provide end-to-end security of the media.\nThe figure depicts a private cybersecurity procedure for on-network PCK distribution, specifically for a single domain. It outlines the steps and protocols to ensure secure distribution of private keys within the network.\nFigure 7.2.2-1: Private call security procedure for on-network PCK distribution for single domain\nThe procedure in figure 7.2.2-1 is now described step-by-step.\n0.\tPrior to beginning this procedure it is assumed that the MC UEs have an authenticated MC user and that the MC UEs have been provisioned with key material associated with a user's MC service ID by a KMS as described in clause 5.3.\n1.\tThe initiating MC UE generates the PCK and sends a private call request to the terminating MC UE. The message is sent to the primary MC server of the initiating UE where it is forwarded to the intended receipient UE. Within this message includes an SDP offer which contains a MIKEY-SAKKE I_MESSAGEs as defined in IETF RFC 6509 [11]. The I_MESSAGE encapsulates the PCK for the terminating MC user, encrypting the key to the UID of the terminating user (derived from the user's URI). The I_MESSAGE also contains an identifier for the PCK (PCK-ID). The I_MESSAGE is signed using (the key associated with) the initiating user's UID.\na)\tIf the choice of initiator KMS (IDRkmsi) or receiver KMS (IDRkmsr) within the MIKEY message is unacceptable, a KMS Redirect Response may be returned to the initiating client providing KMS information. In this case, the initiating client may re-attempt the above procedures.\n2.\tFurther session signalling occurs as defined in 3GPP TS 23.379 [2] for MCPTT and 3GPP TS 23.281 [39] for MCVideo.\nThe figure depicts a private communication security procedure for on-network PCK distribution between multiple domains. It illustrates the steps involved in ensuring secure communication between the domains, including the use of encryption, authentication, and access control mechanisms.\nFigure 7.2.2-2: Private call security procedure for on-network PCK distribution between multiple domains\nThe procedure in figure 7.2.2-2 is now described step-by-step.\n0.\tPrior to beginning this procedure it is assumed that the MC UEs have an authenticated MC user and that the MC UEs have been provisioned with key material associated with a user's MC service ID by a KMS as described in clause 5.3.\n1.\tThe initiating MC UE generates the PCK and sends a  private call request addressed to the terminating MC UE. The message is first routed to the primary MC server of the initiating UE.  The primary MC server routes the private call request to the partner server (home of the intended receipient UE), which is then routed to the receipient UE. The private call request message includes an SDP offer which contains a MIKEY-SAKKE I_MESSAGE as defined in IETF RFC 6509 [11]. The I_MESSAGE encapsulates the PCK for the terminating MC user, encrypting the key to the UID of the terminating user (derived from the user's URI). The I_MESSAGE also contains an identifier for the PCK (PCK-ID). The I_MESSAGE is signed using (the key associated with) the initiating user's UID.\na)\tIf the choice of initiator KMS (IDRkmsi) or receiver KMS (IDRkmsr) within the MIKEY message is unacceptable, a KMS Redirect Response may be returned to the initiating client providing KMS information. In this case, the initiating client may re-attempt the above procedures.\n2.\tFurther session signalling occurs as defined in 3GPP TS 23.379 [2].\nIt is possible that the terminating MC client may be represented by an MC Security Gateway (as defined in Annex L), rather than using full end-to-end security. In this case, the user's KMS Certificate will have the ‘IsSecurityGateway' attribute set to ‘true' (see clause D.3.2.2). Should the terminating client be represented by an MC Security Gateway, the initiating MC client shall warn the MC user that an MC Security Gateway is in use during the private call.\nWith the PCK and PCK-ID shared between the initiating and terminating users, the media communicated between the UEs may be end-to-end protected using the PCK.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.2.3\tSecurity procedures (off-network)",
                            "text_content": "3GPP TS 23.379 [2] describes manual and automatic commencement for private off-network MCPTT communications, while 3GPP TS 23.281 [37] describes manual and automatic commencement for private off-network MCVideo communications.\nSecuring off-network private MCPTT or MCVideo communications is summarized in the following sub clauses and applies to the aforementioned MCPTT and MCVideo off-network private call use cases.\nThe private call setup message used to establish these security procedures may be pre-generated to increase the efficiency of the communication.  Additionally, the MC UE may attach a second SAKKE component which encrypts the PCK to the initiating user (in addition to the terminating user) for use in the ‘SAKKE-to-self' procedure.\nThe security procedure for securing an off-network private call is summarized in figure 7.2.3-1. As part of this process, the PCK and PCK-ID are securely transferred to the terminating UE.\n\n\nThe figure depicts a private call security procedure for off-network PCK (Point-to-Point Key Distribution) distribution, illustrating the steps involved in ensuring secure communication. The diagram includes a diagram of the private call setup, a diagram of the PCK distribution process, and a diagram of the security measures in place.\nFigure 7.2.3-1: Private Call security procedure for off-network PCK distribution\nThe procedure in figure 7.2.3-1 is now described step-by-step.\n0.\tPrior to beginning this procedure the MC UEs may have performed a discovery procedure. Additionally, the MC UEs have been provisioned with key material associated with a user's MC Service user IDs by a KMS as described in clause 5.3.\n1.\tThe initiating UE generates the PCK and sends a Call Setup Request to the terminating UE.   Within this message, the initiating UE includes a MIKEY-SAKKE I_MESSAGEs as defined in IETF RFC 6509 [11]. The I_MESSAGE encapsulates the PCK for the terminating UE, encrypting the key to the UID of the terminating user (derived from the user's URI). The I_MESSAGE also contains an identifier for the PCK (PCK-ID). The I_MESSAGE is signed using (the key associated with) the initiating user's UID.\n2.\tA Call Setup Response is returned to the initiating UE as defined in 3GPP TS 23.379 [2] for MCPTT and as defined in TS 23.281 [37] for MCVideo.\nWith the PCK and PCK-ID shared between the initiating and terminating users, the media communicated between the UEs may be protected using the PCK.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.2.4\tFirst-to-answer security and key management",
                            "text_content": "A ‘first-to-answer' call as defined in clause 10.15 of TS 23.379 [2], is a call request sent to multiple users inviting them into a private call, and where the first user to answer the request is brought into the private call with the initiator while the rest of the invited users are subsequently rejected.  Consequently, a specific key management solution is required.\nThe following defines a method for performing key distribution for a first-to-answer call. From a security point-of-view, the approach is to perform a private call key distribution from the answering client to the initiating client of the call.\nThe first-to-answer messages are routed over the signalling reference points. Consequently, the security mechanisms for protecting signalling between the MC Domain and the MC UE are applied to these messages. This includes the security mechanisms defined in clause 6. Where application signalling security is supported, the security mechanisms defined in clause 5.3 are used, ensuring that the user identities (MCPTT IDs) are confidentiality protected with the CSK or SPK as per clause 5.3.\nThe first-to-answer request (containing the list of target MCPTT IDs) is sent by an initiating UE to the MCPTT server. No key material is provided in the first-to-answer request.\nThe first-to-answer response is sent by a target UE in response to a first-to-answer request.  The first-to-answer response contains both an encapsulatedPCK for the private call and a pair of MCPTT IDs corresponding to the participants (intiator and target) of the private call.\nThe PCK is encapsulated as defined in clause 5.6. In this case, the 'initiating entity' shall be the MC user who provides the first-to-answer response. The initiating entity URI shall be the MC Service user ID of the user who made the first-to-answer response. The receiving entity shall be the MC user who made the first-to-answer request. The receiving entity URI shall be the MC Service user ID of the user who made the first-to-answer request.\nFigure 7.2.4.3-1 below illustrates the first-to-answer call setup procedure with security.\nThe figure depicts a series of signaling messages, each representing a different stage in the call process. The messages are numbered from 1 to 6, with each message containing a security-related key material. The messages are not encrypted, as defined in TS 23.379 [2]. This indicates that the call is not encrypted, and the security-related key material is not included in the messages.Figure 7.2.4.3-1: First-to-answer call setup and key management\n1 to 6.\tFirst-to-answer call signalling occurs as defined in TS 23.379 [2]. These messages do not contain security-related key material.\n7.\tMCPTT user at MCPTT client 2 accepts the call, which causes the MCPTT client 2 to send a first-to-answer call response to the MCPTT server. Included in the response, is the PCK (PCK_1) encapsulated to the user associated with the initiating client, MCPTT client 1.  The PCK is then included in the SDP content of the response.\nNOTE 1:\tIf the choice of initiator KMS (IDRkmsi) or receiver KMS (IDRkmsr) within the MIKEY message is unacceptable, a KMS Redirect Response may be returned to the responding client providing KMS information. In this case, the responding client may re-attempt the above procedures.\n8.\tThe MCPTT server forwards the first-to-answer call response to MCPTT client 1 indicating that the MCPTT user at MCPTT client 2 has accepted the call. MCPTT client 1 extracts the PCK from the message.\n9.\tThe media plane for communication is now established and protected with the shared PCK.\n10. MCPTT user at MCPTT client 3 accepts the call and sends a first-to-answer call response to the MCPTT server. MCPTT client 3 also includes an encapsulated PCK (PCK_2) in the response.\n11. Since the first-to-answer call response from MCPTT client 2 has already been accepted, the MCPTT server sends a MCPTT first-to-answer call cancel request to MCPTT client 3. The encapsulated PCK provided by MCPTT client 3 (PCK_2) is discarded.\n12-16. First-to-answer call signalling occurs as defined in TS 23.379 [2]. These messages do not contain security-related key material.\nThe first-to-answer media plane shall be protected as for a private call. Clause 7.4.1 is applied to convert the PCK into the SRTP Master Key/Salt, and clause 7.5 is applied for the protection of the first-to-answer media.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.2.5\tAmbient listening call",
                            "text_content": "Ambient listening is a required feature for public safety users. Where the MC client may be used by non-public safety users, the feature shall not be implemented on the MC client and it shall not be possible to enable its use.\nAmbient listening is described in clause 10.14 of 23.379 [2] and allows an authorised user to establish a “listening” private voice call with a target user without an indication that the communication is taking place.  There are two types of ambient listening; the first type consists of the authorised user “listening” to a target user and the second type consists of the authorised user transmitting to a target user.  Both types are intiated by the authorised user.\nThe MCPTT server provides the control and authorisation verification associated with an ambient listening call.\nThe security for an ambient listening call is established similar to that of a secure private call, i.e. a PCK is created for the session and provided securely in the ambient listening call request from the authorised user to the target user as per clause 7.2.2 for on-network private calls and clause 7.2.3 for off-network private calls.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCPTT IDs) shall be protected as described in clause 9.3.\nThe media plane for ambient listening shall be protected as for a private call using a PCK.  Clause 7.4.1 is applied to convert the PCK into the SRTP Master Key/Salt, and clause 7.5 is applied for the protection of the ambient listening media.\nFloor control signalling for an ambient listening call shall be protected as described in clause 9.4.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.2.6\tAmbient viewing call",
                            "text_content": "Ambient viewing is a required feature for public safety users. Where the MC client may be used by non-public safety users, the feature shall not be implemented on the MC client and it shall not be possible to enable its use.\nAmbient viewing is described in clause 7.6 of 23.281 [37] and allows an authorised user to establish a “viewing” private video call with a target user without an indication that the communication is taking place.  There are two types of ambient viewing; the first type consists of the authorised user “viewing” to a target user and the second type consists of the authorised user transmitting or “viewing to” a target user.  Both types are intiated by the authorised user.\nThe MCVideo server provides the control and authorisation verification associated with an ambient viewing call.\nThe security for an ambient vewing communication is established similar to that of a secure private video communication, i.e. a PCK is created for the session and provided securely in the ambient viewing call request from the authorised user to the target user as per clause 7.2.2 for on-network private video communications and clause 7.2.3 for off-network video private communications.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCPTT IDs) shall be protected as described in clause 9.3.\nThe media plane for ambient viewing shall be protected as for a private video communication using a PCK.  Clause 7.4.1 is applied to convert the PCK into the SRTP Master Key/Salt, and clause 7.5 is applied for the protection of the ambient viewing media.\nTransmission control signalling for an ambient viewing communication shall be protected as described in clause 9.4.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.2.7\tPrivate video pull",
                            "text_content": "One-to-one video pull is described in clause 7.3.2.3 of 23.281 [37] and consists of a private unidirectional video transmission from the called party to the calling party.  Off-network video pull (video pull to self) is described in clause 7.3.3 of 23.281 [37].\nThe security for a one-to-one video pull communication is established similar to that of a secure private video call, i.e. a PCK is created for the session and provided securely in the Private call request from the calling user to the called user as per clause 7.2.2 for on-network private calls and clause 7.2.3 for off-network (video pull to self) calls.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCVideo IDs) shall be protected as described in clause 9.3.\nThe media plane for one-to-one video pull shall be protected as for a private video call using a PCK.  Clause 7.4.1 is applied to convert the PCK into the SRTP Master Key/Salt, and clause 7.5 is applied for the protection of the video media.\nTrnasmission control signalling for a one-to-one video pull communication shall be protected as described in clause 9.4, while transmission control signalling for off-network video pull to self communications shall be protected as described in clause 9.4.4.\nOne-from-server video pull is described in clause 7.3.2.4 of 23.281 [37] and consists of a private unidirectional video transmission pulled by the calling party from the MCVideo server.  Figure 7.2.7.2-1 shows the messaging for a one-from-server video pull.\nThe figure depicts a one-to-server video pull scenario, where a video stream is transmitted from a server to a client, and the client receives the video content. The figure illustrates the transmission path, including the server, client, and the network infrastructure.\nFigure 7.2.7.2-1 – One-from-server video pull\nThe security for a one-from-server video pull communication is established similar to that of a secure private video call, i.e. a PCK is created for the session and provided securely in the MCVideo pull from server request sent from the MCVideo client to the MCVideo server.  Clause 7.2.2 applies for on-network one-from-server video commnications.  Note that the PCK shall be encrypted to the identity of the MCVideo server rather than to that of another MCVideo user.\nOff-network operation is not supported for one-from-server video pull communications.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCVideo IDs) shall be protected as described in clause 9.3.\nThe media plane for one-to-one video pull shall be protected as for a private call using a PCK.  Clause 7.4.1 is applied to convert the PCK into the SRTP Master Key/Salt, and clause 7.5 is applied for the protection of the video media.\nTransmission control signalling for a one-from-server video pull communication shall be protected as described in clause 9.4.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.2.8\tPrivate video push",
                            "text_content": "One-to-one video push is described in clause 7.4.2.3 of 23.281 [37] and consists of a private unidirectional video transmission from the calling party to the called party.  Off-network video push to another MCVideo user is described in clause 7.4.3.3 of 23.281 [37].\nThe security for a one-to-one video push communication is established similar to that of a secure private video call, i.e. a PCK is created for the session and provided securely in the Private call request from the calling user to the called user as per clause 7.2.2 for on-network private calls and clause 7.2.3 for off-network private calls.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCVideo IDs) shall be protected as described in clause 9.3.\nThe media plane for one-to-one video pull shall be protected as for a private video call using a PCK.  Clause 7.4.1 is applied to convert the PCK into the SRTP Master Key/Salt, and clause 7.5 is applied for the protection of the video media.\nTransmission control signalling for a one-to-one video push communication shall be protected as described in clause 9.4, while transmission control signalling for off-network video push to another MCVideo user communications shall be protected as described in clause 9.4.4.\nOne-to-server video push is described in clause 7.4.2.4 of 23.281 [37] and consists of a private unidirectional video transmission pushed from the calling party to the MCVideo server.  Figure 7.2.8.2-1 shows the messaging for a one-from-server video push.\nThe figure depicts a one-to-server video push scenario, illustrating the process of video data being transmitted from a source to a server. The diagram shows the various components involved, such as the source, server, and network infrastructure, highlighting the importance of network redundancy and the use of optical fibers for high-speed data transmission.\nFigure 7.2.8.2-1 – One-to-server video push\nThe security for a one-to-server video push communication is established similar to that of a secure private video call (i.e. a PCK is created for the session and provided securely in the MCVideo push to server request sent from the MCVideo client to the MCVideo server).  Clause 7.2.2 applies for on-network one-to-server video communications.  Note this requires that the PCK shall be encrypted to the identity of the MCVideo server rather than to that of another MCVideo user.\nOff-network operation is not supported for one-to-server video push communications.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCVideo IDs) shall be protected as described in clause 9.3.\nThe media plane for one-to-server video push shall be protected as for a private call using a PCK.  Clause 7.4.1 is applied to convert the PCK into the SRTP Master Key/Salt, and clause 7.5 is applied for the protection of the video media.\nTransmission control signalling for a one-to-server video push communication shall be protected as described in clause 9.4.\nOn-network remotely intiated video push is described in clause 7.4.2.5 of 23.281 [37] and consists of an authorised MCVideo user initiating a private unidirectional video transmission from a source MCVideo user and a destination MCVideo user.\nOff-network remotely initiated video push is described in clause 7.4.3.4 of 23.281 [37] and consists of an authorised MCVideo user initiating a private unidirectional video transmission from a source MCVideo user to a destination MCVideo user without the MCVideo serving the call setup and media transmission.\nFigure 7.2.8.3-1 shows the messaging for an on-network remotely initiated video push communication.\n\nThe figure depicts a video push scenario on a network, illustrating the process of remotely initiating video content. It shows the on-network video push process, including the initiation of video content, the transmission of video data, and the delivery of video content to the intended recipient. The figure provides a visual representation of the steps involved in this process, making it easier to understand the flow and steps involved.\nFigure 7.2.8.3-1:  On-network remotely initiated video push\nThe security context for an on-network remotely initiated video push communication is established during step 4 of figure 7.2.8.3-1 between MCVideo client 1 and MCVideo client 2 and is similar to that of a secure private video call, i.e. a PCK is created for the session and provided securely in the Private communication request from MCVideo client 1 to MCVideo client 2 as described in clause 7.2.2.\nIn figure 7.2.8.3-2, the remote video push request message from MCVideo client 3 does not establish a security context for the call; however it does provide the MCVideo IDs of participating MCVideo client 1 and MCVideo client 2.\nFigure 7.2.8.3-2 shows the messaging for an off-network remotely initiated video push communication.\n\nThe figure depicts a remote video push scenario in an off-network environment, illustrating the process of video data being transmitted from a remote location to a central server. The figure shows the various components involved, such as the video source, the remote server, and the video processing and storage infrastructure. The figure provides a visual representation of the complex network architecture required for such a remote video push operation, highlighting the need for efficient video transmission and storage solutions.\nFigure 7.2.8.3-2:  Off-network remotely initiated video push\nThe security context for an off-network remotely initiated video push communication is established during step 3 of figure 7.2.8.3-2 between MCVideo client B and MCVideo client C and is similar to that of a off-network secure private video call, i.e a PCK is created for the session and provided securely as described in clause 7.2.3.\nIn figure 7.2.8.3-2, the remote video push request message from MCVideo client A does not establish a security context for the call; however it does provide the MCVideo IDs of participating MCVideo client B and MCVideo client C.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCVideo IDs) shall be protected as described in clause 9.3 for both on-network and off-network operation.\nFor both on-network and off-network, the media plane for a remotely initiated video push communication shall be protected as for a one-to-one video push communication using a PCK.  Clause 7.4.1 is applied to convert the PCK into the SRTP Master Key/Salt, and clause 7.5 is applied for the protection of the video media.\nTransmission control signalling for a remotely initiated video push communication shall be protected as for a one-to-one video push communication, as described in clause 9.4, while transmission control signalling for off-network remotely initiated video push communications shall be protected as described in clause 9.4.4.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "7.3\tGroup communications",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "7.3.1\tGeneral",
                            "text_content": "To support MCPTT and MCVideo group communications, group security procedures are used to establish and distribute keys to the members of predefined or dynamically defined groups.\nKey material (GMK and GMK-ID) for a predefined group is created and distributed by the GMS to the members of the group via the common key distribution mechanisms defined in clause 5.7.\nKey material for dynamically created groups is created and distributed by the GMS to the members of the group via the security mechanisms defined in the following sub clauses.\nNOTE:\tVoid\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.2\tGroup creation security procedure",
                            "text_content": "The group creation procedure is described in clause 10.2.3 of 3GPP TS 23.280 [36] and applies to the MCPTT scenario of normal group creation by an MC administrator and user regrouping operations by an authorized user/dispatcher.  To establish the security context for the group, the GMS follows the procedures in clause 5.7 to create a new GMK and GMK-ID.\nThe encapsulated GMK and GUK-ID is sent to group members by the GMS within a notification message (step 4 in clause 10.2.3 of 3GPP TS 23.280 [36]). The procedure is equivalent to that described in clause 5.7 of this specification.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.3\tDynamic group keying",
                            "text_content": "In the GMK distribution procedures described in this clause, the GMS shall be provisioned with the same information as any MC UE by the KMS as described in clause 5.3; the only distinguishing feature is that the GMS's identity is a Server URI rather than an MC Service ID.\nNOTE 1:\tVoid.\nIn addition to authorisation, the only information the GMS requires to create the group are the MCPTT IDs of the group members. These two features combined allow groups to be created and keyed at any time, by any authorized entity.\nSuch flexibility is required to support a number of MCPTT group procedures within 3GPP TS 23.280 [36].\nNOTE 2:\tThe dynamic group keying mechanisms may not support off-network scenarios.\nGroup Regroup procedures for the MC system are described in clause 10.2.4.1 of 3GPP TS 23.280 [36]. To create the security context for the temporary group, the GMS follows the procedures in clause 5.7, creating a new GMK and GMK-ID for the temporary group.\nAn encapsulated GMK and GUK-ID is sent to the temporary group members by the GMS within a notification message (step 5 in clause 10.2.4.1 of 3GPP TS 23.280 [36]). The procedure is equivalent to that described in clause 5.7.\nThe MCPTT group regroup security procedure (shown below in figure 7.3.3.3-1) involves multiple MC users from multiple MC domains and is an integrated component of the MCPTT group regrouping procedure described in clause 10.2.4.2 of 3GPP TS 23.280 [36].\n\nThe figure depicts a group security procedure for multiple MC domains, illustrating the steps and protocols involved in managing security within a network.\nFigure 7.3.3.3-1: Group regroup security procedure (multiple MC domains)\nPrior to beginning the procedure, the MC UEs, primary GMS and partner GMS are provisioned by a KMS as described in clause 5.3.\n1-5:\tThese steps are as defined in clause 10.2.4.2 of 3GPP TS 23.280 [36].\n6:\tTo create the security context for the temporary group, the primary GMS creates a new GMK and GMK-ID for the temporary group along with other group related information.\n7,8:\tThe primary GMS notifies the partner GMS of the group regroup operation. The primary GMS includes a Group Key Transport payload following the procedures in clause 5.7, treating the partner GMS as another user within the group. Accordingly, the payload encrypts the new GMK to the identity of the partner GMS and is signed using the identity of the primary GMS. The GUK-ID is derived using the User Salt generated from the partner GMS's URI.\nNOTE 1:\tIf the choice of initiator KMS (IDRkmsi) or receiver KMS (IDRkmsr) within the MIKEY message is unacceptable, a KMS Redirect Response may be returned to the primary GMS providing KMS information. In this case, the primary GMS may re-attempt the above procedures.\n9,10:\tThese steps are as defined in clause 10.2.4.2 of 3GPP TS 23.280 [36].\n11:\tThe partner GMS extracts the GMK and GMK-ID from the notification. The partner GMS then notifies the affiliated users within the partner MC domain. The partner GMS re-encrypts the GMK to the identity of the affiliated users in the partner system, generates new GUK-IDs for each user and signs using its identity (the identity of the partner GMS) following the procedure in clause 5.7.\n12,13:\tThese steps are as defined in clause 10.2.4.2 of 3GPP TS 23.280 [36].\n14:\tThe primary GMS notifies the affiliated users within its own MC domain. The primary GMS includes a Group Key Transport payload including a GMK and GUK-ID following the procedures in clause 5.7. The GMK is encrypted to the identity of the MC user and is signed using the identity of the primary GMS.\n15:\t\tThis step is as defined in clause 10.2.4.2 of 3GPP TS 23.280 [36].\nIt is possible that a partner GMS may be represented by an MC Security Gateway (as defined in Annex L), rather than using full end-to-end security. In this case, the partner GMS's KMS Certificate will have the ‘IsSecurityGateway' attribute set to ‘true' (see clause D.3.2.2). Should a partner GMS be represented by an MC Security Gateway, the primary GMS shall indicate to all group users and partner GMS(s) that the GMK is shared with an MC Security Gateway. This is achieved by setting the ‘Security Gateway' bit in the ‘Status' field of the GMK's key parameters (see clause E.6.9).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.4\tBroadcast group call",
                            "text_content": "Broadcast group call is described in clause 10.6.2.5.2 of 23.379 [2] and consists of a group transmission where the initiating user expects no response from the other group members.  When the initiating user's transmission is complete, the broadcast group communication ends.\nThe security context for a broadcast group communication is established similar to that of a secure group communication where the GMK associated to the broadcast group shall be converted into the SRTP Master Key/Salt per clause 7.4.2.   Clause 7.5 shall be applied to establish protection of the broadcast group media.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCX Service User IDs and MCX Group IDs) shall be protected as described in clause 9.3.\nFloor control signalling for on-network broadcast group communications shall be protected as described in clause 9.4.6 while floor control signalling for off-network broadcast group communications shall be protected as described in clause 7.4.2.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.5\tGroup-broadcast group call",
                            "text_content": "Group-broadcast group call is described in clause 10.6.2.5.2.1 of 23.379 [2] and consists of a group transmission to a set of groups rather than to a set of users.  Like a broadcast group communication, the initiating user expects no response from the target groups.  When the initiating user's transmission is complete, the group-broadcast group communication ends.\nThe security context for a group-broadcast group communication is similar to that of a secure group communication, i.e. the group-broadcast group ID is predefined and assigned a GMK.  The GMK associated to the group-broadcast group shall be converted into the SRTP Master Key/Salt per clause 7.4.2.   Clause 7.5 shall be applied to establish protection of the group-broadcast group media.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCX Service User IDs and MCX Group IDs) shall be protected as described in clause 9.3.\nFloor control signalling for on-network group-broadcast group communications shall be protected as described in clause 9.4.6 while floor control signalling for off-network group-broadcast group communications shall be protected as described in clause 7.4.2.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.6\tEmergency group call",
                            "text_content": "An emergency group call is described in clause 10.6.2.6.1 of 23.379 [2] and consists of a group communication where the priority of the transmission or group is set to an emergency status.  An existing group call may be elevated to an emergency status or a separate designated emergency group may be used.\nWhen an existing group call is elevated to emergency status, there should be no change to the ongoing security context for that group.  Media protection, floor control protection, and application signalling protection continue to use the existing keys and mechanisms that were in place prior to elevating the group to emergency status. However, the call may be downgraded to clear to ensure the emergency group call is setup by the MCX system.\nWhen a designated emergency group is used and the user intiates an emergency call, the emergency group is established and a new security context set up shall be attempted (assuming the emergency group is not already active).  If the security context setup is successful the emergency group call shall proceed with security, otherwise based on MCX operator policy the call may default to unencrypted.\nFor either existing or designated call types, a secured emergency group call uses group communication mechanisms where a GMK associated with the emergency group is distributed to the affiliated members per clause 5.7.  The GMK is used to encrypt the media for on-network and off-network, unicast or multicast, emergency group communications.  The GMK shall be converted into the SRTP master key and master salt as described in clause 7.4.2 and the emergency group media shall be encrypted using the SRTP master key and master salt as defined in clause 7.5.1.\nFor either existing or designated call types, floor control signalling for a on-network and off-network secured emergency group communication shall be protected as described in clause 9.4.\nFor either existing or designated call types, when required by the MCX service provider, sensitive application signalling parameters (e.g. MCX Service User IDs and MCX Group IDs) shall be protected as described in clause 9.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.7\tImminent peril group call",
                            "text_content": "An imminent peril group call is described in clause 10.6.2.6.2 of 23.379 [2] and consists of a group communication where the priority of the transmission is elevated to imminent peril status.  The imminent peril transmission may be sent within an existing group call or alternatively a separate designated imminent peril group may be used.\nWhen an imminent peril transmission is sent on an existing group call, there should be no change to the ongoing security context for that group.  Media protection, floor control protection, and application signalling protection continue to use the existing keys and mechanisms that were in place prior to the imminent peril transmission.  However, the call may be downgraded to clear to ensure the emergency alert is setup by the MCX system.\nWhen a designated imminent peril group is used and the user initiates an imminent peril transmission, the imminent peril group is established and a new security context set up shall be attempted (assuming the imminent peril group is not already active). If the security context setup is successful the imminent peril group call shall proceed with security, otherwise based on MCX operator policy the call may be downgraded to unencrypted.\nFor either existing or designated call types, a secured imminent peril group call uses group communication mechanisms where a GMK associated with the existing or imminent peril group is distributed to the affiliated members per clause 5.7.  The GMK is subsequently used to encrypt the media for on-network and off-network, unicast or multicast, imminent peril group communications.  The GMK shall be converted into the SRTP master key and master salt as described in clause 7.4.2 and the imminent peril group media shall be encrypted using the SRTP master key and master salt as defined in clause 7.5.1.\nFor either existing or designated call types, floor control signalling for an on-network and off-network secured imminent peril group communication shall be protected as described in clause 9.4.\nFor either existing or designated call types, when required by the MCX service provider, sensitive application signalling parameters (e.g. MCX Service User IDs and MCX Group IDs) shall be protected as described in clause 9.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.8\tEmergency Alert",
                            "text_content": "An emergency alert is described in clause 10.6.2.6.3 of 23.379 [2] and consists of a group communication where at least one user has issued an emergency alert indication, elevating that user to an emergency state.  A transmission by a user while in the emergency state has elevated priority and may be sent within an existing group call or alternatively a separate designated emergency group.When an existing group call is used as the emergency group, there should be no change to the ongoing security context for that group.  Media protection, floor control protection, and application signalling protection continue to use the existing keys and mechanisms that were in place prior to the emergency alert. However, the call may be downgraded to clear to ensure the emergency alert is setup by the MCX system\nWhen a designated emergency group is used and the user intiates an emergency alert and transmission, the assigned emergency group is established and a new security context set up is attempted (assuming the emergency group is not already active).  If the security context setup is successful, the imminent peril group call shall proceed with security, otherwise based on MCX operator policy the call may default to unencrypted.\nFor either existing or designated call types, a secured emergency alert issued emergency group call uses group communication mechanisms where a GMK associated with the emergency group is distributed to the affiliated members per clause 5.7.  The GMK is used to encrypt the media for on-network and off-network, unicast or multicast, emergency group communications.  The GMK shall be converted into the SRTP master key and master salt as described in clause 7.4.2 and the emergency group media shall be encrypted using the SRTP master key and master salt as defined in clause 7.5.1.\nFor either existing or designated call types, floor control signalling for an on-network and off-network secured emergency group communication shall be protected as described in clause 9.4.\nFor either existing or designated call types, when required by the MCX service provider, sensitive application signalling parameters (e.g. MCX Service User IDs and MCX Group IDs) shall be protected as described in clause 9.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.9\tRemotely initiated video push to group",
                            "text_content": "On-network remotely intiated video push to group is described in clause 7.4.2.6 of 23.281 [37] and consists of an authorised MCVideo user initiating a broadcast video transmission sourced from a second MCVideo user.\nOff-network remotely initiated video push to a group is described in clause 7.4.3.5 of 23.281 [37] and consists of an authorised MCVideo user initiating a broadcast video transmission sourced from a second MCVideo user without the MCVideo serving the call setup and media transmission.\nFigure 7.3.11.1-1 shows the messaging for on-network remotely initiated video push to group communication.\n\nThe figure depicts a video push to a group on an on-network remotely initiated basis, illustrating the use of video push technology in a video conferencing scenario.\nFigure 7.3.11.1-1:  On-network remotely initiated video push to group\nThe security context for an on-network remotely initiated video push to group communication is established in step 4 of figure 7.3.11.1-1 by the target MCVideo user (MCVideo client 2) similar to that of a secure group broadcast communication where a GMK associated to the broadcast group shall be converted into the SRTP Master Key/Salt per clause 7.4.2.   Clause 7.5 shall be applied to establish protection of the broadcast group media.\nIn figure 7.3.11.1-1, the remote video push request message does not establish a security context for the broadcast call but does however provide the group ID for the broadcast group.\nFigure 7.3.11.1-2 shows the messaging for an off-network remotely initiated video push to group communication.\nThe figure depicts a remote video push to a group scenario, where a video stream is transmitted off-network to a group of users. The video is transmitted over a network, and the group is connected to a central server for processing and distribution. The figure illustrates the use of video compression and streaming technologies to ensure high-quality video delivery over long distances.\nFigure 7.3.11.1-2:  Off-network remotely initiated video push to group\nThe security context for an off-network remotely initiated video push to group communication is established in step 3 of figure 7.3.11.1-2 by the target MCVideo user (MCVideo client B) similar to that of a secure group broadcast communication where a GMK associated to the broadcast group shall be converted into the SRTP Master Key/Salt per clause 7.4.2.   Clause 7.5 shall be applied to establish protection of the broadcast group media.\nIn figure 7.3.11.1-2, the remote video push request message from MCVideo client A does not establish a security context for the broadcast call but does however provide the group ID for the broadcast group.\nWhen required by the MCX operator, sensitive application signalling parameters (e.g. MCX Group IDs) shall be protected as described in clause 9.3 for both on-network and off-network operation.\nTransmission control signalling for on-network remotely initiated video push to group communications shall be protected as described in clause 9.4.6 while transmission control signalling for off-network remotely initiated video push to group communications shall be protected as described in clause 7.4.2.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.10\tMulti-talker configured MCPTT group",
                            "text_content": "The requirements of the multi-talker feature for mission critical communications are defined in 22.179 [3] and may occur as part of multi-talker configured MCPTT group communications as decribed in 23.379 [2].  In a multi-talker configured MCPTT group communication, more than one media stream may be mixed together and simultaneously heard by a call participant.\nWhen media protection is applied, the GMK assigned to the multi-talker configured MCPTT group is used to protect the group media as described in clauses 7.4.2 and 7.5, however because the controlling MCPTT server cannot decrypt the media streams (as it does not possess the GMK of the group), the controlling MCPTT server is therefore unable to mix media streams together prior to dissemination of the media to the members of the group.  In this case, all protected and active media streams for the multi-talker configured group call shall be sent by the controlling MCPTT server to the participating MC UEs where each participating MC UE shall decrypt the received media streams. Once the media streams have been decrypted by the MC UE, the media may be mixed and presented to the user.\nIf media protection is not applied then the multi-talker configured group media shall be mixed and provided to the participating MC UEs as indicated in 23.379 [2].\nWhen MC signaling protection is enabled, unicast delivery of signalling messages applicable to multi-talker configured MCPTT group communications shall be protected as defined in clause 9.4.2 and multicast delivery of these signaling messages shall be protected as defined in clause 9.4.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.11\tGroup regroup with preconfigured group",
                            "text_content": "Group regroup with preconfigured group is defined in TS 23.379 [2] and TS 23.280 [36]. The basis of this feature is to allow an authorized MC user to dynamically create a temporary group consisting of a set of predefined groups (i.e. the affiliated members of the predefined groups become members of this new regroup group).  For common group configuration and security, the group regroup with preconfigured group uses a group that is common to all the invited users.  TS 23.379 [2] and TS 23.280 [36] refer to this common group as a preconfigured group.  All users invited to join a secure group regroup with preconfigured group call shall be members of the indicated preconfigured group and shall have obtained the preconfigured group configuration and GMK.\nSecurity for group regroup with preconfigured group follows typical group security establishment procedures using the GMK and GMK-ID obtained through the preconfigured group configuration. The group configuration to be used (i.e. the GMK and GMK-ID) is identified in the initial preconfigured regroup request message.  The GMK and the GMK-ID from the identified preconfigured group shall be used to derive the master key and master salt as described in clause 7.4.2 and used to secure the media as described in clause 7.5.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.3.12\tUser regroup with preconfigured group",
                            "text_content": "User regroup with preconfigured group is defined in TS 23.379 [2] and TS 23.280 [36]. The basis of this feature is to allow an authorized MC user to dynamically create a temporary group consisting of a specified set of users (i.e. the users identified in the user regroup become members of this new temporary group).  For common group configuration and security, the user regroup with preconfigured group uses a group that is common to all the invited users.  TS 23.379 [2] and TS 23.280 [36] refer to this common group as a preconfigured group.  All users invited into a secure user regroup with preconfigured group call shall be members of the indicated preconfigured group and shall have obtained the preconfigured group configuration and GMK.\nSecurity for user regroup with preconfigured group follows typical group security establishment procedures using the GMK and GMK-ID obtained through a preconfigured group configuration. The group configuration to be used (i.e. the GMK and GMK-ID) is identified in the initial preconfigured regroup request message.  The GMK and the GMK-ID from the identified preconfigured group shall be used to derive the master key and master salt as described in clause 7.4.2 and used to secure the media as described in clause 7.5.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "7.4\tKey derivation for media",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "7.4.1\tDerivation of SRTP master keys for private call",
                            "text_content": "As a result of this mechanism, the private call members share a PCK and PCK-ID. The PCK shall be used as the MIKEY Traffic Generating Key (TGK), the PCK-ID shall be used as the MIKEY CSB ID. The MIKEY RAND shall be the MIKEY RAND value transmitted together with the PCK provision. The CS-ID value is defined in Table E.1.3-1. These shall be used to generate the SRTP Master Key and SRTP Master Salt as specified in IETF RFC 3830 [22]. The key derivation function defined in section 4.1.3 of RFC 3830 [22] using the PRF-HMAC-SHA-256 Pseudo-Random Function as described in IETF RFC 6043 [25], section 6.1 shall be supported for generating the SRTP Master Key and Salt.\nThe figure depicts a key derivation for media stream protection in a 4.1-1 network. It illustrates the process of deriving a key for a media stream, which is crucial for secure communication. The figure includes a diagram of the network structure, with key derivation points marked as 1, 2, 3, and 4. Key derivation points are essential for ensuring the integrity of the media stream, as they are used to derive a key for the media stream. The figure also includes a diagram of the network structure, with key derivation points marked as 1, 2, 3, and 4. Key derivation points are essential for ensuring the integrity of the media stream, as they are used to derive a key for the media stream.\nFigure 7.4.1-1: Key Derivation for media stream protection\nTo identify the security context from the media stream, a SRTP Master Key Identifier (MKI) is required. The MKI shall be the 32-bit PCK-ID which has a purpose tag of '1'.\nWhen the MC client is operating off-network, the PCK is used to derive keys for floor control, transmission control, and media control (SRTCP). Thus, the Master Key and Master Salt used for SRTCP is the same with the Master Key and Master Salt used for SRTP, so is the MKI.\nSee clause 9.4.6 for key derivation procedures for private communication floor, transmission, and media control (SRTCP) when the MC client is operating on-network.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.4.2\tDerivation of SRTP master keys for group media",
                            "text_content": "As a result of this mechanism, the group members are able to generate the master keys for a secure group call.\nAs shown in Figure 7.4.2-1, the GMK for the group shall be used as the MIKEY Traffic Generating Key (TGK) and the (derived) GUK-ID shall be used as the MIKEY CSB ID. The MIKEY RAND shall be the MIKEY RAND value transmitted in the MIKEY message used to distribute the GMK. The CS-ID value is defined in Table E.1.3-1. These shall be used to generate the SRTP Master Key and SRTP Master Salt as specified in IETF RFC 3830 [22]. The key derivation function defined in section 4.1.3 of IETF RFC 3830 [22] using the PRF-HMAC-SHA-256 Pseudo-Random Function as described in IETF RFC 6043 [25], section 6.1 shall be supported for generating the SRTP Master Key and Salt.\nThe figure depicts a key derivation for media stream protection in a 4G network. It illustrates the process of deriving a key for a media stream, which is crucial for secure communication. The figure shows the key derivation process, including the key derivation for the media stream, the key derivation for the media stream protection, and the key derivation for the media stream protection key. The key derivation is derived from the key derivation for the media stream, which is derived from the key derivation for the media stream protection, and the key derivation for the media stream protection key is derived from the key derivation for the media stream protection key. The key derivation is derived from the key derivation for the media stream protection key, which is derived from the key derivation for the media stream protection key, and the key derivation for the media stream protection key is derived from the key derivation for the media stream protection key. The key derivation is derived from the key derivation for the media stream protection key, which is derived from the key derivation for the media stream protection key, and the key derivation for the media stream protection key is derived from the key derivation for the media stream protection key. The key derivation is derived from the key derivation for the media stream protection key, which is derived from the key derivation for the media\nFigure 7.4.2-1: Key Derivation for media stream protection\nTo identify the security context from the media stream, a SRTP Master Key Identifier (MKI) is required. The MKI should be a 64-bit value formed by concatenating the GMK-ID with the GUK-ID (GMK-ID || GUK-ID). The GMK-ID shall have a purpose-tag of '0'.\nThe GUK-ID is derived as specified in Annex F.1.3, using the MC service user ID of the transmitting user.\nWhere the transmitting user is known through other means, the MKI may be solely the 32-bit GMK-ID. In this case the terminating user extracts the GUK-ID by calculating the User Salt and xor'ing this value with the GMK-ID.\nWhen the MC client is operating off-network, the GMK is used to derive keys for floor control, transmission control, and media control (SRTCP). Thus, the Master Key and Master Salt used for SRTCP is the same with the Master Key and Master Salt used for SRTP, so is the MKI.\nSee clause 9.4.6 for key derivation procedures for group communication floor, transmission, and media control (SRTCP) when the MC client is operating on-network.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "7.5\tMedia protection profile",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "7.5.1\tGeneral",
                            "text_content": "The following mechanism shall be used to protect MCPTT and MCVideo communications which use the Real-Time Transport Protocol (RTP), cf. IETF RFC 3550 [12]. The integrity and confidentiality protection for MCPTT and MCVideo communications using RTP shall be achieved by using the Secure Real-Time Transport Protocol (SRTP), IETF RFC 3711 [13].\nThe key management mechanism for SRTP is described elsewhere. As a result of this mechanism, those communicating will have shared the following:\n1)\tA SRTP Master Key.\n2)\tA SRTP Master Salt.\n3)\tA SRTP Master Key Identifier (MKI) referencing the above two values.\nThe mechanism described in IETF RFC 3711 [13] is used to encrypt the RTP payload. A diagram of the key derivation mechanism (as described in IETF RFC 3711) is shown in figure 7.5.1-1.\nThe figure depicts a security mechanism for media stream protection, specifically focusing on the encryption and decryption processes. It illustrates the use of encryption algorithms such as AES and RSA, as well as the decryption process, which involves the use of a key. The figure also includes a visual representation of the encryption and decryption process, with arrows indicating the flow of data.\nFigure 7.5.1-1: Security mechanism for media stream protection\nThe AES-CM-128 algorithm as defined in IETF RFC 3711 [13] shall be supported as the SRTP PRF (which is used to derive the SRTP session key and salt). A SRTP key derivation rate of 0 shall be used to indicate that session keys and salts shall not be refreshed. The AEAD_AES_128_GCM algorithm as defined in IETF RFC 7714 [26] shall be supported for providing confidentiality and data authentication of SRTP packets. The AEAD_AES_128_GCM algorithm requires that the SRTP session key is 16 octets in length, and the SRTP session salt is 12 octets in length.\nUnless provided in the MIKEY message used to distribute the SRTP Master Key, the SSRC shall be randomly generated for each session. For group communications, the GMS shall not provide SSRCs, and hence the SSRC shall be randomly generated.\nCare should be taken to avoid SSRC repetition when a user uses the SRTP Master Key for more than one session. In particular, SSRCs shall not be generated in a way which could cause collisions (e.g. from the same seed).\nThe SRTP authentication tag may be appended to every 'rth' packet as defined in IETF RFC 4771 [24] to provide the SRTP ROC counter to MC UEs performing a late-entry to the communication. A 'mode 3' integrity transform (RCCm3) shall be supported for transmitting the ROC within a 4 octet SRTP authentication tag.\nNOTE:\tThe ROC and MKI fields of the SRTP packet are not authenticated as part of the AEAD_AES_128_GCM algorithm. However, modification of these fields would cause a failure to validate the AEAD authentication tag which would cause the packet to be correctly rejected by the receiver. If an unauthenticated SRTP encryption mode be used, there will be a security impact of a malicious modification of the ROC or MKI packets.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "7.5.2\tSecurity procedures for media stream protection",
                            "text_content": "Media stream protection does not require any signalling mechanism to convey information. The information is provided within each SRTP Packet.\nThe figure depicts a security procedure for media stream protection, illustrating the steps taken to ensure the integrity and confidentiality of media streams. The diagram includes a series of steps, such as encryption, authentication, and access control, which are crucial for safeguarding sensitive information. The use of color-coded arrows and labels helps to visually represent the flow of information, making it easier to understand and follow the procedure.\nFigure 7.5.2-1: Security procedure for media stream protection\nFigure 7.5.2-1 shows the security mechanism.\n0)\tPrior to beginning this procedure the MC UEs involved in the communication shall have established a security context (SRTP Master Key, SRTP Master Salt, MKI).\n1)\tTransmitting UEs shall send SRTP packets using the format described in IETF RFC 3711 [13]. The packet shall include a Master Key Identifier (MKI) field which contains the information required to locate the SRTP Master Key and Master Salt, and may include the SRTP ROC as defined in IETF RFC 4771 [24]. On receipt of a SRTP packet, a terminating UE shall use the contents of the MKI to look up the appropriate SRTP Master Key and salt and generate the appropriate SRTP session key and salt if it satisfies the key derivation rate criteria as specified in IETF RFC3711. If it appears in the SRTP packet, the terminating UE shall use the contents of the SRTP authentication tag to establish the SRTP ROC as defined in IETF RFC 4771 [24].\nNOTE 1:\tAssuming members of the group have been keyed/pre-provisioned at some point in the past, this security mechanism is entirely stateless.\nNOTE 2:\tThe receiver does not need to generate an appropriate SRTP session key and salt every time when it receives a SRTP packet. The key derivation rate defined in IETF RFC3711 [13] determines the session key generation frequency. Refer to RFC3711 for more information.\nNOTE 3:\tAs the SRTP synchronization source identifier (SSRC) is used for encryption and decryption, the SSRC value in the SRTP packet needs to be maintained from the transmitting UE to the receiving UE. This includes the uplink and the downlink, over unicast or multicast.\nA diagram of the SRTP packet format is within figure 7.5.2-2.\nThe figure depicts a 5G packet format with security parameters, including the use of Secure R-Parameterized Transmission (SRTP) for data encryption.\nFigure 7.5.2-2: SRTP packet format showing security parameters\nThe length of the MKI field is defined by the key distribution procedure used to create the original security context.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "8\tMCData",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "8.1\tOverview",
                    "description": "",
                    "summary": "",
                    "text_content": "MCData SDS allows transmission of short data messages (SDS), either private or group, over both the signalling plane (reference point MCData-SDS-1) and media plane (reference point MCData-SDS-2).\nMCData File Distribution (FD) also allows for transmission of files, either private or group, over the media plane or using HTTP. When distributed using HTTP, binary data representing the file is uploaded and downloaded using HTTP POST and HTTP GET.\nMCData signalling parameters for SDS and File Distribution are routed within SIP messages. Protection for these signalling messages and files when distributed using HTTP, use the same key material as for MCPTT and MCVideo.\nThe MCData SDS or FD messages may also contain a MCData Data signalling payload or a MCData Data payload or both. These payloads may be within a SIP message should the signalling plane be used, or within a MSRP message should the media plane be used. The MCData Data payload may be end-to-end confidentiality and integrity protected according to an end to end security context payload.\nThe file when distributed using HTTP may be end-to-end confidentiality and integrity protected according to an end to end security context payload before being uploaded.\nComponents of MCData messages:\n-\tMCData signalling parameters: generic Mission Critical Services signalling elements e.g. MCData Group ID, MCData user ID. These parameters are confidentiality protected between the MCData Client and the MCData server with signalling plane security mechanisms.\n-\tMCData Data signalling payload: information elements necessary for identification and management of the MCData messages e.g. conversation identifiers, session identifiers, transaction identifiers, disposition requests, etc. This payload is confidentiality protected between the MCData Client and the MCData server with signalling plane security mechanisms.\n-\tEnd to end security parameters: information specifying the cryptographic elements used to protect the data payload).\n-\tMCData Data payload: the actual user payload for MCData user or application consumption. This payload is end to end confidentiality and integrity protected.\nComponents of the MCData message (MCData signalling parameters and MCData Data signalling payload) are integrity protected between the MCData Client and the MCData server with the signalling plane security mechanisms.\nThe figure depicts the various components of a message in a multi-channel communication system, including the message header, data, and control information. The message header includes the message identifier, message type, and message length. The data section shows the actual data being transmitted, while the control information section provides information about the sender and receiver, as well as any error detection and correction mechanisms. The figure is useful for understanding the structure and components of a message in a multi-channel communication system.\nFigure 8.1-1: MCData message components\nFor one-to-one communications the PCK is used to protect the MCData data payload or the file when distributed using HTTP. For group communications, the GMK is used to protect the MCData data payload or the file when distributed using HTTP. The data payload or the file when distributed using HTTP may also be authenticated by the initiator.\nDistribution of the PCK is within the signalling channel setup for the MCData private message (either SDS or FD). Distribution of the GMK is as defined in clause 5.7.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "8.2\tKey Management",
                    "description": "",
                    "summary": "",
                    "text_content": "Key management for MCData follows the same model as MCVideo and MCPTT. Where a key is used for protection of MCData or MCVideo data, the same type of key shall be used in the same circumstance for MCData. Each key used for protection of MCData payloads is known as the MCData Payload Protection Key (DPPK).\nMCData signalling parameters and Data signaling payloads are protected as follows:\n- Unicast MCData signalling parameters and Data signaling payloads between client and server are protected using the CSK (e.g. the DPPK is the CSK).\n- Multicast MCData signalling parameters and Data signaling payloads from server to client are protected using a MuSiK (e.g. the DPPK is a MuSiK).\n- MCData signalling parameters and Data signaling payloads between servers are protected using the SPK (e.g. the DPPK is the SPK).\n- MCData signalling parameters and Data signaling payloads between two off-network clients are protected using a PCK (e.g. the DPPK is the PCK).\n- MCData signalling parameters and Data signaling payloads between a group of off-network clients are protected using a GMK (e.g. the DPPK is the GMK).\nMCData Data payloads are protected as follows:\n- MCData Data payloads end-to-end protected between two online clients are protected using a PCK (e.g. the DPPK is the PCK).\n- MCData Data payloads end-to-end protected between two off-network clients are protected using a PCK (e.g. the DPPK is the PCK).\n- MCData Data payloads end-to-end protected between a group of online clients are protected using a GMK distributed by a GMS (e.g. the DPPK is the GMK).\n- MCData Data payloads end-to-end protected between a group of off-network clients are protected using a GMK distributed by a GMS (e.g. the DPPK is the GMK).\n- MCData Data payloads are end-to-end authenticated based on SSK, PVT and KPAK distributed by a KMS.\nFiles when distributed using HTTP are protected as follows:\n- Files end-to-end protected between two online clients when distributed using HTTP are protected using a PCK (e.g. the DPPK is the PCK).\n- Files end-to-end protected between a group of online clients when distributed using HTTP are protected using a GMK distributed by a GMS (e.g. the DPPK is the GMK).\nNOTE:\tThe DPPK is not a new type of key, it describes how the MC system's existing key types are used to protect MCData. Consequently, there will be multiple DPPKs in the MC System depending on the communication channel. Furthermore, while a PCK and a GMK may both be used as a DPPK to protect MCData in different channels, the PCK and the GMK are not the same key.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "8.3\tOne-to-one communications",
                    "description": "",
                    "summary": "",
                    "text_content": "The purpose of key management is to establish a MCData Payload Protection Key (DPPK) for the one-to-one communication channel between the pair of communicating clients. In the case of a one-to-one communication, the DPPK shall be the PCK. The PCK is used for end-to-end protection of one-to-one (private) SDS or FD data payloads.\nThe PCK and PCK-ID are distributed within the SIP message used to initiate the session.\nThe PCK and PCK-ID is distributed using service-specific signalling. For all MCData services, SIP signalling is used to establish or send the MCData communication. The PCK and PCK-ID is distributed within a MIKEY payload contained within the SDP offer sent from the initiator to the receiver in the same way as for MCPTT and MCVideo. The procedures for PCK distribution are defined within clause 5.6.\nFor off-network MCData operations, an MCData payload containing a MIKEY_SAKKE I-MESSAGE (clause 8.5.4.1) is used to distribute an MCData DPPK (PCK) from the initiating MCX client to the terminating MCX client.\nThis key distribution mechanism applies to the following messages defined in TS 23.282 [38]:\n-\tMCData standalone data request\n-\tMCData session data request\n-\tMCData FD request\nWhen required by the MCData service provider, protection shall be applied to the MCData Data payloads using the PCK. Payload authentication may also be applied. The mechanisms used to secure these payloads are described in clause 8.5.\nOnce the PCK is established between the source and destination, SDS and FD exchanges between this same source and destination may continue to use the same PCK for subsequent MCData communications by simply providing the PCK-ID in every SDS message.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "8.4\tGroup communications",
                    "description": "",
                    "summary": "",
                    "text_content": "The purpose of key management is to establish a MCData Payload Protection Key (DPPK) for the group communication between the group of communicating clients. In the case of group communication, the DPPK shall be the GMK. The GMK is distributed in the same way as for MCPTT and MCVideo group communications, as defined in clause 5.7.\nWhen required by the MCData service provider, protection shall be applied to the MCData Data payloads using the GMK. Payload authentication may also be applied. The mechanisms used to secure these payloads are described in clause 8.5.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "8.5\tMCData payload protection",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "8.5.1\tGeneral",
                            "text_content": "The protection applied to the MCData payload is indicated by the 'Message Type' of the MCData payload. If the payload is protected (encrypted and integrity protected), Bit '7' of the Message Type shall be '1' (otherwise it shall be '0'), if the payload is authenticated, Bit '8' of the Message Type shall be '1' (otherwise it shall be '0'). See Clause 15.2.2 of TS 24.282 [50].\nThe following protected (encrypted and integrity protected) payloads are defined for MCData SDS and file distribution:\n-\tProtected SDS Signalling Payload.\n-\tProtected FD Signalling Payload.\n-\tProtected Data Payload.\n-\tProtected SDS notification message.\n-\tProtected FD notification message.\n-\tProtected FD network notification message.\n-\tProtected Communication release message.\n-\tProtected binary data representing the file.\nThe following authenticated payloads are defined for MCData SDS and file distribution:\n-\tAuthenticated Data Payload.\nThe following authenticated and protected (encrypted and integrity protected) payloads are defined for MCData SDS and file distribution:\n-\tAuthenticated and Protected Data Payload.\nIn this case both the procedures for protecting a payload and authenticating a payload are applied\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "8.5.2\tPrequisites",
                            "text_content": "The prequisites for encryption and integrity protection of a protected payload is that the MC client(s) or MC server(s) have a shared MCData Payload Protection Key (DPPK). This shall be the CSK, SPK, MuSiK, GMK or PCK depending on the payload that will be protected. The DPPK will also have a shared key identifier, the DPPK-ID. This shall be the CSK-ID, MuSiK-ID, SPK-ID, GMK-ID or PCK-ID respectively, based upon the type of key used.\nThe prequisites for authentication of an authenticated payload is that the MC client will have been keyed (SSK, PVT and KPAK) by a KMS as defined in clause 5.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "8.5.3\tKey derivation for protected payloads",
                            "text_content": "Before protecting an MCData payload, the DPPK is hashed through a KDF (similar to the process used for XML protection for application signalling), to produce a MCData Payload Cipher Key (DPCK). The KDF is defined in Annex F.1.5.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "8.5.4\tPayload protection",
                            "text_content": "All protected payloads shall have the format defined in table 8.5.4.1-1:\nTable 8.5.4.1-1: MCData Protected Payload message content\n\nWhere ‘Payload' will be the encrypted and integrity-protected payload encoded in a binary format.\nNOTE 1:\tDate and Time is included as plaintext to allow the MCData server to order end-to-end protected messages and assess whether end-to-end protected messages may have expired.\nNOTE 2:\tPayload ID and Payload sequence number allow protected payloads to be split over multiple SIP messages.\nNOTE 3:\tWhen file is distributed using HTTP, MCData Protected Payload message is distributed as part of protected FD Signalling Payload and the protected binary data representing the file is uploaded using HTTP.\nNOTE 4\tThis information element applies only to off-network communications. It is optionally included, for example, when the originating client does not have an active PCK for the terminating client.\nNOTE 5\tThis field applies to the protection of the data payload field.\nNOTE 6\tThis field applies to the protection of the MCData signalling parameters field, Data signalling payload field, and End to end security parameters fields. This field defaults to DP_AES_128_GCM (as defined in clause 8.5.4.2) if not present.\nProtection of payloads shall support the following algorithms (cipher suites):\nTable 8.5.4.2-1: DP_AES_128_GCM algorithm parameters\n\nTable 8.5.4.2-2: DP_AES_256_GCM algorithm parameters\n\nIn using the above cipher suites as defined in RFC 5116 [43], the plaintext, P, shall be the full original plaintext payload. The associate data (AD) shall be the Message Type, Date and Time, Payload ID, Payload sequence number, Algorithm, IV, and DPPK-ID fields within the MCData Protected Payload message content defined in clause 8.5.4.1.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 8.5.4.1-1: MCData Protected Payload message content",
                                    "table number": 2,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 8.5.4.2-1: DP_AES_128_GCM algorithm parameters",
                                    "table number": 3,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 8.5.4.2-2: DP_AES_256_GCM algorithm parameters",
                                    "table number": 4,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "8.5.5\tPayload authentication",
                            "text_content": "Authenticated payloads shall have the format defined in table 8.5.5-1:\nTable 8.5.5-1: MCData Authenticated Payload message content\n\nThe signature shall be on the entire payload excluding the value of the signature element. However, the type and length of the signature element shall be included in the signature. The signature value shall be encoded in binary format.\nThe ECCSI signature algorithm as defined in RFC 6507 [9] shall be supported by MC clients.\nThe contents of the Signing Data field is determined by the signature algorithm. For ECCSI, the signing data shall be as defined in table 8.5.5-2:\nTable 8.5.5-2: ECCSI Signing Data content\n\nAfter signature vertification, the verifier shall extract the sender's URI from elsewhere in the message and check that this corresponds to the UID contained in the Signing UID field above. If not, signature verification shall have failed.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 8.5.5-1: MCData Authenticated Payload message content",
                                    "table number": 5,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table 8.5.5-2: ECCSI Signing Data content",
                                    "table number": 6,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "8.6\tMCData message store security",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "8.6.0\tFunctional model",
                            "text_content": "The functional model for the MCData message store is shown in figure 8.6.0-1.\nThe figure depicts a functional model of the MCData message store in a 6.0-1.0 communication system. It illustrates the data flow and communication between the message store and the network, highlighting the use of message queues and message passing. The model is designed to ensure efficient data storage and retrieval, with a focus on minimizing latency and ensuring data integrity.\nFigure 8.6.0-1: MCData message store functional model\nIn the functional model shown in figure 8.6.0-1, the reference points MCData-7 and MCData-8 provide direct communications with the MCData message store from the MCData UE message store client and the MCData server capabilities function, respectively.  Reference point(s) MCData-cap-n provide MCData message store functionality between the MCData client capabilities function and the MCData message store via the MCData server capabilities function.  Security for the MCData message store reference points are described in clause 8.6.1.\nHTTP requests from the MCData message store client to the MCData message store shall include an appropriately scoped access token for MCData.  If the access token cannot be validated by the MCData message store, the HTTP request shall be rejected.  To validate access tokens, the MCData message store shall validate the signature of the access token.  The method used to provision the MCData message store with the IdMS signature validation credentials is out of scope of this document.\nThe MCData message store may be configured with an authorized MCData server list and the MCData server may be configured with an authorized MCData message store server list. When supported, the authorized MCData server list in the MCData message store contains the allowed public service identities of MCData servers of the MC service provider for the MCData Client.\nNOTE: Handling (creating and revocation) of the lists is out of scope of the present document and left to implementation.\nHTTP requests from the MCData capabilities function client to the MCData server capabilities function shall include an appropriately scoped access token for MCData.  If the access token cannot be validated by the MCData server, the HTTP request shall be rejected.\nIf required by the MC domain operator, data and information stored at the MCData message store related to the SDS, FS or DS services shall be stored protected.  The mechanism used to protect the data and information while not actively in use is out of scope of this document.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "8.6.1\tMCData message store reference points",
                            "text_content": "The MCData-7 reference point exists between the Message store client and the MCData message store and is used by the Message store client as defined in 3GPP TS 23.282 [38].\nFor HTTP messaging on the MCData-7 reference point, HTTPS as defined in clause 6.1.2 shall be used.\nFor SIP messaging on the MCData-7 reference point, SIP interface protection mechanisms as defined in clause 6.2.2 shall be used.\nThe MCData-8 reference point, which exists between the MCData server and the MCData message store, is used by the MCData server as defined in 3GPP TS 23.282 [38].  Reference point MCData-8 shall be a direct connection between the MCData server and the MCData message store, i.e. MCData-8 does not pass through the HTTP proxy for HTTP messaging.\nFor HTTP messaging on the MCData-8 reference point, HTTPS as defined in clause 6.1.2 shall be used.\nFor SIP messaging on the MCData-8 reference point, SIP interface protection mechanisms as defined in clause 6.2.2 shall be used.\nThe MCData-cap-n reference point(s) support varying functionality depending on the capabilities function (i.e. SDS, FS or SD) as described in 3GPP TS 23.282 [38].\nIf HTTP messaging is used on the specified MCData-cap-n reference point, HTTPS as defined in clause 6.1.2 shall be used.\nIf SIP messaging is used on the specified MCData-cap-n reference point, SIP protection mechanisms as defined in clause 6.2.2 shall be used.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "9\tSignalling protection",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "9.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "Signalling between entities in the MC System are defined as:\n-\tRTCP signalling (e.g. floor control),\n-\tXML signalling (within SIP messages) , or\n-\tMCData Data signalling (withing SIP or MSRP messages).\nTo allow this signalling to be protected, key distribution mechanisms are required to distribute the associated keys.\nFor protecting signalling between the client and the server, there are two key distribution mechanisms:\n-\t'CSK upload' procedure (as defined in clause 5.4).\n-\t'Key download' procedure (as defined in clause 5.8).\nFor protecting signalling between MCX Servers, there is one key distribution mechanism:\n-\tmanual SPK configuration (as defined in clause 5.5).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "9.2\tKey distribution for signalling protection",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "9.2.1\tClient-Server Key (CSK)",
                            "text_content": "A Client-Server Key is required to protect unicast RTCP signalling between the MC client and the MCX Server. The use of the CSK in this context is defined in clause 9.4.\nAdditionally, the MC Service provider may require that MC identities, access tokens and other sensitive information transferred between clients and MC domain on the SIP-1 and SIP-2 interfaces be protected at the application layer from any viewing, including protection from viewing at the SIP signalling layer. Symmetric key based protection of SIP payload using CSK may be used to satisfy this requirement. The use of CSK in this context is defined in clause 9.3.\nThe uses of the CSK are shown in Figure 9.2.1-1.\n\nThe figure depicts the client-server key used in the context of a client-server architecture, illustrating its importance in maintaining secure communication between the client and server. The key is a cryptographic element that ensures the confidentiality and integrity of data exchanged between the two parties. It is used to encrypt and decrypt messages, preventing unauthorized access and ensuring the integrity of the data. The figure also highlights the use of the RSA algorithm for encryption and decryption, which is a widely-used method in the field of cryptography.\nFigure 9.2.1-1: Uses of the Client-Server Key\nThe 128-bit CSK is initially generated by the client and provided encrypted to the server through the SIP interface along with the CSK-ID identifying the CSK.\nThe key remains in use until: a new CSK is required, the SIP session is torn down, the MC user logs off, or some other indication. If during the active SIP session an update of the CSK is required, the server generates a CSK and provides it to the client using the mechanism defined in clause 5.8.\nThe CSK is initially distributed via the 'CSK upload' procedure as defined in clause 5.4. The 'CSK upload' procedure creates a security association between the MC client and the MCX Server and occurs during the client's initial connection with the MC Server.\nThe following steps describe how the client obtains the user specific key material and securely transfers the CSK to a server within the MC domain.\nPrior to beginning of this procedure, the client would have obtained user-specific key material from the KMS.\n1)\tThe client randomly generates the CSK and encapsulates the CSK as described in clause 5.4.\n2)\tThe client includes the encapsulated CSK in its initial SIP REGISTER or in a SIP PUBLISH message that is used to perform the MC user authorization procedure, and sends the SIP message addressed to the PSI of the server.\nAn illustration is provided below as an example of how this message in included in the body of the SIP REGISTER message. The MIME media type \"application/mikey\" IETF RFC 3830 [22] is used in this example to insert a MIKEY I_MESSAGE in the SIP payload:\nEXAMPLE:\nREGISTER _Server_PSI SIP/2.0\nVia: SIP/2.0/UDP den3.level3.com\nMax-Forwards:70\nFrom: MCPTT client IMPU\nTo:\nCall-ID: <>\nCSeq:  1 REGISTER\nContact: <URI>\nContent-Type: multipart/mixed;boundary=\"boundary1\"\nContent-Length: 619\n\n--boundary1\nContent-Type: application/mikey\nMIKEY I_MESSAGE\n--boundary1\nContent-Type: application/...\nEncrypted Access token, MCPTT ID\n--boundary1—\n\nThe following steps describe how the MCX Server retrieves the CSK from the SIP message:\n1)\tThe server receives the SIP message and decrypts the encapsulated the CSK as described in clause 5.4.\n2)\tOnce the CSK has been extracted, MC user specific information (e.g. the access token) protected in the SIP message as defined in clause 9.3.4, may be decrypted.\nThe MCX Server may decide to update an existing CSK at any time. This may be due to CSK revocation or expiry.\nThe CSK shall be updated by the MCX Server using the 'key download' procedure, defined in clause 5.8. Upon receipt of a CSK via a 'key download' procedure, the MC client shall identify the type of key as a CSK via the 4 most significant bits of the CSK-ID. The MC client shall:\n-\tdiscard any previous CSKs associated with the MC Server FQDN, and\n-\tuse the new CSK for uplink signaling with the MC Server.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.2.2\tMulticast Signalling Key (MuSiK)",
                            "text_content": "The Multicast Signalling Key (MuSiK) is required to protect multicast RTCP signalling from the MCX Server to the MC client. This includes MBMS floor control, media control and transmission control messages.\nThe MuSiK shall be distributed using the ‘key download' procedure.\nA ‘key download' procedure is described in clause 5.8.\nThe use of the MuSiK is shown in Figure 9.2.2-1.\nThe figure depicts a diagram illustrating the various uses of the Multicast Signalling Key (MuSiK) in a 5G network. The MuSiK is a key component in the 5G network, enabling efficient and reliable communication between base stations (BSs) and users. It is used to establish and maintain reliable communication links, ensuring high-quality service for users. The MuSiK is a key part of the 5G network architecture, and its use is crucial for the seamless operation of the network.\nFigure 9.2.2-1: Uses of the Multicast Signalling Key (MuSiK)\nThe MCX Server distributes the Multicast Signalling Key (MuSiK) to a client when:\n-\tThe MCX Server requires protected signalling over the MBMS bearer to the MC client.  In this case, an initial MuSiK (MuSiKAll) is distributed to the client using the key download procedure. By default, this MuSiK is used to protect all multicast signalling excluding bearer announcement messages.\n-\tThe MCX Server requires the transmission of group-related signalling (e.g. media control or floor control) over an MBMS bearer to the MC client, and the group configuration indicates that cryptographic protection is required for multicast group signalling. In this case, a new MuSiK (MuSiKGRP) is created, assigned to the group and distributed to Group clients using the key download procedure. -\tThe MCX Server requires an existing MuSiK to be replaced. This may be due to revocation or expiry.\n-    A participating UE (MC client) of the multicast group roams into the MBMS bearer coverage area.\nNOTE:\tThe participating MCX Server could use a single MuSiK for its MCX Groups and MBMS bearers. Where a MCX Group or MBMS bearer has privacy requirements, these procedures allow a new MuSiK to be distributed specifically for that purpose. A new MuSiK may not need to be distributed before each new bearer is established.\nUpon receipt of a MuSiK the MC client shall store the MuSiK and MuSiK-ID. Should the MuSiK be rejected by the MC client, the MCX Server shall only use a unicast bearer when distributing signalling to the MC client.\nUpon receipt of group-related signalling (e.g. media control or floor control)  in the form of multicast SRTCP, the MC client shall inspect the MKI of the SRTCP packet which shall contain the MuSiK-ID. The MuSiK-ID shall be used to lookup the correct MuSiK for decrypting the SRTCP packet.Upon receipt of multicast MCData Data Signalling payloads, the MC client shall inspect the DPPK-ID element of the payload and extract the MuSiK-ID. The MuSiK-ID shall be used to lookup the correct MuSiK for decrypting the payload.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.2.3\tSignalling Protection Key (SPK)",
                            "text_content": "The SPK is used to protect communications between MCX Servers. The SPK is distributed as defined in clause 5.5. The uses of the SPK for inter-server protection are shown in Figure 9.2.3-1.\nThe figure depicts the various uses of the Signalling Protection Key (SPK) in a 5G network, highlighting its importance in ensuring signal integrity and preventing signal interference.\nFigure 9.2.3-1: Uses of the Signalling Protection Key\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "9.3\tApplication signalling security (XML protection)",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "9.3.1\tGeneral",
                            "text_content": "Certain values, keys and identifiers transferred in XML between a server in the MC domain and client may be treated as sensitive by public safety users and may require protection. To protect these values from all other entities outside of the MC Domain, this clause defines an optional mechanism to provide confidentiality protection on these values using XML encryption. Additionally, as some public safety users may require integrity protection on transmitted content, this clause defines an optional mechanism to provide integrity protection using XML signatures.\nNOTE 1:\tThe protection mechanism specified in this clause is for public-safety use only.\nNOTE 2:\tThe introduction of XML security mechanisms increases the size of the XML document. Consideration should be given to the impact of this size increase.\nEditor's Note: It needs to be confirmed that the virtual proxy techniques being studied in SA3-LI (LIV8 S8HR study) can be extended to control use of MCPTT encryption in VPLMN roaming scenarios.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.3.2\tProtected content",
                            "text_content": "Confidentiality protection may be applied to the entire XML document or to the following individual identifiers and values:\n-\tMCX service user ID (e.g. MCPTT ID, MCData ID, MCVideo ID).\n-\tMCX Group ID.\n-\tUser location information.\n-\tAlerts.\n-\tAccess token.\n-\tKMS provisioned key material.\n-\tFunctional aliases.\nNOTE 1:\tThe use of functional aliases for mission critical communications is defined in clause 5.9a of 22.280 [47] and may be included as part of MCPTT communications call setup and signaling as described in 23.379 [2].\nWhere confidentiality protection is applied to the entire XML document, the 'type' of message shall be clearly stated within the EncryptedData payload. The name shall reflect the names used in the message flows defined in TS 23.379 [2], TS 23.280 [36], TS 23.281 [37] and TS 23.282 [38]. This will allow the serving network to understand how their network is being used.\nNOTE 2:\tWhere the MCPTT Server is supporting legacy clients, these clients may not support confidentiality protection of the entire XML document. In this case, only individual identifiers and values should be confidentiality protected.\nIntegrity protection may be applied to the entire XML document, and to individual KMS certificates.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.3.3\tKey agreement",
                            "text_content": "The confidentiality and integrity protection mechanisms defined in F.1.4 rely on a shared XML Protection Key (XPK) to be able to encrypt and sign XML.\nFor connections between the client and the MC Domain, the XPK shall be the 128-bit shared Client-Server Key (CSK) established as defined in clause 9.2.1. The XPK-ID shall be the CSK-ID.\nFor connections between servers inside and across MC Domains the XPK shall be the 128-bit manually provisioned Signalling Protection Key (SPK) established as defined in clause 9.2.3. The XPK-ID shall be the SPK-ID\nFor connections between the KMS and the MC KM client (as described in clause 5.3.3), confidentiality protection shall use the 256-bit TrK as the XPK and the TrK-ID as the XPK-ID.   Integrity protection shall use the InK as the XPK and the XPK-ID shall be the InK-ID.\nThe integrity key and confidentiality key for application data protection shall be derived from the XPK as defined in annex F.1.4. The XPK-ID may be listed in the XML to aid decryption.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.3.4\tConfidentiality protection using XML encryption (xmlenc)",
                            "text_content": "This clause defines an optional mechanism to allow specific XML content within the XML elements and XML URI attributes to be encrypted between the client and the server.\nNOTE:\tEncryption of XML element content according to XML Encryption Syntax [27] and XML URI attribute encryption according to clause 9.3.4.3 is supported.\nXML content within XML elements is encrypted as defined by XML Encryption Syntax, Version 1.1 [27].\nTo encrypt content within a specific XML element, the content shall be replaced with the <EncryptedData> element. The <EncryptedData> element shall contain a <CipherData> element, containing a <CipherValue> element containing the encrypted content. Encryption shall be performed as defined in [27] using the CSK as the cipher key.\nWhere protecting content, the <EncryptedData> element may:\n-\tUse the 'Type' attribute specifying that content is encrypted ('http://www.w3.org/2001/04/xmlenc#Content').\n-\tContain <KeyData><KeyInfo> element containing the base64 encoded XPK-ID.\n-\tContain <EncryptionMethod> element listing the encryption algorithm used for encrypting the XML content. The AES-128-GCM algorithm shall be supported, as identified by the algorithm identifier: 'http://www.w3.org/2009/xmlenc11#aes128-gcm'.\nWhere protecting key material, the <EncryptedData> element may:\n-\tUse the 'Type' attribute specifying that content is encrypted ('http://www.w3.org/2001/04/xmlenc# EncryptedKey').\n-\tContain <KeyData><KeyInfo> element containing the base64 encoded XPK-ID.\n-\tContain <EncryptionMethod> element listing the encryption algorithm used for encrypting the XML key material. The AES-256 key wrap algorithm as defined in RFC 3394 [34] shall be supported, as identified by the algorithm identifier 'http://www.w3.org/2001/04/xmlenc#kw-aes256'.\nWhere these elements do not occur, the information they contain shall be known to both the client and server in the MC domain through other means.\nThe following is an example of unprotected XML content:\nEXAMPLE:\n<ExampleTag xsd:type=\"Normal\">\nsensitive.data@example.org\n</ExampleTag>\n\nWhen XML encryption is applied, the following is an example of the encrypted content:\nEXAMPLE:\n<ExampleTag xsd:type=\"Encrypted\">\n<EncryptedData xmlns='http://www.w3.org/2001/04/xmlenc#'\nType='http://www.w3.org/2001/04/xmlenc#Content'>\n<EncryptionMethod Algorithm=\"http://www.w3.org/2009/xmlenc11#aes128-gcm\"/>\n<ds:KeyInfo>\n<ds:KeyName>base64XpkId</KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>A23B45C56</CipherValue>\n</CipherData>\n</EncryptedData>\n</ExampleTag>\n\nXML attribute encryption shall be performed by encrypting the URI and embeddeding the encrypted ciphertext within a new URI.  The appended domain name of the new URI identifies the attribute as having confidentiality protection. Encryption shall be performed using the AES-128-GCM [42], as the encryption algorithm, XPK as the key, and the use of a 96 bit randomly selected IV.\nThe output URI is structured to contain:\n-\tthe base64 encoded encrypted URI;\n-\tthe string \";iv=\" followed by the base64 encoded 96-bit random initialisation vector (IV) which is used by the AES-128 encryption algorithm (as described in TS 33.203 subclause 6.4).\n-\tthe string \";key-id=\" followed by the base64 encoded encryption key identifier (XPK-ID);\n-\tthe string \";alg=\" followed by the encryption algorithm identifier (128-bit encryption algorithm \"128-AES-GCM\");\n-\tthe appended domain name of the new URI e.g. “@mc1-encryption.3gppnetwork.org”.\nAn example of the resultant sip-uri after encryption is:\nsip:98yudFG45tx_89TYGedb4ujF;iv=FGD567kjhfH7d4-D;key-id=eV9kl7;alg=128-aes-gcm@mc1-encryption.3gppnetwork.org\nThe following is an example of unprotected XML URI content within XML attributes:\nEXAMPLE:\nContent-Type: application/pidf+xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<presence entity=\"sip:somebody@mcptt.org\">\n<tuple id=\"acD4rhU87bK\">\n<status>\n<affiliation group=\"sip:thegroup@mcptt.org\" />\n</status>\n</tuple>\n</presence>\n\nWhen XML URI attribute encryption is applied, the following is an example of encrypted URIs within XML attributes:\nEXAMPLE:\nContent-Type: application/pidf+xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<presence entity=\"sip:c4Hrt45XG8IohRFT67vfdr3V;iv=45RtfVgHY23k8Ihy;key-id=b7UJv9;alg=128-aes-gcm@mc1-encryption.3gppnetwork.org\">\n<tuple id=\"acD4rhU87bK\">\n<status>\n<affiliation group=\"sip:98yudFG45tx_89TYGedb4ujF ;iv=FGD567kjhfH7d4-D;key-id=eV9kl7;alg=128-aes-gcm@mc1-encryption.3gppnetwork.org \" />\n</status>\n</tuple>\n</presence>\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.3.5\tIntegrity protection using XML signature (xmlsig)",
                            "text_content": "Where integrity protection is required, an XML HMAC signature may be applied using the XPK to key the HMAC to a whole XML MIME body.\nThe XML HMAC signature mechanism is specified by W3C [28]. The HMAC-SHA256 signature method shall be supported.\nWhen integrity protection is enabled, all XML MIME bodies transported in SIP requests and responses are integrity protected.  If one or more of the XML MIME bodies are included in a SIP request or SIP response, then a MIME body is included in the SIP request or SIP response containing one or more signatures pointing to those XML MIME bodies as illustrated in the figure 9.3.5-1.\nIn order to integrity protect the XML MIME bodies in SIP requests and SIP responses, the MC client and MCX server shall for each MIME body, include the Content-ID header field as specified in IETF RFC 2045 [40] containing a Content-ID (\"cid\") Uniform Resource Locator (URL) as specified in IETF RFC 2392 [41].\nThe figure depicts the integrity protection of XML MIME bodies in SIP requests and SIP responses, highlighting the use of XML-based security protocols to ensure the integrity of the data being transmitted.\nFigure 9.3.5-1: Integrity Protection of XML MIME bodies in SIP requests and SIP responses\nEach MIME body that is integrity protected is assigned a unique signature contained in a <Signature> element.\nThe <Signature> element shall contain the following child element:\n<SignatureValue> HMAC signature of the content\nThe <Signature> element may contain the following child elements:\n-\t<CanonicalizationMethod> element listing an appropriate algorithm.\n-\t<SignatureMethod> element listing an appropriate algorithm. HMAC-SHA256 shall be supported for signatures.\n-\t<KeyInfo><KeyName> element containing the base64 encoded XPK-ID.\n-\t<Reference> element containing a URI identifying the content to be signed and the method for hashing the content. SHA-256 shall be supported for hashing content.\nWhere these elements do not occur, the information they contain shall be known to both the client and server in the MC domain through other means.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "9.4\tRTCP signalling protection (SRTCP)",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "9.4.1\tGeneral",
                            "text_content": "RTCP encryption is required between the MC UE and MCX Server and between a pair of MCX Servers. RTCP is protected hop-by-hop, meaning that RTCP is always decrypted by the MCX server and then re-encrypted to its destination.\nThe following signalling uses RTCP and is protected using the procedures in this clause:\n-\tMCPTT floor control signalling (MBCP or TBCP).\n-\tUnicast uplink and downlink (online), multicast downlink (online) and off-network transmission.\n-\tMCVideo transmission control (online/off-network).\n-\tUnicast uplink and downlink (online), multicast downlink (online) and off-network transmission.\n-\tMCPTT/MCVideo media signalling.\n-\tUnicast uplink and downlink (online), multicast downlink (online) and off-network transmission.\n-\tMBMS subchannel control signalling (from MCX Server to MC UE).\n-\tmulticast downlink (online).\nAll RTCP (floor control, media control and MBMS subchannel control signalling) is protected in the same way. RTCP is protected using SRTCP. The master key for SRTCP is derived from a Key For Control signalling (KFC). The KFC is shared between the transmitter and receiver(s) prior to distribution of the SRTCP packets. A 32-bit identifier for the key (KFC-ID) and a 128-bit random value (KFC-RAND) is also established.\nThere are a number of key distribution mechanisms for establishing the KFC based on the interface over which RTCP is being transmitted.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.4.2\tUnicast RTCP protection between client and server",
                            "text_content": "In Clause 9.2.1, a Client-Server Key (CSK) is generated and shared between the MC client and MCX Server along with the CSK identifier (CSK-ID). For floor and media control, the KFC shall be the CSK and the KFC-ID shall be the CSK-ID. KFC-RAND shall be the MIKEY RAND value transmitted in the MIKEY message used to distribute the CSK.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.4.3\tMulticast RTCP protection between client and server",
                            "text_content": "In clause 9.2.2, a Multicast Signalling Key (MuSiK) is generated and shared from the MCX Server to the MC client, along with the MuSiK identifier (MuSiK-ID). For the protection of multicast floor and media control, the KFC shall be the MuSiK and the KFC-ID shall be the MuSiK-ID. KFC-RAND shall be the MIKEY RAND value transmitted in the MIKEY message used to distribute the MuSiK.\nTo support multicast signalling protection, the MSCCK and the legacy MKFCs may also be used for this purpose as defined in Annex H.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.4.4\tOff-network floor and transmission control protection",
                            "text_content": "Off-network, the KFC is the PCK (for private communications) or the GMK (for group communications) as described in clause 7.3.4, and the KFC-ID is the PCK-ID or GMK-ID (respectively).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.4.5\tRTCP protection between servers",
                            "text_content": "In Clause 9.2.3, a Signalling Protection Key (SPK) is shared between MCX Servers along with a SPK-ID. For floor and media control signalling transferred between MCX Servers, the KFC shall be the SPK, the KFC-ID shall be the SPK-ID and the KFC-RAND shall be the SPK-RAND.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.4.6\tKey derivation for SRTCP",
                            "text_content": "As a result of the key agreement process, the entities (MCX client and server, or MCX servers) shall share a KFC, a KFC-ID and a KFC-RAND. The KFC shall be used as the MIKEY Traffic Generating Key (TGK), the KFC-ID shall be used as the MIKEY CSB ID and the KFC-RAND shall be used as the MIKEY RAND value. The MIKEY CS-ID shall be set as defined in table E.1.3-1. These shall be used to generate the SRTCP Master Key and SRTCP Master Salt as specified in IETF RFC 3830 [22]. The key derivation function defined in section 4.1.3 of IETF RFC 3830 [22] using the PRF-HMAC-SHA-256 Pseudo-Random Function described in section 6.1 of IETF RFC 6043 [25], shall be supported for generating the SRTCP Master Key and Salt. SRTCP session keys are generated from the SRTCP Master Key and Salt as defined in clause 9.4.8.\nNOTE:\tWithin RFC 3830 [22], the SRTCP Master Key and SRTCP Master Salt are referred to as the SRTP Master Key and the SRTP Master salt respectively.\nThe figure depicts a key derivation for on-network floor and media control protection, illustrating the process of creating a secure and reliable communication network.\nFigure 9.4.6-1: Key derivation for on-network floor and media control protection\nTo identify the security context from the SRTCP stream a SRTCP Master Key Identifier (MKI) is required. The MKI shall be the 32-bit KFC-ID.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.4.7\tSecurity procedures for transmission of RTCP content",
                            "text_content": "After key establishment, RTCP protection does not require any signalling mechanism to convey information. The RTCP is protected within an SRTCP packet. The information necessary for decryption is provided within each SRTCP Packet.\nThe figure depicts a security procedure for media stream protection, illustrating the steps taken to ensure the integrity and confidentiality of media streams. The diagram includes a series of steps, such as encryption, authentication, and access control, which are crucial for safeguarding sensitive information. The use of color-coded arrows and labels helps to visually represent the flow of information and the sequence of actions, making it easier to understand and follow the procedure.\nFigure 9.4.7-1: Security procedure for media stream protection\nFigure 9.4.7-1 shows the security mechanism.\n0)\tPrior to beginning this procedure the MC entities (MC UEs and/or MCX Server) involved in the communication shall have established a security context for SRTCP (Master Key, Master Salt, MKI).\n1)\tThe transmitting entity (MC UE or MCX Server) shall send SRTCP packets using the format described in IETF RFC 3711 [13]. The packet shall include a Master Key Identifier (MKI) field which contains the information required to locate the Master Key and Master Salt. On receipt of a SRTCP packet, a terminating entity (MC UE or MCX Server) shall use the contents of the MKI to look up the appropriate Master Key and Salt and generate the appropriate SRTCP session key and salt if it satisfies the key derivation rate criteria as specified in IETF RFC 3711 [13].\nNOTE 1:\tAssuming entities have been keyed/pre-provisioned at some point in the past, this security mechanism is entirely stateless.\nNOTE 2:\tThe receiver does not need to generate an appropriate SRTCP session key and salt each time it receives a SRTCP packet. The key derivation rate defined in IETF RFC 3711 [13] determines the session key generation frequency. Refer to RFC 3711 [13] for more information.\nA diagram of the SRTCP packet format is within figure 9.4.7-2.\nThe figure depicts a SRTCP packet format, which is used to describe security parameters in a 4.7-2 SRTCP (Security-Related Transport Control Protocol) packet. The packet format includes information about the security parameters such as the security level, encryption method, and authentication method. The figure provides a visual representation of the packet format, making it easier to understand the security parameters and their implications for network security.\nFigure 9.4.7-2: SRTCP packet format showing security parameters\nThe length of the MKI is determined by the key distribution mechanism.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.4.8\tRTCP protection profile",
                            "text_content": "Integrity and confidentiality protection for communications using RTCP for floor control, transmission control, and media control is achieved using SRTCP, as defined in IETF RFC 3711 [13]. The mechanism described in IETF RFC 3711 [13] is used to encrypt the RTCP payload. A diagram of the key derivation mechanism (as described in IETF RFC 3711 [13]) is shown in figure 9.4.8-1.\nThe figure depicts a security mechanism for floor control, transmission control, and media control protection in a building. It illustrates the various components and their interconnections, highlighting the importance of proper security measures in ensuring the safety and functionality of the building's infrastructure.\nFigure 9.4.8-1: Security mechanism for floor control, transmission control, and media control protection\nThe AES-CM-128 algorithm as defined in IETF RFC 3711 [13] shall be supported as the SRTCP PRF (which is used to derive the SRTCP session key and salt). A SRTP key derivation rate of 0 shall be used to indicate that session keys and salts shall not be refreshed. The AEAD_AES_128_GCM algorithm as defined in IETF RFC 7714 [26] shall be supported for providing confidentiality and data authentication of SRTCP packets. The AEAD_AES_128_GCM algorithm requires that the SRTCP session key is 16 octets in length and the session salt is 12 octets in length.\nNOTE:\tSome SRTCP implementations are not compliant with RFC 3711 due to the size of the SRTCP index, as discussed in RFC 3711 Errata ID 3712 [51].\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "9.5\tMCData signalling protection",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "9.5.1\tKey distribution for signalling protection",
                            "text_content": "Where MCData signalling parameters or MCData Data signalling payload protection is required, key distribution and key use for MCData signalling is equivalent to MCPTT and MCVideo. MCData signalling parameters or MCData Data signalling payload protection is defined in subclause 8.2.\nThe procedures for CSK distribution are defined in clause 9.2.1. The procudures for MuSiK distribution are defined in clause 9.2.2. The procedures for SPK distribution are defined in clause 9.2.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.5.2\tProtection of MCData application signalling payloads (XML)",
                            "text_content": "Protection of MCData application signalling payloads, specifically XML content within SIP messages, is defined in clause 9.3. For the protection of MCData signalling, the XPK shall be the DPPK.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.5.3\tProtection of MCData signalling payloads",
                            "text_content": "Protection of MCData Data signalling payloads is defined in clause 8.5.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "9.6\tMessage origin authentication and authorisation",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "9.6.1\tGeneral",
                            "text_content": "The MC System allows authorised service requests where the 'requester' may cause modification to the operation of the MC Domain service or initiate an action on a target MC client, potentially without that client's permission.\nClauses 9.3 and 9.5 describe how on-network application signalling is protected hop-by-hop within the MC System. In an MC Domain which is interconnected or supporting migration, application signalling may pass through multiple MCX Servers from the requester to the target client. Using hop-by-hop signalling security alone, the target's MCX Server and the target's client would be unable to authenticate the identity of the requester, or whether the requester has permission to perform the action. This leaves the MC domain and MC client open to attack via misuse of signalling requests along the signalling path.\nFor example:\na)\tA 'Group Affiliation Status Update' could originate from a MCX Server in a different domain to the Group Management Server. In this case the GMS requires information to ensure that the MCX Server has permission to modify the affiliation status of the requested user.\nb)\tAn 'Ambient Listening Request' could originate from a different domain to the target user. The target's MCPTT Server requires information to ensure that the originator is permitted to make the request.\nc)\tAn off-network 'Call Setup Request'. The target client requires information to ensure that the originator is permitted to make the request prior to responding to the request.\nThe subsequent clauses define an optional Element for Authenticating Requests (EAR), which is a signed element which may be attached to signalling requests across the MC System, both on and off-network. Where authorisation information is required to support the request, the requesting MC entity may use an Authorised Identity to sign the request.\nThe EAR allows an MC client or MC network entity to verify the origin, target and purpose of a signalling request, and that the origin is authorised to make such a request. In the network, authorisation is given by the profiles within the Configuration Management Server (CMS) and enforced by the MCX Server. The EAR allows authorisation to also be verified at the client, based on the contents of the EAR. EAR authorisations are provided by the the IdM to MC user (via the KMS).\nWith the EAR mechanism enabled, permission to use privileged signalling (e.g. Ambient Listening) needs to be enabled by both the IdM and the CMS. This allows a duel-check approach where the requesting user's permission is verified by both the network (based on the user's profile in the CMS) and the target client (based on the requesting user's Authorised Identity).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.6.2\tOrigin authentication and authorisation in the MC System",
                            "text_content": "The purpose of authentication is to provide evidence to the receiver on the identity of the requester. The purpose of authorisation is to convey to the receiver that the requester has permission to take an action. In the MC System, MC client authentication and authorisation is primarily managed by the client's MCX Server. The MCX Server uses the access token and CSK to authenticate the user's MC client, and the user configuration to authorise the user's MC client. However, local authentication and authorisation may be insufficient where the user or signalling is moving across domains.\nThe additional authentication and authorisation mechanisms defined in Clause 9.6 may be attached to any signalling messages in the MC system, but in some specific cases, the mechanisms should be used. The following situations describe where the mechanisms defined in Clause 9.6 should be used in the MC system:\nCase 1:\tPrivileged signalling sent within the MC System (e.g. Ambient listening request): Authentication should be provided by an EAR using an authorised user identity (MC Service ID). This allows the target's MCX Server and MC client to assess whether the request is authorised.\nNOTE 1: Privileged signalling is signalling which allows one client to remotely cause an intrusive action on a target client without the target user's permission.\nCase 2:\tSignalling between network entities in separate MC domains (e.g. group call request from partner MCPTT server to primary MCPTT server). Authentication should be provided by an EAR using an authorised server/domain identity. This allows the receiving MC domain to confirm the requesting entity is a MCPTT server from a known partner MC domain.\nCase 3:\tSignalling between a group client attached to a partner MC Domain and the Group Management Server. Authentication from the client to the server should be provided by an EAR using the user's identity (MC Service ID). Authentication from the server to the client should be provided by an EAR using an authorised server/domain identity.\nNOTE 2:\tAn authorised user identity is not required in this case as authorisation of the MC client is provided by the user configuration document.\nCase 4:\tSignalling between the home network and a home client who has migrated to a partner MC Domain. Authentication from the client to the server should be provided by an EAR using the user's identity (MC Service ID). Authentication from the server to the client should be provided by an EAR using an authorised server/domain identity.\nNOTE 3:\tAn authorised user identity is not required in this case as authorisation of the MC client is provided by the user configuration document.\nCase 5:\tOff-network signalling between MC clients. Authentication should be provided by an EAR using an authorised user identity (MC Service ID).\nWhere the request, containing a EAR, is routed via a MCX Server, the MCX Server should copy the EAR from the received request to the out-going request. Multiple EARs can be attached to a signalling message. For example, one EAR may be attached to authenticate the user making the request, and another may be attached to authenticate the domain sending the request on behalf of the user.\nAll Privileged Signalling sent within the network should be authenticated and authorised using a EAR signed using an Authorised Identity (MC Service ID). The following are privileged signalling requests which should be explicitly authenticated and authorised:\n-\tMCPTT Private call request in automatic commencement mode (TS 23.379).\n-\tMCPTT Ambient listening call request (TS 23.379).\n-\tMCPTT Remotely initiated MCPTT call request, in unnotified mode (TS 23.379).\n-\tMCVideo Private call request (including private call, video pull and video push) in automatic commencement mode (TS 23.281).\n-\tMCVideo Remote video push request in automatic commencement mode (TS 23.281).\n-\tMCVideo Ambient viewing call request (TS 23.281).\n-\tMCData standalone data request for application consumption (TS 23.282).\n-\tMCData standalone session data request for application consumption (TS 23.282).\n-\tMCData session data request for application consumption (TS 23.282).\n-\tMCData group standalone data request for application consumption (TS 23.282).\n-\tMCData group data request for application consumption (TS 23.282).\n-\tMCData FD request with mandatory indication (TS 23.282).\n-\tMCData group standalone FD request with mandatory indication (TS 23.282).\nWhere signalling is sent across domains, the servers used to send the signalling should be authenticated and authorised using a EAR signed using an Authorised Identity, indicating the server's role. within the MC domain. This ensures that only Group Management Servers are authorised to send group notifications, and only MCX servers are authorised to send key download messages. The following roles are used:\n-\tMCPTT Server\n-\tMCVideo Server\n-\tMCData Server\n-\tCS Proxy\n-\tIS Proxy\n-\tGroup Management Server\nThe IS Proxy is authorised to authenticate the functions of a MCPTT Server, MCVideo Server or MCData Server towards another MC domain. The CS proxy is authorised to authenticate the functions of a MCPTT Server, MCVideo Server or MCData Server towards a MC client. Consequently, the addition of EARs may be performed at the edge of the MC domain.\nWhere signalling is sent between the group management server and the group management client, the entity at each end should be authenticated and authorised using a EAR. The EAR from the GMS should be signed using an Authorised Identity, indicating the server is able to perform GMS functions. The GM client is not required to use an Authorised Identity. The following Group management messages should be explicitly authenticated and authorised:\n-\tSubscribe Group Configuration Request\n-\tSubscribe Group Configuration Response\n-\tNotify Group Configuration Request\n-\tNotify Group Configuration Response\n-\tMC Group affliation request\n-\tGroup affliation status update\nWhere signalling is sent out of the domain towards a migrated MC client, the servers used to send the outbound signalling should be authenticated and authorised using a EAR signed using an Authorised Identity, indicating the server's role. The server roles defined in Clause 9.6.2.3 shall be used.\nThe inbound signalling from the migrated client shall be authenticated and authorised using an EAR. The migrated MC client is not required to use an Authorised Identity.\nThis clause is applicable to all signalling sent to or from the migrated user.\nAll off-network signalling requests should be authenticated and authorised using a EAR signed using an Authorised Identity (MC Service ID). The client's role should be explicitly authorised. The following roles are used:\n-\tMCPTT client\n-\tMCVideo client\n-\tMCData client\nThe client should be authorised to use any off-network functionality. Furthermore, the following are the off-network signalling requests which the client should be authorised to use:\n-\tMCPTT Group call announcement (TS 23.379).\n-\tMCPTT emergency alert announcement (TS 23.379).\n-\tMCPTT Call setup request (TS 23.379).\n-\tMCVideo Group communication announcement (TS 23.281).\n-\tMCVideo emergency alert announcement (TS 23.281).\n-\tMCVideo Private communication request (TS 23.281).\n-\tMCVideo Capability request (TS 23.281).\n-\tMCVideo Activity request (TS 23.281).\n-\tMCData standalone data request (Clause 7.4.3.3.2, TS 23.282).\n-\tMCData group standalone data request (Clause 7.4.3.4.2, TS 23.282).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.6.3\tAuthorised Identities",
                            "text_content": "Authorisation is conveyed using the MC entity's identity (e.g. MC Service ID) that is used to sign the EAR. This is known as the user/entity's Authorised Identity.\nWithin an Authorised Identity, authorisation information is contained within a SIP URI Header (known as an MC authorisation field). Authorisation fields are added to the entity's identity to provide information on the MC entity's authorisations. Authorisation fields are name, value pairs. The value of the authorisation field provides a set of authorisations, formatted as a hexidecimal string. Authorisation fields are defined in Annex J.3.\nAuthorisation is originally requested and provided by the IdM. If authorisation is granted, the IdM provides the authorisation information within the scope of an access token. The scope values contained within the access token are defined in Clause J.3.3.\nThe access token is provided to the KMS as defined in Clause 5.1.\nThe KMS provisions the entity's keys to the entity as defined in Annex D. As part of the key provisioning process, the KMS may provision the entity keys for multiple SIP URIs that are associated with the entity.\nIf supported, where the scope of an access token contains one of the values defined in Clause J.3.3, the KMS provides multiple authorised identities which includes authorisation fields as part of the identity. Specifically, for each SIP URI associated with the entity, the KMS provisions:\n-\tKey material for the identity: the entity's identity (e.g. MC Service ID).\n-\tKey material for the Authorised Identity: the entity's identity with the applicable authorisation fields included.\nThe keyed entity may use either identity when signing within the MC System, (depending on whether it is configured to disclose its authorisations).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "9.6.4\tElement for Authenticating Requests (EARs)",
                            "text_content": "When sending a sensitive signalling message, the requester creates the message as normal, then constructs and attaches an EAR to the message. The EAR contains the purpose and constraints of the request (type of request, restrictions on request, origin, destination) and is signed by the requester using the private signing key for the authorised identity. When used correctly, the EAR should provide a definitive record of the ‘request' that was made, including evidence that the request was not disproportionate.\nThe EAR payload shall contain the following information elements:\nTable 9.6.4.2-1: Element for Authenticating Requests Payload\n\nThe EAR payload shall be signed using the approach defined in Clause 8.5.5. The signed payload is attached to signalling messages as an EAR.\nThe contents of an EAR are defined in Clause 9.6.4.2.\nTo add authorisation information to the EAR, the identity associated with the requester shall be an Authorised Identity. The identity-based signature used to sign the EAR will be an Authorised Identity. The receiver processes the Authorised Identity to extract the requester's authorisations, and confirms that the type of request within the EAR is permitted given the requester's authorisations.\nNOTE:\tThe only entity that could create the signature, and hence the whole EAR, is an entity granted the means to sign using Authorised Identity. The KMS provides the means to sign using a specific identity. By doing so, the KMS has provided authorisation to create the EAR signature and authorise the specific action.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 9.6.4.2-1: Element for Authenticating Requests Payload",
                                    "table number": 7,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "9.6.5\tSecurity procedures for origin authentication",
                            "text_content": "Signalling in the MC System may use Elements for Authenticating Requests (EARs) for communicating origin authentication to the receiving entities.\nA sender or processor of a SIP message may add an EAR to any SIP message to authenticate the origin of the message.\nTo add origin authentication to a SIP message, an application/vnd.3gpp.mc-signalling-ear MIME body is added to tbe message containing an EAR message as defined in Clause 9.6.4.2. Such requests are known as a \"Origin authenticated SIP message\".\nA SIP message may contain multiple application/vnd.3gpp.mc-signalling-ear MIME bodies.\nGroup affiliation signalling requires the EAR to be transferred by the MC Server from the client's request to the status update towards the GMS. The procedure is shown in Figure 9.6.5.2.2-1.\nThe figure depicts the MC service group affiliation procedure, which is a crucial step in the network management process. It illustrates the steps taken by the network operator to assign a service group to a specific MC, ensuring that the network is properly managed and maintained. The figure includes various components such as the MC service group, the network operator, and the network management system, all of which are essential for the successful execution of this procedure.\nFigure 9.6.5.2.2-1: MC service group affiliation procedure\nIn this procedure, an EAR should be attached to Step 1 and passed to the MC service server. The MC service server should copy the client's EAR into the Group affiliation status update message, transmitted by the MC service server to the GMS in Step 5b. The MC service server may also add an additional EAR authenticating the MC service server itself towards the GMS. On receipt of the EAR(s), the GMS has the necessary information to authorise the request to modify group affiliations.\nThe same procedures apply to the de-affiliation process. In this case, client EAR should be copied into the Group de-affiliation status update.\nAn EAR may be attached to any MONP signalling message to authenticate the origin of the message. The message then becomes an authenticated MONP message. Table 9.6.5.3-1 defines an authenticated MONP message.\nTable 9.6.5.3-1: Authenticated MONP message\n\nEARs may be processed by the receiver or routing network equipment to support an authentication and authorisation check on the signalling message. Clause 9.6.2 defines the types of requests where the EAR should be processed.\nIf supported by the receiver, upon receipt of a signalling message containing an EAR the receiver should:\n1)\tValidate the signature on the EAR based on the provided UID.\n2)\tValidate that the Target ID is associated with an apprpropriate user.\n3)\tCheck the date/time is within a recent window (e.g. 300 seconds) and the that a message with the EAR ID has not been already processed within that window.\n4)\tValidate that the Origin ID of the EAR produces the UID.\n5)\tIf the request requires authorisation, extract the authorisation fields from the Origin ID. Validate that the Request Type is authorised by the authorisation fields, and that the KMS URI in the signature is permitted to authorise this type of request.\n6)\tVerify that the Request Type corresponds to the SIP signalling message.\n7)\tVerify that the Request Type parameters are not exceeded by the SIP signalling message.\n8)\tProcess the SIP message as normal.\nIf EARs are not supported by the receiver, the EAR shall be ignored.\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 9.6.5.3-1: Authenticated MONP message",
                                    "table number": 8,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "title": "10\tLogging, Audit and Discreet Monitoring",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "10.1\tLogging and audit of service metadata",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "10.1.1\tOverview",
                            "text_content": "The MC system should generate service metadata. This may include system events, management events, security events and user events. The full range of events that may be logged by the MC system is out-of-scope of the current specification. Furthermore, the mechanism that is used to audit MC system metadata is also out-of-scope of the current specification.\nThis clause defines the security and communications-related data associated to user events that are required to enable the audit of MC user actions within the MC system. User event logs are required to support discreet monitoring or audit.\nTo ensure the privacy of MC users’ data, where this information is collected it shall be protected as defined in Clause 10.1.2.4.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "10.1.2\tUser events",
                            "text_content": "When user events are collected within the MC System, the following events (based on the deployed MC services) are recorded\nClass A:\tCommon signalling events. Sending or receiving a common signalling message as defined in TS 23.280 [36].\nClass B:\tMCPTT signalling events. Sending or receiving an MCPTT signalling message as defined in TS 23.379 [2].\nClass C:\tMCVideo signalling events. Sending or receiving an MCVideo signalling message as defined in TS 23.281 [37].\nClass D:\tMCData signalling events. Sending or receiving an MCData signalling message as defined in TS 23.282 [38].\nClass E:\tInterworking signalling events. Sending or receiving an Interworking signalling message as defined in TS 23.283 [48].\n\nSIP events may be recorded at the CS and IS Proxies and/or MCX Servers. Depending on the configuration of the MC system, the SIP events may also be recorded within the SIP core.\nHTTP events may be recorded at the HTTP Proxy(s).\nWhen a user event occurs, the following security-related information is required:\n-\tThe class and type of a user event\n-\tIP addresses (source and destination)\n-\tSignalling layer identifiers\n-\tSIP URI (source and destination).\n-\tHTTP target URL\n-\tThe initiating user or server\n-\tThe receiving user, group, server or [set of multicast users]\n-\tSecurity parameters (if present in signalling):\n-\tMIKEY message\n-\tAccess or Security Token\n-\tIdentifiers for related media bearers (if applicable).\nNOTE:\tThese logs are required to support disceet monitoring or audit of user content.\nUser event logs need to be protected as they contain information that impacts the user's privacy. User event logs shall be encrypted and integrity protected while stored. Access to user event logs shall only be granted to authorised persons and such access shall be logged.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "10.2\tAudit and Discreet Monitoring of user content",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "10.2.1\tOverview",
                            "text_content": "Disceet Monitoring is access to user content at a network element within the MC Domain. Where Discreet Monitoring is used to access to user voice communications, it is known as Discreet Listening. Discreet Monitoring includes access to voice, video and data communications. For the purposes of this document, discreet monitoring and audit are equivalent processes. For discreet monitoring the access to media is in real-time. For audit, the access to media is at some point after the recording. The systems which support audit or discreet listening are out of scope of this document.\nDisceet Monitoring and Audit are required functions of a public-safety network. For non-public safety services, these functions shall not be implemented in the network without explicit consent from all users of the MC system.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "10.2.2\tCollection of user media",
                            "text_content": "It is assumed that collected Mission Critical media is held in its encrypted form within mass data storage.   The storage solution is out-of-scope of this document.\nUser media is collected from the media paths within the MC Domain. It is expected that the encrypted media shall be collected at the media gateway into the MC system or by the MCX server .\nWhere SDS messages are routed within a signalling path, media will need to be extracted from within MCData signalling paths by the MC Domain. It is expected that the encrypted media routed over the signalling path shall be recorded by the CS and IS Proxies or by the MCData server.\nTo identify and process the collected and encrypted user media, user event logs associated with the media are required, as defined in Clause 10.1.2.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "10.2.3\tStoring of user media",
                            "text_content": "User media in the MC System is end-to-end encrypted by default. Consequently, media can be recorded without modificiation and without additional protection. Media should be recorded alongside:\n-\ta unique identifier for the collected media\n-\ta unique identifier for a user event (with which the media is associated).\nNOTE:\tCollected associated user event metadata may or may not be stored with the media.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "10.2.4\tDecryption of user media",
                            "text_content": "To decrypt a specific target user's media for audit or discreet listening at a specific time 'T', the following process should be used for decryption of user media.  The controlling entity shall be either the KMS or a secured logging device.\n1.\tThe auditor obtains the target user's key material and KMS certificate that was active at time 'T'. This could be performed, for example, using an Audit Client. An Audit Client is a Key Management Client with the special access privilege to request previously-issued user key material for existing clients  The provision of user key material by the KMS grants the auditor access to the user’s communication content..\na.\tAny request made by the auditor shall be controlled and logged(to allow the audit action to be audited) .\nb.\tIt is recommended that each release of key material be authorised by a secondary auditor (e.g. a double-lock mechanism).\nc.\tIt is recommended that the number of requests from each auditor within a time-period be limited. It is also recommended that the total number of requests from all auditors within a time-period be limited.\nNOTE:\tThe release of key material for a user at time 'T' only allows the auditor access to content for the  defined 'key period' associated to time ‘T’. By limiting the total number of requests (e.g. to 0.1% of users), this limits the auditor’s access to communications. These controls help to ensure that the granted access to user content is time-limited and proportionate.\n2.\tThe auditor extracts the user events associated with the user at time 'T'.\n3.\tThe auditor extracts the MIKEY messages from the signalling events and use the audited user's KMS-supplied key material to decrypt the media encryption keys held within the MIKEY messages.\n4.\tThe auditor is now able to associate media with user events and use the media encryption keys extracted from MIKEY message to decrypt the media.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "11\tInterconnection, interworking and migration security",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "11.1\tInterconnection",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "11.1.1\tOverview",
                            "text_content": "MC Systems may interconnect as described in TS 23.379 [2], TS 23.280 [36] and TS 23.281 [37]. This allows inter-system communications to occur.\nTo ensure interconnection is secure, MC clients only connect to MC Servers within their own system (unless migrating). When information is required by a MC client from another interconnected system, the information is first transferred from the interconnected partner system to the interconnected primary system via MCX server to MCX server communications followed by the distribution of that information to the MC client. For example, group management information is transferred between Group Management Servers in Clause 10.2.7 of TS 23.280 [36], prior to distribution to MC clients.\nMC systems should protect themselves at the system border from external attackers. During interconnection, the MC system should use an HTTP proxy and an MC gateway containing an IS proxy as described in clause 11.1.3 to enforce policies and apply security functions (such as topology hiding). Among the security functions that can be performed at both proxies are preventing any direct MC client connection over this interface. Cross-system authentication of interconnection signalling requests may be implicit or explicit, subject to the policy of each MC system. Where authentication is implicit, the HTTP Proxy and IS Proxy should prevent messages that do not have an external MC service ID in the source of the request. MC servers should enforce policy to limit the information provided to a signalling requests from external MC service IDs.\nWhere authentication is explicit, the signalling request shall contain an Element for Authenticating Requests, (EAR), as defined in Clause 9.6. It is recommended that an authorised identity should be used within the EAR, to convey the source's authorisation to make the request.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "11.1.2\tSecurity procedures for interconnection",
                            "text_content": "This clause defines security procedures that are used to support interconnection between MC systems\nTo allow a group to span two, or more, MC Systems, the GMK and GMK-ID needs to be transferred between the GMSs in different MC systems. The procedure follows an equivalent security procedure to that defined in Clause 7.3.3 for group regrouping. In this case, the GMK is transported within a ‘group information notify request' as defined in Clause 10.2.7.5 of TS 23.280 [36].\nPre-conditions:\n-\tBoth the primary and partner GMS have been keyed by their KMS.\nThe notify group configuration procedure is shown in Figure 11.1.2.2-1.\nThe figure depicts the inter-system GMK (Global Multiplexed Keying) transfer process, illustrating the key steps involved in the transmission of data between different systems. The figure shows the transmission of data from the source to the destination, with the GMK key being used to encrypt the data. The figure also includes the key distribution process, which ensures that the key is distributed evenly across the network. The figure is a crucial visual representation of the inter-system GMK transfer process, providing a clear understanding of the key steps involved in the transmission of data between different systems.\nFigure 11.1.2.2-1: Inter-system GMK transfer\n1.\tThe GMS in the primary MC system of the MC service group provides the notification to the GMS in the partner MC system of the MC service group. The primary GMS includes a Group Key Transport payload following the procedures in Clause 5.7, treating the partner GMS as another user within the group. Accordingly, the payload encrypts the GMK to the identity of the partner GMS and is signed using the identity of the primary GMS. The GUK-ID is derived using the User Salt generated from the partner GMS's URI.\nNOTE 1:\tIf the choice of initiator KMS (IDRkmsi) or receiver KMS (IDRkmsr) within the MIKEY message is unacceptable, a KMS Redirect Response may be returned to the primary GMS providing KMS information. In this case, the primary GMS may re-attempt the above procedures.\nNOTE 2:\tIn this case, the partner GMS may discard the GUK-ID once the GMK-ID has been extracted.\n2.\tFurther signalling occurs as defined in TS 23.280 [36].\nUpon receipt of the GMK, the partner GMS shall distribute the GMK and GMK-ID on to group MC clients as described in Clause 5.7.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "11.1.3\tInterconnection security with MC gateway server",
                            "text_content": "A MC gateway server is part of the mission critical architecture for interconnection as defined in 3GPP TS 23.280 [36]. The MC gateway server includes an IS Proxy for inter-domain security as defined in Annex I.  The IS Proxy provides protection of the SIP-3 interface (i.e. SIP payload and RTCP protection using a SPK as defined in clause 9 and clause 6.3.2).  The SIP-3 interface is covered as part of the interconnection MCX-1 reference point.\nFigure 11.1.3-1 shows an interconnection architecture between two MC domains (MC domain A and MC Domain B) each with the MC gateway server which contains the IS proxy for interconnection security.  The MC gateway provides the necessary topology hiding and address translation along with signalling protection via the IS proxy.  HTTP communications for interconnection over the HTTP-3 reference point are provided for via the HTTP proxy as described in 3GPP TS 23.280 [36] and protected as defined in clause 6.1.3 of this specification.\n\nThe figure depicts a network security setup using MC gateways with HTTP and IS proxies. MC gateways are used to establish secure connections between different network segments, while IS proxies are used to provide additional security measures. The setup ensures that only authorized users can access the network, reducing the risk of unauthorized access and data breaches.\nFigure 11.1.3-1: Interconnection security using MC gateway with HTTP and IS proxies\nIn Figure 11.1.3-1, the interface between the MC domains shall be protected hop-by-hop as defined in Clause 6.3.2. The SIP-3 interface between IS Proxies may be protected at the application layer using a shared SPK as defined in Clause 9 and the HTTP-3 interface between HTTP Proxies may be protected using TLS as defined in Clause 6.1.3.For interconnection communications with an MC gateway server (e.g. MC domain A to MC domain B in this example), HTTP and SIP messages are sent by an MC service server or a server in the common services core within the MC domain, towards the MC gateway server or HTTP proxy for processing, protection, and external routing to a partner MC domain.\nFor HTTP messages, the HTTP proxy applies topology hiding by replacing the internal to/from addresses in the HTTP message with the associated external HTTP routing addresses. The HTTP proxy determines the target HTTP proxy for MC domain B and choses the certificates appropriate for that TLS tunnel. The HTTP message is protected and sent towards MC domain B on the HTTP-3 interface.  The HTTP proxy in MC domain B receives the HTTP message where it is decrypted from the external TLS tunnel. The HTTP proxy in MC domain B then replaces any external HTTP routing addresses with internal HTTP addresses applicable to MC domain B and forwards the message to the appropriate server within MC domain B.\nFor SIP messages, the MC gateway server in MC domain A applies topology hiding by replacing the internal to/from SIP addresses (e.g. Public Service Identities) in the SIP header with the associated external SIP routing addresses and passes the SIP message to the MC gateway IS proxy. The IS proxy removes any internal SIP payload encryption, then based on the target MC domain (MC domain B) selects the appropriate inter-domain SPK to re-encrypt the SIP payload(s). The SIP message is then sent towards the MC gateway server in MC domain B over the SIP-3 interface where the MC gateway IS proxy in MC domain B receives the SIP message and decrypts it using the inter-domain SPK it has in common with MC domain A. The IS proxy in MC domain B may then re-encrypt the SIP payload(s) with an internal MC domain B SPK. The topology hiding function of the MC gateway server in MC domain B then replaces the external SIP routing addresses with internal SIP addresses applicable to MC domain B and forwards the message to the appropriate server within MC domain B.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "11.2\tInterworking",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "11.2.1\tGeneral",
                            "text_content": "The 3GPP security architecture supports the transfer of interworking signalling and media.\nFor media sent towards the 3GPP system, the IWF shall apply 3GPP security prior to sending the media to the 3GPP system. This is performed using MC Security Gateway functionality as defined in Annex L.\nFor media sent from the 3GPP system, the IWF shall remove 3GPP security prior to performing any further processing of the media. This is performed using MC Security Gateway functionality as defined in Annex L.\nInterworking media may be end-to-end protected using LMR mechanisms that are out-of-scope of this specification.  3GPP MC application security shall be applied, regardless of whether the LMR security mechanism is used. For further details of LMR end-to-end security mechanisms see Annex K.\nWhen signalling protection is used by the 3GPP MC system, the IWF shall apply the applicable 3GPP signalling protection mechanisms to the signalling packets sent towards the 3GPP system and shall remove the applicable 3GPP signalling protection mechanisms for signalling packets received from the 3GPP system. This is performed using MC Security Gateway functionality as defined in Annex L.\nWhen signalling protection is not used by the 3GPP MC system, the signaling packets sent towards the 3GPP system shall be forwarded by the IWF without signalling protection.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "11.2.2\tTransport of non-3GPP interworking security data (InterSD)",
                            "text_content": "To support the exchange of end-to-end interworking security data (a.k.a. Key Management Messages) between 3GPP MC UEs and the non-3GPP system when the interworking keys are home to the non-3GPP system, transport of the interworking security data is carried out using an Interworking Security Data (InterSD) message as defined in 23.283 [48].  An InterSD message may be generated by either the IWF or the 3GPP interworking MC UE.\nThe formatting and content of non-3GPP security data payloads are defined by the non-3GPP system or the non-3GPP layer of the 3GPP interworking MC UE and are out of scope for this document.  The InterSD message shall support the transfer of non-3GPP security data payloads regardless of the security data payload content, format, or the architecture of the non-3GPP system beyond the IWF.\nSignalling protection may be applied to the InterSD message as defined in clause 9.\nAn interworking key management record as defined in clause 11.2.3 may be required to enable secure InterSD messaging between a MC UE and a non-3GPP system.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "11.2.3\tInterworking key management enablement",
                            "text_content": "To support interworking key management with a non-3GPP system (i.e. InterSD messaging), an interworking MC UE may require provisioning of an interworking key management record (InterKMRec) that supports the secure transfer of InterSD messages. Generally speaking, an InterKMRec provides initial key management parameters needed to send, receive, address, protect, or otherwise interpret InterSD messages passed between an interworking 3GPP MC UE and the non-3GPP interworking system (e.g. interworking key management addressing, interworking key management identifiers, interworking key management root keys, or other interworking key management related parameters).\nThe InterKMRec is provided from the MC KMS to the interworking MC UE during MC user key management authorization.\nThe format of an InterKMRec is shown in figure 11.2.3-1 and consists of a Primary InterKMRec ID, a Secondary InterKMRec ID, and the InterKMRec Payload.\n\n\nFigure 11.2.3-1 Interworking key management record (InterKMRec) structure\nThe Primary InterKMRec ID and Secondary InterKMRec ID are used in combination to identify and manage interworking MC UE clients for a single MC user (i.e. the same MC Service ID such as a MCPTT ID) when that MC user might log onto multiple interworking MC UEs at the same time.  The MC service ID of a particular interworking MC user shall be coupled to the Primary InterKMRec ID and the Secondary InterKMRec ID shall be used to distinguish between the multiple MC clients in use by that MC service ID (e.g. the client ID).\nFor example, when an interworking MC user performs key management authorization, the MC service ID of the user is used to identify the set of InterKMRecs associated to that MC service ID.  The KMS selects one of the associated InterKMRecs (assuming at least one record exists) and then further makes a dynamic association between the client ID making the request and the Secondary InterKMRec ID, this way uniquely identifying the interworking MC user and each interworking MC client the MC user is using.\nThe exact format and contents of the InterKMRec Payload is defined by the non-3GPP system and is out of scope for this document. The method used to provision an InterKMRec into the KMS is out of scope for this document.  The method used to associate an MC service ID to a Primary InterKMRec ID and the method used to associate an MC UE client to a Secondary InterKMRec ID is also out of scope for this document.\nWhen an interworking MC user performs key management authorization at the KMS and the access token has been validated, the KMS shall check to see if the MC service ID provided in the access token has an associated InterKMRec.  If more than one InterKMRec exists for the MC service ID, the KMS shall check to see if the Secondary InterKMRec ID is also already associated to a specific client for that MC Service ID.  If the client cannot be matched, then the KMS shall select one of the InterKMRecs and associate the client ID to the Secondary InterKMRec ID of that InterKMRec.  The KMS shall then deliver the selected InterKMRec to the interworking MC UE during MCX user key management authorization as defined in clause 5.1.3.1.\nIt is out of scope of this document as to when and how the KMS disassociates a client from a particular InterKMRec ID.\nWhen required by the MC system, the InterKMRec shall be transported from the KMS to the interworking MC UE encrypted on the TrK of the interworking MC UE.  The InterKMRec may be signed and if so, shall be signed by either the Ink if the InK is present, or signed by the TrK if the InK is not present.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "",
                                    "table number": 9,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "A.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "Stage 1 requirements pertaining to MCX security are found in 3GPP TS 22.179 [3] and 3GPP TS 22.280 [47]. Stage 2 Architectural requirements pertaining to MCX security are found in 3GPP TS 23.179 [2], 3GPP TS 23.280 [36], 3GPP TS 23.281 [37], and 3GPP TS 23.282 [38]. The following are MCX derived security requirements:\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.2\tConfiguration & service access",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.2-001] The MC UE and the network entity providing the MCX configuration data, shall mutually authenticate each other prior to MC UE configuration to use the MCX service.\n[33.180 MCX-A.2-002] The MC User and the MCX Service shall mutually authenticate each other prior to providing the MC UE with the MCX Service User profile and access to user-specific services.\n[33.180 MCX-A.2-003] The transmission of configuration data and user profile data between an authorized MCX server in the network and the MC UE shall be confidentiality protected, integrity protected and protected from replays.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.3\tGroup key management",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.3-001] Group key material shall be integrity and confidentiality protected for a specific MC User during distribution from the MCX service to MC UEs.\n[33.180 MCX-A.3-002] Group key material shall be authenticated as coming from a valid, authorized source. The authorized source may be an MC Administrator or may be another authorized entity (e.g. an authorized MCX User or Dispatcher).\n[33.180 MCX-A.3-003] It shall be possible for authorized entities to dynamically create and distribute a new group security context at any time. This may be as part of a group creation process, be due to a periodic update to maintain key freshness, or due to compromise of group key material.\n[33.180 MCX-A.3-004] The creation of a new group security context (e.g. via User-Regroup operation) shall not change or compromise an existing group security context.\n[33.180 MCX-A.3-005] It shall be possible for an authorized, authenticated entity to revoke and update a group security context from use.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.4\tOn-network operation",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.4-001] All users of the MCX service shall be authenticated to prevent an adversary impersonating a user for the purpose of denial of service.\n[33.180 MCX-A.4-002] The MCX service should take measures to detect and mitigate DoS attacks to minimize the impact on the network and on MC users.\n[33.180 MCX-A.4-003] The MC user shall be authenticated by the MCX application.\n[33.180 MCX-A.4-004] A mechanism shall exist that allows the MCX application to be authenticated by the MCX user.\n[33.180 MCX-A.4-005] The MC UE and MCX service should enforce the result of the authentication for the duration of communications (e.g. by integrity protection or implicit authentication by encryption with a key that is derived from the authentication and is unknown to the adversary).\n[33.180 MCX-A.4-006] The security solution should minimize the impact of a compromised MC UE on other MC UEs.\n[33.180 MCX-A.4-007] The MCX Service shall provide a means to ensure integrity of all MCX user signalling at the application layer.\n[33.180 MCX-A.4-008] The MCX Service shall protect the administrative and security management parameters from manipulation by individuals who are not explicitly authorized by the Mission Critical Organization.\n[33.180 MCX-A.4-009] The MCX service shall provide a means to support confidentiality of MCX user identities from all entities outside the MCX service.\n[33.180 MCX-A.4-010] The MCX service shall provide a means to support confidentiality of MCX signalling from all entities outside the MCX service.\n[33.180 MCX-A.4-011] The MCX Service shall provide a means to support end-to-end confidentiality and integrity protection for all media traffic transmitted between MC UEs.\n[33.180 MCX-A.4-012] The MCX Service shall provide a means to support the confidentiality and integrity protection of location information transmitted from the MC UE to the MCX application server.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.5\tAmbient listening",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.5-001] Specific roles in the organization and shall be identified to authorize and activate Ambient Listening and privileges shall be assigned to these roles to activate and register the use of ambient listening.\n[33.180 MCX-A.5-002] The activation of the Ambient Listening functionality shall be automatically registered by the system and will be stored as an 'event' by the system.\n[33.180 MCX-A.5-003] Any decision to activate Ambient Listening, or review of such a decision, may also be recorded in a suitable incident log unless to do so would interfere with the purpose for which the functionality is being used i.e. an investigation tool for evidence gathering in cases of suspected gross misconduct of staff or evidence gathering in criminal cases.  If this is the case the authorization needs to be recorded elsewhere as appropriate.\n[33.180 MCX-A.5-004] A radio user should be told as soon as possible that they are, or have been, subject to Ambient Listening and the reason why the functionality was activated.  The fact they have been informed, by whom and when, should be recorded in a suitable log.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.6\tData communication between MCX network entities",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.6-001] A security mechanism shall exist that allows transmission of data between 3GPP MCX network entities to be authenticated, confidentiality protected, integrity protected and protected from replays.\nNOTE:\tUE-to-UE and UE-to-network relays are not considered to be 'network entities'.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.7\tKey stream re-use",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.7-001] The MCX system shall ensure that key streams are not reused.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.8\tLate entry to group communication",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.8-001] An authorized MCX User shall be able to obtain the information necessary to derive the group security context for the MCX Group while an MCX Group communication is on-going. As a result, the MC User shall be able to listen to the group communication within 350ms. This requirement applies for both on-network and off-network MCX operations.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.9\tPrivate call confidentiality",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.9-001] It shall be possible to establish a unique Private Call security context between any pair of authorized MCX users within the MCX system. The security context shall not be available to other MCX users, except, where necessary, authorized MCX monitoring functions (e.g. LI, Discreet Listening). If the security context is made available to monitoring functions, appropriate controls and logging shall exist. This requirement applies when MCX UEs are operating both on-network and off-network.\n[33.180 MCX-A.9-002] The Private Call security context shall provide a means to provide confidentiality and integrity protection of user traffic, and authenticate the MCX users involved in the Private Call.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.10\tOff-network operation",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.10-001] The MCX service should take measures to detect and mitigate DoS attacks to minimize the impact to relays and to off-network MCX users.\n[33.180 MCX-A.10-002] The MCX Service shall provide a means to support end-to-end security for all media traffic transmitted between MCPTT UEs, including where relays are used.\n[33.180 MCX-A.10-003] The MCX Service shall provide a means to support the confidentiality and integrity protection of location information transmitted from the MCX UE to the MCX application server, including where relays are used.\n[33.180 MCX-A.10-004] MCX off-network UEs shall be explicitly or implicitly authenticated to each other.\n[33.180 MCX-A.10-005] MCX off-network UEs and MC relays shall be explicitly or implicitly authenticated to each other.\n[33.180 MCX-A.10-006] The security solution should minimize the impact of a compromised MCX UE on other MCX UEs.\n[33.180 MCX-A.10-007] The MCX Service shall provide a means to ensure integrity of all MCX user signalling at the MCX application layer.\n[33.180 MCX-A.10-008] The MCX service shall provide a means to support confidentiality of MCX service user identities from all entities outside the MCX service.\n[33.180 MCX-A.10-009] The MCX service shall provide a means to support confidentiality of MCX signalling from all entities outside the MCX service.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.11\tPrivacy of MCX service identities",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.11-001] The MCX service user identities of each plane shall be used within the corresponding plane and concealed to other planes.\n[33.180 MCX-A.11-002] When required by the MCX Service provider, MCX application services layer identities (such as the Mission Critical user identity, MCPTT ID, MCVideo ID, MCData ID and MCX Group IDs) and other application services sensitive information (as further described in 3GPP TS 23.179 [2], clause 8.2), shall be contained within the application plane and shall provide a means to support confidentiality and integrity of the application plane from the SIP signaling plane.\n[33.180 MCX-A.11-003] When protection of identities and other sensitive MCX application information is NOT required by the MCX Service provider, the MCX application services layer identities (such as the Mission Critical user identity, MCPTT ID, MCVideo ID, MCData ID and MCX Group IDs) and other application services sensitive information (as further described in 3GPP TS 23.179 [2], clause 8.2), shall remain contained within the application plane. While confidentiality protection is not required, integrity protection may be applied.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.12\tUser authentication and authorization",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.12-001] User authentication and authorization interoperability between different networks and different manufacturers' clients and servers shall satisfy the requirements for mission critical roaming and migration.\n[33.180 MCX-A.12-002] User authentication and authorization shall support all deployment models listed in 3GPP TS 23.179 [2].\n[33.180 MCX-A.12-003] User authentication and authorization shall support interchangeable MC user authentication solutions, allowing implementations to use different means to authenticate the user, e.g. Web SSO, SIP digest, GBA, biometric identifiers, username+password.\n[33.180 MCX-A.12-004] User authentication and authorization shall support scalability (number of users), providing efficient support for small MCX systems with few users, to large MCX systems with hundreds of thousands of users.\n[33.180 MCX-A.12-005] User authentication and authorization shall support extensibility, providing authorization for additional mission critical services including group aware services, additional interfaces, etc.\n[33.180 MCX-A.12-006] All users of the MCX Service shall be authenticated to prevent an adversary impersonating a user for the purpose of denial of service.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.13\tInter-domain",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.13-001] An MCX Service shall provide mechanisms to allow an MCX User to operate in a Partner MCX Service System, subject to authorization from both the Partner and the Primary MCX Service Systems of the MCX User (R-6.17.2-001 [47]).\n[33.180 MCX-A.13-002] The authentication of an MCX User with an MCX Service in a Partner MCX Service System shall be based on security parameters obtained from the Primary MCX Service System of the MCX User (R-6.17.2-002 [47]).\nNOTE 1:\tThis is an application layer authentication and not 3GPP network authentication.\n[33.180 MCX-A.13-003]  An MCX Service shall provide mechanisms to allow an MCX User on the Primary MCX Service System to affiliate to an MCX Service Group from a Partner MCX Service System, subject to authorization from the Primary MCX Service System and the Partner MCX Service System where the MCX Service Group is defined (R-6.17.2-004 [47]).\n[33.180 MCX-A.13-004]  An MCX Service shall provide mechanisms to allow a roaming MCX User to affiliate to an MCX Service Group from the Partner MCX Service System, subject to authorization from the Partner MCX Service System where the MCX Service Group is defined (R-6.17.2-005 [47]).\n[33.180 MCX-A.13-005]  An MCX Service shall provide mechanisms to allow an MCX User that receives service from a Partner MCX Service System to affiliate to an MCX Service Group from another Partner MCX Service System, subject to authorization from the Partner MCX Service System where the MCX Service Group is defined (R-6.17.2-006 [47]).\nNOTE 2:\tIt is assumed that once affiliation from a User to a Group is successful, subsequent communication within that Group are available to the User.\n[33.180 MCX-A.13-006]  End to end security of an MCX Service Group communication (including in Partner MCX Service Systems) shall be based on parameters obtained from the MCX Service system where the MCX Service Group is defined (R-6.17.2-007 [47]).\n[33.180 MCX-A.13-007]  All Mission Critical Users shall be authenticated with their home identity management service prior to authentication or authorisation with a partner domain.\n[33.180 MCX-A.13-008]  A user requiring services at a partner domain shall first acquire a verifiable credential from the user's primary identity management service.\n[33.180 MCX-A.13-009]  An identity management service shall authenticate a visiting user based on a verifiable credential from the user's primary identity management service prior to authorising that user for local service(s).\n[33.180 MCX-A.13-010]  A visiting user shall be authorised with the local server(s) at the partner MCX System before being granted local services.\n[33.180 MCX-A.13-011]  The partner identity management service shall have full and overruling authorisation control of all visiting users requesting services in the partner MCX System.\n[33.180 MCX-A.13-012]  When using external security domains, the Home Security Domain shall apply policies which ensure that only trusted external security domains are used.\n[33.180 MCX-A.13-013]  Use of external security domains shall be logged to detect impersonation and misuse.\n[33.180 MCX-A.13-014]  MCX Services shall be able to permit/deny the use of security domains over their service.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.14\tMCData",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.14-001]  The MCData Service shall provide a means to support end-to-end confidentiality and integrity protection for messaging transmitted between MCX UEs in both media and signalling streams.\n[33.180 MCX-A.14-002]  The MCData Service shall provide a means to authenticate messages in both media and signalling streams.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.15\tMultimedia Broadcast/Multicast Service",
                    "description": "",
                    "summary": "",
                    "text_content": "[33.180 MCX-A.15-001]  The security of signalling transmitted between the MCX client and MCX server shall be controlled by the MCX server. As a consequence of this requirement, the MCX Server shall not require key material from external MC Domains to enable the use of MBMS.\n[33.180 MCX-A.15-002]  The MCX Service shall provide means to support confidentiality and integrity protection for the MBMS subchannel control messages.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "B.1\tGeneral",
            "description": "The information in this annex provides a normative description of the MCX Connect Authentication and Authorization framework based on the OpenID Connect 1.0 standard. Characterization of the ID token, access token, how to obtain tokens, how to validate tokens, and how to use the refresh token is explained.\nThe OpenID Connect 1.0 standard provides the source of the information contained in this annex. MCX Connect profiles the OpenID Connect standard and includes the service IDs in the ID token and the access token, as well as the definition of MCX specific scopes for key management, MCX services, configuration management, and group management. This profile is compliant with OpenID Connect.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.2\tMCX tokens",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "B.2.1\tID token",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "B.2.1.1\tGeneral",
                            "text_content": "The ID Token shall be a JSON Web Token (JWT) and contain the following standard and MCX token claims. Token claims provide information pertaining to the authentication of the MCX user by the IdM server as well as additional claims. This clause profiles the required standard and MC claims for the MCX Connect profile.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "B.2.1.2\tStandard claims",
                            "text_content": "These standard claims are defined by the OpenID Connect 1.0 specification and are REQUIRED for MCX implementation. Other claims defined by OpenID Connect are optional. The standards-based claims for an MCX Connect ID token are shown in table B.2.1.2-1.\nTable B.2.1.2-1: ID token standard claims\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table B.2.1.2-1: ID token standard claims",
                                    "table number": 10,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "B.2.1.3\tMCX claims",
                            "text_content": "The MCX Connect profile extends the OpenID Connect standard claims with the additional claims shown in table B.2.1.3-1.\nTable B.2.1.3-1: ID token MCX claims\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table B.2.1.3-1: ID token MCX claims",
                                    "table number": 11,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "B.2.2\tAccess token",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "B.2.2.1\tIntroduction",
                            "text_content": "The access token is opaque to MCX clients and is consumed by the MCX resource servers (i.e. KMS, MCPTT server, MCVideo server, MCData server, etc). The access token shall be encoded as a JSON Web Token as defined in IETF RFC 7519 [32].  The access token shall include the JSON web digital signature profile as defined in IETF RFC 7515 [35].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "B.2.2.2\tStandard claims",
                            "text_content": "MC access tokens shall convey the following standards-based claims as defined in IETF RFC 7662 [33].\nTable B.2.2.2-1: Access token standard claims\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table B.2.2.2-1: Access token standard claims",
                                    "table number": 12,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "B.2.2.3\tMCX claims",
                            "text_content": "The MCX Connect profile extends the standard claims defined in IETF RFC 7662 [33] with the additional claims shown in table B.2.2.3-1.\nTable B.2.2.3-1: Access token MCX claims\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table B.2.2.3-1: Access token MCX claims",
                                    "table number": 13,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "title": "B.3\tClient registration",
            "description": "Before a client can obtain ID tokens and access tokens (required to access MCX resource servers) it shall first be registered with the IdM server of the service provider as required by OpenID Connect 1.0. The method by which this is done is not specified by this profile.  For native  clients, the following information shall be registered:\n-\tThe client is issued a client identifier. The client identifier represents the client's registration with the authorization server, and enables the IdM server to reference parameters associated with that client's registration when being requested for an access token by the client.\n-\tRegistration of the client's redirect URIs.\nOther information about the client such as (for example): application name, website, description, logo image, legal terms to be consented to, may optionally be registered.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.4\tObtaining tokens",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "B.4.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "Once a client has been successfully registered with the IdM server of the MCX service provider, the client may request ID tokens and access tokens (as required to access MCX resource servers such as PTT, Video, Data and KMS). MCX Connect will support a number of different MCX client types, including: native, web-based, and browser-based. Only native clients are defined in this version of the MCX Connect profile. The exact method in which a client requests the access token depends upon the client profile. The client profiles, along with steps required from them to obtain OAuth access tokens, are explained in technical detail below.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.4.2\tNative MCX client",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "B.4.2.1\tGeneral",
                            "text_content": "This conforms to the Native Application profile of OAuth 2.0 as per IETF RFC 6749 [19].\nMCX clients fitting the Native application profile utilize the authorization code grant type with the IETF RFC 7636 [53] PKCE extension for enhanced security as shown in figure B.4.2.1-1.\nUnless indicated otherwise in this document, the use of HTTP Basic authentication shall be as specified in IETF RFC 6749 [19] and IETF RFC 6750 [20].\n\nThe figure depicts the authorization code flow in a mobile application, illustrating the steps taken by the user to authenticate their identity and access the application. The flow includes inputting the authorization code, validating the code, and finally, authorizing the application.\nFigure B.4.2.1-1: Authorization Code flow\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "B.4.2.2\tAuthentication request",
                            "text_content": "As described in OpenID Connect 1.0, the IdM client constructs a request URI by adding the following parameters to the query component of the authorization endpoint's URI using the \"application/x-www-form-urlencoded\" format, redirecting the user's web browser to the authorization endpoint of the IdM server. The standard parameters shown in table B.4.2.2-1 are required by the MCX Connect profile. Other parameters defined by the OpenID Connect specification are optional.\nTable B.4.2.2-1: Authentication Request standard required parameters\n\nAn example of an authentication request for MCX Connect might look like:\nEXAMPLE:\nGET/as/authorization.oauth2?response_type=code&client_id=idm_client&scope=openid\n3gpp:mc:ptt_service&redirect_uri=\nHTTP/1.1\nHost: IdMS.server.com:9031\nCache-Control: no-cache\nContent-Type: application/x-www-form-urlencoded\n\nUpon receiving the authentication request from the client, the IdM server performs user authentication. Note that user authentication should be completely opaque to the MC services on the client.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table B.4.2.2-1: Authentication Request standard required parameters",
                                    "table number": 14,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "B.4.2.3\tAuthentication response",
                            "text_content": "The authorization endpoint running on the IdM server issues an authorization code and delivers it to the MCX client. The authorization code is used by the MCX client to obtain an ID token, access token and refresh token from the IdM server. The authorization code is added to the query component of the redirection URI using the \"application/x-www-form-urlencoded\" format. The authorization code standard parameters are shown in table B.4.2.3-1.\nTable B.4.2.3-1: Authentication Response standard required parameters\n\nAn example of an authentication response for MCX Connect might look like.\nEXAMPLE:\nHTTP/1.1 302 Found\nLocation:?\ncode=SplxlOBeZQQYbYS6WxSbIA\n&state=abc123\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table B.4.2.3-1: Authentication Response standard required parameters",
                                    "table number": 15,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "B.4.2.4\tAccess token request",
                            "text_content": "In order to exchange the authorization code for an ID token, access token and refresh token, the MCX client makes a request to the authorization server's token endpoint by sending the following parameters using the \"application/x-www-form-urlencoded\" format, with a character encoding of UTF-8 in the HTTP request entity-body. Note that client authentication is REQUIRED for native applications (using PKCE IETF RFC 7636 [53]) in order to exchange the authorization code for an access token. If client secrets are used, the client secret is sent in the HTTP Authorization Header as defined in IETF RFC 6749 [19]. The access token request standard parameters are shown in table B.4.2.4-1.\nTable B.4.2.4-1: Access token request standard required parameters\n\nAn example of an access token request for MCX Connect might look like this.\nEXAMPLE:\nPOST /as/token.oauth2 HTTP/1.1\nHost: IdM.server.com:9031\nCache-Control: no-cache\nAuthorization: Basic cnA33hpsb25nABClY3VyZS1yYW5kb20tc2VjdnV0\nContent-Type: application/x-www-form-urlencoded\ngrant_type=authorization_code\n&code=SplxlOBeZQQYbYS6WxSbIA\n&client_id=myNativeApp\n&code_verifier=0x123456789abcdef\n&redirect_uri=http://3gpp.mcptt/cb\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table B.4.2.4-1: Access token request standard required parameters",
                                    "table number": 16,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "B.4.2.5\tAccess token response",
                            "text_content": "If the access token request is valid and authorized, the IdM server returns an ID token, access token and refresh token to the MCX client in an access token response message; otherwise it will return an error.\nThe access token response standard parameters are shown in table B.4.2.5-1.\nTable B.4.2.5-1: Access token response standard parameters\n\nAn example of a successful response might look like:\nEXAMPLE:\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n{\n   \"access_token\":\"eyJhbGciOiJSUzI1NiJ9.eyJtY3B0dF9pZCI6ImFsaWNlQG9yZy5jb20iLCJleHAiOjE0NTM1MDYxMjEsInNjb3BlIjoib3BlbmlkIDNncHA6bWNwdHQ6cHR0X3NlcnZlciIsImNsaWVudF9pZCI6Im1jcHR0X2NsaWVudCJ9.yXGl0gu3SsRQ_VUrDTWuEp-X8wrj-xUzXzWhTnqntXn0fI6xLR0i6VHtY3L25w81u260bsOFUMiYLLBC0LOKi-SOcwMqrzH6_BZwjkRhExiAciHZNtwgIlHWYwpCuxQII0dcg7_bw_YAFEQQC9IDzsifPXl9JmazI8YMtGcAWohoiSi0KY1pnbORUDBSPLLFlekQH5aOWbe_6EF4pDbm5pH8GXLd_ZtxS7jC6tAAMsCvsRy7Pb_GeDr_jT8-IevGKWO82of7gaUQkF8qnKVagr4-qc2FJeSDuhj4ZvfL510cgcRGy4NJ_7xxS10bzFNLavfqOlgOelJv0KA9IAd-1Q\",\n\"refresh_token\":\"Y7NSzUJuS0Jp7G4SKpBKSOJVHIZxFbxqsqCIZhOEk9\",\n\"id_token\":\"eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiYXVkIjoibWNwdHRfY2xpZW50IiwiaXNzIjoiSWRNUy5zZXJ2ZXIuY29tOjkwMzEiLCJpYXQiOjE0NTM0OTgxNTgsImV4cCI6MTQ1MzQ5ODQ1OCwibWNwdHRfaWQiOiJhbGljZUBvcmcuY29tIn0.Dpn7AhIMaqMEgg12NYUUfJGSFJMPG8M2li9FLtPotDlHvwU2emBws8z5JLw81SXQnoLqZ8ZF8tIhZ1W7uuMbufF4Wsr7PAadZixz3CnV2wxFV9qR_VA1-0ccDTPukUsRHsic0SgZ3aIbcYKd6VsehFe_GDwfqysYzD7yPwCfPZo\",\n\"token_type\": \"Bearer\",\n\"expires_in\": 7199\n}\n\nThe MCX client may now validate the user with the ID token and configure itself for the user (e.g. by extracting the MC service ID from the ID Token). The MCX client then uses the access token to make authorized requests to the MCX resource servers (MCPTT server, MCVideo server, MCData server, KMS, etc.) on behalf of the end user.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table B.4.2.5-1: Access token response standard parameters",
                                    "table number": 17,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "title": "B.5\tRefreshing an access token",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "B.5.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "To protect against leakage or other compromise, access token lifetimes are typically short lived (though it is ultimately a matter of security policy & configuration by the service provider). Some client types can be issued longer-lived refresh tokens, which enable them to refresh the access token and avoid having to prompt the user for authentication again when the access token expires. Refresh tokens are available only to clients utilizing the authorization code grant type (native MCX clients and web-based MCX clients). Refresh tokens are not given to clients utilizing the implicit grant type (browser-based MCX clients). Figure B.5.1-1 shows how Native MCX clients can use the refresh token as a grant type to obtain new access tokens.\nThe figure depicts a request for a new access token, with a user interface (UI) and a server interface (SI) for managing access tokens. The UI includes a form for entering the user's credentials, while the SI manages the access token request, ensuring security and compliance.\nFigure B.5.1-1: Requesting a new access token\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.5.2\tAccess token request",
                    "description": "",
                    "summary": "",
                    "text_content": "To obtain an access token from the IdM server using a refresh token, the MCX client makes an access token request to the token endpoint of the IdM server. The MCX client does this by adding the following parameters using the \"application/x-www-form-urlencoded\" format, with a character encoding of UTF-8 in the HTTP request entity-body. The access token request standard parameters are shown in table B.5.2-1.\nTable B.5.2-1: Access token request standard required parameters\n\nAn example of a token request for MCX Connect might look like:\nEXAMPLE:\nPOST /as/token.oauth2 HTTP/1.1\nHost: IdM.server.com:9031\nCache-Control: no-cache\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&refresh_token=Y7NSzUJuS0Jp7G4SKpBKSOJVHIZxFbxqsqCIZhOEk9&scope=3gpp:mcptt:ptt_server\n\nIf the MCX client was provided with client credentials by the IdM server, then the client shall authenticate with the token endpoint of the IdM server utilizing the client credential (shared secret or public-private key pair) established during the client registration phase.\n",
                    "tables": [
                        {
                            "description": "Table B.5.2-1: Access token request standard required parameters",
                            "table number": 18,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.5.3\tAccess token response",
                    "description": "",
                    "summary": "",
                    "text_content": "In response to the access token request (above) the token endpoint on the IdM server will return an access token to the MCX client, and optionally another refresh token in an access token response message.\nThe access token response standard parameters are shown in table B.5.3-1.\nTable B.5.3-1: Access token response standard parameters\n\nAn example of a successful response for MCX Connect might look like:\nEXAMPLE:\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n{\n\"access_token\":\"eyJhbGciOiJSUzI1NiJ9.eyJtY3B0dF9pZCI6ImFsaWNlQG9yZy5jb20iLCJleHAiOjE0NTM1MDYxMjEsInNjb3BlIjoib3BlbmlkIDNncHA6bWNwdHQ6cHR0X3NlcnZlciIsImNsaWVudF9pZCI6Im1jcHR0X2NsaWVudCJ9.yXGl0gu3SsRQ_VUrDTWuEp-X8wrj-xUzXzWhTnqntXn0fI6xLR0i6VHtY3L25w81u260bsOFUMiYLLBC0LOKi-SOcwMqrzH6_BZwjkRhExiAciHZNtwgIlHWYwpCuxQII0dcg7_bw_YAFEQQC9IDzsifPXl9JmazI8YMtGcAWohoiSi0KY1pnbORUDBSPLLFlekQH5aOWbe_6EF4pDbm5pH8GXLd_ZtxS7jC6tAAMsCvsRy7Pb_GeDr_jT8-IevGKWO82of7gaUQkF8qnKVagr4-qc2FJeSDuhj4ZvfL510cgcRGy4NJ_7xxS10bzFNLavfqOlgOelJv0KA9IAd-1Q\",\n   \"refresh_token\": \"iTxQYALqlc7uLyFGpnl8tR8Y9gkw91mFy2qC9Yywkz\",\n   \"token_type\": \"Bearer\",\n   \"expires_in\": 7199\n}\n\nIt is possible to configure the IdM server to confirm that the user account is still valid each time the refresh token is presented, and to revoke the refresh token if not. This security practice is RECOMMENDED.\n",
                    "tables": [
                        {
                            "description": "Table B.5.3-1: Access token response standard parameters",
                            "table number": 19,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "B.6\tMCX client registration with partner IdM service",
            "description": "MCX client registration with a partner IdM service shall be as described in clause B.3.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.7\tObtaining an access token from a partner domain",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "B.7.1\tOverview",
                    "description": "",
                    "summary": "",
                    "text_content": "When an MCX user requires user service authorisation for services owned and managed within a partner domain, the MCX client shall use the OAuth 2.0 token exchange extension grant type mechanism to obtain a security token for authentication with the partner IdM service.  The OAuth 2.0 token exchange procedure defines a method for obtaining the security token from the primary IdMS which contains information about the user that is verifiable by the partner IdMS.\nThe MCX client then provides this security token to the partner IdM service in exchange for an access token that is specific to the services in the partner domain. The MCX UE then uses the access token for user service authorisation to those services within the partner domain.\nThe security token and acess token(s) are specific to a IdMS and partner domain and therefore the OAuth 2.0 token exchange procedure shall be repeated with each additional domain to obtain user service authorisation to partner services within those domains.\nFigure B.7.1-1 shows the OAuth 2.0 token exchange procedure used to obtain a security token and acess token(s).  The messages are described in the following sub-clauses.\n\nThe figure depicts a token exchange flow in a network, illustrating the process of data transmission between different nodes. The flow is represented by a series of nodes, each connected to the next by a token, which is a small data packet. The nodes are connected to the network through a series of switches, which are responsible for routing the data packets. The flow is shown in a flowchart format, with arrows indicating the direction of the data flow. The figure provides a visual representation of the token exchange process, which is an essential component of network communication.\nFigure B.7.1-1: Token exchange flow\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.7.2\tToken Exchange Request",
                    "description": "",
                    "summary": "",
                    "text_content": "In order to obtain a security token, the MCX client makes a request to the primary authorization server's token endpoint by sending the following parameters using the \"application/x-www-form-urlencoded\" content-type and a character encoding of UTF-8 in the HTTP request entity-body. The standard parameters shown in table B.7.2-1 are required by the MCX Connect profile.\nTable B.7.2-1: Token Exchange Request standard required parameters\n\nAn example of a successful token exchange request might look like:\nEXAMPLE:\nPOST /as/token.oauth2 HTTP/1.1\nHost: IdM.server.com:9031\nAuthorization: Basic cnA33hpsb25nABClY3VyZS1yYW5kb20tc2VjdnV0\nContent-Type: application/x-www-form-urlencoded\ngrant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange\n&resource= IdM.partner_server.com\n&subject_token=baaR3jcJyb4BWCxGsndq23ScbdFMogUC5Pb233jKLTC\n&subject_token_type= urn%3Aietf%3Aparams%3Aoauth%3Atoken-type%3Ajwt\n\n",
                    "tables": [
                        {
                            "description": "Table B.7.2-1: Token Exchange Request standard required parameters",
                            "table number": 20,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.7.3\tToken Exchange Response",
                    "description": "",
                    "summary": "",
                    "text_content": "Upon successfully receiving and validating the token exchange request message from the MCX client, the IdM server shall return a token exchange response containing a security token specific to the partner IdMS.\nThe token exchange response standard parameters are shown in table B.7.3-1.\nTable B.7.3-1: Token exchange response standard required parameters\n\nAn example of a successful token exchange response might look like:\nEXAMPLE:\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-cache, no-store\n{\n\"access_token\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6IjllciJ9.eyJhdWQiOiJo\ndHRwczovL2JhY2tlbmQuZXhhbXBsZS5jb20iLCJpc3MiOiJodHRwczovL2FzLmV\n4YW1wbGUuY29tIiwiZXhwIjoxNDQxOTE3NTkzLCJpYXQiOjE0NDE5MTc1MzMsIn\nN1YiI6ImJjQGV4YW1wbGUuY29tIiwic2NwIjpbImFwaSJdfQ.MXgnpvPMo0nhce\nPwnQbunD2gw_pDyCFA-Saobl6gyLAdyPbaALFuAOyFc4XTWaPEnHV_LGmXklSTp\nz0yC7hlSQ\",\n\"issued_token_type\":\"urn:ietf:params:oauth:token-type:jwt\",\n\"token_type\":\"Bearer\",\n\"expires_in\":600\n}\n\n",
                    "tables": [
                        {
                            "description": "Table B.7.3-1: Token exchange response standard required parameters",
                            "table number": 21,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.7.4\tToken Request",
                    "description": "",
                    "summary": "",
                    "text_content": "In order to exchange the security token for an access token and (optional) refresh token, the MCX client makes a request to the partner authorization server's token endpoint by sending a token request message with the following parameters using the \"application/x-www-form-urlencoded\" format with a character encoding of UTF-8 in the HTTP request entity-body. Note that authentication of the security token by the partner IdMS is REQUIRED in order to exchange the security token for an access token. The security token shall be transported in the body of the token request message. The token request standard parameters are shown in table B.7.4-1.\nTable B.7.4-1: Token Request standard required parameters\n\nExamples of a successful token request might look like:\nEXAMPLE 1:\nPOST /as/token.oauth2 HTTP/1.1\nHost: IdM.server.com:9031\nCache-Control: no-cache\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer& assertion=eyJhbGciOiJFUzI1NiIsImtpZCI6IjllciJ9.eyJhdWQiOiJodHRwczovL2JhY2tlbmQuZXhhbXBsZS5jb20iLCJpc3MiOiJodHRwczovL2FzLmV4YW1wbGUuY29tIiwiZXhwIjoxNDQxOTE3NTkzLCJpYXQiOjE0NDE5MTc1MzMsInN1YiI6ImJjQGV4YW1wbGUuY29tIiwic2NwIjpbImFwaSJdfQ.MXgnpvPMo0nhcePwnQbunD2gw_pDyCFASaobl6gyLAdyPbaALFuAOyFc4XTWaPEnHV_LGmXklSTpz0yC7hlSQ&\nclient_id=myNativeApp&\nscope=openid 3gpp:mc:ptt_group_management_service&\n\nEXAMPLE 2:\nPOST /as/token.oauth2 HTTP/1.1\nHost: IdM.server.com:9031\nCache-Control: no-cache\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer& assertion=eyJhbGciOiJFUzI1NiIsImtpZCI6IjllciJ9.eyJhdWQiOiJodHRwczovL2JhY2tlbmQuZXhhbXBsZS5jb20iLCJpc3MiOiJodHRwczovL2FzLmV4YW1wbGUuY29tIiwiZXhwIjoxNDQxOTE3NTkzLCJpYXQiOjE0NDE5MTc1MzMsInN1YiI6ImJjQGV4YW1wbGUuY29tIiwic2NwIjpbImFwaSJdfQ.MXgnpvPMo0nhcePwnQbunD2gwpDyCFASaobl6gyLAdyPbaALFuAOyFc4XTWaPEnHV_LGmXklSTpz0yC7hlSQ&\nclient_id=myNativeApp&scope=openid 3gpp:mc:ptt_service,3gpp:mc:ptt_key_management_service,3gpp:mc:ptt_config_management_service,3gpp:mc:ptt_group_management_service&\n",
                    "tables": [
                        {
                            "description": "Table B.7.4-1: Token Request standard required parameters",
                            "table number": 22,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.7.5\tToken Response",
                    "description": "",
                    "summary": "",
                    "text_content": "If the token request is valid and authorized, the partner IdM server returns an access token to the MCX client specific to the user for the partner services and optionally a refresh token in a token response message; otherwise, it will return an error.\nThe token response standard parameters are shown in table B.7.5-1.\nTable B.7.5-1: Token response standard parameters\n\nAn example of a successful response might look like:\nEXAMPLE:\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n{\n\"access_token\":\"eyJhbGciOiJSUzI1NiJ9.eyJtY3B0dF9pZCI6ImFsaWNlQG9yZy5jb20iLCJleHAiOjE0NTM1MDYxMjEsInNjb3BlIjoib3BlbmlkIDNncHA6bWNwdHQ6cHR0X3NlcnZlciIsImNsaWVudF9pZCI6Im1jcHR0X2NsaWVudCJ9.yXGl0gu3SsRQ_VUrDTWuEp-X8wrj-xUzXzWhTnqntXn0fI6xLR0i6VHtY3L25w81u260bsOFUMiYLLBC0LOKi-SOcwMqrzH6_BZwjkRhExiAciHZNtwgIlHWYwpCuxQII0dcg7_bw_YAFEQQC9IDzsifPXl9JmazI8YMtGcAWohoiSi0KY1pnbORUDBSPLLFlekQH5aOWbe_6EF4pDbm5pH8GXLd_ZtxS7jC6tAAMsCvsRy7Pb_GeDr_jT8-IevGKWO82of7gaUQkF8qnKVagr4-qc2FJeSDuhj4ZvfL510cgcRGy4NJ_7xxS10bzFNLavfqOlgOelJv0KA9IAd-1Q\",\n \"refresh_token\": \"iTxQYALqlc7uLyFGpnl8tR8Y9gkw91mFy2qC9Yywkz\",\n \"token_type\": \"Bearer\",\n \"expires_in\": 7199\n}\n\nThe MCX client then uses the access token to make authorized requests to the partner MCX resource servers (MCPTT group management service, MCVideo group management service, MCData group management service, etc) on behalf of the end user.\n",
                    "tables": [
                        {
                            "description": "Table B.7.5-1: Token response standard parameters",
                            "table number": 23,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "B.8\tSecurity tokens",
            "description": "Security tokens are obtained from the primary IdMS and used for authentication with a partner IdMS.\nStandard claims are REQUIRED for MCX implementation. Other claims defined by OpenID Connect are optional. The standards-based claims for an MCX Connect ID security token are shown in table B.8-1.\nTable B.8-1: Security token standard claims\n\n",
            "summary": "",
            "tables": [
                {
                    "description": "Table B.8-1: Security token standard claims",
                    "table number": 24,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.9\tAccess tokens for partner services",
            "description": "Access tokens obtained from a partner IdMS and used for user service authorisation to services within the partner domain shall conform to the access token requirements and format described in clause B.2.2.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.10\tUsing the token to access MCX resource servers",
            "description": "MCX Connect shall initially support the bearer access token type. Access tokens of type \"bearer\" shall be communicated from the MCX client to MCX resource servers by including the access token in the HTTP Authorization Header, per IETF RFC 6750 [20].\nThe access token is opaque to the MCX client, meaning that the client does not have any knowledge of the access token itself. The client will be given some metadata corresponding to the access token, such as its expiration time, so that it does not send an expired access token to MCX resource servers. If the access token is presented to an MCX resource server and the scope is invalid or the token is expired or revoked, the MCX resource server should return an error message indicating such to the MCX client.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.11\tToken validation",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "B.11.1\tID token validation",
                    "description": "",
                    "summary": "",
                    "text_content": "The MCX client shall validate the ID token as per section 3.1.3.7 of the OpenID Connect 1.0 specification [21].\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.11.2\tAccess token validation",
                    "description": "",
                    "summary": "",
                    "text_content": "MCX resource servers shall validate access tokens received from the MCX client according to IETF RFC 7519 [32].\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.11.3\tSecurity token validation",
                    "description": "",
                    "summary": "",
                    "text_content": "The IdM server shall validate the security token as per section 3.1.3.7 of the OpenID Connect 1.0 specification [21].\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "B.12\tToken revocation",
            "description": "In order to limit the time validity of a token, the \"exp\" and \"expires_in\" parameters shall be used as a method of access token revocation.\nWithin the standard claims of an access token or security token, the \"exp\" parameter shall be used by the authorising server to determine whether or not the token is valid.  If the current time is beyond the time specified by the \"exp\" parameter, the associated token shall no longer be considered valid and any requests made with an expired token shall be rejected by the authorising server.\nWithin the standard claims of an access token response, token exchange response or token response message, the \"expires_in\" parameter shall be used by the UE client(s) to determine validity of the associated token.  If the current time is beyond the time specified by the \"expires_in\" parameter, the associated token shall no longer be considered valid and no client requests shall be made using the expired token.A refresh token may be used per annex B.5 to obtain a new access token.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.12\tIdMS interface security",
            "description": "The support of Transport Layer Security (TLS) between the IdM client in the MC UE and the IdM server is mandatory. The profile for TLS implementation and usage shall follow the provisions given in 3GPP TS 33.310 [5], annex E.\nIf PSK TLS based authentication is supported, the IdM client in the MC UE and the IdMS shall support the TLS version, PSK ciphersuites and TLS Extensions as specified in the TLS profile given in 3GPP TS 33.310 [5], annex E. The usage of pre-shared key ciphersuites for TLS is specified in the TLS profile given in 3GPP TS 33.310 [5], annex E.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.1\tDetailed flow for MC user authentication and registration using OpenID Connect",
            "description": "Figure C.1-1 shows the detailed flow for MC User Authentication and Registration using the OpenID Connect messages as described in annex B.\n\nThe figure depicts the OpenID Connect (OIDC) user authentication and registration process, showing the user's identity and credentials being validated and stored in the OpenID Connect server. The process involves the user providing their OpenID Connect credentials, which are then validated and stored in the server. The figure also shows the user's identity being registered in the OpenID Connect server, which is a crucial step in the authentication process.\nFigure C.1-1: OpenID Connect MC User Authentication and Registration\nStep 0:\tThe UE attaches/registers to the network, establishes normal connectivity, and sets up network security by following the procedures defined in TS 33.401 [14] or as defined in TS 33.501 [55]. Local P-CSCF in the Home IMS network is discovered at this point.\nStep 1:\tThe UE IMS/SIP Client authenticates with the primary IMS/SIP core. For IMS authentication, 3GPP TS 33.203 [9] applies.\nStep 2:\tThe SIP core sends a SIP 3rd Party Registration to the MCX application Server(s), notifying them of the MC UE SIP registration. The 3rd party REGISTER message includes the registered IMPU and S-CSCF's SIP-URI or IP Address.\nStep 3a:\tThe IdM client in the UE issues a HTTPS Authentication request to the OIDC based IdM Server in the MC network. The client includes the code_challenge value in this request.\nStep 3b:\tThe MC User Identity and associated credentials are provided to the IdM server. The credentials are successfully authenticated (and optionally authorized) by the IdM Server.\nStep 3c:\tThe IdM Server may optionally request user consent for granting the MCX client access to the MCX service in the MCX Server.\nStep 3d:\tThe IdM Server generates an authorization code that is associated with the code_challenge provided by the client. It sends a browser redirect HTTP message with the Authorization Response containing the authorization code.\nStep 3e:\tThe UE IdM Client performs a HTTP POST request to exchange the authorization code for an access token. In the request, the client includes the code-verifier string. This string is cryptographically associated with the code_challenge value provided in the Authorization Request in Step 3a.\nStep 3f:\tThe IdM Server verifies the IdM Client based on the received code-verifier string and issues a 200 OK with an access token and ID token (specific to the MC user and MCX service(s)) included in it.\nNOTE:\tThe server verifies by calculating the code challenge from the received code_verifier and comparing it with the code_challenge value provided by the client in Step 3a.\nStep 3g:\tThe access token and ID token are made available to the MCX client(s).\nStep 4:\tThe MC UE performs user service authorization.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.2\tDetailed flow for inter-domain MC user service authorization using OpenID Connect token exchange",
            "description": "Figure C.2-1 shows the detailed message flow for inter-domain MCX user authentication and service authorisation using the OpenID Connect token exchange method as described in Annex B.\nFigure C.2-1: Inter-domain user authentication and service authorisation\nSteps 0-3: These steps are the same as described in steps 0-3 of Figure C.1-1, which provide the initial network access, network security, HTTPS tunnel to IdM server, user authentication, IMS authentication, and SIP registration.\nStep 4:\tThis step represents the culmination of steps C-1 through C-5 in Figure 5.1.3.1-1, which authorises the user for services in the primary domain.  As part of this step the UE obtains the user's profile, which specifies both the local (primary domain) and the non-local (partner domain) group services.\nStep 5:\tFrom the user's profile, the UE identifies group service(s) home to a partner domain.  The user profile includes metadata of the group service(s) and information about the partner IdMS (i.e. the token endpoint host address and the \"aud\" parameter for use in the token exchange request).\nStep 6a:\tBased on the OAuth token exchange procedure, the UE IdM Client performs a HTTP POST (token exchange) request to the user's primary IdM Server token endpoint.  This request consists of the access token obtained in step 3 and information about the partner IdMS (i.e. the \"aud\" parameter obtained from the user profile group metadata).\nStep 6b:\tThe primary IdM Server token endpoint verifies the access token and returns a security token specific to the partner IdM Server.\nStep 7:\tThe UE establishes a secure HTTP tunnel with the partner IdM token endpoint using HTTPS.\nEditor's Note: It is FFS how the TLS tunnel between the visiting user and the partner systems IdM server is authenticated.\nStep 8a:\tThe UE IdM Client performs a HTTP POST token request to the partner IdM token endpoint to exchange the security token for an access token. This message is defined in [19].\nStep 8b:\tThe partner IdM Server token endpoint verifies the security token and issues an access token specific to the user and the user's local MC group service(s).\nNOTE 1:\tAdditional access tokens may be requested as needed by repeating steps 8a and 8b.\nStep 9:\tFor each group service, the GM client in the UE follows the \"Retrieve group configurations at the group management client\" flow as shown in clause 10.1.5.2 of TS 23.280 [36], presenting an access token in the Get group configuration request over HTTP.  If the access token is valid, the GMS authorises the user for the specific group management service.  Completion of this step results in the GMS sending the user's group policy information and group key information to the GM client.  This step is repeated for each additional group service that is home to this partner domain.\nNOTE 2:\tSteps 5–9 are repeated for user service authorization to services in each additional partner domain.\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "D.1\tGeneral aspects",
            "description": "This annex specifies the key management procedures between the KMS and the key management client that allows keys to be provisioned to the key management client based on an identity. It describes the requests and responses for the authorization following provisioning messages:\n-\tKMS Initialize.\n-\tKMS KeyProvision.\n-\tKMS CertCache.\n-\tKMS Cert.\n-\tKMS Discovery Lookup\n-\tKMS Discovery Upload\nAll KMS communications are made via HTTPS. The key management client is provisioned via XML content in the KMS's response. The XML content is designed to be extendable to allow KMS/client providers to add further information in the XML. Where the interface is extended, a different XML namespace should be used (so that may be ignored by non-compatible clients).\nIt is assumed that transmissions between the KMS and the key management client are secure and that the KMS has authenticated the identity of the key management client.\nAdditionally, to allow the transmission of key material securely between a secure element within the KMS and a secure element within the key management client, a security extension is defined which allows messages to be signed using the shared Integrity key (InK) or Transport Key (TrK) and key material to be encrypted using a shared Transport Key (TrK). The signature algorithm used to sign a KMS Request message or a KMS Response message shall be HMAC-SHA256 with a signature length of 256.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "D.2\tKMS requests",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "D.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "Requests to the KMS are made to specific resource URIs. Requests are made using a HTTP POST request to a URI. The content of the URI indicates the type of request. Resource URIs are rooted under the tree \"/keymanagement/identity/v1\" for a particular domain.\nFor example, the resource path to initialize a user within the domain \"example.org\" is:\nEXAMPLE:\nhttp://example.org/keymanagement/identity/v1/init\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.2.2\tKMS request security",
                    "description": "",
                    "summary": "",
                    "text_content": "The content of the KMS Request Type XML payload is:\nTable D.2.2-1: Contents of a KMS Request Type XML\n\nWhen application confidentiality is required by the MC operator, the TrK-ID of the TrK currently residing in the MC UE shall be included in the KMS request message as shown in Table D.2.2-1.\nWhen a signature is applied to the KMS request, the Signature-ID field in Table D.2.2-1 shall be present and indicate either the InK-ID if the InK is used or the TrK-ID if the TrK is used. When a signature is applied and the InK is present, the InK shall be used. When a signature is applied and an InK is not present but a TrK is present, then the TrK shall be used.\nThe XML schema for the SignedKmsRequestType is provided in Clause D.3.5.1.\nAn optional security extension may be used to authenticate the KMS request from the client. To use the optional security extension, the POST request shall be accompanied with an XML payload MIME type containing details of the request, signed by the shared InK or TrK.\nIf the KMS supports authenticated requests, upon receipt of a SignedKmsRequestType attached to a KMS Request, the KMS shall verify that:\n-\tthe signature is valid, based on the UserUri and the InK or TrK used to sign the message.\n-\tthe XML is valid.\n-\tthe KmsUri is the KMS's KMS URI.\n-\tthe Time is within a recent time window (e.g. 5 seconds).\n-\tthe ClientReqUrl is the same as the resource URI to which the HTTP POST request is sent.\nIf so, the request is accepted and processed.\n",
                    "tables": [
                        {
                            "description": "Table D.2.2-1: Contents of a KMS Request Type XML",
                            "table number": 25,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.2.3\tKMS Initialize request",
                    "description": "",
                    "summary": "",
                    "text_content": "To make a \"KMS Initialize\" request the key management client shall make a HTTP POST request to the subdirectory \"init\" i.e. Request-URI takes the form of:\nEXAMPLE:\n…/keymanagement/identity/v1/init\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.2.4\tKMS KeyProvision request",
                    "description": "",
                    "summary": "",
                    "text_content": "To make a \"KMS KeyProvision\" request the key management client shall make a HTTP POST request to the subdirectory \"keyprov\" i.e. Request-URI takes the form of\nEXAMPLE1:\n…/keymanagement/identity/v1/keyprov\n\nOptionally, the Request-URI of the POST request may contain a specific user or group URI which the key management client would like the KMS to provision. The URI shall be within a subdirectory of \"keyprov\". For example, the user URI \"sip:user@example.org\" is provisioned via a request to: \"/keymanagement/identity/v1/keyprov/sip%3Auser%40example.org\". Additionally, if the Request-URI contains a specific URI, the client may also request a specific time which the client would like the KMS to provision. The time URI shall be the same time as used in the MIKEY payload, a NTP-UTC 64-bit timestamp as defined in IETF RFC 5905 [29]. For example, if the user required keys specifically for 23rd Feb 2014 at 08:39:14.000 UTC, the request would be:\nEXAMPLE 2:\n…/keymanagement/identity/v1/keyprov/sip%3Auser%40example.org/D6B4323200000000\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.2.5\tKMS CertCache request",
                    "description": "",
                    "summary": "",
                    "text_content": "To make a \"KMS CertCache\" request the key management client shall make a HTTP POST request to the subdirectory \"certcache\". For example, the request-URI takes the form of \"/keymanagement/identity/v1/certcache\". If a cache has been previously received, the request URI may optionally be directed to the subdirectory indicating the number of the client's latest version of the cache. For example, the request-URI takes the form of\nEXAMPLE:\n…/keymanagement/identity/v1/certcache/12345\n\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.2.6\tKMS Cert request",
                    "description": "",
                    "summary": "",
                    "text_content": "\"KMS Cert\" requests are used to request the KMS certificate of a specific external KMS, referenced by the KMS's KMS URI.\nTo make a \"KMS Cert\" request the key management client shall make a HTTP POST request to the subdirectory \"cert\".  Within the subdirectory \"cert\", the POST request shall contain a specific KMS URI of the External KMS. For example, the request-URI takes the form:\nEXAMPLE:\n…/keymanagement/identity/v1/cert/kms.example.org\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.2.7\tKMS Lookup request",
                    "description": "",
                    "summary": "",
                    "text_content": "\"KMS Discovery Lookup\" requests are used to request the KMS certificate of a specific entity, referenced by the entity's URI.\nTo make a \"KMS Discovery Lookup\" request the key management client shall make a HTTP POST request to the subdirectory \"lookup\".  Within the subdirectory \"lookup\", the POST request shall contain a specific SIP URI of the entity. For example, the request-URI takes the form:\nEXAMPLE:\n…/keymanagement/identity/v1/lookup/user%40example.org\n\nThe KMS responds with a list of permitted KMS URIs for the target entity.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.2.8\tKMS Redirect Upload",
                    "description": "",
                    "summary": "",
                    "text_content": "\"KMS Redirect Upload\" messages are used to upload KMS Redirect Responses (KRRs) to the KMS for audit purposes.\nTo send a \"KMS Redirect Upload\" message the key management client shall make a HTTP POST request to the subdirectory \"redirect\".  Within the subdirectory \"redirect\", the POST request shall contain a specific SIP URI of the entity that resulted in the received KRR. For example, the request-URI takes the form:\nEXAMPLE:\n…/keymanagement/identity/v1/redirect/user%40example.org\n\nThe POST message shall be accompanied with an MIME type containing a \"KMS Request Type\" XML payload (as defined in Clause D.2.2). The XML payload shall contain one or more KMS Redirect Responses (KRRs). The \"KMS Request Type\" XML payload may also be signed as defined in Clause D.2.2.\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "D.3\tKMS responses",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "D.3.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "This clause defines the HTTP responses made by the KMS to KMS requests. The KMS attaches XML content to the HTTP responses. The XML serves to provision the client based upon its request.\nThough a \"KmsResponse\" message containing a \"KmsMessage\" Type is the general response to any request, the content of the \"KmsMessage\" varies depending on the exact response type (i.e. KmsInit, KmsKeyProv, KmsCertCache, KmsLookup).\nThe content provided within a KmsInit, KmsKeyProv, KmsCertCache or KmsLookup may include a TrK, InK, KMS URIs, (public) KMS Certificates, (private) user Key Set provisioning, or combinations thereof.\nThe \"KmsResponse\" message is shown in Table D.3.1-1.\nTable D.3.1-1: Contents of a \"KmsResponse\" message\n\nIn response to a \"KMS Initialize\" request, the KMS shall respond with the KMS's own certificate (the Root KMS certificate), and may respond with a new TrK and/or a new InK. The data is returned within a \"KMSInit\" tag.\nIn response to a \"KMS KeyProvision\" request, the KMS shall provision appropriate user Key Sets within a \"KMSKeyProv\" tag, and may also respond with a new TrK and/or a new InK.\nIn response to a \"KMS CertCache\" request, the KMS shall provision a cache of KMS certificates allowing inter-domain communications within a \"KMSCertCache\" tag.\nIn response to a \"KMS Cert\" request, the KMS shall provision a single KMS certificate within a \"KMSCertCache\" tag. If the requested KMS Certificate is not available, then an error message is returned.\nIn response to a \"KMS Lookup\" request, the KMS shall provide information on the KMS URI associated with the requested SIP URI, within a \"KMSLookup\" tag.\nThe KMS does not respond to a \"KMS Redirect Upload\" message, unless an error occurs.\nWhen confidentiality is applied to the KmsResponse payload (KmsMessage), the KMS shall use the TrK currently residing in the MC UE to encrypt the KmsMessage. The associated TrK-ID shall then be included in the KmsResponse message as shown in Table D.3.1-1.\nWhen protecting a KmsResponse payload, the <EncryptedData> element may:\n-\tUse the 'Type' attribute specifying that content is encrypted ('http://www.w3.org/2001/04/xmlenc#Content').\n-\tContain <KeyData><KeyInfo> element containing the base64 encoded TrK-ID.\n-\tContain <EncryptionMethod> element listing the encryption algorithm used for encrypting the XML content. The AES-128-GCM algorithm as defined in [42] shall be supported, as identified by the algorithm identifier: 'http://www.w3.org/2009/xmlenc11#aes128-gcm'.\nWhen a signature is applied to the KmsResponse message, the Signature-ID field in Table D.3.1-1 shall be present and indicate either the InK-ID if the InK is used or the TrK-ID if the TrK is used. When a signature is applied and the InK is present, the InK shall be used. When a signature is applied and an InK is not present but a TrK is present, then the TrK shall be used.\nThe XML schema for the SignedKmsRequestType is provided in Clause D.3.5.1.\n",
                    "tables": [
                        {
                            "description": "Table D.3.1-1: Contents of a \"KmsResponse\" message",
                            "table number": 26,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.3.2\tKMS certificates",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "D.3.2.1\tDescription",
                            "text_content": "A KMS Certificate is a certificate that applies to an entire domain of users. A Certificate consists of XML containing the information required to encrypt messages to a domain of users and verify signatures from the domain of users.\nA KMS has exactly one root certificate at any one time, which contains the public keys used by the KMS. The root certificate is the only certificate for which the KMS has the private keys and is able to issue user-specific key material. Should the root certificate need to be updated, a new KMS with a new KMS URI should be established with a new root certificate.\nIt is assumed that the user is managed by a single KMS. The root certificate for this KMS is required to encrypt messages to the user, and verify signatures from the user.\nThe KMS may also provision a number of 'external' KMS certificates to allow inter-domain communications.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "D.3.2.2\tFields",
                            "text_content": "The KMS Certificate shall be within a XML tag named \"KmsCertificate\". This type shall have the following subfields.\nTable D.3.2.2-1: Contents of a KMS Certificate\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table D.3.2.2-1: Contents of a KMS Certificate",
                                    "table number": 27,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "D.3.2.3\tUser IDs",
                            "text_content": "To secure communications with a specific user, the initiator shall compose the User Identifier (UID) to which the message will be encrypted. IETF RFC 6509 [11] defines a UID generation scheme for Tel URIs, however this cannot be used with Mission Critical Services as MC Service IDs are not Tel URIs.\nClause F.2.1 defines the UID generation scheme for the Mission Critical System. This shall be identified within the KMS certificate by using the value '2' within the UserIDFormat field.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "D.3.3\tUser Key Provision",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "D.3.3.1\tDescription",
                            "text_content": "User keys are private information associated to a user's identity (UserID) which allow a user to decrypt information encrypted to that identity and sign information as that identity. User keys are provisioned as XML containing the key information required and associated metadata.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "D.3.3.2\tFields",
                            "text_content": "The KMS shall provision keys within an XML tag named \"KmsKeySet\". This shall have the following subfields.\nTable D.3.3.2-1: Contents of a KMS Key Set\n\nNOTE:\tThe key may be valid outside of its defined key period of use to enable decryption of old messages encrypted to the user.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table D.3.3.2-1: Contents of a KMS Key Set",
                                    "table number": 28,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "D.3.4\tExample KMS response XML",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "D.3.4.1\tExample KMSInit XML",
                            "text_content": "If the security extension is used, it is assumed that before this response is received, the secure element within the KMS and the secure element within the key management client have shared a bootstrap TrK, e.g. 'tk.11.user@example.org'.\nIn this example, the KMS provides the user with the KMS root certificate and a new TrK to protect future KMS communications. Keys are encrypted and the message is signed using the bootstrap TrK.\nEXAMPLE:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<SignedKmsResponse xmlns=\"urn:3gpp:ns:mcsecKMSInterface:1.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\nId=\"xmldoc\">\n<KmsResponse Version=\"1.0.0\">\n<UserUri>example:user@example.org</UserUri>\n<KmsUri>kms.example.org</KmsUri>     <Time>2014-01-26T10:05:52</Time>\n<KmsId>KMSProvider12345</KmsId>\n<ClientReqUrl>http://kms.example.org/keymanagement/identity/v1/init</ClientReqUrl>\n<KmsMessage>\n<KmsInit Version=\"1.0.0\" xsi:type=\"KmsInitTkIkType\">\n<KmsCertificate Version=\"1.1.0\" Role=\"Root\">\n<CertUri>cert1.kms.example.org</CertUri>\n<KmsUri>kms.example.org</KmsUri>\n<Issuer>www.example.org</Issuer>\n<ValidFrom>2000-01-26T00:00:00</ValidFrom>\n<ValidTo>2025-01-26T23:59:59</ValidTo>\n<Revoked>false</Revoked>\n<UserIdFormat>2</UserIdFormat>\n<UserKeyPeriod>2592000</UserKeyPeriod>\n<UserKeyOffset>0</UserKeyOffset>\n<PubEncKey>029A2F</PubEncKey>\n<PubAuthKey>029A2F</PubAuthKey>\n<ParameterSet>1</ParameterSet>\n<KmsDomainList>\n<KmsDomain>sec1.example.org</KmsDomain>\n<KmsDomain>sec2.example.org</KmsDomain>\n</KmsDomainList>\n</KmsCertificate>\n<NewTransportKey xmlns=\"urn:3gpp:ns:mcsecKMSInterface:1.0\">\n<EncryptedKey xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#EncryptedKey\">\n<EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#kw-aes256\"/>\n<ds:KeyInfo>\n<ds:KeyName>\ntk.11.user@example.org</ds:KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>DEADBEEF</CipherValue>\n</CipherData>\n<CarriedKeyName>tk.12.user@example.org</CarriedKeyName>\n</EncryptedKey>\n</NewTransportKey>\n<NewIntegrityKey xmlns=\"urn:3gpp:ns:mcsecKMSInterface:1.0\">\n<EncryptedKey xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#EncryptedKey\">\n<EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#kw-aes256\"/>\n<ds:KeyInfo>\n<ds:KeyName>\ntk.11.user@example.org</ds:KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>DEADBEEF</CipherValue>\n</CipherData>\n<CarriedKeyName>ink.12.user@example.org</CarriedKeyName>\n</EncryptedKey>\n</NewIntegrityKey>\n</KmsInit>\n</KmsMessage>\n</KmsResponse>\n<Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n<SignedInfo>\n<CanonicalizationMethod Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n<SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#hmac-sha256\">\n<HMACOutputLength>256</HMACOutputLength>\n</SignatureMethod>\n<Reference URI=\"#xmldoc\">\n<DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/>\n<DigestValue>nnnn</DigestValue>\n</Reference>\n</SignedInfo>\n<SignatureValue>DEADBEEF</SignatureValue>\n<KeyInfo>\n<KeyName>tk.11.user@example.org</KeyName>\n</KeyInfo>\n</Signature>\n</SignedKmsResponse>\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "D.3.4.2\tExample KMSKeyProv XML",
                            "text_content": "In this example, the user's key material is provided for two user identifiers. The key material includes the UserDecryptKey (see IETF RFC 6508 [10]) and the UserSigningKey and PVT (see IETF RFC 6507 [9]) for each identifier.\nAs the security extension has been used, the key material is encrypted using the shared TrK and the message signed using the shared InK. Additionally, a new TrK is provided as part of the key provision.\nEXAMPLE:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<SignedKmsResponse xmlns=\"urn:3gpp:ns:mcsecKMSInterface:1.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\nId=\"xmldoc\">\n<KmsResponse Version=\"1.0.0\">\n<UserUri>example:user@example.org</UserUri>\n<KmsUri>kms.example.org</KmsUri>    <Time>2014-01-26T10:07:14</Time>\n<KmsId>KMSProvider12345</KmsId>\n<ClientReqUrl>http://kms.example.org/keymanagement/identity/v1/keyprov</ClientReqUrl>\n<KmsMessage>\n<KmsKeyProv Version = \"1.0.0\" xsi:type=\"KmsKeyProvTkIkType\">\n<KmsKeySet Version = \"1.1.0\">\n<KmsUri>kms.example.org</KmsUri>\n<CertUri>cert1.kms.example.org</CertUri>\n<Issuer>www.example.org</Issuer>\n<UserUri>example:user@example.org</UserUri>\n<UserID>0123456789ABCDEF0123456789ABCDEF</UserID>\n<ValidFrom>2015-12-30T00:00:00</ValidFrom>\n<ValidTo>2016-03-29T23:59:59</ValidTo>\n<KeyPeriodNo>1514</KeyPeriodNo>\n<Revoked>false</Revoked>\n<UserDecryptKey xsi:type=\"EncKeyContentType\">\n<EncryptedKey xmlns=\"http://www.w3.org/2001/04/xmlenc#\">\n<EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#kw-aes256\"/>\n<ds:KeyInfo>\n<ds:KeyName>tk.12.user@example.org</ds:KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>DEADBEEF</CipherValue>\n</CipherData>\n</EncryptedKey>\n</UserDecryptKey>\n<UserSigningKeySSK xsi:type=\"EncKeyContentType\">\n<EncryptedKey xmlns=\"http://www.w3.org/2001/04/xmlenc#\">\n<EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#kw-aes256\"/>\n<ds:KeyInfo>\n<ds:KeyName>tk.12.user@example.org</ds:KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>DEADBEEF</CipherValue>\n</CipherData>\n</EncryptedKey>\n</UserSigningKeySSK>\n<UserPubTokenPVT xsi:type=\"EncKeyContentType\">\n<EncryptedKey xmlns = \"http://www.w3.org/2001/04/xmlenc#\">\n<EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#kw-aes256\"/>\n<ds:KeyInfo>\n<ds:KeyName>tk.12.user@example.org</ds:KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>DEADBEEF</CipherValue>\n</CipherData>\n</EncryptedKey>\n</UserPubTokenPVT>\n</KmsKeySet>\n<KmsKeySet Version = \"1.1.0\">\n<KmsUri>kms.example.org</KmsUri>\n<CertUri>cert1.kms.example.org</CertUri>\n<Issuer>www.example.org</Issuer>\n<UserUri>example:user.pseudonym@example.org</UserUri>\n<UserID>0011223344556677889900AABBCCDDEEFF</UserID>\n<ValidFrom>2015-12-30T00:00:00</ValidFrom>\n<ValidTo>2016-03-29T23:59:59</ValidTo>\n<KeyPeriodNo>1514</KeyPeriodNo>\n<Revoked>false</Revoked>\n<UserDecryptKey xsi:type=\"EncKeyContentType\">\n<EncryptedKey xmlns=\"http://www.w3.org/2001/04/xmlenc#\">\n<EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#kw-aes256\"/>\n<ds:KeyInfo>\n<ds:KeyName>tk.12.user@example.org</ds:KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>DEADBEEF</CipherValue>\n</CipherData>\n</EncryptedKey>\n</UserDecryptKey>\n<UserSigningKeySSK xsi:type=\"EncKeyContentType\">\n<EncryptedKey xmlns=\"http://www.w3.org/2001/04/xmlenc#\">\n<EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#kw-aes256\"/>\n<ds:KeyInfo>\n<ds:KeyName>tk.12.user@example.org</ds:KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>DEADBEEF</CipherValue>\n</CipherData>\n</EncryptedKey>\n</UserSigningKeySSK>\n<UserPubTokenPVT xsi:type=\"EncKeyContentType\">\n<EncryptedKey xmlns=\"http://www.w3.org/2001/04/xmlenc#\">\n<EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#kw-aes256\"/>\n<ds:KeyInfo>\n<ds:KeyName>tk.12.user@example.org</ds:KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>DEADBEEF</CipherValue>\n</CipherData>\n</EncryptedKey>\n</UserPubTokenPVT>\n</KmsKeySet>\n<NewTransportKey>\n<EncryptedKey xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#EncryptedKey\">\n<EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#kw-aes256\"/>\n<ds:KeyInfo>\n<ds:KeyName>tk.12.user@example.org</ds:KeyName>\n</ds:KeyInfo>\n<CipherData>\n<CipherValue>DEADBEEF</CipherValue>\n</CipherData>\n<CarriedKeyName>tk.13.user@example.org</CarriedKeyName>\n</EncryptedKey>\n</NewTransportKey>\n</KmsKeyProv>\n</KmsMessage>\n</KmsResponse>\n<Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n<SignedInfo>\n<CanonicalizationMethod Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n<SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#hmac-sha256\">\n<HMACOutputLength>256</HMACOutputLength>\n</SignatureMethod>\n<Reference URI=\"#xmldoc\">\n<DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/>\n<DigestValue>nnnn</DigestValue>\n</Reference>\n</SignedInfo>\n<SignatureValue>DEADBEEF</SignatureValue>\n<KeyInfo>\n<KeyName>ink.12.user@example.org</KeyName>\n</KeyInfo>\n</Signature>\n</SignedKmsResponse>\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "D.3.4.3\tExample KMSCertCache XML",
                            "text_content": "In this example, a number of 'external' KMS certificates are provided to the user. These allow the user to encrypt to users managed by a different KMS.\nAs the security extension is in use, the message is signed using the shared InK.\nEXAMPLE:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<SignedKmsResponse xmlns=\"urn:3gpp:ns:mcsecKMSInterface:1.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\nId=\"xmldoc\">\n<KmsResponse Version=\"1.0.0\">\n<UserUri>example:user@example.org</UserUri>\n<KmsUri>kms.example.org</KmsUri>\n<Time>2014-01-26T10:14:12</Time>\n<KmsId>KMSProvider12345</KmsId>\n<ClientReqUrl>http://kms.example.org/keymanagement/identity/v1/certcache</ClientReqUrl>\n<KmsMessage>\n<KmsCertCache Version = \"1.0.0\">\n<SignedKmsCertificate Id = \"cert1\">\n<KmsCertificate Version = \"1.1.0\" Role = \"External\">\n<CertUri>cert2.kms.example.org</CertUri>\n<KmsUri>kms.example.org</KmsUri>\n<Issuer>www.example.org</Issuer>\n<ValidFrom>2000-01-26T00:00:00</ValidFrom>\n<ValidTo>2100-01-26T23:59:59</ValidTo>\n<Revoked>false</Revoked>\n<UserIdFormat>2</UserIdFormat>\n<UserKeyPeriod>2592000</UserKeyPeriod>\n<UserKeyOffset>0</UserKeyOffset>\n<PubEncKey>029A2F</PubEncKey>\n<PubAuthKey>029A2F</PubAuthKey>\n<ParameterSet>1</ParameterSet>\n<KmsDomainList>\n<KmsDomain>sec3.example.org</KmsDomain>\n</KmsDomainList>\n</KmsCertificate>\n<Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n<SignedInfo>\n<CanonicalizationMethod Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n<SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256\"/>\n<Reference URI=\"#cert1\">\n<DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/>\n<DigestValue>nnnn</DigestValue>\n</Reference>\n</SignedInfo>\n<SignatureValue>DEADBEEF</SignatureValue>\n<KeyInfo>\n<KeyName>cert1.kms.example.org</KeyName>\n</KeyInfo>\n</Signature>\n</SignedKmsCertificate>\n<SignedKmsCertificate Id=\"cert2\">\n<KmsCertificate Version=\"1.1.0\" Role=\"External\">\n<CertUri>cert1.kms.another.example.org</CertUri>\n<KmsUri>kms.another.example.org</KmsUri>\n<Issuer>www.another.example.org</Issuer>\n<ValidFrom>2000-01-26T00:00:00</ValidFrom>\n<ValidTo>2100-01-26T23:59:59</ValidTo>\n<Revoked>false</Revoked>\n<UserIdFormat>2</UserIdFormat>\n<UserKeyPeriod>604800</UserKeyPeriod>\n<UserKeyOffset>432000</UserKeyOffset>\n<PubEncKey>029A2F</PubEncKey>\n<PubAuthKey>029A2F</PubAuthKey>\n<ParameterSet>1</ParameterSet>\n<KmsDomainList>\n<KmsDomain>another.example.org</KmsDomain>\n</KmsDomainList>\n</KmsCertificate>\n<Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n<SignedInfo>\n<CanonicalizationMethod Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n<SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256\"/>\n<Reference URI=\"#cert2\">\n<DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/>\n<DigestValue>nnnn</DigestValue>\n</Reference>\n</SignedInfo>\n<SignatureValue>DEADBEEF</SignatureValue>\n<KeyInfo>\n<KeyName>cert1.kms.example.org</KeyName>\n</KeyInfo>\n</Signature>\n</SignedKmsCertificate>\n</KmsCertCache>\n</KmsMessage>\n</KmsResponse>\n<Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n<SignedInfo>\n<CanonicalizationMethod Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n<SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#hmac-sha256\">\n<HMACOutputLength>256</HMACOutputLength>\n</SignatureMethod>\n<Reference URI=\"#xmldoc\">\n<DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/>\n<DigestValue>nnnn</DigestValue>\n</Reference>\n</SignedInfo>\n<SignatureValue>DEADBEEF</SignatureValue>\n<KeyInfo>\n<KeyName>ink.12.user@example.org</KeyName>\n</KeyInfo>\n</Signature>\n</SignedKmsResponse>\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "D.3.5\tKMS response XML schema",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "D.3.5.1\tBase XML schema",
                            "text_content": "This clause contains the  XML schema  for KMS responses. This will validate Version '1.1.0' or '1.2.0' certificates:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\nxmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\nxmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\nxmlns:krr=\"urn:3gpp:ns:mcsecKMSKRR:1.0\"\nxmlns=\"urn:3gpp:ns:mcsecKMSInterface:1.0\"\ntargetNamespace=\"urn:3gpp:ns:mcsecKMSInterface:1.0\"\nelementFormDefault=\"qualified\" version=\"1.0\">\n\n<xsd:import namespace = \"http://www.w3.org/2000/09/xmldsig#\" />\n<xsd:import namespace = \"http://www.w3.org/2001/04/xmlenc#\" />\n<xsd:import namespace =\"urn:3gpp:ns:mcsecKMSKRR:1.0\"/>\n\n<!-- Global elements -->\n<xsd:element name=\"KmsRequest\" type=\"KmsRequestType\" />\n<xsd:element name=\"SignedKmsRequest\" type=\"SignedKmsRequestType\"/>\n\n<xsd:element type=\"KmsResponseType\" name=\"KmsResponse\"/>\n<xsd:element type=\"SignedKmsResponseType\" name=\"SignedKmsResponse\"/>\n\n<!-- KMS Request Type definitions (see clause D.2.2) -->\n<xsd:complexType name = \"KmsRequestType\">\n<xsd:sequence>\n<xsd:element name=\"UserUri\" type=\"xsd:anyURI\"/>\n<xsd:element name=\"KmsUri\" type=\"xsd:anyURI\"/>\n<xsd:element name=\"Time\" type=\"xsd:dateTime\"/>\n<xsd:element name=\"ClientId\" type=\"xsd:string\" minOccurs=\"0\"/>\n<xsd:element name=\"DeviceId\" type=\"xsd:string\" minOccurs=\"0\"/>\n<xsd:element name=\"ClientReqUrl\" type=\"xsd:anyURI\"/>\n<xsd:element name=\"KrrList\" type=\"krr:KmsRedirectResponseType\" minOccurs=\"0\"></xsd:element>\n<xsd:element name=\"ClientError\" type=\"ErrorType\" minOccurs=\"0\"/>\n<!-- Can extend in another namespace - for more types of communication-->\n<xsd:any namespace=\"##other\" processContents=\"lax\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n</xsd:sequence>\n<xsd:attribute name=\"Id\" type=\"xsd:string\"/>\n<xsd:attribute name=\"Version\" type=\"xsd:string\" fixed=\"1.1.0\"/>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n<xsd:complexType name=\"SignedKmsRequestType\">\n<xsd:sequence>\n<xsd:element name=\"KmsRequest\" type=\"KmsRequestType\"/>\n<xsd:element ref=\"ds:Signature\"/>\n</xsd:sequence>\n<xsd:attribute name=\"Id\" type=\"xsd:string\"/>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n<xsd:complexType name = \"ErrorType\">\n<xsd:sequence>\n<xsd:element type = \"xsd:integer\" name = \"ErrorCode\" maxOccurs = \"1\"/>\n<xsd:element type = \"xsd:string\" name = \"ErrorMsg\" maxOccurs = \"1\"/>\n<xsd:any namespace = \"##other\" processContents = \"lax\" minOccurs = \"0\" maxOccurs = \"unbounded\"/>\n</xsd:sequence>\n<xsd:attribute name = \"Id\" type = \"xsd:string\"/>\n<xsd:attribute name = \"Version\" type = \"xsd:string\"/>\n<xsd:anyAttribute namespace = \"##other\" processContents = \"lax\"/>\n</xsd:complexType>\n\n<!-- KMS Response Type definitions (see clause D.2.3) -->\n<xsd:complexType name=\"KmsResponseType\">\n<xsd:sequence>\n<xsd:element name=\"UserUri\" type=\"xsd:anyURI\"/>\n<xsd:element name=\"KmsUri\" type=\"xsd:anyURI\"/>\n<xsd:element name=\"Time\"  type=\"xsd:dateTime\"/>\n<xsd:element name=\"KmsId\" type=\"xsd:string\" minOccurs = \"0\"/>\n<xsd:element name=\"ClientReqUrl\" type = \"xsd:anyURI\"/>\n<xsd:element name=\"KmsMessage\" type=\"KMSMessage\" minOccurs = \"0\" />\n<xsd:element name=\"KmsError\" type=\"ErrorType\" minOccurs = \"0\"/>\n<xsd:any namespace = \"##other\" processContents = \"lax\" minOccurs = \"0\" maxOccurs = \"unbounded\"/>\n</xsd:sequence>\n<xsd:attribute name=\"Id\" type=\"xsd:string\"/>\n<xsd:attribute name=\"Version\" type=\"xsd:string\" fixed=\"1.0.0\"/>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n\n<xsd:complexType name=\"SignedKmsResponseType\">\n<xsd:sequence>\n<xsd:element ref=\"KmsResponse\"/>\n<xsd:element ref=\"ds:Signature\" minOccurs=\"0\"/>\n</xsd:sequence>\n<xsd:attribute name=\"Id\" type=\"xsd:string\"/>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n<xsd:complexType name=\"KMSMessage\">\n<xsd:choice>\n<xsd:element name=\"KmsInit\" type=\"KmsInitType\"/>\n<xsd:element name=\"KmsKeyProv\" type=\"KmsKeyProvType\"/>\n<xsd:element name=\"KmsCertCache\" type=\"KmsCertCacheType\"/>\n<xsd:any namespace=\"##other\" processContents=\"lax\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n</xsd:choice>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n<xsd:complexType name=\"KmsInitType\">\n<xsd:sequence>\n<xsd:choice>\n<xsd:element name=\"SignedKmsCertificate\" type=\"SignedKmsCertificateType\"/>\n<xsd:element name=\"KmsCertificate\" type=\"KmsCertificateType\"/>\n</xsd:choice>\n<xsd:any namespace=\"##other\" processContents=\"lax\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n</xsd:sequence>\n<xsd:attribute name=\"Id\" type=\"xsd:string\"/>\n<xsd:attribute name=\"Version\" type=\"xsd:string\"/>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n<xsd:complexType name=\"KmsKeyProvType\">\n<xsd:sequence>\n<xsd:element name=\"KmsKeySet\" type=\"KmsKeySetType\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n<xsd:any namespace=\"##other\" processContents=\"lax\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n</xsd:sequence>\n<xsd:attribute name=\"Id\" type=\"xsd:string\"/>\n<xsd:attribute name=\"Version\" type=\"xsd:string\" fixed=\"1.0.0\"/>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n<xsd:complexType name=\"KmsCertCacheType\">\n<xsd:sequence>\n<xsd:element name=\"SignedKmsCertificate\" type=\"SignedKmsCertificateType\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n<xsd:element name=\"KmsCertificate\" type=\"KmsCertificateType\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n<xsd:any namespace=\"##other\" processContents=\"lax\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n</xsd:sequence>\n<xsd:attribute name=\"Id\" type=\"xsd:string\"/>\n<xsd:attribute name=\"Version\" type=\"xsd:string\" fixed=\"1.0.0\"/>\n<xsd:attribute name=\"CacheNum\" type=\"xsd:integer\"/>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n<!-- KmsCertificate definition - see clause D.3.2.2 -->\n<xsd:element name = \"KmsCertificate\" type = \"KmsCertificateType\"/>\n<xsd:complexType name = \"KmsCertificateType\">\n<xsd:sequence>\n<xsd:element name=\"CertUri\" type=\"xsd:anyURI\" minOccurs = \"0\"/>\n<xsd:element name=\"KmsUri\" type=\"xsd:anyURI\"/>\n<xsd:element name=\"Issuer\" type=\"xsd:string\" minOccurs = \"0\"/>\n<xsd:element name=\"ValidFrom\" type=\"xsd:dateTime\" minOccurs = \"0\"/>\n<xsd:element name=\"ValidTo\" type=\"xsd:dateTime\" minOccurs = \"0\"/>\n<xsd:element name=\"Revoked\" type=\"xsd:boolean\" minOccurs = \"0\"/>\n<xsd:element name=\"UserIdFormat\" type=\"xsd:string\"/>\n<xsd:element name=\"UserKeyPeriod\" type=\"xsd:integer\"/>\n<xsd:element name=\"UserKeyOffset\" type=\"xsd:integer\"/>\n<xsd:element name=\"PubEncKey\" type=\"xsd:hexBinary\"/>\n<xsd:element name=\"PubAuthKey\" type=\"xsd:hexBinary\"/>\n<xsd:element name=\"ParameterSet\" type=\"xsd:integer\" minOccurs = \"0\"/>\n<xsd:element name=\"KmsDomainList\" minOccurs = \"0\">\n<xsd:complexType>\n<xsd:sequence>\n<xsd:element type = \"xsd:anyURI\" name = \"KmsDomain\" maxOccurs = \"unbounded\"/>\n</xsd:sequence>\n</xsd:complexType>\n</xsd:element>\n<xsd:any namespace = \"##other\" processContents = \"lax\" minOccurs = \"0\" maxOccurs = \"unbounded\"/>\n</xsd:sequence>\n<xsd:attribute name = \"Id\" type = \"xsd:string\"/>\n<xsd:attribute name = \"Version\" type = \"xsd:string\"/>\n<xsd:attribute name = \"Role\" type = \"RoleType\"/>\n<xsd:attribute name = \"IsSecurityGateway\" type = \"xsd:boolean\" use=\"optional\"/>\n<xsd:anyAttribute namespace = \"##other\" processContents = \"lax\"/>\n</xsd:complexType>\n\n<xsd:simpleType name = \"RoleType\">\n<xsd:restriction base = \"xsd:string\">\n<xsd:enumeration value = \"Root\"/>\n<xsd:enumeration value = \"External\"/>\n</xsd:restriction>\n</xsd:simpleType>\n\n<xsd:element name=\"SignedKmsCertificate\" type=\"SignedKmsCertificateType\"/>\n<xsd:complexType name=\"SignedKmsCertificateType\">\n<xsd:sequence>\n<xsd:element name=\"KmsCertificate\" type=\"KmsCertificateType\"/>\n<xsd:element ref=\"ds:Signature\" minOccurs=\"0\"/>\n</xsd:sequence>\n<xsd:attribute name=\"Id\" type=\"xsd:string\"/>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n<xsd:element name=\"KmsKeySet\" type=\"KmsKeySetType\"/>\n\n<xsd:complexType name = \"KmsKeySetType\">\n<xsd:sequence>\n<xsd:element name=\"KmsUri\" type=\"xsd:anyURI\"/>\n<xsd:element name=\"CertUri\" type=\"xsd:anyURI\" minOccurs = \"0\"/>\n<xsd:element name=\"Issuer\" type=\"xsd:string\" minOccurs = \"0\"/>\n<xsd:element name=\"UserUri\" type=\"xsd:anyURI\"/>\n<xsd:element name=\"UserID\" type=\"xsd:string\"/>\n<xsd:element name=\"ValidFrom\" type=\"xsd:dateTime\" minOccurs = \"0\"/>\n<xsd:element name=\"ValidTo\" type=\"xsd:dateTime\" minOccurs = \"0\"/>\n<xsd:element name=\"KeyPeriodNo\" type=\"xsd:integer\"/>\n<xsd:element name=\"Revoked\" type=\"xsd:boolean\" minOccurs = \"0\"/>\n<xsd:element name=\"UserDecryptKey\" type=\"abstractKeyContentType\"/>\n<xsd:element name=\"UserSigningKeySSK\" type=\"abstractKeyContentType\"/>\n<xsd:element name=\"UserPubTokenPVT\" type=\"abstractKeyContentType\"/>\n</xsd:sequence>\n<xsd:attribute name=\"Id\" type=\"xsd:string\"/>\n<xsd:attribute name=\"Version\" type=\"xsd:string\" fixed=\"1.1.0\"/>\n<xsd:anyAttribute namespace=\"##other\" processContents=\"lax\"/>\n</xsd:complexType>\n\n<xsd:complexType name=\"abstractKeyContentType\" abstract=\"true\" mixed=\"true\" />\n\n<xsd:complexType name = \"KeyContentType\">\n<xsd:simpleContent>\n<xsd:restriction base = \"abstractKeyContentType\">\n<xsd:simpleType>\n<xsd:restriction base=\"xsd:hexBinary\"></xsd:restriction>\n</xsd:simpleType>\n</xsd:restriction>\n</xsd:simpleContent>\n</xsd:complexType>\n\n<xsd:complexType name=\"EncKeyContentTypeMixed\" mixed=\"false\" abstract=\"true\">\n<xsd:complexContent>\n<xsd:restriction base=\"abstractKeyContentType\">\n<xsd:sequence>\n</xsd:sequence>\n</xsd:restriction>\n</xsd:complexContent>\n</xsd:complexType>\n\n<xsd:complexType name=\"EncKeyContentType\">\n<xsd:complexContent>\n<xsd:extension base=\"EncKeyContentTypeMixed\">\n<xsd:sequence>\n<xsd:element ref=\"xenc:EncryptedKey\"/>\n</xsd:sequence>\n</xsd:extension>\n</xsd:complexContent>\n</xsd:complexType>\n\n<xsd:complexType name=\"KmsInitTkIkType\">\n<xsd:complexContent>\n<xsd:extension base=\"KmsInitType\">\n<xsd:sequence>\n<xsd:element type=\"EncKeyContentType\" name=\"NewTransportKey\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\n<xsd:element type=\"EncKeyContentType\" name=\"NewIntegrityKey\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\n</xsd:sequence>\n</xsd:extension>\n</xsd:complexContent>\n</xsd:complexType>\n\n<xsd:complexType name = \"KmsKeyProvTkIkType\">\n<xsd:complexContent>\n<xsd:extension base=\"KmsKeyProvType\">\n<xsd:sequence>\n<xsd:element type=\"EncKeyContentType\" name=\"NewTransportKey\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\n<xsd:element type=\"EncKeyContentType\" name=\"NewIntegrityKey\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\n</xsd:sequence>\n</xsd:extension>\n</xsd:complexContent>\n</xsd:complexType>\n\n</xsd:schema>\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "D.3.5.2\tVoid",
                            "text_content": "",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "D.3.5.3\tBase XML schema extensions",
                            "text_content": "The following are extensions to the base XML schema defined in clause D.3.5.1. These extensions provide support for the TrK-ID and Signature-ID parameters used in the KmsRequest message (clause D.2.2) and the KmsResponse message (clause D.3.1). When the TrK-ID is present, there shall be a maximum occurance of one TrK-ID. When the Signature-ID is present, there shall be a maximum occurance of one Signature-ID.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"urn:3gpp:ns:mcsecKMSInterface:extensions:1.0\" targetNamespace=\"urn:3gpp:ns:mcsecKMSInterface:extensions:1.0\" elementFormDefault=\"qualified\" version=\"1.0\">\n<xsd:element name=\"TrK-ID\" type=\"xsd:string\"/>\n<xsd:element name=\"Signature-ID\" type=\"xsd:string\"/>\n</xsd:schema>\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "D.4\tKMS Redirect Response (KRR)",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "D.4.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "A KMS Redirect Response is generated by an entity within the MC system on detection that a KMS URI within a MIKEY I_MESSAGE is not acceptable in the current circumstance, or on receipt of a KRR containing KMS URIs that are not acceptable to be returned to the sender.\nThe entity returns a SIP 488 response 'Not Acceptable Here', attaching an XML MIME body to the response. The MIME body shall have content type: 'application/vnd.3gpp.kmsredirectresponse+xml'. The MIME body shall adhere to the XML schema in Clause D.4.4.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.4.2\tKRR XML signature profile",
                    "description": "",
                    "summary": "",
                    "text_content": "Signatures should be used to authenticate KRRs. Where supported, senders and processors of KRRs shall support the following XML Signature 1.1 profile as defined in [28]:\nDigest: SHA256 ()\nSignature: ECDSAwithSHA256 ()\nCanonicalization:\nKeyInfo: X509 certificate\nVerification of the X509 certificate is out of scope of this document.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.4.3\tExample XML",
                    "description": "",
                    "summary": "",
                    "text_content": "In this example, 'example:initiator@example.org' has sent a MIKEY I_MESSAGE to 'example:receiver@example.org' with KMS 'kms.reject.example.org'. At some point along the message flow, the KMS used for the receiver is rejected by entity 'example:processor.1@example.org'. The rejecting entity creates and returns a KRR proposing two KMS URIs for the receiver ('kms.option1.example.org' and 'kms.option2.example.org'). The KRR is received by 'example:processor.2@example.org' who rejects one of the proposed KMS URIs and creates a new KRR, embedding the old KRR within the new KRR and updating the list of receiver KMS URIs to the one that is acceptable ('kms.option1.example.org').\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<KmsRedirectResponse xmlns= \"urn:3gpp:ns:mcsecKMSKRR:1.0\"\nxmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:ds = \"http://www.w3.org/2000/09/xmldsig#\"\nVersion = \"1.0.0\" Id = \"0123456789abcdef\">\n<Time>2018-01-26T11:15:43</Time>\n<KRRCreatorUri>example:processor.2@example.org</KRRCreatorUri>\n<InitiatorUri>example:initiator@example.org</InitiatorUri>\n<InitiatorKmsUri>kms.init.example.org</InitiatorKmsUri>\n<ReceiverUri>example:receiver@example.org</ReceiverUri>\n<ReceiverKmsUri>kms.reject.example.org</ReceiverKmsUri>\n<InitiatorKmsList>\n<ANY></ANY>\n</InitiatorKmsList>\n<ReceiverKmsList>\n<KmsUri>kms.option1.example.org</KmsUri>\n</ReceiverKmsList>\n<ReceivedKmsRedirectResponse>\n<KmsRedirectResponse Version = \"1.0.0\" Id = \"001122334455667788\">\n<Time>2018-01-26T11:15:40</Time>\n<KRRCreatorUri>example:processor.1@example.org</KRRCreatorUri>\n<InitiatorUri>example:initiator@example.org</InitiatorUri>\n<InitiatorKmsUri>kms.init.example.org</InitiatorKmsUri>\n<ReceiverUri>example:receiver@example.org</ReceiverUri>\n<ReceiverKmsUri>kms.reject.example.org</ReceiverKmsUri>\n<InitiatorKmsList>\n<ANY></ANY>\n</InitiatorKmsList>\n<ReceiverKmsList>\n<KmsUri>kms.option1.example.org</KmsUri>\n<KmsUri>kms.option2.example.org</KmsUri>\n</ReceiverKmsList>\n<Signature xmlns = \"http://www.w3.org/2000/09/xmldsig#\">\n<SignedInfo>\n<CanonicalizationMethod Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n<SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256\"/>\n<Reference URI=\"#001122334455667788\">\n<DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/>\n<DigestValue>...</DigestValue>\n</Reference>\n</SignedInfo>\n<SignatureValue>...</SignatureValue>\n<KeyInfo>\n<X509Data>\n...\n</X509Data>\n</KeyInfo>\n</Signature>\n</KmsRedirectResponse >\n</ReceivedKmsRedirectResponse>\n<Signature>\n<SignedInfo xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n<CanonicalizationMethod Algorithm=\" http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n<SignatureMethod Algorithm=\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256\"/>\n<Reference URI=\"#0123456789abcdef\">\n<DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/>\n<DigestValue>...</DigestValue>\n</Reference>\n</SignedInfo>\n<SignatureValue xmlns=\"http://www.w3.org/2000/09/xmldsig#\">...</SignatureValue>\n<KeyInfo xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n<X509Data>\n...\n</X509Data>\n</KeyInfo>\n</Signature>\n</KmsRedirectResponse>\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "D.4.4\tExample XML schema",
                    "description": "",
                    "summary": "",
                    "text_content": "This clause contains the XML schema for KMS Redirect Responses:\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<xsd:schema xmlns:xsd = \"http://www.w3.org/2001/XMLSchema\" xmlns:ds = \"http://www.w3.org/2000/09/xmldsig#\"\nxmlns = \"urn:3gpp:ns:mcsecKMSKRR:1.0\" targetNamespace = \"urn:3gpp:ns:mcsecKMSKRR:1.0\" elementFormDefault = \"qualified\" version = \"1.0\">\n<xsd:import namespace = \"http://www.w3.org/2000/09/xmldsig#\"/>\n\n<!-- An identifier for this type of response -->\n<xsd:element type = \"KmsRedirectResponseType\" name = \"KmsRedirectResponse\"/>\n\n<xsd:complexType name = \"KmsRedirectResponseType\">\n<xsd:sequence>\n<!-- The date and time -->\n<xsd:element type = \"xsd:dateTime\" name = \"Time\" minOccurs = \"1\" maxOccurs = \"1\"/>\n<!-- The identity of the KRR creator. -->\n<xsd:element type = \"xsd:anyURI\" name = \"KRRCreatorUri\" minOccurs = \"1\" maxOccurs = \"1\"/>\n<!-- The MIKEY initiating identity used within the MIKEY message (IDRi). -->\n<xsd:element type = \"xsd:anyURI\" name = \"InitiatorUri\" minOccurs = \"1\" maxOccurs = \"1\"/>\n<!-- The MIKEY initiating KMS URI used within the MIKEY message (IDRkmsi). -->\n<xsd:element type = \"xsd:anyURI\" name = \"InitiatorKmsUri\" minOccurs = \"1\" maxOccurs = \"1\"/>\n<!-- The MIKEY receiving identity used within the MIKEY message (IDRr). -->\n<xsd:element type = \"xsd:anyURI\" name = \"ReceiverUri\" minOccurs = \"1\" maxOccurs = \"1\"/>\n<!-- The MIKEY receiving KMS URI used within the MIKEY message (IDRkmsr). -->\n<xsd:element type = \"xsd:anyURI\" name = \"ReceiverKmsUri\" minOccurs = \"1\" maxOccurs = \"1\"/>\n<!-- The initiator list containing a list of acceptable KMS URIs (List of IDRkmsi's). -->\n<xsd:element name = \"InitiatorKmsList\" type = \"KmsUriListType\" minOccurs = \"1\" maxOccurs = \"1\"/>\n<!-- The receiver list containing a list of acceptable KMS URIs (List of IDRkmsr's). -->\n<xsd:element name = \"ReceiverKmsList\" type = \"KmsUriListType\" minOccurs = \"1\" maxOccurs = \"1\"/>\n<!-- An embedded received KRR (optional, used if KRR is generated from a received KRR). -->\n<xsd:element name = \"ReceivedKmsRedirectResponse\" type = \"ReceivedKmsRedirectResponseType\" minOccurs = \"0\" maxOccurs = \"1\"/>\n<!-- Allow extensions -->\n<xsd:any namespace = \"##other\" processContents = \"lax\" minOccurs = \"0\" maxOccurs = \"unbounded\"/>\n<!-- A signature (using the originating identity) over the entire message (optional, but recommended). -->\n<xsd:element name=\"Signature\" type = \"ds:SignatureType\" minOccurs = \"0\"/>\n</xsd:sequence>\n<xsd:attribute name = \"Id\" type = \"xsd:string\"/>\n<xsd:attribute name = \"Version\" type = \"xsd:string\" fixed=\"1.0.0\"/>\n<xsd:anyAttribute namespace = \"##other\" processContents = \"lax\"/>\n</xsd:complexType>\n\n<xsd:complexType name = \"KmsUriListType\">\n<xsd:sequence>\n<xsd:choice maxOccurs = \"1\">\n<xsd:sequence>\n<xsd:element type=\"xsd:string\" name=\"ANY\" fixed=\"\"/>\n</xsd:sequence>\n<xsd:sequence>\n<xsd:element type = \"xsd:anyURI\" name = \"KmsUri\" minOccurs = \"0\" maxOccurs = \"unbounded\"/>\n</xsd:sequence>\n</xsd:choice>\n<xsd:any namespace = \"##other\" processContents = \"lax\" minOccurs = \"0\" maxOccurs = \"unbounded\"/>\n</xsd:sequence>\n<xsd:anyAttribute namespace = \"##other\" processContents = \"lax\"/>\n</xsd:complexType>\n\n<xsd:complexType name = \"ReceivedKmsRedirectResponseType\">\n<xsd:sequence>\n<xsd:element name = \"KmsRedirectResponse\" type = \"KmsRedirectResponseType\" minOccurs = \"1\" maxOccurs = \"1\"/>\n</xsd:sequence>\n</xsd:complexType>\n</xsd:schema>\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "E.1\tGeneral aspects",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "E.1.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "MIKEY-SAKKE as defined in IETF RFC 6509 [11] is used to transport Group Master Keys (GMKs) from a Group Management Server to a Group Management Client on a MC UE, Private Call Keys (PCKs) between MC UEs, Client-Server keys (CSKs) between MCX Server and MC client, and Multicast Signalling Keys (MuSiK) from MCX Servers to MC clients.\nThe GMK is encrypted to the UID generated from the receiving user's MC Service user ID and current time period. It is signed using the UID generated from the URI associated to the Group Management Server and current time period. Similarly, the PCK is encrypted to the UID generated from the receiving user's MC Service user ID and current time period. It is signed using the UID generated from the initiating user's MC Service user ID and current time period. When uploaded, the CSK is encrypted to the UID generated from the MCX Server's FQDN and current time period and signed using the UID of the MC user. When downloaded, the CSK and MuSiK is encrypted to the UID of the MC user and signed using the UID of the MCX Server. Details of this process are defined in IETF RFC 6508 [10] and IETF RFC 6507 [9]. The generation of the MIKEY-SAKKE UID is defined in clause F.2.1.\nThe GMK, PCK, CSK and MuSiK shall be 16 octets in length.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.1.2\tMIKEY common fields",
                    "description": "",
                    "summary": "",
                    "text_content": "All MIKEY-SAKKE messages shall include the Common Header payload (HDR), Timestamp payload (TS), RAND payload, IDRi payload, IDRr payload, IDRkmsi payload, IDRkmsr payload, SAKKE payload and a SIGN (ECCSI) payload.\nOptionally, the MIKEY-SAKKE message may contain a Security Properties payload (SP), a second SAKKE payload (SAKKE-to-self specified in Annex E.5), and a key parameter payload (specified in Annex E.6)\nIn the MIKEY HDR, the 'data type' shall be '26' (as this is a MIKEY-SAKKE message). The 'V' bit shall be '0'. The 'PRF func' may be '1' indicating the use of 'PRF-HMAC-SHA-256' ('PRF-HMAC-SHA-256' is the only PRF algorithm that is mandatory to support). The 'CS#' may be 0 or more.\n-\tWhere the 'CS#' is '0', the 'CS ID map type' shall be '1' (empty map) and 'CS ID Map Info' shall have length '0'. This shall imply that default security policies shall be applied (as defined in further clauses).\n-\tWhere the 'CS#' is greater than '0', the 'CS ID map type' shall be '2' (GENERIC-ID as defined in RFC 6043 [25]).\nEach MIKEY message contains the timestamp field (TS). The timestamp field shall be TS type NTP-UTC (TS type 0), and hence is a 64-bit UTC time.\nThe ID Scheme in the SAKKE payload shall be '3GPP MCX hashed UID ' to reflect the generation scheme defined in clause F.2.1.\nThe ID Scheme '3GPP MCX hashed UID' takes on the IANA assigned value of '2' [52].\nThe entire MIKEY message shall be signed by including an Signature payload (SIGN) providing authentication of the origin of the message. The signature (S type) field shall be of type '2' (ECCSI) and the Signature length field shall be \"32\", indicating a signature length of 32 bytes (i.e. 256 bits). The signature shall then be calculated over the entire MIKEY message (including the S type field and Signature length field of the Signature payload) followed by concatenation of the signature to the end of the MIKEY message as described in RFC 3830 [22] section 5.2..\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.1.3\tCrypto Session Identifiers",
                    "description": "",
                    "summary": "",
                    "text_content": "The MIKEY payload defines the use of Crypto Sessions. Each Crypto Session is identified by a CS-ID. To ensure that a crypto session can be assigned to a specific use within the MC System, the Crypto Session identifiers are defined in Table E.1.3-1.\nTable E.1.3-1: CS-ID assignment\n\nIn Table E.1.3-1, CS-ID '0' and '2' are used for SRTP/SRTCP streams originating from the initator of the private call. CS-ID '1' and '3' are used for SRTP/SRTCP streams originating from the receiver of the private call.\n\n",
                    "tables": [
                        {
                            "description": "Table E.1.3-1: CS-ID assignment",
                            "table number": 29,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "E.2\tMIKEY message structure for GMK distribution",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "E.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "In the Common Header payload, the CSB ID field of MIKEY common header shall be the GUK-ID.\nWhere no crypto sessions are included in the payload, (CS# is 0), the default security profile defined in Annex E.2.2 shall be used, and no Secuirty Properties payload (SP) is required. The profile in Annex E.2.2 is mandatory to support.\nIdentity payloads shall be IDR payloads as defined in section 6.6 of IETF RFC 6043 [25]. The IDRi payload shall contain the MCX service identifier associated with the group management server. The IDRr payload shall contain the MC Service user ID associated to the group management client. The message shall also include IDRkmsi and IDRkmsr that contains the URI of the MC KMS used by the group management server and MC user respectively.\nNOTE:\tIn some deployments MC Service user IDs (i.e. MCPTT ID, MCVideo ID, MCData ID) within these payloads may be treated as private. In this case, these identities may be hidden using the mechanism in clause E.7.\nThe SAKKE payload shall encapsulate the GMK to the UID generated from the MC Service user ID of the group management client. Only one GMK key shall be transported in the SAKKE payload. The same GMK shall be encapsulated to each member of the group.\nA SAKKE-to-SELF payload may be included. It is recommended that where the GMK is being transported beyond a single MC system, the message should include a SAKKE-to-SELF payload as described in clause E.5.\nA 'Key Properties' payload (Annex E.6) should be included to provide details of the GMK.\nThe signature shall use the UID generated from the identifier associated with the group management server.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.2.2\tDefault SRTP security profile for GMK use",
                    "description": "",
                    "summary": "",
                    "text_content": "The default security profile is used to support MCPTT and MCVideo communications. It defines the mandatory to support security settings for distribution and use of the GMK. It is the profile that should be used should no information (Crypto session information or security policies) be provided in the MIKEY message.\nThe CS-ID (for input into the MIKEY PRF) shall be '4' for MCPTT and '5' for MCVideo. The 'Prot Type' shall be '0' (SRTP).\nThe Security Policies are shown in Table E.2-1.\n\nTable E.2.2-1: MIKEY Group call SRTP Default Profile\n\nShould a security profile be provided by the GMS, the mapping is provided in a GENERIC-ID component of the MIKEY HDR. The CS-ID shall be '4' for MCPTT and/or '5' for MCVideo. Consequently, the CS# shall be '1' or '2'. The 'Prot Type' shall be '0' (SRTP).\nIn each GENERIC-ID crypto session, '#P' shall be 1 (a single security policy shall be referenced). The 'Session Data length' shall be '0' as SSRCs are not provided by the GMS. The MKI (GMK-ID || GUK-ID) may be included in the SPI field.\n",
                    "tables": [
                        {
                            "description": "Table E.2.2-1: MIKEY Group call SRTP Default Profile",
                            "table number": 30,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "E.3\tMIKEY message structure for PCK distribution",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "E.3.1 General",
                    "description": "",
                    "summary": "",
                    "text_content": "In the Common Header payload, the CSB ID field of MIKEY common header shall be the PCK-ID.\nWhere no crypto sessions are included in the payload, (CS# is 0), the default security profile defined in Annex E.3.2 shall be used, and no Secuirty Properties payload (SP) is required. The profile in Annex E.3.2 is mandatory to support.\nIdentity payloads shall be IDR payloads as defined in section 6.6 of IETF RFC 6043 [25]. The IDRi payload shall contain the MC Service user ID associated with the initiating user. The IDRr payload shall contain the MC Service user ID associated to the receiving user. The message shall also include IDRkmsi and IDRkmsr that contains the URI of the KMS used by the initiating user and terminating user respectively\nNOTE:\tIn some deployments MC Service user IDs (i.e. MCPTT ID, MCVideo ID, MCData ID) within these payloads may be treated as private. In this case, these identities may be hidden using the mechanism in clause E.7.\nThe SAKKE payload shall encapsulate the PCK to the UID generated from the MC Service user ID of the terminating user. The ID Scheme in the SAKKE payload shall be 'URI Scheme' to reflect the generation scheme defined in clause F.2.1.\nA SAKKE-to-SELF payload may be included. It is recommended that where the PCK is being transported beyond a single MC system, the message should include a SAKKE-to-SELF payload as described in clause E.5.\nThe signature shall use the UID generated from the MC Service user ID of the initiating user.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.3.2\tDefault SRTP security profile for PCK",
                    "description": "",
                    "summary": "",
                    "text_content": "The default security profile is used to support MCPTT and MCVideo communications. It defines the mandatory to support security settings for distribution and use of the PCK. It is the profile that should be used should no information (Crypto session information or security policies) be provided in the MIKEY message.\nThe CS-ID (for input into the MIKEY PRF) shall be '0' for the MCPTT session from the initiator, '1' for MCPTT session from the receiver, '2' for the MCVideo session from the initiator and '3' for the MCVideo session from the receiver.\nThe Security Policies are shown in Table E.3.2-1.\n\nTable E.3.2-1: MIKEY Private call SRTP Default Profile\n\n",
                    "tables": [
                        {
                            "description": "Table E.3.2-1: MIKEY Private call SRTP Default Profile",
                            "table number": 31,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.3.3\tProviding a SRTP security profile for PCK use",
                    "description": "",
                    "summary": "",
                    "text_content": "Should a security profile be provided by the initiator, the mapping is provided in a GENERIC-ID component of the MIKEY HDR. The CS-ID shall be '0' for the MCPTT session from the initiator, '1' for MCPTT session from the receiver, '2' for the MCVideo session from the initiator and '3' for the MCVideo session from the receiver. Consequently, the CS# shall be between 1 and 4 inclusive. The 'Prot Type' shall be '0' (SRTP).\nIn each GENERIC-ID crypto session, '#P' shall be 1 (a single security policy shall be referenced). It is recommended that the 'Session Data length' is '0' as SSRCs do not need to be provided. The MKI (PCK-ID) may be included in the SPI field.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "E.4\tMIKEY message structure for CSK and MuSiK distribution",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "E.4.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "The CSK and MuSiK shall only be used to protect SRTCP payloads and shall not be used to protect SRTP payloads.\nIn the Common Header payload, the CSB ID field of MIKEY common header for CSK and MuSiK distribution shall be the CSK-ID or MuSiK-ID (resp).\nWhere no crypto sessions are included in the payload, (CS# is 0), the default security profile defined in Annex E.4.2 shall be used, and no Secuirty Properties payload (SP) is required. The profile in Annex E.4.2 is mandatory to support.\nIdentity payloads shall be IDR payloads as defined in section 6.6 of IETF RFC 6043 [25].\nFor CSK upload, the IDRi payload shall contain the MC Service user ID associated with the initiating user. The IDRr payload shall contain the MDSI of the MCX Domain. The message shall also include IDRkmsi and IDRkmsr that contains the URI of the KMS used by the initiating user and MCX Domain respectively.\nFor CSK and MuSiK download, the IDRi payload shall contain the MDSI of the MCX Domain. The IDRr payload shall contain the MC Service user ID associated with the initiating user. The message shall also include IDRkmsi and IDRkmsr that contains the URI of the KMS used by the MCX Domain and initiating user respectively.\nNOTE:\tIn some deployments MC Service user IDs (i.e. MCPTT ID, MCVideo ID, MCData ID) within these payloads may be treated as private. In this case, these identities may be hidden using the mechanism in clause E.7.\nFor CSK upload, the SAKKE payload shall encapsulate the CSK to the UID generated from the MDSI of the MCX Domain, and the current time period. For CSK or MuSiK download, the SAKKE payload shall encapsulate the key to the UID generated from the user ID associated with the initiating user and the current time period.\nA 'Key Properties' payload (Annex E.6) may be included to provide details of the CSK or MuSiK.\nFor CSK Upload, the signature shall use the UID generated from the identifier associated with MC Service user ID associated with the initiating user. For CSK and MuSiK download, the signature shall use the UID generated from the identifier associated with MDSI of the MCX Domain.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.4.2\tDefault SRTCP security profile for CSK and MuSiK",
                    "description": "",
                    "summary": "",
                    "text_content": "The default security profile is used to support SRTCP for MCPTT and MCVideo communications. It defines the mandatory to support security settings for distribution and use of the CSK and MuSiK. It is the profile that should be used should no information (Crypto session information or security policies) be provided in the MIKEY message.\nThe CS-ID (for input into the MIKEY PRF) shall be '6' for CSK use within MCPTT (floor control and media control), '7' for MuSiK use within MCPTT, '8' for CSK use within MCVideo (transmission control), and '9' for MuSiK use within MCVideo. The 'Prot Type' shall be '0' (SRTP).\nThe Security Policies are shown in Table E.4.2-1.\nTable E.4.2-1: MIKEY Default Profile for CSK and MuSiK\n\n",
                    "tables": [
                        {
                            "description": "Table E.4.2-1: MIKEY Default Profile for CSK and MuSiK",
                            "table number": 32,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.4.3\tProviding a SRTCP security profile for CSK or MuSiK",
                    "description": "",
                    "summary": "",
                    "text_content": "Should a security profile be provided, the mapping is provided in a GENERIC-ID component of the MIKEY HDR. For CSK transmission, the CS-ID shall be '6' for CSK use within MCPTT (floor control and media control) and '8' for CSK use within MCVideo (transmission control),. For MuSiK transmission, the CS-ID shall be '7' for MuSiK use within MCPTT and '9' for MuSiK use within MCVideo. Consequently, the CS# shall be '1' or '2' for either CSK or MuSiK transmission.\nIn each GENERIC-ID crypto session, '#P' shall be 1 (a single security policy shall be referenced). The MC Server may provide SSRCs for SRTCP within the Session Data. The MKI (GMK-ID || GUK-ID) may be included in the SPI field.\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "E.5\tMIKEY general extension payload to support 'SAKKE-to-self'",
            "description": "In some circumstances it is useful for the initiator to be able to decrypt a MIKEY-SAKKE payload and recover the key (as well as the receiver). For example, where the initiating user is attached to the MCX service via more than one MC UE, the other MC UEs associated with the initiating user will also need the key material to be able to join the communication.\nTo support this scenario, an optional MIKEY General Extension Payload may be added to the MIKEY-SAKKE message. This general extension payload has type 'SAKKE-to-self'. The contents of the payload will be a full SAKKE payload as defined in IETF RFC 6509 [11]. Within the second SAKKE payload the key (GMK or PCK) shall be encapsulated to the UID generated from the MC identifier associated with the initiating user (either group management server or private call initiator). The ID Scheme in the SAKKE payload shall be '3GPP MCX hashed UID ' to reflect the generation scheme defined in clause F.2.1.\nThe General Extensions Field Name 'SAKKE-to-self' type takes on the IANA assigned value of '6' [52].\n\nEXAMPLE SAKKE-to-self payload:\n*   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n*  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n*  ! Next payload  ! Type          ! Length                        !\n*  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n*  ! Next payload  ! SAKKE params  !   ID scheme   !  SAKKE data   ~\n*  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n*  ~ length (cont) !                  SAKKE data                   ~\n*  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\nThe SAKKE-to-self payload encapsulates a SAKKE payload. Consequently, the SAKKE-to-self payload will contain two 'next payload' fields. The second 'next payload' field, which corresponds to the encapsulated SAKKE payload, shall be set to zero and ignored.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "E.6\tMIKEY general extension payload to encapsulate parameters associated with a key",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "E.6.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "The parameters associated with the key shall be contained in the 'General extension payload' specified in IETF RFC 3830 [22] using the '3GPP key parameters ' Type value and contained within the signed envelope of the MIKEY-SAKKE I_MESSAGE specified in clause E.2. The format and cryptography of the payload are specified in this subclause.\nThe General Extensions Field Name '3GPP key parameters' type takes on the IANA assigned value of '7' [52].\nThe payload consist of a series of information elements. The standard format and encoding rules for the information elements follow that defined for the MCPTT Off-Network Protocol (MONP) as documented in Annex I of 3GPP TS 24.379 [10].\nThe four octets consisting of the header of the 'General extension payload' shall be formatted according to IETF RFC 3830 [22].\nThe contents of the 'General extension payload' shall be an MCData Protected Payload message as defined in Clause 8.5.4 with the ‘Payload' element consisting of the 'Key Parameters' payload defined in this clause. The ‘Payload ID’ and the ‘Payload sequence number' of the Protected Payload shall be set to '0' by the sender and ignored by the receiver. The DPPK-ID of the Protected Payload shall be the same as the CSB-ID of the encapsulating MIKEY payload. The key encapsulated by the MIKEY payload (e.g. GMK, MuSiK, etc) shall be used to protect the Protected Payload (the Key Parameters payload).\nThe 'Key Parameters' payload is a type 6 information element composing a 1 byte Key Parameters IEI, a 2 byte length of the Key Parameters payload contents, and the Key Parameters payload content itself. The Key Parameters payload content shall be of the format specified in Table E.6.1-1.\nTable E.6.1-1: Key Parameters Payload content\n\nNOTE:\tThe 'MC group IDs' IE is only present in the Key Parameters payload if the key type is 'GMK', 'MKFC' or 'MuSiK'.\nThe IEs in the Key Parameters Payload are described in the following subclauses.\n",
                    "tables": [
                        {
                            "description": "Table E.6.1-1: Key Parameters Payload content",
                            "table number": 33,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.2\tVoid",
                    "description": "",
                    "summary": "",
                    "text_content": "\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.3\tMC group IDs",
                    "description": "",
                    "summary": "",
                    "text_content": "The 'MC group IDs' IE is only present in the Key Parameters payload if the key type is 'GMK', 'MKFC' or 'MuSiK'.\nThe 'MC group IDs' IE shall be of the format specified in Table E.6.3-1.\nTable E.6.3-1: MC Group IDs IE content\n\nNOTE:\tThe Number of Group IDs dictates the number of Group ID information elements that are included in the payload. If the number of group IDs is zero, there will be no Group ID IEs in the payload.\nThe Group ID payload has the same format as the 'MCData Group ID' payload defined in clause 15.2.14 of TS 24.282.\nWhere the key does not correspond to a group ID, the 'MC group ID' IE shall contain a two octet 'Length' sub-element with the value '1', followed by a 'Number of Group IDs' element of value '0'.  .\nThis field allows distribution of MC Group IDs that are associated with the current key carried in the MIKEY-SAKKE I_MESSAGE.  This means that each specified MC Group ID shall use this key for group communications.  Assigned MC Group IDs may include any combination of MCPTT Group IDs, MCData Group IDs or MCVideo Group IDs.\n",
                    "tables": [
                        {
                            "description": "Table E.6.3-1: MC Group IDs IE content",
                            "table number": 34,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.4\tActivation time",
                    "description": "",
                    "summary": "",
                    "text_content": "The 'Activation time' element shall define the time in UTC at which the associated key is to be made active for transmission in seconds since midnight UTC of January 1, 1970 (not counting leap seconds). It shall be 5 octets in length.\nA value of 0 shall imply the  activation time is the timestamp of the received MIKEY I_MESSAGE.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.5\tText",
                    "description": "",
                    "summary": "",
                    "text_content": "The 'Text' sub-element shall contain the user-readable name associated with the key.\nWhere there is no text, the 'Text' element shall contain a two octet 'Length' sub-element with the value 0 .\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.6\tReserved",
                    "description": "",
                    "summary": "",
                    "text_content": "The definition and encoding of the Reserved IE is outside of scope of the present document.\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.7\tVoid",
                    "description": "",
                    "summary": "",
                    "text_content": "\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.8\tVoid",
                    "description": "",
                    "summary": "",
                    "text_content": "\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.9\tStatus",
                    "description": "",
                    "summary": "",
                    "text_content": "The 'Status' element shall determine the current status of the key. It shall be 4 octets in length. The following values are defined in Table E.6.9-1.:\nTable E.6.9-1: Key status bit field\n\nUndefined bits shall be ignored.\n",
                    "tables": [
                        {
                            "description": "Table E.6.9-1: Key status bit field",
                            "table number": 35,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.10\tExpiry time",
                    "description": "",
                    "summary": "",
                    "text_content": "The 'Expiry time' element shall define the time in UTC at which the associated key shall no longer be used in seconds since midnight UTC of January 1, 1970 (not counting leap seconds). It shall be 5 octets in length.\nA value of 0 shall imply the key shall not expire.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.6.11\tKey Type",
                    "description": "",
                    "summary": "",
                    "text_content": "The purpose of Key Type IE is to specify the type and purpose of the key.\nThe value part of the Key type information element is coded as shown in Table E.6.11-1.\nTable E.6.11-1: Key type\n\n",
                    "tables": [
                        {
                            "description": "Table E.6.11-1: Key type",
                            "table number": 36,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "E.7\tHiding identities within MIKEY messages",
            "description": "In some public-safety use cases there is a requirement to protect MC Service user IDs in transit. To protect these identifiers in MIKEY-SAKKE messages the following approach may be taken.\nThe sensitive MC Service user ID in the IDRr or IDRi field is replaced with the UID generated from the MC Service user ID as defined in clause F.2.1. In the former case, the 'role' of the IDRr field is replaced with a role of IDRuidr. In the latter case, the 'role' of the IDRi field is replaced with a role of IDRuidi.\nThe ID Role of Hashed Initiator (IDRuidi) takes on the IANA assigned value of '8' while the ID Role of Hashed Responder (IDRuidr) takes on the IANA assigned value of '9' [52].\nThe processing of the MIKEY-SAKKE I_MESSAGE at the initiator stays the same. If the initiator has hidden its own MC Service user ID, it shall ensure that the SIP message containing the I_MESSAGE contains the initiator's MC Service user ID encrypted to the receiver.\nAs a consequence of identity hiding, the receiver of the MIKEY-SAKKE I_MESSAGE will be able to check the signature based on the initiator's UID in the IDRuidi field, but initially will be unable to confirm the MC Service user ID that has been used to generate the UID. The receiver will recognize its own UID in the IDRuidr field, and be able to extract the encapsulated key.\nUsing the encapsulated key or otherwise, the receiver is able to extract associated metadata in the message, including the initiator's MC Service user ID. On obtaining the initiator's MC Service user ID, the receiver is able to compute the UID and ensure this matches the UID in the IDRuidi field. By performing this check, the receiver has authenticated the I_MESSAGE.\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "F.1\tKDF interface and input parameter construction",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "F.1.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "This annex specifies the use of the Key Derivation Function (KDF) specified in 3GPP TS 33.220 [17] for the current specification. This annex specifies how to construct the input string, S, to the KDF (which is input together with the relevant key). For each of the distinct usages of the KDF, the input parameters S are specified below.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "F.1.2\tFC value allocations",
                    "description": "",
                    "summary": "",
                    "text_content": "The FC number space used is controlled by 3GPP TS 33.220 [17].\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "F.1.3\tCalculation of the User Salt for GUK-ID generation",
                    "description": "",
                    "summary": "",
                    "text_content": "When calculating a User Salt using the GMK for generating the GUK-ID from the GMK-ID, the following parameters shall be used to form the input S to the KDF that is specified in annex B of 3GPP TS 33.220 [17]:\n-\tFC = 0x50.\n-\tP0 = MC Service user ID.\n-\tL0 = length of above (i.e. 0x00 0x17).\nThe GMK and MC Service user ID follow the encoding also specified in annex B of 3GPP TS 33.220 [17]. The 28 least significant bits of the 256 bits of the KDF output shall be used as the User Salt.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "F.1.4\tCalculation of keys for application data protection",
                    "description": "",
                    "summary": "",
                    "text_content": "The two keys used to protect either signalling plane confidentiality, or signalling plane integrity are derived from the XPK, using the KDF that is specified in annex B of 3GPP TS 33.220 [17].\nThe following parameters shall be used to form the input S to the KDF that is specified in annex B of 3GPP TS 33.220 [27]. The key used by the KDF shall be the XPK:\n-\tFC = 0x51, (for signalling plane confidentiality), or\n-\tFC = 0x52 (for signalling plane integrity).\n-\tP0 = MC Service user ID.\n-\tL0 = length of above, expressed in number of bytes (i.e. 0x00 0x17).\n-\tP1 = XPK-ID.\n-\tL1 = length of above, expressed in number of bytes (i.e. 0x00 0x17).\nThe MC Service user ID and XPK-ID follow the encoding also specified in annex B of 3GPP TS 33.220 [17].\nWhere the XPK is 128-bits, the output keys shall be 128-bits and hence the 128 least significant bits of the 256 bits of the KDF output shall be used as the signalling protection key. Where the XPK is 256-bits, the output keys shall be 256-bits and hence the entire output of the KDF shall be used.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "F.1.5\tCalculation of keys for MCData payload protection",
                            "text_content": "The following parameters shall be used to form the input S to the KDF that is specified in annex B of 3GPP TS 33.220 [27]. The key used by the KDF shall be the DPPK:\n-\tFC = 0x53, (for MCData Payload Protection),\n-\tP0 = DPPK-ID.\n-\tL0 = length of above, expressed in number of bytes (i.e. 0x00 0x17).\nThe DPPK-ID follow the encoding also specified in annex B of 3GPP TS 33.220 [17].\nWhere the DPPK is 128-bits, the DPCK shall be 128-bits and hence the 128 least significant bits of the 256 bits of the KDF output shall be used as the signalling protection key. Where the DPPK is 256-bits, the output DPCK shall be 256-bits and hence the entire output of the KDF shall be used.\nFor MCData signalling parameters, Data signaling payload, and End to end security parameter protection between the MCData client and MCData server, the CSK is used as the DPPK. When the selected algorithm is DP_AES_128_GCM (see clause 5.8.1), the DPCK shall be 128-bits and hence the 128 least significant bits of the 256 bits of the KDF output shall be used as the signalling protection key. When the selected algorithm is DP_AES_256_GCM (see clause 5.8.1), the output DPCK shall be 256-bits and hence the entire output of the KDF shall be used.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "F.2\tHash functions",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "F.2.1\tGeneration of MIKEY-SAKKE UID",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "F.2.1.1\tOverview",
                            "text_content": "Section 3.2 of IETF RFC 6509 [11] defines an identifier for use in MIKEY SAKKE, referred to as the UID in the present document. This requires a Tel-URI as the user's URI and monthly key periods. As MC Service user IDs may not be Tel-URIs, this UID format cannot be used within MC applications. This clause defines how the 256-bit MIKEY-SAKKE UID is generated using a generic identifier and generic key period.\nThe MIKEY-SAKKE UID is generated by hashing a fixed string, the identifier of the user, the identifier of the KMS, the key period length, the current key period number and their respective lengths. Key periods are a repeating sequence of fixed time periods, where the first key period commences at an offset in time following 0h on 1 January 1900.\nThe input to the hash function shall be encoded as specified in clause B.2 of 3GPP TS 33.220 [17]. The hash function shall be SHA-256 as specified in [18]. The full 256-bit output shall be used as the identifier within MIKEY-SAKKE (referred to as 'ID' in IETF RFC 6507 [9] and 'a' or 'b' within IETF RFC 6508 [10]. The resulting UID shall be base64 encoded.\nFC = 0x00\nP0 = The fixed string: ''MIKEY-SAKKE-UID''\nL0 = Length of P0 value\nP1 = Identifier (e.g. MCPTT ID, MCVideo ID or MCData ID)\nL1 = Length of P1 value\nP2 = KMS Identifier (e.g. secgroup1.kms.example.org)\nL2 = Length of P2 value\nP3 = Key Period length in seconds (e.g. 2592000)\nL3 = Length of P3 value\nP4 = Key Period offset in seconds (e.g. 0)\nL4 = Length of P4 value\nP5 = Current Key Period No. since 0h on 1 January 1900 (e.g. 553)\nL5 = Length of P5 value\nNOTE 1:\tThe key derivation function defined in clause B.2 of 3GPP TS 33.220 [17] is not used, therefore the FC value should only be considered as a dummy value.\nP0 is a fixed 15 character string encoded as described in annex B of 3GPP TS 33.220 [17]. P1 is the identifier, which for MCPTT would be the MCPTT ID. P2 is the identifier of the KMS, and uniquely identifies the public key used for encryption and signing. P3 is the integer representing the number of seconds in every key period. P4 is the offset of the start time of the first key period from 0h on 1 January 1900 and shall be less than P3.  The combination of P4 and multiples of P3 set the time at which keys are changed over at the end of every key period. Both P3 and P4 are extracted from the KMS certificate (UserKeyPeriod and UserKeyOffset from table D.3.2.2-1, respectively) and encoded as integers as described in annex B of 3GPP TS 33.220 [17]. P5 is the integer representing the current key period number since 0h on 1 January 1900, which may be calculated as:\nP5 = Floor ( ( TIME - P4 ) / P3 )\nWhere TIME is a NTP timestamp, i.e., a number in seconds relative to 0h on 1 January 1900. P4 is encoded as described in annex B of 3GPP TS 33.220 [17].\nNOTE 2:\tWhen used to generate a UID for encrypting using a MIKEY payload, P1 will commonly be the 'ID Data' from the IDRr payload, P2 will be the encoded 'ID Data' from the IDRkmsr payload, and TIME will be the NTP timestamp within the MIKEY payload.\nNOTE 3:\tWhen used to generate a UID for signing a MIKEY payload, P1 will commonly be the 'ID Data' from the IDRi payload, P2 will commonly be the 'ID Data' from the IDRkmsi payload, and TIME will be the NTP timestamp within the MIKEY payload.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "F.2.1.2\tExample UID",
                            "text_content": "This clause calculates an example UID demonstrating the hash defined in clause F.2.1.1.\nIn this example:\n-\tThe identifier, P1, is sip:user@example.org.\n-\tThe KMS identifier, P2, is kms.example.org.\n-\tThe key period is 4 weeks, hence P3 is 2592000.\n-\tThe offset, P4, is 0.\n-\tthe calculation time is: <2014:01:26T10:07:14Z>, hence TIME is 3599719634.\nBased on these details:\nP5 = Floor ( (3599719634 – 0) / 2592000 ) = 1388.\nConsequently, S is constructed from the concatenation of:\nFC = 0x00\nP0 = MIKEY-SAKKE-UID\nL0 = 15\nP1 = sip:user@example.org\nL1 = 20\nP2 = kms.example.org\nL2 = 15\nP3 = 2592000\nL3 = 3\nP4 = 0\nL4 = 1\nP5 = 1388\nL5 = 2\nUsing the conversion in Clause B.2 of TS 33.220 [17]:\nS   = \t0x00 ||\n0x4d 0x49 0x4b 0x45 0x59 0x2d 0x53 0x41 0x4b 0x4b 0x45 0x2d 0x55 0x49 0x44 || 0x00 0x0f ||\n0x73 0x69 0x70 0x3a 0x75 0x73 0x65 0x72 0x40 0x65 0x78 0x61 0x6d 0x70 0x6c 0x65 0x2e 0x6f 0x72 0x67 || 0x00 0x14 ||\n0x6b 0x6d 0x73 0x2e 0x65 0x78 0x61 0x6d 0x70 0x6c 0x65 0x2e 0x6f 0x72 0x67 || 0x00 0x0f ||\n0x27 0x8d 0x00 || 0x00 0x03 ||\n0x00 || 0x00 0x01 ||\n0x05 0x6c || 0x00 0x02\nConsequently:\nUID  =  SHA-256 (004d494b45592d53414b4b452d554944000f7369703a75736572406578616d706c652e6f726700146b6d732e6578616d706c652e6f7267000f278d000003000001056c0002)\n= OoH7FMOx0P5DycV3EE1VptgXiL/S8JdDxFV3RqWgNTs=\n\nThe 'purpose tag' within the key identifier (e.g. GMK-ID) shall be the most significant four bits of the key and shall be used to indicate the use of the key. The use of key and application of key diversity are specified in Table G-1.\nTable G-1: Key usage according to purpose tag\n\nIn this way, the MC UE is able to identify the purpose of the key.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table G-1: Key usage according to purpose tag",
                                    "table number": 37,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "H.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "TS 33.179 [7] specified a different key distribution mechanism for the distribution of group multicast keys (MKFC). To allow MCPTT clients to operate with legacy MCPTT servers (as defined by the functionality in TS 33.179 [7]), MCPTT clients shall support the MKFC key distribution mechanisms defined in clause H.2 with the following constraints:\n-\tThe MCPTT client shall reject MKFCs received from other MC systems (based upon the GMS identity).\n-\tThe MCPTT client shall discard previously received MKFCs upon attaching to a new MC system.\nMCPTT Servers shall not support MKFC distribution. The MCPTT Server shall only support transmission of signalling over a unicast bearer to a legacy MCPTT client (as defined by the functionality TS 33.179 [7]). This shall be detected by the MCPTT Server on the rejection of the MuSiK.\nMCPTT Servers and MCPTT clients shall support distribution of the MSCCK. The mechanism for the distribution of the MSCCK is defined in clause H.3.\nNOTE:\tVoid.\nMSCCK and MKFC are used as defined in clause H.4.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "H.2\tMKFC Receipt",
                    "description": "",
                    "summary": "",
                    "text_content": "MKFCs are distributed using the same procedures as for GMK distribution. The client receives an MKFC from the MCPTT server using the procedures in clause 7.3, with the exception that the MKFC and MKFC-ID is distributed in the place of the GMK and GMK-ID, and the user salt is zero (meaning that the GUK-ID is the MKFC-ID).\nMKFCs are either distributed in their own group key distribution message (separate from the GMK distribution message), or in the same distribution message as the GMK. Distributing the MKFC in the same message as the GMK is achieved by embedding two MIKEY payloads in one distribution message.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "H.3\tMSCCK Distribution",
                    "description": "",
                    "summary": "",
                    "text_content": "MSCCK and MSCCK-ID are distributed within MBMS bearer announcement messages. The procedures are identical to those for distribution of the MuSiK, as defined in clause 5.9, with the exception that the MSCCK and MSCCK-ID are distributed instead of the MuSiK and MuSiK-ID.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "H.4\tUse of multicast signalling keys (MKFC and MSCCK)",
                    "description": "",
                    "summary": "",
                    "text_content": "For the protection of multicast floor and media control received from legacy MCPTT servers, the KFC shall be the MKFC and the KFC-ID shall be the MKFC-ID. KFC-RAND shall be the MIKEY RAND value transmitted in the MIKEY message used to distribute the KFC. The KFC is used as defined in clause 9.4.6 and 9.4.7.\nFor the protection of MBMS subchannel control messages, the KFC shall be the MSCCK and the KFC-ID shall be the MSCCK-ID. KFC-RAND shall be the MIKEY RAND value transmitted in the MIKEY message used to distribute the KFC. The KFC is used as defined in clause 9.4.6 and 9.4.7.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.1\tOverview",
                    "description": "",
                    "summary": "",
                    "text_content": "This solution defines the role of a Signalling Proxy within the Mission Critical System. Signalling Proxies are optional elements providing a deployment option to allow security enforcement at the edge of the MC Doman. Using the functionality defined in this document, Signalling Proxies can be used transparently to MC clients. When Signalling Proxies are used, the MCX Servers within the domain may not need to support security functionality.\nThe primary function of the signalling proxy is to perform key management of signalling keys, and encryption/decryption of application signalling transiting the edge of the mission critical domain.\nThis solution defines two types of signalling proxy:\n-\tClient Signalling proxy (CS Proxy)\n-\tInterconnection Signalling Proxy (IS Proxy)\nThe Client Signalling Proxy may perform security operations towards the client on behalf of the mission critical domain. This includes:\n-\tTopology hiding\n-\tResilience against signalling storm\n-\tCSK key management (per client);\n-\tMuSiK key management (where protection of multicast signalling is required);\n-\tProtection of application layer signalling (XML in SIP);\n-\tProtection of floor control signalling, transmission control signalling and media signalling (SRTCP);\n-\tProtection of MCData signalling payloads.\n-\tCreation of KMS Redirect Responses (KRRs).\nThe Interconnection Signalling Proxy may perform security operations towards other mission critical domains. This includes:\n-\tTopology hiding\n-\tResilience against signalling storm\n-\tStorage of SPK(s);\n-\tProtection of application layer signalling (XML in SIP);\n-\tProtection of floor control signalling, transmission control signalling and media signalling (SRTCP);\n-\tProtection of MCData signalling payloads.\n-\tCreation of KMS Redirect Responses (KRRs).\nSignalling proxies may present one or multiple identifiers externally. A CS proxy requires keying by the Key Management Server (KMS) to receive key material associated with the identifiers that it represents externally.\nNOTE:\tWhere signalling proxies are used, MCX Servers may not require keying by the KMS as they may not perform any security functionality.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.2\tLocation of a signalling proxy",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "I.2.1\tOverview",
                            "text_content": "A signalling proxy should be located at the logical edge of the MC Domain. Signalling routed via the SIP Core should be routed via the signalling proxy on entry or exit of the MC Domain. This includes RTCP signalling such as transmission and floor control.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.2.2\tDeployment with an untrusted SIP Core",
                            "text_content": "Where the SIP Core is not trusted by the Mission Critical provider, the Signalling Proxy should be located between Mission Critical Functions (MCX Server, GMS, etc.) and the external SIP Core. The use of Signalling Proxies within a MC System where the SIP Core is untrusted is shown in Figure I.2.2-1.\nThe figure depicts a simplified representation of a signalling proxy in a SIP Core, highlighting the various components and their roles in the communication process.\nFigure I.2.2-1: Signalling proxies (with untrusted SIP Core)\nInternal signalling within the MC Domain (between MCX Server(s) and GMS(s)) routes via the SIP Core. Consequently, in this scenario, the IS Proxy will route all internal signalling to/from itself via the SIP core. Each time it receives an internal signalling message, the IS Proxy should apply an SPK for protection and it should perform topology hiding towards the SIP Core.\nNOTE:\tThere may be a performance impact of locating the SIP Core outside of the MC Domain due to the increased load on the IS Proxy.\nThe use of the signalling proxy at the edge of the Mission Critical network does not remove the need to deploy a SIP Session Border Controller (as defined in RFC 5853 [24]), or IMS IBCF (as defined in Annex I of 3GPP TS 23.228 [23]), to protect the SIP core.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.2.3\tDeployment with a trusted SIP Core",
                            "text_content": "Where the SIP Core is trusted by the Mission Critical provider, the Signalling Proxy should be located at the edge of the external SIP Core, allowing data transiting the SIP core to be unencrypted. The use of Signalling Proxies within a MC System where the SIP Core is trusted is shown in Figure I.2.3-1.\nThe figure depicts a simplified representation of a signalling proxy, which is a key component in a 5G network. It shows the trusted SIP Core, which is responsible for managing the signalling between the network and the user equipment (UE). The figure illustrates the various layers of the network, including the core switches, optical line terminals (OLTs), and distributed nodes, which are essential for ensuring network reliability and failover.\nFigure I.2.3-1: Signalling proxies (with trusted SIP Core)\nIn this deployment scenario, the MC Signalling Proxy may be co-located with the SIP Core's Session Border Controller (as defined in RFC 5853 [24]), or IMS IBCF (as defined in Annex I of 3GPP TS 23.228 [23]). This has the security benefit that the SIP identities and the Mission Critical identities can be correlated at the edge, increasing the system's ability to detect misuse, associate signalling and media and apply system policies.\nNOTE 1:\tIn this deployment scenario, signalling security (e.g. XMLSec) and SIP security (e.g. TLS/IPSec) are performing the same function within the MC System. Consequently, the use of both signalling protection methods may not be necessary.\nNOTE 2:\tIn this deployment scenario, the IS Proxy is not involved in the routing of internal signalling.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "I.3\tFunctions of a signalling proxy",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "I.3.1\tOverview",
                            "text_content": "A signalling proxy may perform the functions specified in this clause.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.3.2\tIdentifier modification (topology hiding)",
                            "text_content": "One function of a signalling proxy is to change the source and destination identifiers in signalling messages to prevent the network topology being exposed externally.\n-\tMessages received on the external interface will be forwarded to an appropriate MC Server based on the type of message and consequently the destination identifier of the message will be changed by the proxy.\n-\tMessages received on the internal interface will have their source identifier replaced with the proxy's identifier.\nModification of identifiers applies to all signalling handled by the proxy. Specifically:\n-\tSIP;\n-\tApplication layer signalling (XML in SIP);\n-\tFloor control signalling, transmission control signalling and media signalling (SRTCP);\n-\tMCData signalling payloads.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.3.3\tResilience against signalling storm",
                            "text_content": "The signalling proxy is able to monitor the quantity and type of signalling entering the MC Domain. Signalling Proxy should be resilient to receiving a large amount of signalling, such as a high number of MCX Server registrations. The Signalling Proxy should be able to block, throttle or prioritise the signalling routed into the MC Domain to prevent overload of application signalling at the MCX Server, while maintaining the most critical MC services. Applying limits to signalling could be performed at a service-level or to a specific user's signalling.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.3.4\tClient connection to a CS Proxy",
                            "text_content": "When an MC client first connects to a CS Proxy, it will provide an encapsulated CSK along with an access token as part of a SIP SUBSCRIBE or SIP PUBLISH message. The CS Proxy should extract and store the CSK and decrypt the access token. The CS Proxy may verify that the message is properly constructed and applicable to this MC Domain (e.g. verify that the access token is applicable to the current MC domain). Verification failure should cause the CS Proxy to drop the message.\nThe CS Proxy should then forward the SIP SUBSCRIBE or SIP PUBLISH message onto an appropriate MCX Server with an unencrypted access token and without the encapsulated CSK.\nFrom this point onwards, signalling received from the client should be decrypted using the CSK, and signalling sent to the client should be encrypted using the CSK. This functionality is as currently defined for a MCX Server.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.3.5\tCSK key download from a CS Proxy",
                            "text_content": "The CS Proxy is responsible for CSK key management. Hence, should the CSK require renewal, the CS Proxy should create and send a ‘key download' message to the MC client containing the new CSK. This functionality is as currently defined for a MCX Server.\nAs signalling proxies may present the one or multiple SIP URIs externally, the same client may attempt to connect to the same CS Proxy twice, using different URIs and different CSKs each time. In this scenario, the CS Proxy may remove CSK ambiguity by using the ‘CSK key download' procedure as follows:\n1)\tThe MC client connects to the CS Proxy using the URI ‘A'. The MC client provides CSKA.\n2)\tThe CS Proxy receives CSKA and the MC client and CS Proxy use CSKA to protect application signalling.\n3)\tThe MC client connects to the CS Proxy using the URI ‘B'. The MC client provides CSKB.\n4)\tThe CS Proxy observes that the same client has connected again using a different destination URI.\n5)\tThe CS Proxy performs a ‘CSK key download' to update CSKB. The CS Proxy sets CSKB to CSKA.\n6)\tThe MC client and CS Proxy use CSKA to protect application signalling (regardless of source URI).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.3.6\tMuSiK and MSCCK key download from a CS Proxy",
                            "text_content": "Should multicast signalling be required, the CS Proxy should perform MuSiK key download from the CS Proxy to the MC client. To support this, the CS Proxy should perform a MuSiK key download procedure toward the MC clients that will receive multicast signalling. This functionality is as currently defined for a MCX Server.\nOn receipt of signalling from the MC domain towards a multicast bearer, the CS Proxy should protect the signalling with a MuSiK and forwards the message externally. This functionality is as currently defined for a MCX Server.\nNOTE:\tAs multiple MCX Servers can use the same CS Proxy for multicast signalling, this allows multiple MCX Servers to share multicast bearers.\nSimilarly, the CS Proxy should attach a MSCCK to MBMS Bearer Annoucement messages, and encrypt MBMS subchannel control messages with the MSCCK.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.3.7\tSignalling protection by the IS Proxy",
                            "text_content": "The IS Proxy is configured with one, or more, SPKs for protection of signalling and each SPK will be associated with specific interconnection end-point(s). On receipt of signalling from the MC domain towards an interconnection end-point, the IS Proxy should encrypt the signalling using the appropriate SPK and forward the message externally. On receipt of signalling from an interconnection end-point towards the MC Domain, the IS Proxy should decrypt the signalling and forward the message internally.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.3.8\tCreation of KMS Redirect Responses (KRRs)",
                            "text_content": "The Signalling Proxy may create KRRs to enforce local policy around the use of KMSs within the MC Domain. For example, should a MIKEY message be sent through the domain using a KMS that is unacceptable within the domain, the CS or IS Proxy may drop the MIKEY message, create a KRR and return the KRR to the sender of the MIKEY message.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "I.3.9\tPolicy enforcement",
                            "text_content": "As gateways to the MC domain, signalling proxies may also be appropriate locations to enforce policy within the MC domain.\nEditor's Note: Defining the policies that could be enforced at the signalling proxy is FFS.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "J.1\tElements for Authenticating Requests",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "J.1.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "This clause describes the functional definitions and contents for the Element for Authenticating Requests (EARs). EARs may be used to authenticate and potentially authorise signalling requests within the MC System.\nEach EAR consist of a series of information elements. The standard format of an EAR and the encoding rules for each type of information element follow that defined for the MCPTT Off-Network Protocol (MONP) as documented in Annex I of 3GPP TS 24.379 [49].\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.1.2\tFormat of an EAR",
                    "description": "",
                    "summary": "",
                    "text_content": "This subclause defines the contents of an EAR message. The EAR provides details of the request and associates that request with an authenticated identity. The EAR shall be signed using the mechanism defined in Clause 8.5.5. For the contents of the EAR see Table J.1.2-1.\nMessage type:\tEAR PAYLOAD\nDirection:\t\t\tAttached to a signalling request as defined in Clause 9.6.2.\nTable J.1.2-1: EAR PAYLOAD message content\n\n",
                    "tables": [
                        {
                            "description": "Table J.1.2-1: EAR PAYLOAD message content",
                            "table number": 38,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.1.3\tFormat of an EAR ID",
                    "description": "",
                    "summary": "",
                    "text_content": "The EAR ID information element uniquely identifies the EAR.\nThe EAR ID information element is coded as shown in Figure J.1.3-1 and Table J.1.3-1.\nThe EAR ID information element is a type 3 information element with a length of 16 octets.\nFigure J.1.3-1: EAR ID value\nTable J.1.3-1: EAR ID value\n\n",
                    "tables": [
                        {
                            "description": "The EAR ID information element is a type 3 information element with a length of 16 octets.",
                            "table number": 39,
                            "summary": "",
                            "name": ""
                        },
                        {
                            "description": "Table J.1.3-1: EAR ID value",
                            "table number": 40,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.1.4\tFormat of an entity's Role ID",
                    "description": "",
                    "summary": "",
                    "text_content": "The purpose of the Role ID information element is to identify the role of the entity and the type of entity ID used by the entity.\nThe value part of the Role ID information element is coded as shown in Table J.1.4-1.\nThe Role ID information element is a type 3 information element with a length of 1 octet.\nTable J.1.4-1: Role IDs\n\nMore fine-grained role identifications may be provided using an Authorised Identity (as defined in Clause 9.6.3).\n",
                    "tables": [
                        {
                            "description": "Table J.1.4-1: Role IDs",
                            "table number": 41,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.1.5\tFormat of an MC Entity ID",
                    "description": "",
                    "summary": "",
                    "text_content": "The MC Entity ID information element is used to indicate an MC Service user ID, an MC Group ID or an FQDN associated with an MC function. The type of Entity ID is defined by the Role ID as defined Clause J.1.4.\nThe MC Entity ID information element is coded as shown in Figure J.1.5-1 and Table J.1.5-1.\nThe MC Entity ID information element is a type 6 information element.\nFigure J.1.5-1: MC Entity ID information element\nTable J.1.5-1: MC Entity ID information element\n\n",
                    "tables": [
                        {
                            "description": "The MC Entity ID information element is a type 6 information element.",
                            "table number": 42,
                            "summary": "",
                            "name": ""
                        },
                        {
                            "description": "Table J.1.5-1: MC Entity ID information element",
                            "table number": 43,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "J.2\tRequest types and parameters",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "J.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "This clause defines the information elements that provide details of the authenticated request within an EAR payload.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.2.2\tRequest Information element",
                    "description": "",
                    "summary": "",
                    "text_content": "This subclause defines the contents of a Request. The EAR provides details of the request and associates that request with an authenticated identity. The EAR shall be signed using the mechanism defined in Clause 8.5.5. For the contents of the EAR see Table J.1.2-1.\nMessage type:\tREQUEST PAYLOAD\nDirection:\t\t\tAttached to a signalling request as defined in Clause 9.6.2.\nTable J.2.2-1: REQUEST PAYLOAD message content\n",
                    "tables": [
                        {
                            "description": "Table J.2.2-1: REQUEST PAYLOAD message content",
                            "table number": 44,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.2.3\tRequest type",
                    "description": "",
                    "summary": "",
                    "text_content": "The purpose of the Request Type information element is to identify the type of the request.\nThe value part of the Request Type information element is coded as shown in Table J.2.3-1.\nThe Request Type information element is a type 3 information element with a length of 1 octet.\nTable J.2.3-1: Request Types\n\n",
                    "tables": [
                        {
                            "description": "Table J.2.3-1: Request Types",
                            "table number": 45,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.2.4\tRequest expiry",
                    "description": "",
                    "summary": "",
                    "text_content": "The Request expiry information element is used to indicate the UTC time when the request shall no longer be considered valid. After this time, all events (e.g. calls) caused by the request shall be terminated.\nThe Request expiry information element is coded as shown in Figure J.2.4-1 and Table J.2.4-1.\nThe Request expiry information element is a type 3 information element with a length of 6 octets.\nFigure J.2.4-1: Request expiry value\nTable J.2.4-1: Request expiry value\n",
                    "tables": [
                        {
                            "description": "The Request expiry information element is a type 3 information element with a length of 6 octets.",
                            "table number": 46,
                            "summary": "",
                            "name": ""
                        },
                        {
                            "description": "Table J.2.4-1: Request expiry value",
                            "table number": 47,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.2.5\tRequest IDs",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "J.2.5.1\tFormat",
                            "text_content": "The Request ID information element is used to indicate the exact request made by a MC entity. Only Request IDs are defined for Priviledged signalling and off-network signalling Request Types. Request ID payload shall not be used for other request types.\nThe Request ID information element is coded as shown in Figure J.2.5.1-1. The contents are coded as described in subsequent subclauses.\nThe Request expiry information element is a type 3 information element with a length of 3 octets.\nFigure J.2.5.1-1: Request ID value\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "The Request expiry information element is a type 3 information element with a length of 3 octets.",
                                    "table number": 48,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "J.2.5.2\tRequest ID values for priviledged signalling",
                            "text_content": "Table J.2.5.2-1: Request ID values for priviledged signalling\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table J.2.5.2-1: Request ID values for priviledged signalling",
                                    "table number": 49,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "J.2.5.3\tRequest IDs for off-network signalling",
                            "text_content": "\nTable J.2.5.3-1: Request ID values for off-network\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table J.2.5.3-1: Request ID values for off-network",
                                    "table number": 50,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "title": "J.3\tAuthorisation fields",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "J.3.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "Authorisation fields are used to convey the entity's authorisations within the entity's identity. They are a set of name, value pairs added as SIP URI Headers.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.3.2\tAuthorisation field names",
                    "description": "",
                    "summary": "",
                    "text_content": "MC authorisation fields are encoded using the standard SIP URI Header mechanism (RFC 3261). After the '?', the fields are encoded as ampersand separated hname = hvalue pairs. Each authorisation hvalue is a bit field denoting the entity's permissions. The bit fields are defined in Clause J.3.3. The bit field is encoded in hex within the SIP URI.\nTable J.3.2-1 contains the defined SIP URI header names (hname) for the authorisation fields.\nTable J.3.2-1: SIP URI Header name denoting a MC authorisation field\n",
                    "tables": [
                        {
                            "description": "Table J.3.2-1: SIP URI Header name denoting a MC authorisation field",
                            "table number": 51,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.3.3\tAuthorisation field values",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "J.3.3.1\tGeneral",
                            "text_content": "The tables contained in this clause define the bit fields used for authorisation. In the tables, the byte ordering is left-most byte first. The bit ordering is least-signficant bit first.\nThe bit fields may be extended with further bytes in future specifications. Any bytes within the authorisation fields of a MC Service ID that do not correspond with a bit in a table below shall be ignored. The maximum length of a bit field shall be 1024 bits (or 256 hex characters).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "J.3.3.2\tRole authorisations",
                            "text_content": "Table J.3.3.2-1: User role authorisations (mc-role-client)\n\nTable J.3.3.2-2: Server role authorisations (mc-role-server)\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table J.3.3.2-1: User role authorisations (mc-role-client)",
                                    "table number": 52,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table J.3.3.2-2: Server role authorisations (mc-role-server)",
                                    "table number": 53,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "J.3.3.3\tAuthorisations for priviledged signalling",
                            "text_content": "Table J.3.3.3-1: MCPTT privileged signalling authorisations (mc-priv-mcptt)\n\nTable J.3.3.3-2: MCVideo privileged signalling authorisations (mc-priv-mcvideo)\n\nTable J.3.3.3-3: MCData privileged signalling authorisations (mc-priv-mcdata)\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table J.3.3.3-1: MCPTT privileged signalling authorisations (mc-priv-mcptt)",
                                    "table number": 54,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table J.3.3.3-2: MCVideo privileged signalling authorisations (mc-priv-mcvideo)",
                                    "table number": 55,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table J.3.3.3-3: MCData privileged signalling authorisations (mc-priv-mcdata)",
                                    "table number": 56,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "J.3.3.4\tAuthorisations for off-network signalling",
                            "text_content": "Table J.3.3.4-1: MCPTT Off-network signalling authorisations (mc-offnet-mcptt)\n\nTable J.3.3.4-2: MCVideo Off-network signalling authorisations (mc-offnet-mcvideo)\n\nTable J.3.3.4-3: MCData Off-network signalling authorisations (mc-offnet-mcdata)\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table J.3.3.4-1: MCPTT Off-network signalling authorisations (mc-offnet-mcptt)",
                                    "table number": 57,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table J.3.3.4-2: MCVideo Off-network signalling authorisations (mc-offnet-mcvideo)",
                                    "table number": 58,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table J.3.3.4-3: MCData Off-network signalling authorisations (mc-offnet-mcdata)",
                                    "table number": 59,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "J.3.4\tExample Authorised Identities",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "J.3.4.1\tGeneral",
                            "text_content": "This clause contains examples of Authorised Identities using the names from Clause J.3.2 and the values from Clause J.3.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "J.3.4.2\tPTT User (on and off-network)",
                            "text_content": "If a user has the following MC Service ID (without authorisation):\nsip:mc.user@example.org\nIf the user is authorised to use a mcptt client, on and off-network (but no privileged signalling), then the IdM-provided access token sent to the KMS will contain the following values in the scope:\n\"3gpp:mc:auth:role:client:ptt\"\n\"3gpp:mc:auth:offnet:mcptt:use\"\n\"3gpp:mc:auth:offnet:mcptt:group_call_announcement\"\n\"3gpp:mc:auth:offnet:mcptt:emergency_alert_announcement\"\n\"3gpp:mc:auth:offnet:mcptt:call_setup_req\"\nThe following is the user's authorised MC Service ID:\nsip:mc.user@example.org?mc-role-client=01&mc-offnet-mcptt=0f\nIf supported, the KMS shall provision keys to the user's KM client for both the original MC Service ID and the authorised MC Service ID.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "J.3.4.3\tDispatcher",
                            "text_content": "If we assume a dispatcher has full permission to take any action (on-network) and the following MC Service ID:\nsip:mc.dispatcher@example.org\nThen the authorised MC Service ID is:\nsip: mc.dispatcher@example.org?mc-role-client=07&mc-priv-mcptt=07&mc-priv-mcvideo=07&mc-priv-mcdata=7f\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "K.1\tGeneral",
            "description": "This clause provides some details of non-3GPP security mechanisms which may be in use in the 3GPP network. The purpose of including it in this specification is to inform 3GPP vendors and system owners about the existance of such mechanisms. The definition of these mechanisms is out of scope of this document.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "K.2\tLMR E2EE",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "K.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "LMR end-to-end security allows the IWF to pass protected media unmodified from the 3GPP system to the LMR system. The LMR end-to-end security mechanisms are out of scope of this document.\nThis clause assumes a non-3GPP (LMR) layer operating below the 3GPP layer defined in this specification at the UE, and potentially at the IWF. This layer may pass media packets to the 3GPP layer for further processing. The 3GPP layer and the non-3GPP layer act independently of each other.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "K.2.2\tInterworking E2EE keys and key management",
                    "description": "",
                    "summary": "",
                    "text_content": "Void.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "K.2.3\tInterworking E2EE media for MCPTT",
                    "description": "",
                    "summary": "",
                    "text_content": "Non-3GPP RTP or SRTP packets are generated within the non-3GPP layer of the 3GPP MC UE. The generation method of these media packets within the non-3GPP layer of the 3GPP MC UE is out of scope for this document. The non-3GPP layer may or may not apply non-3GPP security to the media.  Any non-3GPP security applied to the media packets within the non-3GPP layer is out of scope for this document.  Management of the non-3GPP E2EE interworking keys is defined in clause 11.2.\nOnce processed by the non-3GPP layer, the packet is passed to the 3GPP application layer for further 3GPP processing.  The 3GPP application layer views the packet as an unencrypted RTP stream regardless of whether security has been applied at the non-3GPP layer.  If the interworking communication is a private MCPTT call, the 3GPP application layer applies MCPTT private call security to the media packet as defined in clause 7.2.  If the interworking communication is a group MCPTT call, the 3GPP application layer applies MCPTT group call security to the media packet as defined in clause 7.3.  Once processed by the MC application layer, the media is sent by the MC client to the IWF.\nAs defined in clause 11.2, the IWF is the 3GPP security endpoint for any private or group call security applied to the interworking RTP packets that is sent to, or received from, the 3GPP system.  The IWF applies SeGy security functionality to remove security from the messages sent by the 3GPP system before processing the unencrypted message.  Consequently, the IWF processes inbound interworking RTP packets prior to applying SeGy security functionality and sending them into the 3GPP system.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "K.2.4\tInterworking E2EE media for MCData",
                    "description": "",
                    "summary": "",
                    "text_content": "Non-3GPP MCData Data payloads sent from a 3GPP MC UE to the IWF are generated within the non-3GPP layer of the 3GPP MC UE. The generation method of the payload within the non-3GPP layer of the 3GPP MC UE is out of scope for this document. The non-3GPP layer may or may not apply MCData security to the payload.  Any E2EE non-3GPP security applied to the payload within the non-3GPP layer is out of scope for this document.  Management of the non-3GPP E2EE interworking keys is defined in clause 11.2.\nFor MCData messages sent by the 3GPP system, the non-3GPP layer creates the MCData Data payload and passes to the 3GPP application layer for further 3GPP processing.  The 3GPP application layer views the packet as an unencrypted payload regardless of whether security has been applied at the non-3GPP layer.  If the interworking communication is a private MCData call, the 3GPP application layer applies MCData private communication security to the payload as defined in clause 8. If the interworking communication is a group MCData communication, the 3GPP application layer applies MCData group communication security to the payload as defined in clause 8.  Once processed by the MC application layer, the media is sent by the MC client to the IWF.\nAs defined in clause 11.2, the IWF is the 3GPP security endpoint for any MCData security applied to the interworking MCData message that is sent to, or received from, the 3GPP system.  The IWF applies SeGy security functionality to remove security from the MCData messages sent by the 3GPP system before processing the unencrypted message.  Consequently, the IWF processes inbound MCData messages prior to applying SeGy security functionality and sending them into the 3GPP system.\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "L.1\tGeneral",
            "description": "The MC Security Gateway is a network function that terminates all 3GPP MC security functionality from a protected 3GPP MC system to allow MC signalling and media to be provided to an unprotected MC system or external system. The use of a MC Security Gateway is required when the system that the user wishes to communicate with does not support MC security mechanisms defined in this specification.\nThe SeGy is a network element in its own right. It may also be used as part of a Interworking Function (IWF) when the IWF requires MC security functionality to be terminated.\nThe use of a MC Security Gateway terminates end-to-end 3GPP protected media and signalling security.  For this reason, a notification shall be provided to the MC user by the MC client when the user's communication involves a MC Security Gateway.\nProtection of media and signalling within an external system is out of scope for this standard, and therefore the external system is responsible for ensuring that both signalling and media within the external system are appropriately protected.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "L.2\tFunctional model for the MC Security Gateway (SeGy)",
            "description": "A MC Security Gateway (SeGy) communicates with 3GPP MC systems as a 3GPP partner interconnected MC domain. The SeGy has two interfaces. On the encrypted interface, the SeGy acts as a 3GPP MC domain that uses MC security mechanisms defined in this specification. On the encrypted interface, the SeGy communicates with protected MC systems (MC systems that use the security mechanisms defined in this specification). On the unencrypted interface the SeGy acts as a 3GPP MC domain that does not use the security mechanisms defined in this specification. On the unencrypted interface, the SeGy communicates with unprotected MC systems (MC systems that do not use the security mechanisms defined in this specification) or external systems. Consequently, on the encrypted interface media shall be encrypted and signalling may be encrypted. On the unencrypted interface, media and signalling are unencrypted. Figure L.2-1 shows the role of the SeGy in context.\nThe MC Security Gateway (SeGy) is a security gateway designed for use with MC Security Networks. It is a modular, scalable, and secure solution that provides advanced security features and capabilities. The MC Security Network is a network that uses MC Security Gateways to provide secure communication and data protection. The MC Security Gateway is a key component of the MC Security Network, enabling secure communication and data protection.\nFigure L.2-1: MC Security Gateway (SeGy)\nThe SeGy shall be configured as an independent security domain to existing MC security domains. In Figure L.2-1, the MC Domain is in Security Domain A, whereas the SeGy is in Security Domain X. This allows the risk of terminating security to be isolated to the SeGy, and allows the use of the SeGy to be communicated to clients.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "L.3\tFunctions of a MC Security Gateway (SeGy)",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "L.3.1\tComponents of a MC Security Gateway (SeGy)",
                    "description": "",
                    "summary": "",
                    "text_content": "At a high-level, the MC Security gateway is composed of four components:\n-\tPseudo KMS.\n-\tPseudo GMS.\n-\tPseudo MCX Server(s).\n-\tPseudo MC clients.\nThe term \"pseudo\" in this case is used to indicate that the security functionality of these components shall be implemented as part of a SeGy however physical entities and servers (i.e. KMS, GMS, MC service servers and MC clients) are not required. The method used to implement a pseudo KMS, GMS, MC service server or MC clients and associated key material within a SeGy is left to the manufacturer and is outside the scope of 3GPP. These components are shown in Figure L.3.1-1.\nThe MC Security Gateway (SeGy) in Figure L.3.1-1 is a crucial component in the network security architecture. It is designed to protect the network from unauthorized access and potential threats. The figure illustrates the various components of the SeGy, including the security gateway, the network security system, and the network security management system. The SeGy is designed to provide a secure environment for the network, ensuring that only authorized users and devices can access the network. The figure also highlights the importance of network security in today's digital age, where cyber threats are becoming increasingly sophisticated.\nFigure L.3.1-1: Components of a MC Security Gateway (SeGy)\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "L.3.2\tPseudo KMS",
                    "description": "",
                    "summary": "",
                    "text_content": "The SeGy contains a KMS function. This establishes the SeGy as containing its own security domain (Security Domain X). The Pseudo KMS does not perform key management functions with any clients, but allows the SeGy to represent external system functions and users as members of the SeGy's security domain within the 3GPP MC System.\nThe Pseudo KMS shall cross-sign with KMSs in partner protected MC systems that use the SeGy. This means that the SeGy's KMS Certificate shall be provided to the KMS in a partner protected MC system (and vice-versa). As a consequence of cross-signing, users in partner security domains will be able to securely communicate with (external users and groups represented by) the SeGy. As cross-signing is a manual process, no communication is required between KMSs in partner protected MC systems and the SeGy's pseudo KMS.\nThe SeGy shall create a KMS Certificate as defined in Annex D. The KMS Certificate generated by the SeGy shall include the information that the Certificate originates from an MC Security Gateway. The SeGy's KMS Certificate represents the security domain for the external users that use the SeGy's unencrypted interface and the pseudo network entities within the SeGy itself. This type of KMS Certificate is known as a SeGy KMS Certificate. The use of a SeGy KMS Certificate ensures that 3GPP MC systems and 3GPP MC clients that use the SeGy are aware that a gateway is in use. A visual reference shall be provided to MC users when communicating with a user whose KMS URI corresponds to a SeGy.\nIn partner systems, the Pseudo KMS shall never be a Migration KMS, but shall be an External KMS.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "L.3.3\tPseudo GMS",
                    "description": "",
                    "summary": "",
                    "text_content": "Should the MC Security Gateway support group communications, the SeGy shall contain a Pseudo GMS. The SeGy's GMS will perform the security functionality of a GMS towards partner GMSs on the encrypted interface. In terms of security, the SeGy GMS will create and add GMKs to Notification messages sent to GMSs in partner protected systems. The SeGy GMS will also receive GMKs from within Notification messages sent by GMSs in partner protected systems. Specifically, on the encrypted interface the SeGy:\n-\tShall support inter-GMS GMK distribution functionality defined in Clauses 5.7 and 11.1.2.2.\n-\tMay support verification of EAR elements attached to incoming signalling messages from external security domains as defined in Clause 9.6.\n-\tMay support attaching EAR elements to outgoing signalling messages as defined in Clause 9.6.\nThe SeGy is able to sign and encrypt messages on the encrypted interface as the pseudo GMS using key material provided by the SeGy's Pseudo KMS.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "L.3.4\tPseudo MCX Server or IS Proxy",
                    "description": "",
                    "summary": "",
                    "text_content": "The SeGy performs the security functions of an IS Proxy (or equivalently, the MCX Server) towards protected MC systems. Specifically, the on the encrypted interface SeGy may:\n-\tEstablish and use a SPK with protected MC systems as defined in Clauses 5.5 and 9.\n-\tVerify EAR elements attached to incoming signalling messages from external security domains as defined in Clause 9.6.\n-\tAttach EAR elements to outgoing signalling messages as defined in Clause 9.6.\nThe SeGy is able to sign and encrypt messages as the IS Proxy using key material provided by the Pseudo KMS.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "L.3.5\tPseudo MC clients",
                    "description": "",
                    "summary": "",
                    "text_content": "For each client in an external or unprotected MC system that uses the SeGy's unenrypted interface, the SeGy performs the security functions of an MC client on behalf of the external user. As an external user is signalled from the protected MC system, or sends signalling from within the unprotected MC system, the SeGy creates security credentials on behalf of the user using the Pseudo KMS. Consequently, any group or private communications directed towards a user in the unprotected MC system can be decrypted by the SeGy. Unencrypted communications can then be sent towards the client in the unprotected MC system over the unencrypted interface.\nSpecifically, on the encrypted interface the SeGy:\n-\tShall support end-to-end security functionality for MCPTT, MCVideo and MCData defined in Clauses 7 and 8.\n-\tMay support verification of EAR elements attached to incoming signalling messages from external security domains as defined in Clause 9.6.\n-\tMay support attaching EAR elements to outgoing signalling messages as defined in Clause 9.6.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "L.4\tSecurity procedures for the MC Security Gateway (SeGy)",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "L.4.2\tSecurity procedures for private communication (initiated in the protected MC system)",
                    "description": "",
                    "summary": "",
                    "text_content": "The following private communication security procedures provide a mechanism for establishing a security context as part of the following private communication requests:\n-\tPrivate Call Request (MCPTT)\n-\tPrivate Call Request (MCVideo)\n-\tMCData standalone data request\n-\tMCData session data request\n-\tMCData FD request\nThese requests are sent from an initiating MC client (on the unencrypted interface) to the terminating MC client (on the encrypted interface) via the MC Security Gateway.\nThe security procedure for a private communication via an MC Security Gateway is summarized in Figure L.4.2-1, In these procedures, the initiating client follows the security procedures defined in Clause 7.2.2 (MCPTT or MCVideo) or Clause 8.3 (MCData). The terminating client on the unencrypted interface does not use the MC security procedures defined in Clause 7 and 8. Prior to beginning this procedure, it is assumed that the initiating MC client has been provisioned with key material associated with a user's MC service ID by the initiating user's KMS as described in clause 5.3. It is also assumed that the SeGy has established its own ‘pseudo KMS'. Finally, it is assumed that the SeGy's KMS Certificate has been provisioned as an External KMS Certificate to the initiating client by the initiating user's KMS (as defined in Clause 5.3). The SeGy's KMS Certificate shall have the ‘IsSecurityGateway' attribute set to ‘true'.\n\nThe figure depicts a private call security procedure for SeGy (call initiated on the encrypted interface), illustrating the steps taken to ensure the confidentiality and integrity of the communication.\nFigure L.4.2-1: Private call security procedure for SeGy (call initiated on the encrypted interface)\nThe procedure in Figure L.4.2-1 is now described step-by-step.\n1a.\tThe initiating MC client generates the PCK and sends a private call request to the terminating entity as defined in Clause 7.2.2 (MCPTT and MCVideo) or Clause 8.3 (MCData). The message is routed via a SeGy. The SeGy receives the I_MESSAGE and generates the terminating user's decryption key material using its ‘pseudo KMS'. The SeGy uses this key material to decrypt the PCK and stores the PCK and the PCK-ID for future use.\n1b.\tThe SeGy removes the I_MESSAGE from the communication request and extracts the PCK.  The SeGy forwards the modified communication request towards the terminating MC client.\n2a.\tFurther session signalling that occurs between the client and MCX server is protected using the CSK and protected from the MCX server to the SeGy using the SPK.\n2b. Further session signalling that occurs between the SeGy and the unprotected MC domain is unencrypted.\n3.\tCommunication media sent and received on the encrypted interface is encrypted using the PCK (3a) as defined in Clause 7.5 or 8.5. Communication media sent and received on the unencrypted interface is unencrypted (3b). On receipt of media on the encrypted interface, the SeGy decrypts the media using the PCK and forwards the media on the unencrypted interface. On receipt of media on the unencrypted interface, the SeGy encrypts the media using the PCK and forwards the media on the encrypted interface.\nThe initiating MC client is aware a MC Security Gateway is in use based upon the ‘IsSecurityGateway' flag in the KMS Certificate used by the SeGy. During the communication, the initiating MC client shall warn the MC user that the communication is via an MC Security Gateway.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "L.4.3\tSecurity procedures for private communication (initiated in the unprotected MC system)",
                    "description": "",
                    "summary": "",
                    "text_content": "The following private communication security procedures provide a mechanism for establishing a security context between the SeGy and a MC client as part of the following private communication requests:\n-\tPrivate Call Request (MCPTT).\n-\tPrivate Call Request (MCVideo).\n-\tMCData standalone data request.\n-\tMCData session data request.\n-\tMCData FD request.\nThese requests are sent from an initiating MC client (on the unencrypted interface) to the terminating MC client (on the encrypted interface) via the MC Security Gateway.\nThe security procedure for an on-network MCPTT or MCVideo private call via an MC Security Gateway is summarized in Figure L.4.3-1, In these procedures, the terminating client follows the security procedures defined in Clause 7.2.2 (MCPTT and MCVideo) or Clause 8.3 (MCData). The initiating client on the unencrypted interface does not use the MC security procedures defined in Clause 7 and 8.\nPrior to beginning this procedure, it is assumed that the terminating MC client has been provisioned with key material associated with a user's MC service ID by the terminating user's KMS as described in Clause 5.3. It is also assumed that the SeGy has established its own ‘pseudo KMS'. Finally, it is assumed that the SeGy's KMS Certificate has been provisioned as an External KMS Certificate to the terminating client by the terminating user's KMS (as defined in Clause 5.3). The SeGy's KMS Certificate shall have the ‘IsSecurityGateway' attribute set to ‘true'.\n\nThe figure depicts a private call security procedure for SeGy (call initiated on the unencrypted interface), illustrating the steps taken to ensure the confidentiality and integrity of the call.\nFigure L.4.3-1: Private call security procedure for SeGy (call initiated on the unencrypted interface)\nThe procedure in figure L.4.3-1 is now described step-by-step.\n1a.\tThe initiating client sends a private communication request to the terminating MC client. The message is routed via a SeGy. The SeGy receives the message and generates a PCK and PCK-ID. The SeGy creates an I_MESSAGE and encapsulates the PCK and PCK-ID as defined in Clause 5.6. The SeGy attaches the I_MESSAGE to the received communication request within an SDP offer as defined in IETF RFC 6509 [11]. The modified communication request is forwarded towards the terminiating MC client.\n1b.\tThe terminating MC client receives the communication request and processes it as described in Clause 7.2.2 (MCPTT and MCVideo) or Clause 8.3 (MCData).\n2a.\tFurther session signalling that occurs between the SeGy and MCX server is protected using the SPK and protected between the MCX server and terminating MC UE client using the CSK.\n2b. Further session signalling that occurs between the SeGy and the unprotected MC domain is unencrypted.\n3.\tCommunication media sent and received on the encrypted interface is encrypted using the PCK (3a) as defined in Clause 7.5 or 8.5. Communication media sent and received on the unencrypted interface is unencrypted (3b). On receipt of media on the encrypted interface, the SeGy decrypts the media using the PCK and forwards the media on the unencrypted interface. On receipt of media on the unencrypted interface, the SeGy encrypts the media using the PCK and forwards the media on the encrypted interface.\nThe terminating MC client is aware a MC Security Gateway is in use based upon the ‘IsSecurityGateway' flag in the KMS Certificate used by the SeGy. During the communication, the terminating MC client shall warn the MC user that the communication is via an MC Security Gateway.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "L.4.4\tSecurity procedures for group communications (group homed in the protected MC system)",
                    "description": "",
                    "summary": "",
                    "text_content": "This procedure uses a MIKEY payload to distribute a GMK from the GMS to another GMS to support group interconnection. The GMS follows the procedures in Clause 5.7 and 11.1.2.2. In this clause, it is assumed that at least one group member is in the unprotected system and hence the Notify group request containing the GMK is routed to the GMS in the unprotected system.\nPrior to beginning this procedure, it is assumed that the GMS has been provisioned by its KMS with key material associated with its identity. It is also assumed that the SeGy has established its own ‘pseudo KMS'. Finally, it is assumed that the SeGy's KMS Certificate has been provisioned as an External KMS Certificate to the GMS by the GMS's KMS (as defined in Clause 5.3). The SeGy's KMS Certificate shall have the ‘IsSecurityGateway' attribute set to ‘true'.\nFigure L.4.4-1 shows the security procedures for creating a security association for a group with a SeGy.\nFigure L.4.4-1: Security configuration for MC groups (where a group member is behind a SeGy)\nA description of the procedures depicted in figure L.4.4-1 follows:\n1a.\tThe GMS shall send a MIKEY payload containing a GMK to the GMS in an interconnected system within a 'Group information notify request' message as defined in Clause 11.1.2.2. Where the interconnected system is unprotected and hence is behind a SeGy, the 'Group information notify request' is sent via the SeGy. The SeGy shall generate the Pseudo GMS's identity-based key material using its pseudo-KMS and use this key material to extract the GMK and GMK-ID from the I_MESSAGE within the ‘Notify group request'.\n1b.\tThe SeGy shall remove the I_MESSAGE from the 'Group information notify request' and forward the modified request towards the unprotected MC system's GMS.\n2.\tThe SeGy shall forward on further signalling invisibly (including the ‘Notify response').\n3a.\tGroup media sent and received on the encrypted interface is encrypted using the GMK (3a) as defined in Clause 7.5 or 8.5. Group signalling sent and received on the encrypted interface is protected as defined in clause 9.  On receipt of media on the encrypted interface, the SeGy decrypts the media using the GMK and GMK-ID and forwards the media on the unencrypted interface.\n3b. Group media sent and received on the unencrypted interface is unencrypted (3b). Group signalling sent and received on the unencrypted interface is unprotected.  On receipt of media on the unencrypted interface, the SeGy encrypts the media using the GMK and forwards the media on the encrypted interface.\nThe GMS is aware a MC Security Gateway is in use based upon the ‘IsSecurityGateway' flag in the KMS Certificate used by the SeGy. When any group member is behind a Security Gateway, the GMS shall set the ‘Security Gateway' flag within the ‘Status' field of the group GMK's key parameters (as defined in Clause E.6.9).\nThe MC group clients within the protected MC system are aware the MC Security Gateway is in use based upon the ‘Security Gateway' flag within the ‘Status' field of the GMK's key parameters (as defined in Clause E.6.9). During a communication encrypted with the GMK, the MC group client shall warn the MC user that the communication may be via an MC Security Gateway.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "L.4.5\tSecurity procedures for group communications (group homed in the unprotected MC system)",
                    "description": "",
                    "summary": "",
                    "text_content": "In this clause, it is assumed that the group is owned by a GMS inside the unprotected system and group members and their GMS are inside the protected domain. The GMS in the protected domain follows the procedures in Clause 5.7 and 11.1.2.2. A Notify group request is routed from the GMS in the unprotected domain to the GMS in the protected system.\nPrior to beginning this procedure, it is assumed that the GMS in the protected domain has been provisioned by its KMS with key material associated with its identity. It is also assumed that the SeGy has established its own ‘pseudo KMS'. Finally, it is assumed that the SeGy's KMS Certificate has been provisioned as an External KMS Certificate to the GMS in the protected system by the GMS's KMS (as defined in Clause 5.3). The SeGy's KMS Certificate shall have the ‘IsSecurityGateway' attribute set to ‘true'.\nFigure L.4.5-1 shows the security procedures for creating a security association for a group with a SeGy.\nThe figure depicts a security configuration for MC groups in an unprotected domain, illustrating the various security measures and configurations that can be applied to protect the network.\nFigure L.4.5-1: Security configuration for MC groups (where group is homed in an unprotected domain)\nA description of the procedures depicted in figure L.4.5-1 follows:\n1a.\tThe GMS in the unprotected system send a Group Notify to the GMS in an interconnected system within a 'Group information notify request' message as defined in Clause 11.1.2.2. Where the interconnected system is protected and hence is behind a SeGy, the 'Group information notify request' is sent via the SeGy.\n1b.\tOn receipt of a Notify group request on the unencrypted interface, the SeGy shall generate a GMK and GMK-ID and encrypt the GMK to the GMS in the protected system using the SeGy's Pseudo GMS's identity-based key material. SeGy shall set the ‘Security Gateway' flag within the ‘Status' field of the group GMK's key parameters (as defined in Clause E.6.9). The encapsulated GMK and GMK-ID is attached to the ‘Notify group request' within an I_MESSAGE as defined in Clause 5.7. The modified ‘Notify group request' is sent on by the SeGy to the GMS in the protected system.\n2.\tThe SeGy shall forward on further signalling invisibly (including the ‘Notify response').\n3a.\tGroup media sent and received on the encrypted interface is encrypted using the GMK (3a) as defined in Clause 7.5 or 8.5. Group signalling sent and received on the encrypted interface is protected as defined in clause 9.  On receipt of media on the encrypted interface, the SeGy decrypts the media using the GMK and GMK-ID and forwards the media on the unencrypted interface.\n3b. Group media sent and received on the unencrypted interface is unencrypted (3b). Group signalling sent and received on the unencrypted interface is unprotected.  On receipt of media on the unencrypted interface, the SeGy encrypts the media using the GMK and forwards the media on the encrypted interface.\nThe GMS in the protected system is aware a MC Security Gateway is in use based upon the ‘IsSecurityGateway' flag in the KMS Certificate used by the SeGy and as the ‘Security Gateway' flag will be set within the ‘Status' field of the group GMK's key parameters (as defined in Clause E.6.9).\nOn receipt of the GMK, the GMS in the protected domain shall distribute the key to group clients as defined in Clause 5.7. MC group clients in the protected system are aware the MC Security Gateway is in use based upon the ‘Security Gateway' flag within the ‘Status' field of the GMK's key parameters (as defined in Clause E.6.9). During a communication encrypted with the GMK, the MC group client shall warn the MC user that the communication may be via an MC Security Gateway.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "L.5\tInterworking using a MC Security Gateway",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "L.5.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "Interworking with Land Mobile Radio Systems is defined in TS 23.283[48]. An interworking function (IWF) is required to allow the MC System to interwork with Land Mobile Radio Systems.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "L.5.2\tMC Security Gateway and the IWF",
                    "description": "",
                    "summary": "",
                    "text_content": "The functional model for the SeGy as used within the IWF is shown in Figure L.5.2-1. Where the IWF terminates the security of the 3GPP MC Domain, the IWF performs the functions of a SeGy for that purpose.\nFor interworking communications sent towards the non-3GPP system, an MC gateway with an IS Proxy and the HTTP proxy are used to provide topology hiding and terminate external routing as defined in clause 11.1.3 and the IWF processes the signalling and media for use in the Land Mobile Radio System after terminating the 3GPP MC system security.  Where the media and signalling between an MC Domain and IWF is not encrypted using 3GPP MC security mechanisms, the SeGy functionality is not applied by the IWF, allowing the media and signaling to pass directly through for processing by the IWF.\nFor interworking communications sent from a Land Mobile Radio system towards the 3GPP system, the IWF processes the signalling and media from the Land Mobile Radio system prior to applying 3GPP security and sending it into the 3GPP system.  Where the media and signalling between an MC Domain and IWF is not encrypted using 3GPP MC security mechanisms, the SeGy functionality is not applied by the IWF, allowing the processed media and signaling to pass directly from the IWF into the 3GPP system.\nThe figure depicts a functional model for MC Security Gateway use during interworking, illustrating the various components and their interactions.\nFigure L.5.2-1: Functional model for MC Security Gateway use during interworking\nThe IWF-1 reference point is defined in 23.283 [48] and provides for the transfer of MCPTT media and signalling between a 3GPP MC domain MCPTT server and the IWF.  Authentication and security of this interface shall be as described in clause 6.\nThe IWF-2 reference point is defined in 23.283 [48] and provides for the transfer of MCData media and signalling between a 3GPP MC domain MCData server and the IWF.  Authentication and security of this interface shall be as described in clause 6.\nThe IWF-3 reference point is defined in 23.283 [48] and provides for the transfer of group management information between a 3GPP MC domain GMS and the IWF.  Authentication and security of this interface shall be as described in clause 6.\nAny security applied by the non-3GPP system to MCPTT or MCData media and signalling, or any interfaces within the non-3GPP system is defined by the non-3GPP system and is out of scope for this document.\n\n\n\n",
                    "tables": [
                        {
                            "description": "",
                            "table number": 60,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        }
    ]
}