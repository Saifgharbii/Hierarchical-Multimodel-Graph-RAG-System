{
    "document_name": "33220-i20.docx",
    "content": [
        {
            "title": "Foreword",
            "description": "This Technical Specification has been produced by the 3rd Generation Partnership Project (3GPP).\nThe contents of the present document are subject to continuing work within the TSG and may change following formal TSG approval. Should the TSG modify the contents of the present document, it will be re-released by the TSG with an identifying change of release date and an increase in version number as follows:\nVersion x.y.z\nwhere:\nx\tthe first digit:\n1\tpresented to TSG for information;\n2\tpresented to TSG for approval;\n3\tor greater indicates TSG approved document under change control.\ny\tthe second digit is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc.\nz\tthe third digit is incremented when editorial only changes have been incorporated in the document.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "1\tScope",
            "description": "The present document describes the security features and mechanisms to bootstrap authentication and key agreement for application security. Candidate applications to use this bootstrapping mechanism include but are not restricted to subscriber certificate distribution TS 33.221 [5]. Subscriber certificates support services whose provision mobile operator assists, as well as services that mobile operator provides.\nThe scope of this specification includes generic bootstrapping functions, an architecture overview and the detailed procedure how to bootstrap the credential.\nClause 4 of this specification describes a mechanism, called GBA_ME, to bootstrap authentication and key agreement, which does not require any changes to the UICC. Clause 5 of this specification describes a mechanism, called GBA_U, to bootstrap authentication and key agreement, which does require changes to the UICC, but provides enhanced security by storing certain derived keys on the UICC.  Annex I of this specification describes a mechanism, called 2G GBA, to bootstrap authentication and key agreement using 2G AKA protocol.  Annex M of this specification describes a mechanism, called GBA_Digest, to bootstrap authentication and key agreement using HTTP Digest protocol with SIP Digest credentials.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "2\tReferences",
            "description": "The following documents contain provisions which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non-specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TS 31.102: \"Characteristics of the USIM application\".\n[2]\t3GPP TS 33.102: \"3G Security; Security architecture\".\n[3]\tVoid\n[4]\tIETF RFC 3310: \"Hypertext Transfer Protocol (HTTP) Digest Authentication Using Authentication and Key Agreement (AKA)\".\n[5]\t3GPP TS 33.221: \"Generic Authentication Architecture (GAA); Support for Subscriber Certificates\".\n[6]\tVoid\n[7]\tVoid\n[8]\tVoid\n[9]\tVoid.\n[10]\t3GPP TS 31.103: \"Characteristics of the IP Multimedia Services Identity Module (ISIM) application\".\n[11]\t3GPP TS 23.003: \"Numbering, addressing and identification\".\n[12]\tVoid\n[13]\t3GPP TS 33.210: \"3G Security; Network domain security; IP network layer security\".\n[14]\tVoid.\n[15]\t3GPP TS 31.101: \"UICC-terminal interface; Physical and logical characteristics\".\n[16]\t3GPP TS 33.203: \"3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G security; Access security for IP-based services\".\n[17]\tVoid.\n[18]\tIETF RFC 2818: \"HTTP over TLS\".\n[19]\t3GPP TS 33.310: \"Network Domain Security (NDS); Authentication Framework (AF)\".\n[20]\tVoid.\n[21]\tVoid.\n[22]\tIETF RFC 2104: \"HMAC: Keyed-Hashing for Message Authentication\".\n[23]\tISO/IEC 10118-3:2004: \"Information Technology – Security techniques – Hash-functions – Part 3: Dedicated hash-functions\".\n[24]\tIETF RFC 3629: \"UTF-8, a transformation format of ISO 10646\".\n[25]\t3GPP TS 33.222: \"Generic Authentication Architecture (GAA); Access to network application functions using Hypertext Transfer Protocol over Transport Layer Security (HTTPS)\".\n[26]\t3GPP TS 33.246: \"3G Security; Security of Multimedia Broadcast/Multicast Service (MBMS)\".\n[27]\tVoid.\n[28]\tVoid\n[29]\t3GPP TS 24.109: \"Bootstrapping interface (Ub) and network application function interface (Ua); Protocol details\".\n[30]\t(void)\n[31]\t(void)\n[32]\t3GPP TS 29.109: \"Generic Authentication Architecture (GAA); Zh and Zn Interfaces based on the Diameter protocol; Stage 3\".\n[33]\tVoid\n[34]\t3GPP TS 23.002: “Network architecture “.\n[35]\t3GPP TS 33.401: \"3GPP System Architecture Evolution (SAE); Security Architecture\".\n[36]\t3GPP TS 33.402: \"3GPP System Architecture Evolution (SAE); Security aspects of non-3GPP accesses\".\n[37]\t\"Unicode Standard Annex #15; Unicode Normalization Forms\", Unicode 5.1.0, March 2008.\n[38]\t3GPP TS 26.237: \"IP Multimedia Subsystem (IMS) based Packet Switch Streaming (PSS) and Multimedia Broadcast/Multicast Service (MBMS) User Service; Protocols\".\n[39]\t3GPP TS 33.224: \"Generic Authentication Architecture (GAA); Generic Bootstrapping Architecture (GBA) Push Layer\".\n[40]\t3GPP TS 33.328: \"IMS Media plane security\".\n[41]\tVoid\n[42]\t(void)\n[43]\tVoid.\n[44]\tIETF RFC 5705: \"Keying Material Exporters for Transport Layer Security (TLS)\".\n[45]\t3GPP TS 33.223: \"Generic Authentication Architecture (GAA); Generic Bootstrapping Architecture (GBA) Push function\".\n[46]\t3GPP TS 44.006 \"Technical Specification Group GSM/EDGE Radio Access Network; Mobile Station - Base Station System (MS - BSS) interface; Data Link (DL) layer specification\".\n[47]\t3GPP TS 43.020 \"Technical Specification Group Services and system Aspects; Security related network functions\".\n[48]\tIETF RFC 5929 \"Channel Bindings for TLS\".\n[49]\t3GPP TS 33.303: \"Proximity-based Services; Security Aspects\".\n[50]\t3GPP TS 33.179: \"Security of Mission Critical Push-To-Talk (MCPTT)\".\n[51]\t3GPP TS 33.203: \"3G security; Access security for IP-based services\".\n[52]\t3GPP TS 33.163: \" Battery Efficient Security for very low Throughput Machine Type Communication (MTC) devices (BEST)\".\n[53]\t3GPP TS 33.501: \" Security architecture and procedures for 5G system\".\n[54]\t3GPP TS 33.180: \"Technical Specification Group Services and System Aspects; Security of the mission critical service\".\n[55]\t3GPP TS 33.122: \"Security Aspects of Common API Framework for 3GPP Northbound APIs\".\n[56]\t3GPP TS 33.536: \"Security Aspect of 3GPP Support for Advanced V2X Services\".\n[57]\tVoid\n[58]\t3GPP TS 33.535: \"Authentication and Key Management for Applications (AKMA) based on 3GPP credentials in the 5G System (5GS)\".\n[59]\tIETF RFC 8446 \"The Transport Layer Security (TLS) Protocol Version 1.3\".\n[60]\tIETF RFC 4648: \"The Base16, Base32, and Base64 Data Encodings\".\n[61]\tIETF RFC 9110: \"HTTP Semantics\".\n[62]\tIETF RFC 7616: \"HTTP Digest Access Authentication\".\n[63]\t Void.\n[64]\t3GPP TS 23.502: \"Procedures for the 5G System (5GS)\".\n[65]\t3GPP TS 23.228: \"IP Multimedia Subsystem (IMS); Stage 2\".\n[66]\t3GPP TS 23.501: \" System architecture for the 5G System (5GS)\".\n[67]\t3GPP TS 33.503: \"Security Aspects of Proximity based Services (ProSe) in the 5G System (5GS)\".\n[68]\tIETF RFC 9146: \"The Datagram Transport Layer Security (DTLS) Protocol Version 1.3\".\n[69]\tIETF RFC 8613: \"Object Security for Constrained RESTful Environments (OSCORE)\".\n[70]\tIETF RFC 7252: \"The Constrained Application Protocol (CoAP)\".\n[71]\tIETF RFC 8949: \"Concise Binary Object Representation (CBOR)\".\n[72]\tIETF RFC 8152: \"CBOR Object Signing and Encryption (COSE)\".\n[73]\tIETF RFC 5869: \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\".\n[74]\t3GPP TS 33.533: \"Security aspects of ranging based services and sidelink positioning\".\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "3\tDefinitions, abbreviations symbols and conventions",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "3.1\tDefinitions",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the following terms and definitions apply:\nAKA-based GBA: This term collectively refers to all GBA variants that make use of a form of the AKA protocol on the Ub interface, i.e. the term refers to GBA_ME, GBA_U, and 2G GBA, as defined in the present document, and to GBA_push as defined in TS 33.223 [45].\nApplication: In all places in this document where the term application is used to refer to a service offered by the MNO or a third party to the mobile subscriber, then it always denotes the type of application and not the actual instance of an application installed on an application server.\nBootstrapping Server Function: BSF is hosted in a network element under the control of an MNO. BSF, HSS, and UEs participate in GBA in which a shared secret is established between the network and a UE by running the bootstrapping procedure. The shared secret can be used between NAFs and UEs, for example, for authentication purposes.\nBootstrapping Usage Procedure: A procedure using bootstrapped security association over Ua reference point.\nGBA Function: A function on the ME executing the bootstrapping procedure with BSF (i.e. supporting the Ub reference point) and providing Ua applications with security association to run bootstrapping usage procedure. GBA function is called by a Ua application when a Ua application wants to use bootstrapped security association.\nME-based GBA: in GBA_ME, all GBA-specific functions are carried out in the ME. The UICC is GBA-unaware. If the term GBA is used in this document without any further qualification then always GBA_ME is meant, see clause 4 of this specification.\nUICC-based GBA: this is a GBA with UICC-based enhancement. In GBA_U, the GBA-specific functions are split between ME and UICC, see clause 5 of this specification.\nGBA_Digest: A GBA variant that extends the usage of GBA to environments where the UICC is not available to the subscriber. In this variant, the GBA client on the UE and the BSF communicate using HTTP protocol and SIP Digest credentials, such as a shared secret or password, that are used for authentication instead of credentials stored in the SIM, USIM or ISIM.\nNetwork Application Function: NAF is hosted in a network element. GBA may be used between NAFs and UEs for authentication purposes, and for securing the communication path between the UE and the NAF.\nBootstrapping Transaction Identifier: the bootstrapping transaction identifier (B-TID) is used to bind the subscriber identity to the keying material in reference points Ua, Ub and Zn.\nGBA User Security Settings: GUSS contains the BSF specific information element and the set of all application-specific USSs.\nGUSS timestamp: the timestamp of the GUSS is set by the HSS. It changes whenever the HSS has modified the GUSS.\nNAF Group: A grouping of NAFs to allow assignment of different USSs to NAFs representing the same application. This grouping is done in each home network separately, i.e. one NAF contacting BSFs in different home networks belongs to different groups in every home network.\nNAF_Id: The FQDN of the NAF, concatenated with the Ua security protocol identifier.\nTemporary IP Multimedia Private Identity: a temporary identity which is used on the Ub interface to prevent passive eavesdropping attacks against the IMPI.\nUa Application: An application on the ME intended to run bootstrapping usage procedure with a NAF.\nUa security protocol identifier: An identifier which is associated with a security protocol over Ua.\nUser Security Setting: A USS is an application and subscriber specific parameter set that defines two parts, an authentication part, which contains the list of identities of the user needed for the application (e.g. IMPUs, MSISDN, pseudonyms), and an authorisation part, which contains the user permission flags (e.g. access to application allowed, type of certificates which may be issued). In addition, a USS may contain a key selection indication, which is used in the GBA_U case to mandate the usage of either the ME-based key (Ks_(ext)_NAF) or the UICC-based key (Ks_int_NAF) or both. Sometimes also called application-specific user security setting. The USS is delivered to the BSF as a part of GUSS from the HSS, and from the BSF to the NAF if requested by the NAF.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.2\tAbbreviations",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the following abbreviations apply:\nAK\tAnonymity Key\nAKA\tAuthentication and Key Agreement\nB-TID\tBootstrapping Transaction Identifier\nBSF\tBootstrapping Server Function\nCA\tCertificate Authority\nCBOR\tConcise Binary Object Representation\nCoAP\tConstrained Application Protocol\nFQDN\tFully Qualified Domain Name\nGAA\tGeneric Authentication Architecture\nGBA\tGeneric Bootstrapping Architecture\nGBA_ME\tME-based GBA\nGBA_U\tGBA with UICC-based enhancements\nGUSS\tGBA User Security Settings\nHLR\tHome Location Register\nHSS\tHome Subscriber System\nIK\tIntegrity Key\nKDF\tKey Derivation Function\nKISS\tKey Indicator for Service Selection\nKs_int_NAF\tDerived key in GBA_U which remains on UICC\nKs_ext_NAF\tDerived key in GBA_U\nMNO\t Network Operator\nNAF\tNetwork Application Function\nOSCORE\tObject Security for Constrained RESTful Environments\nPKI\tPublic Key Infrastructure\nSLF\tSubscriber Locator Function\nTMPI\tTemporary IP Multimedia Private Identity\nUSS\tUser Security Setting\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.3\tSymbols",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the following symbols apply:\n||\tConcatenation\nÅ\tExclusive or\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.4\tConventions",
                    "description": "",
                    "summary": "",
                    "text_content": "All data variables in this specification are presented with the most significant substring on the left hand side and the least significant substring on the right hand side. A substring may be a bit, byte or other arbitrary length bitstring. Where a variable is broken down into a number of substrings, the leftmost (most significant) substring is numbered 0, the next most significant is numbered 1, and so on through to the least significant.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "4\tGeneric Bootstrapping Architecture",
            "description": "The 3GPP authentication infrastructure, including the 3GPP Authentication Centre (AuC), the USIM or the ISIM, and the 3GPP AKA protocol run between them, is a very valuable asset of 3GPP operators. It has been recognised that this infrastructure could be leveraged to enable application functions in the network and on the user side to establish shared keys. Therefore, 3GPP can provide the \"bootstrapping of application security\" to authenticate the subscriber by defining a Generic Bootstrapping Architecture (GBA) based on AKA protocol.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "4.1\tReference model",
                    "description": "",
                    "summary": "",
                    "text_content": "For HLR and HSS definitions used in this chapter refer to [34].\nWhen HSS is mentioned in this specification without an indication of supported reference point towards the BSF, then the support of the Zh reference point is meant.\nFigure 4.1 shows a simple network model of the entities involved in the bootstrapping approach when an HSS with Zh reference point is deployed, and the reference points used between them.\nThe figure depicts a simplified network model for bootstrapping, where HSS (Hybrid Service Set) with Zh reference point is used. The model includes a router, a switch, and a router with a Zh reference point. The router is responsible for routing packets to the appropriate HSS, while the switch is responsible for forwarding packets between the router and the Zh reference point. The Zh reference point is used to establish a connection with the Zh network, allowing for communication between the two networks.\nFigure 4.1: Simple network model for bootstrapping involving HSS with Zh reference point\nFigure 4.1a shows a simple network model of the entities involved when the network application function is located in the visited network.\nThe figure depicts a simplified representation of a 5G network, highlighting the signal propagation in a 5G network. It illustrates the multi-path signal propagation in a 5G network, showing how signals reflect off buildings (NLOS) and combine at the receiver. Key components include the base station (gNB), user equipment (UE), and scatterers. The diagram highlights beamforming techniques to mitigate interference.\nNOTE:\tThe Zn' reference point is distinguished from the Zn reference point in that it is used between operators.\n\nFigure 4.1a: Simple network model for bootstrapping in visited network involving HSS with Zh reference point\nFigure 4.1b shows a simple network model of the entities involved in the bootstrapping approach when either an HLR or an HSS without Zh reference point support is deployed, and the reference points used between them. The reference point Zh' is optional for the BSF to support.\nThe figure depicts a simplified network model for bootstrapping, where either an HLR or an HSS is used without Zh reference point support. The model includes a router (R) and a switch (S) connected to a base station (B). The router is responsible for routing packets to the appropriate network segment, while the switch is responsible for forwarding packets between the router and the network segment. The model also includes a Zh reference point (Z) that is used to determine the routing path for packets. The model is useful for understanding the basic structure of a network bootstrapping scenario and for designing network protocols that support this type of network configuration.\nFigure 4.1b: Simple network model for bootstrapping involving either an HLR or an HSS without Zh reference point support\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.2\tNetwork elements",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.2.1\tBootstrapping server function (BSF)",
                            "text_content": "A generic Bootstrapping Server Function (BSF) and the UE shall mutually authenticate using the AKA protocol, and agree on session keys that are afterwards applied between UE and a Network Application Function (NAF). The BSF shall restrict the applicability of the key material to a specific NAF by using the key derivation procedure as specified in Annex B. The key derivation procedure may be used with multiple NAFs during the lifetime of the key material. The lifetime of the key material is set according to the local policy of the BSF. The generation of key material is specified in clause 4.5.2.\nThe BSF shall be able to acquire the GBA user security settings (GUSS) from the HSS.\nThe BSF shall be able to keep a list, which assigns NAFs to NAF Groups. This list is used to select if any and which application-specific USS within GUSS is valid for a certain NAF.\nNOTE 1:\tThe operator does the assignment of NAFs to NAF Groups. NAF Group definitions in HSS and all connected BSFs belonging to the same operator's network shall be equal (cf., clause 4.2.3). As these network elements belong to the same operator's network, standardisation of the NAF Group definitions themselves is not necessary in 3GPP.\nNOTE 2:\tThe NAF grouping may be e.g. \"home\" and \"visited\". It allows the BSF to send USSs for the same application with e.g. different authorization flags to different NAFs, e.g., in home network and visited networks. The NAF e.g. in visited network indicates only the requested application, but it is unaware of the grouping in home network of the subscriber.\nNOTE 3:\tIf support of GBA User Security Settings (GUSS) for service differentiation or GBA_U is desired in combination with HLR or HSS without Zh reference point support, then this can be achieved, for instance by storing the GUSS information in a BSF database (external and/or external to the node itself), or in any other network database which is deemed as appropriate for a specific deployment. GUSS information is not sent over Zh' reference point.\nIf an HLR or an HSS without Zh reference point support is used within the GBA architecture, then the BSF needs to be configured to use the Zh' reference point with that HLR or HSS. If the Zh reference point is available in the HSS and the full migration has happened, then it shall be used between the BSF and the HSS.\nNOTE 4:\tIf an operator wants to upgrade from a GBA architecture using HLR or HSS without Zh reference point support, to one using HSS with Zh reference point support, then the BSF needs to be configured accordingly to use then the Zh reference point. This can also involve a configuration, where gradual replacement is needed. If GBA is deployed from the beginning with an HSS with Zh reference point support then this kind of configuration is not needed.\nNOTE 5:\tDuring migration from HLR to HSS, the BSF will need to select for a subscriber between HSS and HLR's. Such a mechanism (e.g. configuration based) will not be standardized.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.2\tNetwork application function (NAF)",
                            "text_content": "After the bootstrapping has been completed, the UE and a NAF can run some application specific protocol where the authentication of messages will be based on those session keys generated during the mutual authentication between UE and BSF.\nGeneral assumptions for the functionality of a NAF are:\n-\tthere is no previous security association between the UE and the NAF;\n-\tNAF shall be able to locate and communicate securely with the subscriber's BSF;\n-\tNAF shall be able to acquire a shared key material established between UE and the BSF during the run of the application-specific protocol;\n-\tNAF shall be able to acquire zero or more application-specific USSs from the HSS via the BSF;\n-\tNAF shall be able to set the local validity condition of the shared key material according to the local policy;\n-\tin the case of GBA_U, the NAF shall be able to determine which key (i.e., Ks_ext_NAF or Ks_int_NAF or both) should be used by using a local policy in the NAF or a key selection indication in the application-specific USS. If the NAF has received an application-specific USS, which contains the key selection indication, this shall override the local policy in the NAF;\n-\tNAF shall be able to check lifetime and local validity condition of the shared key material.\nNOTE:\tWithout additional measures, GBA does not guarantee the freshness of the key, Ks(_int/ext)_NAF in the sense that it does not guarantee that the key was not used in a previous run of the Ua protocol. The additional measures which may be taken by the UE and the NAF to ensure key freshness in GBA are:\n1)\tenforce a new run of the Ub protocol (thus generating a new Ks) before deriving a new Ks_NAF.\n2)\tstore previously used keys Ks(_int/ext)_NAF, or the corresponding key identifiers B-TID, until the end of their lifetime.\nA UE and a NAF that support a Ua protocol that does not provide replay protection over unconnected runs of the protocol, will need to take corresponding action to avoid replay attacks if desired.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.2a\tZn-Proxy",
                            "text_content": "In the case where UE has contacted a NAF that is operated in another network than home network, this visited NAF shall use a Zn-Proxy of the NAFs network to communicate with subscriber's BSF (i.e. home BSF).\nNOTE:\tZn-Proxy functionality may be implemented as a separate network element, or be part of any NE in the visited network that implements Diameter/HTTP proxy functionality (examples of such NE's are the BSF of the network that the visited NAF belongs to, or an AAA-server, or an HTTP server).\nGeneral requirements for the functionality of Zn-Proxy are:\n-\tZn-Proxy shall be able to function as a proxy between the visited NAF, and the subscriber's home BSF;\n-\tZn-Proxy shall be able to locate subscriber's home BSF and communicate with it over secure channel;\n-\tZn-Proxy shall be able to validate that the visited NAF is authorized to participate in GBA and shall be able to assert to subscriber's home BSF the visited NAFs DNS name. The Zn-Proxy shall also be able to assert to the BSF that the visited NAF is authorized to request the GBA specific user profiles contained in the NAF request;\n-\tthe physical security level of the Zn-proxy shall not be lower than the highest level of the NAFs which it interfaces with.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.3\tHSS",
                            "text_content": "The set of all user security settings (USSs), i.e. GUSS, is stored in the HSS. In the case where the subscriber has multiple subscriptions, i.e. multiple ISIM or USIM applications on the UICC, the HSS may contain one or more GUSSs that can be mapped to one or more private identities, i.e. IMPIs and IMSIs. Each of the existing GUSSs shall be mapped to one or more private identities, but each private identity shall only have zero or one GUSS mapped to it.\nThe requirements on the HSS are:\n-\tHSS shall provide the only persistent storage for GUSSs;\n-\tGUSS shall be defined in such a way that interworking of different operators for standardised application profiles is possible;\n-\tGUSS shall be defined in such a way that profiles for operator specific applications and extensions to existing application profiles are supported without need for standardisation of these elements.\n-\tGUSS shall be able to contain application-specific USSs that contain parameters that are related to key selection indication in the case of GBA_U (i.e., whether the NAF shall use Ks_ext_NAF or Ks_int_NAF), identification or authorization information of one or more applications hosted by one ore more NAFs. Any other types of parameters are not allowed in the application-specific USS.\nNOTE 1:\tThe necessary subscriber profile data may be fetched by the NAF from its local database without involvement with the HSS.\nNOTE 2:\tOne possibility to revoke temporarily an application specific USS from the GUSS is that the HSS may temporarily remove an application-specific USS from the GUSS if the service is temporarily revoked from the subscriber. The GUSS in the BSF is not changed by this operation and only updated when the existing bootstrapping session times out, or is overwritten by a new bootstrapping session during which the new modified GUSS is fetched from HSS along with the AV.\n-\tGUSS shall be able to contain parameters intended for the BSF usage:\n-\tthe type of the UICC the subscriber is issued (i.e. is it GBA_U aware or not, cf. subclause 5);\n-\tsubscriber specific key lifetime:\n-\toptionally the timestamp indicating the time when the GUSS has been last modified by the HSS.\nNOTE 3:\tThese parameters are optional and if they are missing from subscriber's GUSS or subscriber does not have GUSS then the BSF will use the default values in the BSF local policy defined by the particular MNO.\n-\tHSS shall be able to assign application-specific USSs to a NAF Group. This shall be defined in such a way that different USSs for the same application, but for different groups of NAFs, are possible. The restrictions on the number of USSs per GUSS are dependent on the usage of NAF Groups by the operator:\n-\tif no NAF Groups are defined for this application then at most one USS per application is stored in GUSS;\n-\tif NAF Groups are defined for this application then at most one USS per application and NAF Group is stored in GUSS.\n-\tNAF Group definitions in the HSS and all connected BSFs belonging to the same operator's network shall be equal.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.4\tUE",
                            "text_content": "The required functionalities from the UE are:\n-\tthe support of HTTP Digest AKA protocol;\n-\tthe capability to use both a USIM and an ISIM in bootstrapping;\n-\tthe capability to select either a USIM or an ISIM to be used in bootstrapping, when both of them are present;\n-\tthe capability for a Ua application on the ME to indicate to the GBA Function on the ME the type or the name of UICC application to use in bootstrapping (see clause 4.4.8);\n-\tthe capability to derive new key material to be used with the protocol over Ua interface from CK and IK;\n-\tsupport of NAF-specific application protocol (For an example see TS 33.221 [5]).\nA GBA-aware ME shall support both GBA_U, as specified in clause 5.2.1 and GBA_ME procedures, as specified in clause 4.5.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.5\tSLF",
                            "text_content": "The SLF:\n-\tis queried by the BSF in conjunction with the Zh interface operation to get the name of the HSS containing the required subscriber specific data.\n-\tis accessed via the Dz interface by the BSF.\nThe SLF is not required in a single HSS environment. Use of SLF is not required when BSF are configured/managed to use pre-defined HSS.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.2.6\tHLR",
                            "text_content": "If a HLR is used, then the requirement on the HLR is:\n-\tThe HLR shall support the request from the BSF for the required authentication vector.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.3\tBootstrapping architecture and reference points",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.3.1\tReference point Ub",
                            "text_content": "The reference point Ub is between the UE and the BSF. Reference point Ub provides mutual authentication between the UE and the BSF. It allows the UE to bootstrap the session keys based on 3GPP AKA infrastructure.\nThe HTTP Digest AKA protocol, which is specified in RFC 3310 [4], is used on the reference point Ub. It is based on the 3GPP AKA TS 33.102 [2] protocol. The interface to the USIM is as specified in TS 31.102 [1] and to the ISIM is as specified in TS 31.103 [10].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.2\tReference point Ua",
                            "text_content": "The reference point Ua carries the application protocol, which is secured using the keys material agreed between UE and BSF as a result of the run of HTTP Digest AKA over reference point Ub. For instance, in the case of support for subscriber certificates TS 33.221 [5], it is a protocol, which allows the user to request certificates from the NAF. In this case the NAF would be the PKI portal.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.3\tReference point Zh",
                            "text_content": "The reference point Zh used between the BSF and the HSS allows the BSF to fetch the required authentication information and all GBA user security settings from the HSS. The reference point Zh is an intra-operator domain interface. The interface to the 3G Authentication Centre is HSS-internal, and it need not be standardised as part of this architecture.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.4\tReference point Zn",
                            "text_content": "The reference point Zn is used by the NAF to fetch the key material agreed during a previous HTTP Digest AKA protocol run over the reference point Ub from the UE to the BSF. It is also used to fetch application-specific user security settings from the BSF, if requested by the NAF.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.5\tReference point Dz",
                            "text_content": "The reference point Dz used between the BSF and the SLF allows the BSF to get the name of the HSS containing the required subscriber specific data.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.3.6\tReference point Zh'",
                            "text_content": "The reference point Zh' used between the BSF and the HLR allows the BSF to fetch the required authentication information. The reference point Zh' is an intra-operator domain interface.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.4\tRequirements and principles for bootstrapping",
                    "description": "",
                    "summary": "",
                    "text_content": "The following requirements and principles are applicable to bootstrapping procedure:\n-\tthe bootstrapping function shall not depend on the particular NAF;\n-\tthe server implementing the bootstrapping function needs to be trusted by the home operator to handle authentication vectors;\n-\tthe server implementing the NAF needs only to be trusted by the home operator to handle derived key material;\n-\tit shall be possible to support NAF in the operator's home network and in the visited network;\n-\tthe architecture shall not preclude the support of network application function in a third network;\n-\tto the extent possible, existing protocols and infrastructure should be reused;\n-\tin order to ensure wide applicability, all involved protocols are preferred to run over IP;\n-\tit shall be prevented that a security breach in one NAF who is using the GBA, can be used by an attacker to mount successful attacks to the other NAFs using the GBA.\n-\tan attacker shall not be able to exploit a security breach in one security protocol over Ua in order to mount a successful attack against a different security protocol over Ua.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.4.1\tAccess",
                            "text_content": "Bootstrapping procedure is access independent. Bootstrapping procedure requires IP connectivity from UE.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.2\tAuthentication methods",
                            "text_content": "Authentication between the UE and the BSF shall not be possible without a valid cellular subscription. Authentication shall be based on the 3GPP AKA protocol.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.3\tRoaming",
                            "text_content": "The requirements on roaming are:\n-\tThe roaming subscriber shall be able to utilize the bootstrapping function in the home network. The subscriber shall be able to utilize network application function that is in a visited network.\n-\tThe home network shall be able to control whether its subscriber is authorized to use the service in the visited network.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.4\tRequirements on reference point Ub",
                            "text_content": "The requirements for reference point Ub are:\n-\tthe BSF shall be able to identify the UE;\n-\tthe BSF and the UE shall be able to authenticate each other based on AKA;\n-\tthe BSF shall be able to send a bootstrapping transaction identifier to the UE;\n-\tthe UE and the BSF shall establish shared keys;\n-\tthe BSF shall be able to indicate to the UE the lifetime of the key material. The key lifetime sent by the BSF over Ub shall indicate the expiry time of the key.\nNOTE 1:\tThis does not preclude a UE to refresh the key before the expiry time according to the UE's local policy.\n-\tthe BSF and the UE shall protect the permanent user identity IMPI against passive eavesdropping attacks by using a temporary identity. The support of the temporary identity by UE or BSF shall not preclude a successful bootstrapping procedure if the other entity conforms to an earlier release of this specification and does not support the use of a temporary identity.\nNOTE 2:\tUser identity privacy can be achieved only when both, UE and BSF, support the use of a temporary identity.\nNOTE 3:\tThe use of a temporary identity is not required for 2G GBA (cf. Annex I) as the IMPI is already protected by the mandatory TLS tunnel.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.5\tRequirements on reference point Zh",
                            "text_content": "The requirements for reference point Zh are:\n-\tmutual authentication, confidentiality and integrity shall be provided;\nNOTE 1:\tThis requirement may be fulfilled by physical or proprietary security measures since BSF and HSS are located within the same operator's network.\n-\tthe BSF shall be able to send bootstrapping information request concerning a subscriber;\n-\toptionally the BSF may have the capability able to send the timestamp of subscriber's GBA user security settings to the HSS (timestamp option);\n-\tthe HSS shall be able to send one 3GPP AKA vector at a time to the BSF;\n-\tthe HSS shall be able to send the complete set of subscriber's GBA user security settings needed for security purposes to the BSF. Optionally the HSS may have the capability to indicate to the BSF whether the BSF already has the latest copy of the GUSS based on the GUSS timestamp (timestamp option);\nNOTE 2:\tIf subscriber's GUSS is updated in HSS, this is not propagated to the BSF. The GUSS in the BSF is updated when the BSF next time fetches the authentication vectors and GUSS from the HSS over Zh reference point as part of the bootstrapping procedure.\n-\tno state information concerning bootstrapping shall be required in the HSS;\n-\tall procedures over reference point Zh shall be initiated by the BSF;\n-\tthe number of different interfaces to HSS should be minimized.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.6\tRequirements on reference point Zn",
                            "text_content": "The requirements for reference point Zn are:\n-\tmutual authentication, confidentiality and integrity shall be provided;\n-\tIf the BSF and the NAF are located within the same operator's network, the DIAMETER based Zn reference point shall be secured according to NDS/IP [13] or may be secured using TLS as specified in Annex E of the present document;\n-\tIf the BSF and the NAF are located in different operators' networks, the DIAMETER based Zn' reference point between the Zn-Proxy and the BSF shall be secured using TLS as specified in Annex E of the present document;\n-\tAn HTTP based Zn/Zn' reference point shall be secured using TLS as specified in Annex E of the present document;\n-\tThe BSF shall verify that the requesting NAF is authorised to obtain the key material or the key material and the requested USS;\n-\tThe NAF shall be able to send a key material request to the BSF, containing NAF's public hostname used by the UE's corresponding request. The BSF shall be able to verify that a NAF is authorized to use this hostname, i.e. the FQDN used by UE when it contacts the NAF;\n-\tThe BSF shall be able to send the requested key material to the NAF;\n-\tThe NAF shall be able to get a selected set of application-specific USSs from the BSF, depending on the policy of the BSF and the application indicated in the request from the NAF over Zn;\n-\tThe NAF shall be able to indicate to the BSF the single application or several applications it requires USSs for;\nNOTE 2:\tIf some application needs only a subset of an application-specific USS, e.g. only one IMPU or MSISDN, the NAF selects this subset from the complete set of USS sent from BSF.\n-\tThe BSF shall be able to be configured on a per NAF or per application basis\n-\twhether private subscriber identity, i.e. IMPI, may be sent to the NAF;\n-\twhether a particular USS may be sent to a NAF;\nNOTE 3:\t Privacy issues need be considered when determining which user identifier is sent to the NAF. If service continuity is desired, then the BSF can be configured to send the IMPI. If HLR is utilized instead of HSS, BSF can be configured to send MSISDN over Zn (but then there is no user anonymity). If the BSF does not send the IMPI, MSISDN or IMPU / pseudonym in the USS, then the user remains anonymous towards the NAF; or more precisely, the B-TID functions as a temporary user identifier. This can cause that the NAF cannot provide a continuous service, since a user identity is needed in the NAF to ensure that the NAF is able to update keys for a Ua session when the UE has bootstrapped and contacts the NAF with a new B-TID. If user privacy is desired, the NAF can requests a USS and the BSF is configured to send a user pseum in the USS, but not the IMPI.\n-\tIf a NAF requests USSs from the BSF and they are not present in subscriber's GUSS, it shall not cause an error, provided the conditions of the local policy of the BSF are fulfilled. The BSF shall then send only the requested and found USSs to the NAF;\n-\tIt shall be possible to configure a local policy as follows: BSF may require one or more application-specific USS to be present in a particular subscriber's GUSS for a particular requesting NAF, and to reject the request from the NAF in case the conditions are not fulfilled. In order to satisfy this local policy, it is not required that the NAF requests the USSs over the Zn reference point, which the BSF requires to be present in the GUSS, rather it is sufficient that the BSF checks the presence of the USSs locally. It shall also be possible to configure the BSF in such a way that no USS is required for the requesting NAF;\nNOTE 4: For more information on the local policy usage, see Annex J.\n-\tThe BSF shall be able to indicate to the NAF the bootstrapping time and the lifetime of the key material. The key lifetime sent by the BSF over Zn shall indicate the expiry time of the key, and shall be identical to the key lifetime sent by the BSF to the UE over Ub.\nNOTE 5:\tThis does not preclude a NAF to refresh the key before the expiry time according to the NAF's local policy.\nNOTE 6:\tIf one or more of the USSs that have been delivered to the NAF has been updated in subscriber's GUSS in the HSS, this change is propagated to the NAF the next time it fetches the USS from the BSF over Zn reference point (provided that the BSF has updated subscriber's GUSS from the HSS over Zh reference point).\n-\tThe BSF shall remove any existing attribute indicating NAF Grouping from the USSs sent to NAFs.\n-\tNAF shall be able to indicate to BSF the protocol identifier of Ua security protocol it requires the key material by sending NAF-Id to BSF (cf. Annex H).\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.7\tRequirements on Bootstrapping Transaction Identifier",
                            "text_content": "Bootstrapping transaction identifier (B-TID) shall be used to bind the subscriber identity to the keying material in reference points Ua, Ub and Zn.\nRequirements for B-TID are:\n-\tB-TID shall be globally unique;\n-\tB-TID shall be usable as a key identifier in protocols used in the reference point Ua;\n-\tNAF shall be able to detect the home network and the BSF of the UE from the B-TID.\nNOTE 1:\tNAF can remove the security association based on deletion conditions after the key has become invalid.\nNOTE 2:\tCare has to be taken that the parallel use of GBA and non-GBA authentication between UE and NAF does not lead to conflicts, e.g. in the name space. This potential conflict cannot be resolved in a generic way as it is dependent on specific protocol and authentication mechanism used between UE and application server. It is therefore out of scope of this specification.\nFor the example of HTTP Digest authentication used between UE and NAF, parallel use is possible as the following applies: <username,password>-pairs must be unique to one realm only. As the NAF controls the realm names, it has to ensure that only the GBA based realm is named with the reserved 3GPP realm name. In the special case that the NAF wants to allow non GBA based authentication in the GBA realm also, it has to ensure that no usernames in the format of a B-TID are used outside GBA based authentication.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.8\tRequirements on selection of UICC application and related keys",
                            "text_content": "When several applications are present on the UICC, which are capable of running AKA, then the ME shall choose one of these UICC applications for performing the GBA procedures specified in this document in the following order of preference:\n1.\tThe UE determines which UICC application is to be involved:\na.\tthe application on the ME that needs Ks_NAF (Ua application) may indicate to the GBA support function (GBA function) the type or the name of the UICC application: no preference, USIM, ISIM, or the \"Label\" (see definition in TS 31.101 [15]) of the UICC application.\nNOTE 1:\tA Ua application specification may require the use of only a USIM (e.g. in MBMS) or only an ISIM.\nNOTE 2: \tA user or operator may want to use a Ua application with a specific UICC application indicated by the “Label”. This could be configured in the Ua application in the ME by the user or the operator.\nA Ua application may require to use the same UICC application in the first and all consecutive runs of Ub protocol for a Ua application instance to ensure that IMPI is not changed during a Ua application session which lasts over several runs of Ub protocol. In this case the Ua application shall request the GBA function to run the Ub protocol with the UICC application that is indicated by the corresponding \"Label\" or IMPI, depending on which one is available. If both are available, then IMPI shall be used to indicate which UICC application is to be used by the GBA function.\nIf the application on the ME indicated a \"Label\" of the UICC application, step b below shall be executed.\nIf the application on the ME indicated that the UICC application type should be:\n-\tthe USIM; step b below is skipped and in steps c and d only USIM applications are considered.\n-\tthe ISIM; step b below is skipped and in steps c and d only ISIM applications are considered.\nif the application on the ME did not indicate a preference, step b below is skipped and the selection process is executed as described below, starting with step c;\nb.\tif a \"Label\" was indicated in step a:\nAt most, there can be only one USIM active at one time. Therefore, if the USIM indicated in the \"Label\" by the Ua application is different to the currently active USIM application, then the ME shall reject this request.\nIf a different ISIM to the currently active ISIM application(s) is indicated to the GBA support function by the Ua application, then the ME shall not terminate the currently active ISIM application(s) but the ME shall follow the procedure in chapter 4.4.8.1 when activating the ISIM application indicated by the \"Label\", as the UE is allowed to have several ISIM's active simultaneously.\nc.\tif no \"Label\" was indicated in step a and there are UICC applications active:\nIf a preferred UICC application type was indicated but no UICC application of this type is active then step d shall be followed.\nIf a preferred UICC application type was indicated and there are active UICC applications of this preferred type, then the GBA function shall choose:\n-\tif the preferred UICC application type is USIM then the active USIM is selected\n-\tif the preferred UICC application type is ISIM and only one ISIM is active then this is selected\n-\tif the preferred UICC application type is ISIM and more than one ISIM is active then the GBA function may show a UICC application choosing dialogue to the end user (the list contains the \"Labels\" from the application list of all active ISIM applications on the UICC), from which the end user chooses the UICC application to be selected; if no dialogue is shown the GBA function shall select an active ISIM.\nIf no preference was given and there is more than one active UICC application, the GBA function may show a UICC application choosing dialogue to the end user (the list contains the \"Labels\" from the application list of all active UICC applications), from which the end user chooses the UICC application to be selected; if no dialogue is shown the GBA function shall select the active USIM application, if an active USIM application exists, otherwise any active ISIM application.\nIf no preference was given and there is only one active UICC application, then the GBA function selects this active UICC application;\nd.\tif no \"Label\" was indicated in step a and if there are no UICC applications active active or if there is no UICC application of the preferred UICC application type active:\n-\tif there is only one UICC application on the UICC, the GBA function selects it, if possible;\n-\tif there is more than one UICC application on the UICC, the GBA function may show a UICC application choosing dialogue to the end user (the list contains the \"Labels\" from the application list of the UICC), from which the end user chooses the UICC application to be selected. If a preferred UICC application type was indicated and there are UICC applications of this type on the UICC, then the list shown contains only UICC applications of this type, otherwise the list contains all UICC applications on the UICC. If no dialogue is shown the GBA function shall select the \"last selected\" UICC application of the preferred type (i.e. either the \"last selected\" USIM or the \"last selected\" ISIM depending on the given preference), if possible. In case the Ua application indicated \"no preference\" and both USIM and ISIM are present on the UICC, then the \"last selected\" USIM is selected.\nThe procedure in clause 4.4.8.1 shall be followed.\ne.\tif the UICC application type indicated in step a and used in step c and/or d was ISIM, but there was no ISIM to select, then step c and/or d is repeated with UICC application type USIM; otherwise the selection process fails.\nNOTE 3:\tStep e is required for the case that an ISIM as defined in TS 33.203 [16] may be realised using a USIM application on the UICC.\n2.\tIf there already is a key Ks derived from the chosen UICC application, the UE takes this key to derive Ks_NAF.\n3.\tIf there is no such key Ks, the UE first runs the Ub protocol involving the selected UICC application and then goes to step 2.\nIf a USIM is chosen, the IMPI obtained from the IMSI stored on the USIM as specified in TS 23.003 [11] clause 13.3, is used in the protocol run over Ub.\nNOTE 4:\tStrictly speaking, an IMPI, and the derivation of an IMPI from an IMSI as in TS 23.003 [11], clause 13 are only defined in the context of the IMS. For the purposes of this specification, however, an identifier obtained from an IMSI as specified in TS 23.003 [11], clause 13.3 is also called an IMPI, even if the user has no IMS subscription.\nIf an ISIM is selected, the IMPI stored on the ISIM is used in the protocol run over Ub.\nWhenever a UICC application is successfully selected or terminated, the rules in this clause for choosing the UICC application are re-applied and, consequently, the UICC application chosen for GBA may change.\nNOTE 5:\tAt any one time, there is at most one UICC application chosen for performing the GBA procedures.\nUICC application activation is defined in TS 31.101 [15].\nNOTE:\tAs part of the UICC application (USIM or ISIM) activation procedure, the UICC may require user verification e.g. PIN entry.\nIf activation of a new UICC application fails then the GBA function shall indicate this to the Ua application.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.9\tRequirements on reference point Ua",
                            "text_content": "The generic requirements for reference point Ua are:\n-\tthe UE and the NAF shall be able to secure the reference point Ua using the GBA-based shared secret;\nNOTE:\tThe exact method of securing the reference point Ua depends on the application protocol used over reference point Ua.\n-\tin the case of GBA_U, the UE and the NAF shall be able to agree which key (i.e, Ks_ext_NAF or Ks_int_NAF or both) is used as the GBA-based shared secret if both keys may be used;\nThere are two ways to have an agreement between the UE and the NAF which key shall be used Ks_(ext)_NAF or Ks_int_NAF or both:\na)\tIn a generic case, where the protocol used over reference point Ua can be used for different applications (e.g., HTTPS), the protocol should be able to indicate which key should be used.\nb)\tIn a specific case, where the protocol is application specific (e.g., MIKEY in MBMS), the agreement can be based on implicit knowledge.\n\n-\tany security protocol over Ua shall be associated with a Ua security protocol identifier. This identifier shall be specified in Annex H of this specification.\n-\tthe NAF shall be able to indicate to the UE that GBA-based shared secret should be used;\n-\tthe NAF shall be able to indicate to the UE that the current shared secret has expired and the UE should use newer shared secret with the NAF.\n-\tThe default lifetime of the NAF specific key material Ks_(ext/int)_NAF shall be equal to the lifetime of Ks when not specified within the Ua-application specification. The lifetime of the Ks_(ext/int)_NAF shall not exceed the lifetime of corresponding Ks. If a lifetime for the Ks_(ext/int)_NAF (or further adapted key material) is available in the NAF, due to a Ua application specification having its own lifetime value or due to NAF having it's own policy for the adapted key material, then if this lifetime is different from the Ks lifetime received from the BSF, then the NAF shall always select the minimum value for the lifetime out of these two.\n-\tThe UE and NAF may adapt the key material Ks_(ext/int)_NAF to the specific needs of the reference point Ua. This adaptation is outside the scope of this specification. The default lifetime of the adapted key material shall be equal to the lifetime of Ks_(ext/int)_NAF when not specified within the Ua-application specification. The lifetime of the adapted key material shall not exceed the lifetime of corresponding Ks_(ext/int)_NAF. If a lifetime for the Ks_(ext/int)_NAF (or further adapted key material) is available in the NAF, due to a Ua application specification having its own lifetime value or due to NAF having it's own policy for the adapted key material, then if this lifetime is different from the Ks lifetime received from the BSF, then the NAF shall always select the minimum value for the lifetime out of these two.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.10\tRequirements on reference point Dz",
                            "text_content": "This interface between BSF and SLF is used to retrieve the address of the HSS which holds the subscription for a given user. This interface is not required in a single HSS environment.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.11\tRequirements on GBA keys and parameters handling",
                            "text_content": "When referring to GBA keys, the following keys are intended: Ks and NAF specific keys derived from the Ks. When referring to NAF specific keys, the following keys are intended: Ks_ext/int_NAF (in GBA_U context) and Ks_NAF (in GBA_ME context), and any keys derived from these keys. The notation Ks_(ext/int)_NAF refers to Ks_ext/int_NAF in GBA_U context and Ks_NAF in GBA_ME context. The notation Ks_(ext)_NAF refers to Ks_ext_NAF in GBA_U context, and Ks_NAF in GBA_ME context.\nThe ME shall delete all GBA keys (i.e., Ks, and NAF specific keys) and the corresponding NAF_IDs, B-TID, Ks_(int/ext)_NAF lifetimes, Ks lifetime, and lifetime (of the keys derived from Ks_(ext)_NAF) when at least one of the conditions below is met:\n1\tthe UICC is removed from the ME when the ME is in power on state;\n2\tthe ME is powered up and the ME discovers that another UICC has been inserted to the ME. For this, the ME needs to store in non-volatile memory the last inserted UICC-identity to be able to compare that with the used UICC-identity at UICC insertion and power up; or\n3\tthe ME is powered up and the ME discovers that no UICC has been inserted to the ME.\nNOTE 1:\tOne possible way, how this requirement can be fulfilled by an application in an open platform is, if the keys are deleted at shut-down and at start-up of the application. When the ME operating system detects one of the conditions above, it can shut down the application to force key deletion. The deletion at start-up ensures that keys are also deleted, when an irregular power-down or UICC removal during power down has occurred.\nThe ME shall delete all GBA keys related to a certain Ks (i.e., Ks itself, and NAF specific keys derived from this specific Ks) and the corresponding NAF_IDs, B-TID, Ks_(ext/int)_NAF lifetimes, Ks lifetime, and lifetime (of the keys derived from Ks_(ext)_NAF) when the key lifetime of this specific Ks expires.\nIn the case of GBA_ME, the key Ks shall be deleted from the ME when the ME is powered down. The NAF specific keys (i.e. Ks_(ext)_NAF and keys derived therefrom, if any) may be deleted from the ME when the ME is powered down. If the ME does not delete these NAF specific keys at power down then the NAF specific keys (i.e. Ks_(ext)_NAF and keys derived therefrom, if any) together with the NAF_IDs, B-TID, Ks_(ext)_NAF lifetime and lifetimes (of the keys derived from Ks_(ext)_NAF) shall be stored in non-volatile memory.\nIf the NAF specific keys are stored in non-volatile memory, then when the ME is powered up again, the ME may need to ensure that the same UICC application is selected for the Ua application, in order to allow the re-use of the NAF specific keys (i.e. Ks_(ext)_NAF and keys derived therefrom, if any), cf. clause 4.4.8. For this, the ME shall store also the IMPI in non-volatile memory. If the same UICC application can not be selected for a Ua application at UE power up, then the ME shall delete the NAF specific keys related to that IMPI stored in non-volatile memory.\nWhenever a UICC application is terminated (see section 4.4.8) the shared key Ks established from it in the protocol over the Ub reference point (according to clauses 4.5.2 and 5.3.2) shall be deleted.\nNOTE 2:\tIn case the key Ks has been deleted, but the same UICC is still present (i.e. none of conditions 1, 2 or 3 is met), the Ua applications can continue using the NAF specific keys (Ks_(ext/int)_NAF) until the Ks lifetime expires.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.12\tRequirements on reference point Zh'",
                            "text_content": "This reference point is optional for the BSF to support. The requirements for reference point Zh' are:\n-\tmutual authentication, confidentiality and integrity shall be provided;\nNOTE 1:\tThis requirement may be fulfilled by physical or proprietary security measures, since BSF and HLR are located within the same operator's network.\n-\tthe BSF shall be able to send an authentication vector request concerning a subscriber;\n-\tthe HLR shall be able to send one authentication vector, as described in TS 29.109 [32] at a time to the BSF;\n-\tno other GBA functionality than conveying authentication vectors shall be required on Zh';\n-\tno state information concerning bootstrapping shall be required in the HLR;\n-\tall procedures over reference point Zh' shall be initiated by the BSF;\n-\tthe number of different interfaces to HLR should be minimized.\nNOTE 2:\tIf support of GBA User Security Settings (GUSS) is desired in combination with HLR or HSS with Zh' reference point support, then this can be achieved, for instance by storing the GUSS information in a BSF database (external and/or external to the node itself), or in any other network database which is deemed as appropriate for a specific deployment. GUSS information is not sent over Zh' reference point.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.4.13\tRequirements on TMPI handling",
                            "text_content": "The BSF shall store a TMPI together with the IMPI, from which it was derived (cf. Annex B.4), until the next bootstrapping procedure is executed using this TMPI.\nThe BSF may have a local policy for deleting stored (TMPI, IMPI)-pairs before the next bootstrapping procedure is executed using this TMPI, e.g. for storage or performance reasons.\nThe ME shall store a TMPI together with the IMPI, from which it was derived (cf. Annex B.4), in non-volatile memory.\nThe ME shall delete all stored (TMPI, IMPI)-pairs when at least one of the conditions below is met:\n1.\tthe UICC is removed from the ME when the ME is in power on state; or\n2.\tthe ME is powered up and the ME discovers that another UICC has been inserted to the ME. For this, the ME needs to store in non-volatile memory the last inserted UICC-identity to be able to compare that with the used UICC-identity at UICC insertion and power up; or\n3.\tthe ME is powered up and the ME discovers that no UICC has been inserted to the ME.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "4.5\tProcedures",
                    "description": "",
                    "summary": "",
                    "text_content": "This chapter specifies in detail the format of the bootstrapping procedure that is further utilized by various applications. It contains the AKA authentication procedure with BSF, and the key material generation procedure.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "4.5.1\tInitiation of bootstrapping",
                            "text_content": "Before communication between the UE and the NAF can start, the UE and the NAF first have to agree whether to use the GBA. When a UE wants to interact with a NAF, but it does not know if the NAF requires the use of shared keys obtained by means of the GBA, the UE may contact the NAF for further instructions (see figure 4.2).\nNOTE: The above text implies that a UE may contact either the BSF or the NAF without knowing whether the NAF supports GBA\nThe figure depicts the initiation of bootstrapping in a 5G network, illustrating the process of network initialization. The figure shows the network's initial state, including the base station (gNB), user equipment (UE), and scatterers. The diagram highlights the use of beamforming techniques to mitigate interference, emphasizing the importance of network reliability and efficiency.\nFigure 4.2: Initiation of bootstrapping\n1.\tThe UE may start communication over reference point Ua with the NAF with or without any GBA-related parameters.\n2.\tIf the NAF requires the use of shared keys obtained by means of the GBA, but the request from UE does not include GBA-related parameters, the NAF replies with a bootstrapping initiation message. The form of this initiation message may depend on the particular reference point Ua.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.5.2\tBootstrapping procedures",
                            "text_content": "When a UE wants to interact with a NAF, and it knows that the bootstrapping procedure is needed, it shall first perform a bootstrapping authentication (see figure 4.3). Otherwise, the UE shall perform a bootstrapping authentication only when it has received bootstrapping initiation required message or a bootstrapping negotiation indication from the NAF, or when the lifetime of the key in UE has expired (cf. subclause 4.5.3).\nNOTE 1:\tThe main steps from the specifications of the AKA protocol in TS 33.102 [2] and the HTTP digest AKA protocol in RFC 3310 [4] are repeated in figure 3 for the convenience of the reader. In case of any potential conflict, the specifications in TS 33.102 [2] and RFC 3310 [4] take precedence.\nThe figure depicts the bootstrapping procedure, which is a crucial step in the network's initial setup. It illustrates the process of initializing the network by connecting the base station (gNB) to the network, followed by the connection of the user equipment (UE) and the distribution of nodes. The figure highlights the importance of redundancy paths to ensure failover reliability and the layered design of the network, aligning with the principles of Software-Defined Networking (SDN).\nFigure 4.3: The bootstrapping procedure\nA UE shall always include the product token \"3gpp-gba-tmpi\" in the user agent request-header field when communicating over Ub. A BSF shall always include the product token \"3gpp-gba-tmpi\" in the server response-header field when communicating over Ub.\nNOTE 1a:\tAccording to the HTTP specification RFC 9110 [61], the product tokens may contain any text. They are ignored when unknown by a UE or a BSF.\n1.\tThe UE sends an HTTP request towards the BSF. When a TMPI associated with the IMPI in use is available on the UE, the UE includes this TMPI in the \"username\" parameter, otherwise the UE includes the IMPI.\n2.\tThe BSF recognises from the structure of the \"username\" parameter (cf. Annex B.4) whether a TMPI or an IMPI was sent. If a TMPI was sent the BSF looks up the corresponding IMPI in its local database. If the BSF does not find an IMPI corresponding to the received TMPI it returns an appropriate error message to the UE. The UE then deletes the TMPI and retries the request using the IMPI.\nThe BSF retrieves the complete set of GBA user security settings and one Authentication Vector (AV, AV = RAND||AUTN||XRES||CK||IK) over the reference point Zh from the HSS.\nIn the case that no HSS with Zh reference point is deployed, the BSF retrieves the Authentication Vector over the reference point Zh' from either an HLR or an HSS with Zh' reference point support.\nIf the BSF implements the timestamp option and has a local copy of the GUSS for the subscriber that has been fetched from the HSS during a previous bootstrapping procedure, and this GUSS includes a timestamp, the BSF may include the GUSS timestamp in the request message. Upon receiving that timestamp, if the HSS implements the timestamp option, the HSS may compare it with the timestamp of the GUSS stored in the HSS. In this case, if and only if the HSS has done the comparison and the timestamps are equal, then the HSS shall send \"GUSS TIMESTAMP EQUAL\" indication to the BSF. In any other case, the HSS shall send the GUSS (if available) to the BSF. If the BSF receives \"GUSS TIMESTAMP EQUAL\" indication, it shall keep the local copy of the GUSS. In any other case, the BSF shall delete the local copy of the GUSS, and store the received GUSS (if sent).\nNOTE 2:\tIn a multiple HSS environment, the BSF may have to obtain the address of the HSS where the subscription of the user is stored by querying the SLF, prior to step 2.\n3.\tThen BSF forwards the RAND and AUTN to the UE in the 401 message (without the CK, IK and XRES). This is to demand the UE to authenticate itself.\n4.\tThe UE checks AUTN to verify that the challenge is from an authorised network; the UE also calculates CK, IK and RES. This will result in session keys IK and CK in both BSF and UE.\n5.\tThe UE sends another HTTP request, containing the Digest AKA response (calculated using RES), to the BSF.\n6.\tThe BSF authenticates the UE by verifying the Digest AKA response.\nNOTE 3:\tThe password in \"AKAv1\" HTTP Digest AKA is in binary format.\n7.\tThe BSF generates key material Ks by concatenating CK and IK. The B-TID value shall be also generated in format of NAI by taking the base64 encoded (cf. RFC 4648 [60]) RAND value from step 3, and the BSF server name, i.e. base64encode()@BSF_servers_domain_name.\nNOTE 3a:\tIf the HSS/AuC uses a good random number generator, then the chance of a B-TID collision is practically zero. If such a collision occurs, then the key retrieved by the NAF can have a mismatch with the UE generated NAF key. This will result in a Ua authentication failure which will cause the NAF to once again request the UE to bootstrap which will create a new Ks and a new B-TID.\nIf the request included the product token \"3gpp-gba-tmpi\" in the user agent request-header field the BSF shall compute a new TMPI as specified in Annex B.4 and store it together with the IMPI, overwriting a previous TMPI related to this IMPI, if any.\n8.\tThe BSF shall send a 200 OK message, including a B-TID, to the UE to indicate the success of the authentication. In addition, in the 200 OK message, the BSF shall supply the lifetime of the key Ks. The key material Ks is generated in UE by concatenating CK and IK.\n9.\tBoth the UE and the BSF shall use the Ks to derive the key material Ks_NAF during the procedures as specified in clause 4.5.3. Ks_NAF shall be used for securing the reference point Ua.\nKs_NAF is computed as Ks_NAF = KDF (Ks, \"gba-me\", RAND, IMPI, NAF_Id), where KDF is the key derivation function as specified in Annex B, and the key derivation parameters consist of the user's IMPI, the NAF_Id and RAND. The NAF_Id is constructed as follows: NAF_Id = FQDN of the NAF || Ua security protocol identifier. The Ua security protocol identifier is specified in Annex H. KDF shall be implemented in the ME.\nNOTE 4:\tIf a NAF hosts two or more applications which use the same FQDN and Ua security protocol identifier, they will share the same NAF specific keys. This causes a risk of so called two-time pad which may lead to the situation that the security of these applications is compromised. This can be avoided by running bootstrapping separately to each application or by application specific means, which are however out of the scope of the current specification.\nTo allow consistent key derivation based on NAF name in UE and BSF, at least one of the three following prerequisites shall be fulfilled:\n(1)\tThe NAF is known in DNS under one domain name (FQDN) only, i.e. no two different domain names point to the IP address of the NAF. This has to be achieved by administrative means.\nThis prerequisite is not specific to 3GPP, as it is necessary also under other circumstances, e.g. for TLS without use of wildcard or multiple-name certificates.\n(2)\tEach DNS entry of the NAF points to a different IP address. The NAF responds to all these IP addresses. Each IP address is tied to the corresponding FQDN by NAF configuration. The NAF can see from the IP address, which FQDN to use for key derivation.\n(3)\tUa uses a protocol which transfers the host name (FQDN of NAF as used by UE) to NAF (e.g. HTTP/1.1 with mandatory Host request header field). This requires the NAF to check the validity of the host name, to use this name in all communication with UE where appropriate, and to transfer this name to BSF to allow for correct derivation of Ks_NAF.\nIn case of a TLS tunnel this requires either multiple-identities certificates or the deployment of  TLS Extensions as specified in Annex E of TS 33.310 [19] or other protocol means with similar purpose.\nThe UE and the BSF shall store the key Ks with the associated B-TID for further use, until the lifetime of Ks has expired, or until the key Ks is updated or until the deletion conditions are satisfied (see 4.4.11).\nNOTE 5: \tThe following case can occur. The UE contacts the NAF1 and generates keys for NAF1. Then the UE contacts NAF2 and generates NAF2 keys. Then NAF1 requests then keys from the BSF, but the old key keys could have been overwritten due to NAF2 having initiated a new GBA run. The UE initiates a new GBA-run (B-TID2) after handling NAF1 (B-TID1) and starting the request to the NAF1 over Ua. One possible reason is that B-TID1 lifetime was about to expire. It is very likely that the GBA-run takes much more time (HSS involvement) then the Zn/Ua request such that the B-TID1 request at the BSF should arrive in most cases earlier at the BSF. So this out-of-order case should be very rare. This error situation will be signalled back to the UE, such that the most recent B-TID2 will also be used for NAF1. This out-of order case is self-correcting, since if the B-TID1 is unknown in the BSF, then the Ua request will fail and the UE can send a new request using B-TID2.\nIf the response included the product token \"3gpp-gba-tmpi\" in the server response-header field the UE shall compute the TMPI as specified in Annex B.4 and store it together with the IMPI, overwriting a previous TMPI related to this IMPI, if any.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.5.3\tProcedures using bootstrapped Security Association",
                            "text_content": "Before communication between the UE and the NAF can start, the UE and the NAF first have to agree whether to use shared keys obtained by means of the GBA. If the UE does not know whether to use GBA with this NAF, it uses the Initiation of Bootstrapping procedure described in clause 4.5.1.\nOnce the UE and the NAF have established that they want to use GBA then every time the UE wants to interact with an NAF the following steps are executed as depicted in figure 4.4.\n1.\tUE starts communication over reference point Ua with the NAF:\n-\tin general, UE and NAF will not yet share the key(s) required to protect the reference point Ua. If they already do (i.e. if a key Ks_NAF for the corresponding key derivation parameter NAF_Id is already available), the UE and the NAF can start to securely communicate right away. If the UE and the NAF do not yet share a key, the UE proceeds as follows:\n-\tif a key Ks for the selected UICC application is available in the UE, the UE derives the key Ks_NAF from Ks, as specified in clause 4.5.2;\n-\tif no key Ks for the selected UICC application is available in the UE, the UE first agrees on a new key Ks with the BSF over the reference point Ub, and then proceeds to derive Ks_NAF\nIf it is not desired by the UE to use the same Ks for the selected UICC application to derive more than one Ks_NAF then the UE should agree on a new key Ks with the BSF over the reference point Ub, and then proceed to derive Ks_NAF.\n-\tif the NAF shares a key with the UE, but the NAF requires an update of that key, e.g. because the key's lifetime has expired or will expire soon, or the key can not meet the NAF local validity condition, it shall send a suitable bootstrapping renegotiation request to the UE, see figure 4.5. If the key's lifetime has expired the protocol used over reference point Ua shall be terminated. The form of this indication depends on the particular protocol used over reference point Ua. If the UE receives a bootstrapping renegotiation request, it starts a run of the protocol over reference point Ub, as specified in clause 4.5.2, in order to obtain a new key Ks.\nTo allow for consistent key derivation in BSF and UE, both have to use the same FQDN for derivation (see clause 4.5.2). For each protocol used over Ua it shall be specified if only cases (1) and (2) of clause 4.5.2 are allowed for the NAF or if the protocol used over Ua shall transfer also the FQDN used for key derivation by UE to NAF.\nNOTE 1:\tIf the shared key between UE and NAF is invalid, the NAF can set deletion conditions to the corresponding security association for subsequent removal.\n-\tthe UE supplies the B-TID to the NAF, in the form as specified in clause 4.5.2, to allow the NAF to retrieve the corresponding keys from the BSF;\nNOTE 2:\tThe UE may adapt the key material Ks_NAF to the specific needs of the reference point Ua. This adaptation is outside the scope of this specification.\n-\tthe key management procedures for GBA related keys in the ME (i.e. Ks and Ks_NAF keys) are described in section 4.4.11.\n-\twhen a new Ks is agreed over the reference point Ub and a key Ks_NAF, derived from one NAF_Id, is updated, the other keys Ks_NAF, derived from different values NAF_Id, stored on the UE shall not be affected;\nAccording to the procedures defined in clauses 4.5.2 and 4.5.3, in the UE there is at most one Ks_NAF key stored per NAF-Id.\n2.\tNAF starts communication over reference point Zn with BSF\n-\tThe NAF requests key material corresponding to the B-TID supplied by the UE to the NAF over reference point Ua.;\n-\tThe NAF may also request one or more application-specific USSs for the applications, which the request received over Ua from UE may access;\nNOTE 3: \tIf the NAF requires service continuity, then the NAF can request a USS that contains a user pseum that allows service continuity according to BSF policy.\n-\tWith the key material request, the NAF shall supply a NAF-Id (which includes the NAF's FQDN that the UE has used to access this NAF and the Ua security protocol identifier) to the BSF. (This is to allow for consistent key derivation in the BSF and UE as described above). The BSF shall verify that the NAF is authorized to use that FQDN.\n3.\tThe BSF derives the keys required to protect the protocol used over reference point Ua from the key Ks and the key derivation parameters, as specified in clause 4.5.2, and supplies to NAF the requested key Ks_NAF, as well as the bootstrapping time and the lifetime of that key, and the requested application-specific and potentially NAF group specific USSs if they are available in subscriber's GUSS and if the NAF is authorized to receive the requested USSs. For any USSs containing a NAF Group attribute, this attribute shall be removed in the USSs supplied to the NAF. If the key identified by the B-TID supplied by the NAF is not available at the BSF, the BSF shall indicate this in the reply to the NAF. The NAF then indicates a bootstrapping renegotiation request to the UE.\nNOTE 4:\tThe NAF can further set the local validity condition of the Ks_NAF according to the local policy, for example a limitation of reuse times of a Ks_NAF.\nNOTE 5:\tThe NAF will adapt the key material Ks_NAF to the specific needs of the reference point Ua in the same way as the UE did. This adaptation is outside the scope of this specification.\n-\tThe BSF may require that one or more application-specific and potentially NAF group specific USSs shall be present in subscriber's GUSS for the NAF (see clause 4.4.6). If one or more of these required settings are missing from the GUSS, the BSF shall indicate this in the reply to the NAF.\n-\tThe BSF may also send the private user identity (IMPI) and requested USSs to NAF according to the BSF's policy;\n4.\tNAF continues with the protocol used over the reference point Ua with the UE.\nOnce the run of the protocol used over reference point Ua is completed the purpose of bootstrapping is fulfilled as it enabled UE and NAF to use reference point Ua in a secure way.\nThe figure depicts the bootstrapping usage procedure, illustrating the steps involved in initializing a network. The figure shows a series of steps, including selecting a network, configuring the network, and initiating the bootstrapping process. The steps are visually represented by arrows and labels, providing a clear and concise overview of the procedure.\nFigure 4.4: The bootstrapping usage procedure\nThe figure depicts a bootstrapping renegotiation request, which is a key component in the process of network reconfiguration. The request is initiated by the network administrator to update the network configuration to improve performance or address network issues. The figure shows the request process, including the initiation of the request, the network administrator's decision to accept or reject the request, and the subsequent steps in the network configuration update. The figure provides a visual representation of the complex process involved in network management and the importance of maintaining a well-functioning network.\nFigure 4.5: Bootstrapping renegotiation request\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "4.5.4\tProcedure related to service discovery",
                            "text_content": "The UE shall discover the address of the BSF the from the identity information related to the UICC application that is used during bootstrapping procedure, i.e., IMSI for USIM, or IMPI for ISIM. The address of the BSF is derived as specified in TS 23.003 [11].\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "5\tUICC-based enhancements to Generic Bootstrapping Architecture (GBA_U)",
            "description": "It is assumed that the UICC, BSF, and HSS involved in the procedures specified in this clause are capable of handling the GBA_U specific enhancements. The procedures specified in this clause also apply if NAF is not GBA_U aware.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "5.1\tArchitecture and reference points for bootstrapping with UICC-based enhancements",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from clause 4.4 of this specification applies also here, with the addition that the interface between the ME and the UICC, as specified in TS 31.102 [1] and TS 31.103 [10], needs to be enhanced with GBA_U specific commands. The requirements on these commands can be found in clause 5.2.1, details on the procedures are in clause 5.3.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "5.2\tRequirements and principles for bootstrapping with UICC-based enhancements",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements and principles from clause 4.4 also apply here with the following addition:\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.2.1\tRequirements on UE",
                            "text_content": "The 3G AKA keys CK and IK resulting from a run of the protocol over the Ub reference point shall not leave the UICC.\nThe UICC shall be able to distinguish between authentication requests for GBA_U, and authentication requests for other 3G authentication domains.\nUpon an authentication request from the ME, which the UICC recognises as related to GBA_U, the UICC shall derive the bootstrapping key.\nUpon request from the ME, the UICC shall be able to derive further NAF-specific keys from the derived key stored on the UICC.\nAll GBA-aware MEs shall support procedures for the two previous requests.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.2\tRequirements on BSF",
                            "text_content": "BSF shall support both GBA_U and GBA_ME bootstrapping procedures. The decision on running one or the other shall be based on subscription information (i.e. UICC capabilities).\nThe BSF shall be able to acquire the UICC capabilities related to GBA as part of the GBA user security settings received from the HSS.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.3\tProcedures for bootstrapping with UICC-based enhancements",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.3.1\tInitiation of bootstrapping",
                            "text_content": "The text from clause 4.5.1 of the present document applies also here.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.2\tBootstrapping procedure",
                            "text_content": "The procedure specified in this clause differs from the procedure specified clause 4.5.2 in the local handling of keys and Authentication Vectors in the UE and the BSF. The messages exchanged over the Ub reference point are identical for both procedures.\nWhen a UE wants to interact with a NAF, and it knows that the bootstrapping procedure is needed, it shall first perform a bootstrapping authentication (see figure 5.1). Otherwise, the UE shall perform a bootstrapping authentication only when it has received bootstrapping initiation required message or a bootstrapping renegotiation indication from the NAF, or when the lifetime of the key in UE has expired (see clause 5.3.3).\nNOTE:\tThe main steps from the specifications of the AKA protocol in TS 33.102 [2] and the HTTP digest AKA protocol in RFC 3310 [4] are repeated in figure 5.1 for the convenience of the reader. In case of any potential conflict, the specifications in TS 33.102 [2] and RFC 3310 [4] take precedence.\nThe bootstrapping procedure with UICC-based enhancements is depicted in Figure 5.1, illustrating the process of initializing a network with a combination of user equipment (UE) and base station (gNB) components. The figure highlights the importance of using UICC (User Equipment Configuration) to ensure efficient network operation.\nFigure 5.1: The bootstrapping procedure with UICC-based enhancements\nA UE shall always include the product token \"3gpp-gba-tmpi\" in the user agent request-header field when communicating over Ub. A BSF shall always include the product token \"3gpp-gba-tmpi\" in the server response-header field when communicating over Ub.\nNOTE a:\tAccording to the HTTP specification RFC 9110 [61], the product tokens may contain any text. They are ignored when unknown by a UE or a BSF.\n1.\tThe ME sends an HTTP request towards the BSF. When a TMPI associated with the IMPI in use is available on the UE, the UE includes this TMPI in the \"username\" parameter, otherwise the UE includes the IMPI.\n2.\tThe BSF recognises from the structure of the \"username\" parameter (cf. Annex B.4) whether a TMPI or an IMPI was sent. If a TMPI was sent the BSF looks up the corresponding IMPI in its local database. If the BSF does not find an IMPI corresponding to the received TMPI it returns an appropriate error message to the UE. The UE then deletes the TMPI and retries the request using the IMPI.\nThe BSF retrieves the complete set of GBA user security settings and one Authentication Vector \n(AV, AV = RAND||AUTN||XRES||CK||IK) over the Zh reference point from the HSS.\nThe HSS shall also send an indication that the UICC supports SHA-256 to the BSF if the UICC supports SHA-256.\nIf the BSF implements the timestamp option and has a local copy of the GUSS for the subscriber that has been fetched from the HSS during a previous bootstrapping procedure, and this GUSS includes a timestamp, the BSF may include the GUSS timestamp in the request message. Upon receiving that timestamp, if the HSS implements the timestamp option, the HSS may compare it with the timestamp of the GUSS stored in the HSS. In this case, if and only if the HSS has done the comparison and the timestamps are equal, then the HSS shall send \"GUSS TIMESTAMP EQUAL\" indication to the BSF. In any other case, the HSS shall send the GUSS (if available) to the BSF. If the BSF receives \"GUSS TIMESTAMP EQUAL\" indication, it shall keep the local copy of the GUSS. In any other case, the BSF shall delete the local copy of the GUSS, and store the received GUSS (if sent).\nThe BSF can then decide to perform GBA_U, based on the user security settings (USSs). In this case, the BSF proceeds in the following way:\n-\tThe BSF computes MAC*. If an indication that the UICC supports SHA-256 is received from the HSS, the MAC* is computed as MAC*= MACÅ Trunc(SHA-256(IK)); otherwise,  MAC* = MACÅ Trunc(SHA-1(IK)).\nNOTE 1:\tTrunc denotes that from the output of SHA-256 or SHA-1 [23], the 64 bits numbered as [0] to [63] are used within the * operation to MAC.\nThe BSF stores the XRES after flipping the least significant bit.\nNOTE 2:\tIn a multiple HSS environment, the BSF may have to obtain the address of the HSS where the subscription of the user is stored by querying the SLF, prior to step 2.\n3.\tThen BSF forwards the RAND and AUTN* (where AUTN* =  || AMF || MAC*) to the UE in the 401 message (without the CK, IK and XRES). This is to demand the UE to authenticate itself.\n4.\tThe ME sends RAND and AUTN* to the UICC. The UICC calculates IK and MAC (by performing MAC= MAC*  Trunc(SHA-256(IK)) if the UICC supports SHA-256, otherwise by performing MAC= MAC*  Trunc(SHA-1(IK)). Then the UICC checks AUTN(i.e.  || AMF || MAC) to verify that the challenge is from an authorised network; the UICC also calculates CK and RES. This will result in session keys CK and IK in both BSF and UICC. The UICC then transfers RES (after flipping the least significant bit) to the ME and stores Ks, which is the concatenation of CK and IK, on the UICC.\nThe usage of SHA-256 for MAC* computation at BSF and MAC calculation at UICC is recommended.\nNOTE 2a:\tThe usage of SHA-1 is only for backward compatibility.\nNOTE 2b:\tBSF and HSS need to be upgraded to use SHA-256 before a UICC supporting SHA-256 can be used.\n5.\tThe ME sends another HTTP request, containing the Digest AKA response (calculated using RES), to the BSF.\n6.\tThe BSF authenticates the UE by verifying the Digest AKA response.\nNOTE 3:\tThe password in \"AKAv1\" HTTP Digest AKA is in binary format.\n7.\tThe BSF generates the key Ks by concatenating CK and IK. The B-TID value shall be also generated in format of NAI by taking the base64 encoded [12] RAND value from step 3, and the BSF server name, i.e. base64encode()@BSF_servers_domain_name.\nNOTE 3a:\tIf the HSS/AuC uses a good random number generator, then the chance of a B-TID collision is practically zero. If such a collision occurs, then the key retrieved by the NAF can have a mismatch with the UE generated NAF key. This will result in a Ua authentication failure which will cause the NAF to once again request the UE to bootstrap which will create a new Ks and a new B-TID.\nIf the request included the product token \"3gpp-gba-tmpi\" in the user agent request-header field the BSF shall compute a new TMPI as specified in Annex B.4 and store it together with the IMPI, overwriting a previous TMPI related to this IMPI, if any.\n8.\tThe BSF shall send a 200 OK message, including the B-TID, to the UE to indicate the success of the authentication. In addition, in the 200 OK message, the BSF shall supply the lifetime of the key Ks.\n9.\tBoth the UICC and the BSF shall use the Ks to derive NAF-specific keys Ks_ext_NAF and Ks_int_NAF during the procedures as specified in clause 5.3.3, if applicable. Ks_ext_NAF and Ks_int_NAF are used for securing the Ua reference point.\nKs_ext_NAF is computed in the UICC as Ks_ext_NAF = KDF(Ks, \"gba-me\", RAND, IMPI, NAF_Id), and Ks_int_NAF is computed in the UICC as Ks_int_NAF = KDF(Ks, \"gba-u, RAND, IMPI, NAF_Id), where KDF is the key derivation function as specified in Annex B, and the key derivation parameters include the user's IMPI, the NAF_Id and RAND. The NAF_Id is constructed as follows: NAF_Id = FQDN of the NAF || Ua security protocol identifier. The Ua security protocol identifier is specified in Annex H. The key derivation parameters used for Ks_ext_NAF derivation must be different from those used for Ks_int_NAF derivation. This is done by adding a static string \"gba-me\" in Ks_ext_NAF and \"gba-u\" in Ks_int_NAF as an input parameter to the key derivation function.\nNOTE 4:\tIf a NAF hosts two or more applications which use the same FQDN and Ua security protocol identifier, they will share the same NAF specific keys. This causes a risk of so called two-time pad which may lead to the situation that the security of these applications is compromised. This can be avoided by running bootstrapping separately to each application or by application specific means, which are however out of the scope of the current specification.\nTo allow consistent key derivation based on NAF name in UE and BSF, at least one of the prerequisites which are specified in clause 4.5.2 shall be met.\nThe UICC and the BSF store the key Ks with the associated B-TID for further use, until the lifetime of Ks has expired, or until the key Ks is updated or until the deletion conditions are satisfied (see 4.4.11).\nIf the response included the product token \"3gpp-gba-tmpi\" in the server response-header field the UE shall compute the TMPI as specified in Annex B.4 and store it together with the IMPI, overwriting a previous TMPI related to this IMPI, if any.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.3\tProcedures using bootstrapped Security Association",
                            "text_content": "Before communication between the UE and the NAF can start, the UE and the NAF first have to agree whether to use shared keys obtained by means of the GBA. If the UE does not know whether to use GBA with this NAF, it uses the Initiation of Bootstrapping procedure described in clause 5.3.1.\nOnce the UE and the NAF have established that they want to use GBA then every time the UE wants to interact with a NAF the following steps are executed as depicted in figure 5.3.\nNext, the UE and the NAF have to agree, which type of keys to use, Ks_ext_NAF or Ks_int_NAF, or both. The default is the use of Ks_ext_NAF only. This use is also supported by MEs and NAFs, which are GBA_U unaware. If Ks_int_NAF, or both Ks_ext_NAF and Ks_int_NAF are to be used, this use has to be agreed between UE and NAF prior to the execution of the procedure described in the remainder of this clause 5.3.3. Any such agreement overrules the default use of the keys. A key selection indication, which key (i.e. Ks_int_NAF or Ks_ext_NAF) the NAF shall use in the Ua reference point may be present in the application specific USS as defined in stage 3 specification. If the indication exists, the NAF shall use the indicated key. If the Ks_int_NAF key was indicated in the USS, the UE attempts to use Ks_ext_NAF key, the NAF shall terminate the communication with the UE.\nNOTE 1:\tThis agreement may be mandated by the specification, which defines the Ua reference point between UE and NAF, e.g. TS 33.246 for the use of GBA in MBMS, or negotiated by the NAF and the UE over the Ua reference point, or reached by configuration.\n1.\tUE starts communication over reference point Ua with the NAF using the keys Ks_ext_NAF or Ks_int_NAF, or both, as required:\n-\tin general, UE and NAF will not yet share the key(s) required to protect the Ua reference point. If they do not, the UE proceeds as follows:\n-\tif Ks_ext_NAF is required and a key Ks for the selected UICC application is available in the UICC, the ME requests the UICC to derive the key Ks_ext_NAF from Ks, as specified in clause 5.3.2;\n-\tif Ks_int_NAF is required and a key Ks for the selected UICC application is available in the UICC, the ME requests the UICC to derive the key Ks_int_NAF from Ks, as specified in clause 5.3.2;\nIf it is not desired by the UE to use the same Ks for the selected UICC application to derive more than one Ks_ext/int_NAF, then the UE should first agree on new key Ks with the BSF over the Ub reference point, as specified in clause 5.3.2, and then proceeds to derive Ks_ext_NAF or Ks_int_NAF, or both, as required.\n-\tif Ks for the selected UICC application is not available in the UE, the UE first agrees on a new key Ks with the BSF over the Ub reference point, as specified in clause 5.3.2, and then proceeds to derive Ks_ext_NAF or Ks_int_NAF, or both, as required;\n-\tif the NAF shares a key with the UE, but the NAF requires an update of that key, it shall send a suitable bootstrapping renegotiation request to the UE. If the key's lifetime has expired the protocol used over reference point Ua shall be terminated. The form of this indication depends on the particular protocol used over Ua reference point. If the UE receives a bootstrapping renegotiation request, it starts a run of the protocol over Ub, as specified in clause 5.3.2, in order to obtain new keys.\nNOTE 2:\tIf the shared keys between UE and NAF become invalid, the NAF can set deletion conditions to the corresponding security association for subsequent removal.\nNOTE 3:\tIf it is not desired by the NAF to use the same Ks to derive more than one Ks_int/ext_NAF then the NAF can reply to the first request sent by a UE by sending a key update request to the UE.\n-\tThe UE supplies the B-TID to the NAF, as specified in clause 5.3.2, to allow the NAF to retrieve the corresponding keys from the BSF\nTo allow for consistent key derivation in BSF and UE, both have to use the same FQDN for derivation (cf. clause 4.5.2). For each protocol used over Ua it shall be specified if only cases (1) and (2) of clause 4.5.2 are allowed for the NAF or if the protocol used over Ua shall transfer also the FQDN used for key derivation by UE to NAF.\nNOTE 4\tThe UE may adapt the keys Ks_ext_NAF or Ks_int_NAF to the specific needs of the Ua reference point. This adaptation is outside the scope of this specification.\n-\tthe key management procedures for GBA related keys in the ME (i.e. Ks_ext_NAF keys) are described in section 4.4.11.\n-\tall GBA related keys in the UICC do not need to be deleted when the ME is powered down.\nNOTE 5:\tAfter each run of the protocol over the Ub reference point, a new key Ks, associated with a new B-TID, are derived in the UE according to clause 5.3.2, so that it can never happen, that key Ks with different B-TIDs simultaneously exist in the UE.\n-\tWhen new key Ks is agreed over the Ub reference point and new NAF-specific keys need to be derived for one NAF_Id, then both, Ks_ext_NAF and Ks_int_NAF (if present), shall be updated for this NAF_Id, but other keys Ks_ext_NAF or Ks_int_NAF relating to other NAF_Ids, which may be stored on the UE, shall not be affected.\nAccording to the procedures defined in clauses 5.3.2 and 5.3.3, in the UE there is at most one Ks_int_NAF/Ks_ext_NAF key pair stored per NAF_Id.\nNOTE 6:\tThis rule ensures that the keys Ks_ext_NAF and Ks_int_NAF are always in synch at the UE and the NAF.\n2.\tNAF now starts communication over the Zn reference point with the BSF.\n-\tThe NAF requests from the BSF the keys corresponding to the B-TID, which was supplied by the UE to the NAF over the Ua reference point. If the NAF is GBA_U aware it indicates this by including a corresponding flag in the request;\n-\tThe NAF may also request one or more application-specific USSs for the applications, which the request received over Ua from UE may access;\nNOTE 7: \tIf the NAF requires service continuity, then the NAF can request a USS that contains a user pseum that allows service continuity according to BSF policy.\n-\tWith the keys request over the Zn reference point, the NAF shall supply a NAF-Id (which includes NAF's FQDN that the UE has used to access this NAF and the Ua security protocol identifier) to the BSF. (This is to allow for consistent key derivation in the BSF and UE as described above). The BSF shall verify that the NAF is authorized to use that FQDN.\n3.\tThe BSF derives the keys Ks_ext_NAF, and Ks_int_NAF (if additionally required), as specified in clause 5.3.2. If the NAF indicated in its request that it is GBA_U aware, the BSF supplies to NAF both keys, Ks_ext_NAF, and Ks_int_NAF, otherwise the BSF supplies only Ks_ext_NAF. In addition, the BSF supplies the bootstrapping time and the lifetime time of these keys, and the requested application-specific and potentially NAF group specific USSs if they are available in subscriber's GUSS and if the NAF is authorized to receive the requested USSs. For any USSs containing a NAF Group attribute, this attribute shall be removed in the USSs supplied to the NAF.If the key identified by the B-TID supplied by the NAF is not available at the BSF, the BSF shall indicate this in the reply to the NAF. The NAF then indicates a bootstrapping renegotiation request (See figure 4.5) to the UE;\nNOTE 8:\tThe NAF can further set the local validity condition of the Ks_NAF according to the local policy, for example a limitation of reuse times of a Ks_NAF.\nNOTE 9:\tThe NAF will adapt the keys Ks_ext_NAF and Ks_int_NAF to the specific needs of the Ua reference point in the same way as the UE did. This adaptation is outside the scope of this specification.\n-\tThe BSF may require that one or more application-specific and potentially NAF group specific USSs shall be present in subscriber's GUSS for the NAF (see clause 4.4.6). If one or more of these required settings are missing from the GUSS, the BSF shall indicate this in the reply to the NAF.\n-\tThe BSF may also send the private user identity (IMPI) and requested USSs to NAF according to the BSF's policy.\n4.\tThe NAF now continues with the protocol used over the Ua reference point with the UE.\n-\tIf the NAF requested an application-specific USS from the BSF and the USS was returned the NAF, the NAF shall check whether this USS contains an key selection indication. If the key selection indication is present, the NAF shall use only the indicated key. If a different key was used over Ua, then the protocol used over reference point Ua shall be terminated.\nOnce the run of the protocol used over Ua reference point is completed the purpose of bootstrapping is fulfilled as it enabled the UE and NAF to use Ua reference point in a secure way.\nThe bootstrapping usage procedure with UICC-based enhancements is depicted in Figure 5.3, illustrating the process of initializing a network with a specific configuration. The figure shows the steps involved in initializing the network, including the use of the Universal Interconnect Control Channel (UICC) for enhanced bootstrapping. This process is crucial for ensuring the reliability and performance of the network.\nFigure 5.3: The bootstrapping usage procedure with UICC-based enhancements\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.4\tProcedure related to service discovery",
                            "text_content": "The text from clause 4.5.4 of this document applies also here.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "B.1\tIntroduction",
            "description": "This annex specifies the key derivation function (KDF) that is used in the NAF specific key derivation in GBA (i.e. GBA_ME), GBA_U and GBA Digest. This KDF is also used to derive the TMPI. The key derivation function defined in the annex takes the following assumptions:\n1.\tthe input parameters to the key derivation functions are octet strings - not bit strings of arbitrary length:\n2.\ta single input parameter will have lengths no greater than 65535 octets.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.2\tGeneric key derivation function",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "B.2.0\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "The input parameters and their lengths shall be concatenated into a string S as follows:\n1.\tThe length of each input parameter measured in octets shall be encoded into a two octet-long string:\na)\texpress the number of octets in input parameter Pi as a number k in the range [0, 65535].\nb)\tLi is then a 16-bit long encoding of the number k, encoded as described in clause B.2.1.\n2.\tString S shall be constructed from n+1 input parameters as follows:\nS = FC || P0 || L0 || P1 || L1 || P2 || L2 || P3 || L3 ||... || Pn || Ln\nwhere\nFC is used to distinguish between different instances of the algorithm and is either a single octet or consists of two octets of the form FC1|| FC2 where FC1 =  0xFF and FC2 is a single octet,\nP0 ... Pn are the n+1 input parameter encodings, and\nL0 ... Ln are the two-octet representations of the length of the corresponding input parameter encodings P0.. Pn.\nIn this specification the following restriction applies to P0:  P0 is a static ASCII-encoded string.\nThis restriction is not part of the KDF definition and does not apply to the KDF when used by other 3GPP specifications unless explicitly stated so in those specifications.\n3.\tThe final output, i.e. the derived key is equal to the KDF computed on the string S using the key, denoted Key. The present document defines the following KDF:\nderived key = HMAC-SHA-256 ( Key , S )\nas specified in [22] and [23].\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.2.1\tInput parameter encoding",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "B.2.1.1\tGeneral",
                            "text_content": "This clause specifies how encodings of different data types is to be done. Encoding rules for further data types may be added in future releases if needed.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "B.2.1.2\tCharacter string encoding",
                            "text_content": "A character string shall be encoded to an octet string according to UTF-8 encoding rules as specified in IETF RFC 3629 [24] and apply Normalization Form KC (NFKC) as specified in [37].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "B.2.1.3\tNon-negative integer encoding",
                            "text_content": "A non-negative integer value j, which is input to the KDF, shall be encoded into the octet string Pi as follows:\n1)\tEncode j in base 2.\n2)\tLet n be number of bits as defined for this input parameter in 3GPP specifications, or, if undefined elsewhere, let n be the least multiple of 8 that is greater or equal to the number of bits of the base 2 encoding of j\n3)\tCreate an octet string such that the least significant bit of the octet string shall be equal to the least significant bit of j written in base 2, the second to least significant bit of the octet string shall be equal to the second to least significant bit of j written in base 2 and so on (according to clause 3.4 of this specification). If the number of bits in j written in base 2 is less than n, the remaining most significant bits in the octet string shall be set to zero; if the number of bits in j written in base 2 is equal to n, there is no need for such zero padding.\nThe encoding Li of the number k of octets in Pi follows the above rule.\nEXAMPLE1:\tIf Pi is Uplink NAS COUNT then the number k of octets in Pi is 4, according to TS 33.401, Annex A, and n = 32. Assume that Uplink NAS COUNT has the integer value j = 259. Then the base 2 encoding of 259 is 100000011,  and Pi consists of the octet string 0000000 0000000 00000001 00000011, or 0x00 0x00 0x01 0x03 in hex representation, and Li consists of the octet string 0000000 00000100, or 0x00 0x04 in hex representation.\nEXAMPLE2:\tIf the length of Pi is undefined elsewhere, and the integer value j = 259 is to be encoded into the parameter Pi then the base 2 encoding of 259 is 100000011,  n and hence the length of parameter Pi in bits is 16, the number k of octets in Pi is 2, and Pi consists of the octet string 00000001 00000011, or 0x01 0x03 in hex representation, and Li consists of the octet string 0000000 00000010, or 0x00 0x02 in hex representation.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "B.2.2\tFC value allocations",
                    "description": "",
                    "summary": "",
                    "text_content": "FC values shall only be assigned to a key derivation function by their allocated specification.\nFC values in the range 0x00 – 0x0F are allocated for use in this specification.\nFC values in the range 0x10 – 0x1F are allocated for use in TS 33.401 [35].\nFC values in the range 0x20 – 0x2F are allocated for use in TS 33.402 [36].\nFC values in the range 0x30 – 0x37 are allocated for use in TS 33.102 [2].\nFC values in the range 0x38 – 0x3F are allocated for use in TS 43.020 [47].\nFC values in the range 0x40 – 0x47 are allocated for use in TS 33.224 [39].\nFC values in the range 0x48 – 0x4F are allocated for use in TS 33.303 [49].\nFC values in the range 0x50 – 0x57 are allocated for use in TS 33.179 [50].\nFC values in the range 0x50 – 0x57 are also allocated for use in TS 33.180 [54].\nFC values in the range 0x58 – 0x5F are allocated for use in TS 33.203 [51].\nFC values in the range 0x60 – 0x68 are allocated for use in TS 33.163 [52].\nFC values in the ranges 0x69 – 0x79, 0x7B – 0x7D and 0x83-0x84 are allocated for use in TS 33. 501 [53].\nFC value 0x7A is allocated for use in TS 33.122 [55].\nFC values in the range 0x7E – 0x7F are allocated for use in TS 33.536 [56].\nFC values in the range 0x80 – 0x82 are allocated for use in TS 33.535 [58].\nFC values in the range 0x85 – 0x8B are allocated for use in TS 33.503 [67].\nFC values in the range 0x8C – 0x8E are allocated for use in TS 33.533 [74].\nFC values in the range 0x8F – 0xDF are reserved for future use in 3GPP specifications.\nFC values in the range 0xE0 – 0xEF are reserved for uses of the KDF by other standardization organisations where the FC value for such use is registered in the present specification.\nFC values in the range 0xF0 – 0xFE are reserved for proprietary uses of the KDF where the FC value for the such use is not registered with 3GPP.\nFC values of the form 0xFF || FC2 are reserved for future use in 3GPP specifications.\nNOTE 1:\tRegistering an FC value with 3GPP for use by other standardization organisations means that only the FC value is recorded in the present specification, but the full specification of the key derivation is done elsewhere. This has the advantage that clashes in FC values in different uses by other standardization organisations can be avoided. On the other hand, not registering an FC value with 3GPP for proprietary use means that 3GPP may have no knowledge of this use at all.\nNOTE 2:\tRanges of FC values for use by other standardization organisations or for proprietary use could be extended in the future if such a need was indicated to 3GPP.\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "B.3\tNAF specific key derivation in GBA and GBA_U",
            "description": "In GBA and GBA_U, the input parameters for the key derivation function shall be the following:\n-\tFC = 0x01,\n-\tP1 = ,\n-\tL1 = length of  is 16 octets (i.e. 0x00 0x10),\n-\tP2 = IMPI encoded to an octet string using UTF-8 encoding (see clause B.2.1),\n-\tL2 = length of IMPI is variable (not greater that 65535),\n-\tP3 = NAF_ID with the FQDN part of the NAF_ID encoded to an octet string using UTF-8 encoding (see clause B.2.1), and\n-\tL3 = length of NAF_ID is variable (not greater that 65535).\nIn the key derivation of Ks_NAF as specified in clause 4 and Ks_ext_NAF as specified in clause 5,\n-\tP0 = \"gba-me\" (i.e. 0x67 0x62 0x61 0x2d 0x6d 0x65), and\n-\tL0 = length of P0 is 6 octets (i.e., 0x00 0x06).\nIn the key derivation of Ks_int_NAF as specified in clause 5,\n-\tP0 = \"gba-u\" (i.e. 0x67 0x62 0x61 0x2d 0x75), and\n-\tL0 = length of P0 is 5 octets (i.e., 0x00 0x05).\nThe Key to be used in key derivation shall be:\n-\tKs (i.e. CK || IK concatenated) as specified in clauses 4 and 5,\nNOTE:\tIn the specification this function is denoted as: \n\tKs_NAF = KDF (Ks, \"gba-me\", RAND, IMPI, NAF_Id),\n\tKs_ext_NAF = KDF (Ks, \"gba-me\", RAND, IMPI, NAF_Id), and\nKs_int_NAF = KDF (Ks, \"gba-u\", RAND, IMPI, NAF_Id).\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.4\tDerivation of TMPI",
            "description": "Derivation of TMPI follows the same procedure as NAF specific key derivation in GBA and GBA_U (see clause B.3). As the TMPI is stored in ME, for GBA_U the procedure for derivation of Ks_ext_NAF is followed.\nNOTE:\tThis procedure was chosen to avoid any changes to existing UICCs in case of GBA_U.\nThe BSF_Id defined in this clause consists of the full DNS name of the BSF as used for B-TID generation (see clause 4.5.2), concatenated with the Ua security protocol identifier for TMPI as specified in Annex H.\nIn GBA and GBA_U, the input parameters for the key derivation function to derive the TMPI shall be the following:\n-\tFC = 0x01,\n-\tP0 = \"gba-me\" (i.e. 0x67 0x62 0x61 0x2d 0x6d 0x65) (see clause B.3 for Ks_NAF and Ks_ext_NAF),\n-\tL0 = length of P0 is 6 octets (i.e., 0x00 0x06).\n-\tP1 = ,\n-\tL1 = length of  is 16 octets (i.e. 0x00 0x10),\n-\tP2 = IMPI encoded to an octet string using UTF-8 encoding (see clause B.2.1),\n-\tL2 = length of IMPI is variable (not greater that 65535),\n-\tP3 = the BSF_Id encoded to an octet string using UTF-8 encoding (see clause B.2.1), and\n-\tL3 = length of P3 is variable (not greater that 65535).\nThe Key to be used in derivation of TMPI shall be:\n-\tKs (i.e. CK || IK concatenated) as specified in clauses 4 and 5.\nThe TMPI is then computed as TEMP@tmpi.bsf.3gppnetwork.org where TEMP is the base64-encoding [60] of the 24 most significant octets of the output of KDF.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.5\tDerivation of passwd and Ks",
            "description": "Derivation of passwd and Ks for GBA_Digest shall follow the same procedure as NAF specific key derivation in GBA and GBA_U as specified in clause B.3.\nThe input parameters for the key derivation function to derive passwd and Ks shall be the following:\n-\tFC = 0x01,\n-\tP1 = TLS_MK_Extr,\n-\tL1 = length of TLS_MK_Extr is 48 octets (i.e. 0x00 0x30),\nIn the derivation of passwd as specified in clause M.6.3, step 5,\n-\tP0 = \"GBA_Digest_RESP\"\n(i.e. 0x47 0x42 0x41 0x5F 0x44 0x69 0x67 0x65 0x73 0x74 0x5F 0x52 0x45 0x53 0x50), and\n-\tL0 = length of P0 is 15 octets (i.e., 0x00 0x0F).\nIn the key derivation of Ks as specified in clause M.6.3, step 6,\n-\tP0 = \"GBA_Digest_Ks\" \n(i.e. 0x47 0x42 0x41 0x5F 0x44 0x69 0x67 0x65 0x73 0x74 0x5F 0x4B 0x73),\n-\tL0 = length of P0 is 13 octets (i.e., 0x00 0x0D),\n-\tP2 = RESP, and\n-\tL2 = length of RESP is variable and depends on the algorithm used in HTTP Digest (e.g., 32 if SHA-256 is used).\nThe Key to be used in key derivation function shall be:\n-\tH(A1) as specified in clause M.6.3, step 5.\nNOTE:\tIn the present document this function is denoted as:\n\tpasswd = KDF (H(A1), \"GBA_Digest_RESP\", TLS_MK_Extr), and\n\tKs = KDF (H(A1), \" GBA_Digest_Ks\", TLS_MK_Extr, RESP).\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.6\tNAF specific key derivation in GBA_Digest",
            "description": "In GBA_Digest, the input parameters for the key derivation function to derive Ks_NAF shall be the following:\n-\tFC = 0x01;\n-\tP0 = \"gba-digest\" (i.e. 0x67 0x62 0x61 0x2d 0x64 0x69 0x67 0x65 0x73 0x74);\n-\tL0 = length of P0 is 10 octets (i.e., 0x00 0x0a);\n-\tP1 = nonce;\n-\tL1 = length of nonce is variable (not greater than 65535);\n-\tP2 = IMPI encoded to an octet string using UTF-8 encoding (see clause B.2.1 of the present document);\n-\tL2 = length of IMPI is variable (not greater than 65535);\n-\tP3 = NAF_ID with the FQDN part of the NAF_ID encoded to an octet string using UTF-8 encoding (see clause B.2.1 of the present document;\n-\tL3 = length of NAF_ID is variable (not greater that 65535).\nThe Key to be used in key derivation shall be:\n-\tKs as specified in clause B.5 of the present document.\nNOTE:\tIn clause M.6.3 this function is denoted as:\nKs_NAF = KDF (Ks, \"gba-digest\", nonce, IMPI, NAF_Id).\n\nFor certain cases, clause 4.4.8 specifies user involvement in the selection of the UICC application used for GBA procedures. A dialog window example for such an involvement is described below:\n-\tThe title of the dialog: \"Authentication request\".\n-\tExplanation: \"A service requires you to authenticate, please select your identity:\"\n-\tList of identities: A selectable list of applications on the UICC. The text visible for each application is extracted from the \"Label\" field of the application list on the UICC.\n-\tButtons: \"Select\" and \"Cancel\".\nThis Annex applies for the Zn' reference point when using DIAMETER or HTTP, and applies for the Zn reference point if using HTTP.\nThe TLS profile is specified in TS 33.310 [19], Annex E and shall apply. The TLS endpoints shall mutually authenticate using certificates as part of TLS session establishment.\nNOTE:\tVoid.\nThe TLS certificates shall follow the requirements in clause 6.1 of TS 33.310 [19] for TLS certificates, with the exceptions as given in the following.\nThe Zn-Proxy certificate, i.e. the client certificate used in TLS handshake, shall contain the subjectAltName extension with one or more dNSName names. The dNSName name may contain the wildcard character '*' and the matching is performed as specified in RFC 2818 [18] section 3.1.\nThe Zn-Proxy certificate shall contain all the DNS names of NAFs that may send a request for NAF specific shared secret through the Zn-Proxy to the subscriber's home BSF. If a new NAF is added, the new DNS name is either covered in the certificate by using the wildcard character approach (e.g. \"*.operator.com\"), or a new dNSName name needs to be added to the certificate. In the latter case, new certificate is needed for the Zn-Proxy.\n\nAn authentication framework for TLS is available [19].\nThis annex describes the UICC-ME interface to be used when a GBA_U aware UICC application is active and the ME is involved in a GBA bootstrapping procedure. When the UICC application is not GBA_U aware, the ME uses AUTHENTICATE command in non-GBA_U security context (i.e. UMTS security context in case of USIM application and IMS security context in case of the ISIM) as defined in TS 31.102 [1] and TS 31.103 [10].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "G.1\tGBA_U Bootstrapping procedure",
            "description": "This procedure is part of the Bootstrapping procedure as described in clause 5.3.2.\nThe ME sends RAND and AUTN to the UICC, which performs the Ks derivation as described in clause 5.3.2.\nThe UICC then stores Ks. The UICC also stores the used  to identify the current bootstrapped values.  value in the UICC shall be further accessible by the ME.\nThe ME then finalizes the Bootstrapping procedure and stores in the UICC the Transaction Identifier (B-TID) and Key Life Time associated with the previous bootstrapped keys (i.e. Ks). Transaction Identifier and Key Life Time values in the UICC shall be further accessible by the ME.\nAt the end of the GBA_U bootstrapping procedure the UICC stores Ks, Transaction Identifier, Key Life Time and the .\nThe UICC sends RES to the ME.\nA new bootstrapping procedure replaces Ks, B-TID, Key LifeTime and  values of the previous bootstrapping procedure.\nThe figure depicts the GBA_U Bootstrap Procedure, which is a crucial step in the network's bootstrapping process. It involves the creation of a new network segment, known as a GBA, which is used to connect the network to the Internet. The figure illustrates the steps involved in the procedure, including the creation of a new network segment, the establishment of a new IP address, and the establishment of a new subnet. The figure also shows the creation of a new network interface, which is used to connect the new segment to the Internet. The figure is important for understanding the network's bootstrapping process and ensuring that the network is properly connected to the Internet.\nFigure G.1: GBA_U Bootstrap Procedure\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "G.2\tGBA_U NAF Derivation procedure",
            "description": "This procedure is part of the Procedures using bootstrapped Security Association as described in clause 5.3.3\nThe ME sends NAF_ID and IMPI to the UICC. The UICC then performs Ks_ext_NAF and Ks_int_NAF derivation as described in clause 5.3.2. The UICC uses the  and Ks values stored from the previous bootstrapping procedure. The UICC returns Ks_ext_NAF to the ME and stores Ks_int_NAF and associated B-TID together with NAF_Id.\nIn case that the UICC does not have enough storage available for the generated Ks_int_NAF and associated parameters, the UICC shall overwrite an existing Ks_int_NAF entry (Ks_int_NAF and associated parameters). To determine the Ks_int_NAF to overwrite, the UICC shall construct a list of Ks_int_NAF entry numbers by storing in the list first position the entry number of the last used or derived Ks_int_NAF and by shifting down the remaining list elements. The last Ks_int_NAF entry number in this list corresponds to the Ks_int_NAF to overwrite when the UICC runs out of free records.\nIf an existing Ks_int_NAF entry in use is overwritten, the application Ks_int_NAF shall not be affected (e.g. in case a Ks_int_NAF was put into use as an MBMS MUK key, the MUK key shall continue to be available for the MBMS application).\nNOTE:\tA previous GBA_U Bootstrap needs to be undertaken before. If Ks is not available in the UICC, the command will answer with the appropriate error message.\nThe input parameters IMPI and the FQDN part of NAF_ID shall be encoded as specified Annex B.2.1.\nThe figure depicts the GBA_U NAF derivation procedure, which is a crucial step in the network architecture of 5G networks. The figure illustrates the derivation of the NAF (Network Access Function) from the GBA (Giga-Billion-Aperture Network) in 5G networks. The NAF is a key component in 5G networks, responsible for delivering high-speed data services to users. The figure shows the steps involved in the derivation process, including the selection of the NAF, the calculation of the NAF, and the generation of the NAF. The figure is crucial for understanding the 5G network architecture and the NAF derivation process.\nFigure G.2: GBA_U NAF derivation procedure\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "H.1\tDefinition",
            "description": "The Ua security protocol identifier is a string of five octets. The first octet denotes the organization which specifies the Ua security protocol. The four remaining octets denote a specific security protocol within the responsibility of the organization.\nFor all Ua protocols specified by 3GPP this Annex shall contain a complete list of these protocols. For Ua protocols specified by other organizations this Annex shall only specify the organization octet of the Ua security protocol identifier. Two organization octets are reserved for special use.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "H.2\tOrganization Octet",
            "description": "The organization octet denotes the organization specifying the particular protocol. Each organization intending to specify a Ua security protocol identifier shall apply to 3GPP to receive an organization octet value, which shall be registered within this Annex. Following is a list of registered organization octets:\n\"0x00\" as first octet is the default value for protocols not specified otherwise. When octet \"0x00\" is used as first octet, only Ua security protocol identifier ( 0x00,0x00,0x00,0x00,0x00 ) shall be used.\nNOTE 1:\tAll protocols having this Ua security protocol identifier cannot be separated from each other.\n\"0x01\" .. \"0xFE\" as the first octet denote organizations specifying Ua security protocol identifiers.\n\"0xFF\" as the first octet denotes the private range of Ua security protocol identifiers.\nNOTE 2:\tidentifiers with \"0xFF\" as first octet may be used for defining local/experimental protocols without need for registration. When using such an identifier, however, it may happen that a security breach in one security protocol over Ua can be exploited by an attacker to mount successful attacks on a different security protocol over Ua.\nThe following values for organizations are assigned:\n\"0x01\"\t3GPP\nNOTE 3:\tAll protocols having the organization octet \"0x01\" are specified in annex H.3.\n\"0x02\"\t3GPP2\n\"0x03\"\tOpen Mobile\n\"0x04\"\tGSMA\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "H.3\tUa security protocol identifiers for 3GPP specified protocols",
            "description": "The following Ua security protocol identifiers are specified by 3GPP:\n( 0x01,0x00,0x00,0x00,0x00 )\t\tUa security protocol according to TS 33.221 [5].\n( 0x01,0x00,0x00,0x00,0x01 )\t\tUa security protocols according to TS 33.246 [26].\nNOTE 1:\tTS 33.246 [26] provides key separation between the keys that are used within HTTP digest and MIKEY protocols.\n( 0x01,0x00,0x00,0x00,0x02) \tUa security protocol HTTP digest authentication according to TS 24.109 [29], unless HTTP digest authentication is used in the context of another Ua security protocol, which is already covered elsewhere in this Annex.\n( 0x01,0x00,0x00,0x00,0x03 )\tUa security protocols used with HTTP-based security procedures for MBMS user services according to TS 26.237 [38].\n( 0x01,0x00,0x00,0x00,0x04 )\tUa security protocols used with SIP-based security procedures for MBMS user services according to TS 26.237 [38].\n( 0x01,0x00,0x00,0x00,0x05 )\tUa security protocols used with Generic Push Layer according to TS 33.224 [39], unless Generic Push Layer is used in the context of another Ua security protocol, which is already covered elsewhere in this Annex.\n( 0x01,0x00,0x00,0x00,0x06 )\tUa security protocol for IMS UE to KMS  http based message exchanges according  to \"IMS media plane security\", TS 33.328 [40]\n( 0x01,0x00,0x00,0x00,0x07 )\t\tUa security protocol for shared key TLS 1.3 given in clause 5.4.0.2 of TS 33.222 [25]\n( 0x01,0x00,0x00,0x00,0x08 )\tUa security protocol for OSCORE according to Annex P.\n( 0x01,0x00,0x00,0x00,0x09 )\t\tUa security protocol for DTLS according to Annex O.\n( 0x01,0x00,0x00, 0x01,0x00 ) \t\tGeneration of TMPI according to Annex B.4.\nNOTE 2:\tThis protocol identifier is not strictly a Ua protocol identifier, but its use in key derivation function is exactly equal.to a Ua protocol identifier.\n( 0x01,0x00,0x01,yy,zz )\tUa security protocol for \"Shared key-based UE authentication with certificate-based NAF authentication\", according to TS 33.222 [25] section 5.3, or \"Shared key-based mutual authentication between UE and NAF\" for TLS 1.2 (see above for Ua security protocol identifier for TLS 1.3 with shared keys), according to TS 33.222 [25] section 5.4.0.1. Here, \"yy,zz\" is the protection mechanism CipherSuite code according to the defined values for TLS CipherSuites in the IANA TLS Cipher Suite Registry which is referenced in RFC 8446 [59].\nNOTE 3: \tThe \"Certificate based mutual authentication between UE and NAF” according to TS 33.222 [25] section 5.5 does not require a Ua protocol identifier.\n\nNOTE 4:\tAs an example: The TLS 1.2 CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 has code = { 0xC0,0x2B  }, thus the according protocol identifier shall be ( 0x01,0x00,0x01, 0xC0,0x2B  ).\n( 0x01,0x00,0x02,yy,zz ) \tUa security protocol for \"Shared key-based UE authentication with certificate-based NAF authentication\", according to TS 33.222 [25] Annex D. Here, \"yy,zz\" is the protection mechanism CipherSuite code according to the defined values for TLS CipherSuites in the IANA TLS Cipher Suite Registry which is referenced in RFC 8446 [59]. This Ua security protocol identifier is used for the case outlined in TS 33.222 [5] Annex D, where e.g.  HTML FORM based authentication is used within a TLS tunnel.\nNOTE 4: \tThe third octet (0x02) distinguish this case from other protocols tunneled inside the TLS tunnel.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "I.0\tIntroduction",
            "description": "This annex specifies the implementation option to allow the use of SIM cards or SIMs on UICC for GBA. The procedure specified in this annex is called 2G GBA. 2G GBA allows access to applications in a more secure way than would be possible with the use of passwords or with GSM without enhancements. It may be useful for operators who have not yet fully deployed USIMs.\nThe usage of the term 2G GBA in this specification does not restrict the usage of GBA over only 2G access networks i.e. GSM access. Similarly the use of the term 3G GBA in this specification does not restrict the usage of GBA over only 3G access networks i.e. UMTS. In this specification the term 2G GBA refers to the usage of a SIM card or SIM on UICC, while 3G GBA or GBA on its own, refers and to the usage of a USIM/ISIM on a UICC.\nClauses 4 and 5 of the present document do not apply to this annex unless explicitly stated.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "I.1\tReference model",
            "description": "The reference model is the same as described in section 4.1.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "I.2\tNetwork elements",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "I.2.1\tBootstrapping server function (BSF)",
                    "description": "",
                    "summary": "",
                    "text_content": "A generic Bootstrapping Server Function (BSF) and the UE shall mutually authenticate using the 2G AKA protocol and the TLS protocol, and agree on session keys that are afterwards applied between UE and a Network Application Function (NAF). The BSF shall restrict the applicability of the key material to a specific NAF by using the key derivation procedure as specified in Annex B. The key derivation procedure may be used with multiple NAFs during the lifetime of the key material. The lifetime of the key material is set according to the local policy of the BSF. The generation of key material is specified in clause I.5.2.\nThe BSF shall be able to acquire the GBA user security settings (GUSS) from the HSS.\nThe BSF shall be able to discover from the type of authentication vectors sent by the HSS whether the subscriber is a 2G or a 3G subscriber.\nThe BSF shall be able to keep a list, which assigns NAFs to NAF Groups. This list is used to select if any and which application-specific USS within GUSS is valid for a certain NAF.\nNOTE 1:\tThe operator does the assignment of NAFs to NAF Groups. NAF Group definitions in HSS and all connected BSFs belonging to the same operator's network shall be equal (cf., clause I.2.3). As these network elements belong to the same operator's network, standardisation of the NAF Group definitions themselves is not necessary in 3GPP.\nNOTE 2:\tThe NAF grouping may be e.g. \"home\" and \"visited\". It allows the BSF to send USSs for the same application with e.g. different authorization flags to different NAFs, e.g., in home network and visited networks. The NAF e.g. in visited network indicates only the requested application, but it is unaware of the grouping in home network of the subscriber.\nNOTE 3:\tIf support of GBA User Security Settings (GUSS) for service differentiation is desired in combination with HLR, then this can be achieved by addition of a database to the BSF containing the needed GUSS information.\nThe BSF shall allow the operator to configure a BSF policy whether to accept 2G subscribers or not for a certain NAF.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.2.2\tNetwork application function (NAF)",
                    "description": "",
                    "summary": "",
                    "text_content": "After the bootstrapping has been completed, the UE and a NAF can run some application specific protocol where the authentication of messages will be based on those session keys generated during the mutual authentication between UE and BSF.\nGeneral assumptions for the functionality of a NAF are:\n-\tthere need not be a previous security association between the UE and the NAF;\n-\tNAF shall be able to locate and communicate securely with the subscriber's BSF;\n-\tNAF shall be able to acquire a shared key material established between UE and the BSF during the run of the application-specific protocol;\n-\tNAF shall be able to acquire zero or more application-specific USSs from the HSS via the BSF;\n-\tNAF shall be able to set the local validity condition of the shared key material according to the local policy;\n-\tNAF shall be able to check lifetime and local validity condition of the shared key material;\n-\tNAF shall have a policy whether to accept 2G subscribers. However, whether the SIM card is allowed to be used with a specific Ua application or not, is dependent on the relevant Ua application. If there is a specific TS for an application using a particular Ua protocol, and unless this TS explicitly prohibits the use of SIM, the operator is allowed to configure a NAF policy whether to accept 2G subscribers or not for this Ua application.\nNOTE:\tWithout additional measures, GBA does not guarantee the freshness of the key, Ks(_int/ext)_NAF in the sense that it does not guarantee that the key was not used in a previous run of the Ua protocol. The additional measures which may be taken by the UE and the NAF to ensure key freshness in GBA are:\n1)\tenforce a new run of the Ub protocol (thus generating a new Ks) before deriving a new Ks_NAF.\n2)\tstore previously used keys Ks(_int/ext)_NAF, or the corresponding key identifiers B-TID, until the end of their lifetime.\nA UE and a NAF that support a Ua protocol that does not provide replay protection over unconnected runs of the protocol, will need to take corresponding action to avoid replay attacks if desired.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.2.2a\tZn-Proxy",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from section 4.2.2a applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.2.3\tHSS",
                    "description": "",
                    "summary": "",
                    "text_content": "The set of all user security settings (USSs), i.e. GUSS, is stored in the HSS.\nThe requirements on the HSS are:\n-\tHSS shall provide the only persistent storage for GUSSs;\n-\tGUSS shall be defined in such a way that interworking of different operators for standardised application profiles is possible;\n-\tGUSS shall be defined in such a way that profiles for operator specific applications and extensions to existing application profiles are supported without need for standardisation of these elements.\n-\tGUSS shall be able to contain application-specific USSs that contain parameters that are related to identification or authorization information of one or more applications hosted by one ore more NAFs. Any other types of parameters are not allowed in the application-specific USS.\nNOTE 1:\tThe necessary subscriber profile data may be fetched by the NAF from its local database.\nNOTE 2:\tOne possibility to revoke temporarily an application specific USS from the GUSS is that the HSS may temporarily remove an application-specific USS from the GUSS if the service is temporarily revoked from the subscriber. The GUSS in the BSF is not changed by this operation and only updated when the existing bootstrapping session times out, or is overwritten by a new bootstrapping session during which the new modified GUSS is fetched from HSS along with the AV.\n-\tGUSS shall be able to contain parameters intended for the BSF usage:\n-\tsubscriber specific key lifetime;\n-\toptionally the timestamp indicating the time when the GUSS has been last modified by the HSS.\nNOTE 3:\tThese parameters are optional and if they are missing from subscriber's GUSS or subscriber does not have GUSS then the BSF will use the default values in the BSF local policy defined by the particular MNO.\n-\tHSS shall be able to assign application-specific USSs to a NAF Group. This shall be defined in such a way that different USSs for the same application, but for different groups of NAFs, are possible. The restrictions on the number of USSs per GUSS are dependent on the usage of NAF Groups by the operator:\n-\tif no NAF Groups are defined for this application then at most one USS per application is stored in GUSS;\n-\tif NAF Groups are defined for this application then at most one USS per application and NAF Group is stored in GUSS.\n-\tNAF Group definitions in the HSS and all connected BSFs belonging to the same operator's network shall be equal.\n-\tInformation on UICC type and on key choice are not required for 2G subscribers. 2G GBA is regarded as ME-based.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.2.4\tUE",
                    "description": "",
                    "summary": "",
                    "text_content": "The required functionalities from the UE are:\n-\tthe support of HTTP Digest AKA protocol;\n-\tthe support of TLS;\n-\tthe capability to use a SIM in bootstrapping;\n-\tthe capability for a Ua application on the ME to indicate to the GBA Function on the ME whether a SIM is allowed for use in bootstrapping (see clause I.4.8);\n-\tthe capability to derive new key material to be used with the protocol over Ua interface from Kc, , SRES and Ks-input;\n-\tsupport of NAF-specific application protocol (For an example see TS 33.221 [5]).\nA 2G GBA-aware ME shall support both 3G GBA_U, as specified in clause 5.2 and 3G GBA_ME procedures, as specified in clause 4.5.\nThe security of2G GBA relies on that the ME hasimplemented the following properties:\n-\tThe ME sets each fill bit it sends to a random value, in accordance with clause 5.2 of TS 44.006 [46].\nNOTE: This requirement is fulfilled by MEs from Rel-8 onwards.\n-\tThe ME does not implement GEA1, in accordance with clause D.4.9 of TS 43.020 [47].\nNOTE: This requirement is fulfilled by MEs from Rel-12 onwards.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.2.5\tSLF",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from section 4.2.5 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.2.6\tHLR",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirement on the HLR is the same as in clause 4.3.6.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "I.3\tBootstrapping architecture and reference points",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "I.3.1\tReference point Ub",
                    "description": "",
                    "summary": "",
                    "text_content": "The reference point Ub is between the UE and the BSF. Reference point Ub provides mutual authentication between the UE and the BSF. It allows the UE to bootstrap the session keys based on 2G AKA infrastructure.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.3.2\tReference point Ua",
                    "description": "",
                    "summary": "",
                    "text_content": "The reference point Ua carries the application protocol, which is secured using the keys material agreed between UE and BSF as a result of the run of the protocol over reference point Ub.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.3.3\tReference point Zh",
                    "description": "",
                    "summary": "",
                    "text_content": "The reference point Zh used between the BSF and the HSS allows the BSF to fetch the required authentication information and all GBA user security settings from the HSS. The reference point Zh is an intra-operator domain interface. The interface to the 2G Authentication Centre is HSS-internal, and it need not be standardised as part of this architecture.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.3.4\tReference point Zn",
                    "description": "",
                    "summary": "",
                    "text_content": "The reference point Zn is used by the NAF to fetch the key material agreed during a previous protocol run over the reference point Ub from the UE to the BSF. It is also used to fetch application-specific user security settings from the BSF, if requested by the NAF.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.3.5\tReference point Dz",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from section 4.3.5 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.3.6\tReference point Zh'",
                    "description": "",
                    "summary": "",
                    "text_content": "The optional reference point Zh' used between the BSF and the HLR allows the BSF to fetch the required authentication information. The reference point Zh' is an intra-operator domain interface.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "I.4\tRequirements and principles for bootstrapping",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "I.4.0\tGeneral requirements",
                    "description": "",
                    "summary": "",
                    "text_content": "The following requirements and principles are applicable to bootstrapping procedure:\n-\tthe 2G GBA bootstrapping function shall not depend on the particular NAF;\n-\tthe server implementing the bootstrapping function needs to be trusted by the home operator to handle authentication vectors;\n-\tthe server implementing the NAF needs only to be trusted by the home operator to handle derived key material;\n-\tit shall be possible to support NAF in the operator's home network and in the visited network;\n-\tthe architecture shall not preclude the support of network application function in a third network;\n-\tto the extent possible, existing protocols and infrastructure should be reused;\n-\tin order to ensure wide applicability, all involved protocols are preferred to run over IP;\n-\tit shall be prevented that a security breach in one NAF who is using the GBA, can be used by an attacker to mount successful attacks to the other NAFs using the GBA.\n-\tan attacker shall not be able to exploit a security breach in one security protocol over Ua in order to mount a successful attack against a different security protocol over Ua.\n- \tExisting SIM cards or SIMs on UICCs and their specifications shall not be impacted.\n- \tIf USIM or ISIM are available they shall be used as specified in sections 4 and 5, and 2G GBA shall not be used.\n- \t2G GBA shall not impact the USIM / ISIM based GBA as specified in sections 4 and 5.\n- \t2G GBA shall not reduce security for USIM / ISIM users.\n- \t2G GBA shall minimise the changes to the USIM / ISIM based GBA specified in section 4.\n- \t2G GBA shall provide measures to mitigate known vulnerabilities of GSM.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.1\tAccess",
                    "description": "",
                    "summary": "",
                    "text_content": "Bootstrapping procedure is access independent. Bootstrapping procedure requires IP connectivity from UE.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.2\tAuthentication methods",
                    "description": "",
                    "summary": "",
                    "text_content": "Authentication between the UE and the BSF shall not be possible without a valid cellular subscription. Authentication shall be based on the GSM authentication (also called 2G AKA) protocol. BSF authentication shall in addition be based on TLS with server certificates.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.3\tRoaming",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from section 4.4.3 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.4\tRequirements on reference point Ub",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements for reference point Ub are:\n-\tthe BSF shall be able to identify the UE;\n-\tthe BSF and the UE shall be able to authenticate each other based on the methods in I.4.2;\n-\tthe BSF shall be able to send a bootstrapping transaction identifier to the UE;\n-\tthe UE and the BSF shall establish shared keys;\n-\tthe BSF shall be able to indicate to the UE the lifetime of the key material. The key lifetime sent by the BSF over Ub shall indicate the expiry time of the key.\nNOTE:\tThis does not preclude a UE to refresh the key before the expiry time according to the UE's local policy.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.5\tRequirements on reference point Zh",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements for reference point Zh are:\n-\tmutual authentication, confidentiality and integrity shall be provided;\nNOTE 1:\tThis requirement may be fulfilled by physical or proprietary security measures since BSF and HSS are located within the same operator's network.\n-\tthe BSF shall be able to send bootstrapping information request concerning a subscriber;\n-\toptionally the BSF may have the capability able to send the timestamp of subscriber's GBA user security settings to the HSS (timestamp option);\n-\tthe HSS shall be able to send one 2G AKA vector at a time to the BSF;\n-\tthe HSS shall be able to send the complete set of subscriber's GBA user security settings needed for security purposes to the BSF. Optionally the HSS may have the capability to indicate to the BSF whether the BSF already has the latest copy of the GUSS based on the GUSS timestamp (timestamp option);\nNOTE 2:\tIf subscriber's GUSS is updated in HSS, this is not propagated to the BSF. The GUSS in the BSF is updated when the BSF next time fetches the authentication vectors and GUSS from the HSS over Zh reference point as part of the bootstrapping procedure.\n-\tno state information concerning bootstrapping shall be required in the HSS;\n-\tall procedures over reference point Zh shall be initiated by the BSF;\n-\tthe number of different interfaces to HSS should be minimized.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.6\tRequirements on reference point Zn",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements for reference point Zn are:\n-\tmutual authentication, confidentiality and integrity shall be provided;\n-\tIf the BSF and the NAF are located within the same operator's network, the DIAMETER based Zn reference point shall be secured according to NDS/IP [13];\n-\tIf the BSF and the NAF are located in different operators' networks, the DIAMETER based Zn' reference point between the Zn-Proxy and the BSF shall be secured using TLS as specified in Annex E of the present document;\n-\tAn HTTP based Zn/Zn' reference point shall be secured using TLS as specified in Annex E of the present document;\n-\tThe BSF shall verify that the requesting NAF is authorised to obtain the key material or the key material and the requested USS;\n-\tThe NAF shall be able to send a key material request to the BSF, containing NAF's public hostname used by the UE's corresponding request. The BSF shall be able to verify that a NAF is authorized to use this hostname, i.e. the FQDN used by UE when it contacts the NAF;\n-\tThe BSF shall be able to send the requested key material to the NAF;\n-\tThe NAF shall be able to get a selected set of application-specific USSs from the BSF, depending on the policy of the BSF and the application indicated in the request from the NAF over Zn;\n-\tThe NAF shall be able to indicate to the BSF the single application or several applications it requires USSs for;\nNOTE 2:\tIf some application needs only a subset of an application-specific USS the NAF selects this subset from the complete set of USS sent from BSF.\n-\tThe BSF shall be able to be configured on a per NAF or per application basis if private subscriber identity and which application-specific USSs may be sent to a NAF;\nNOTE 3:\tPrivacy issues need be considered when determining which user identifier is sent to the NAF. If service continuity is desired, then the BSF can be configured to send the IMPI (but then there is no user anonymity). If the BSF does not send the IMPI or IMPU / pseudonym in the USS, then the user remains anonymous towards the NAF; or more precisely, the B-TID functions as a temporary user identifier. This can cause that the NAF cannot provide a continuous service, since a user identity is needed in the NAF to ensure that the NAF is able to update keys for a Ua session when the UE has bootstrapped and contacts the NAF with a new B-TID. If user privacy is desired, the NAF can requests a USS and the BSF is configured to send a user pseum in the USS, but not the IMPI.\n-\tIf a NAF requests USSs from the BSF and they are not present in subscriber's GUSS, it shall not cause an error, provided the conditions of the local policy of the BSF are fulfilled. The BSF shall then send only the requested and found USSs to the NAF;\n-\tIt shall be possible to configure a local policy as follows: BSF may require one or more application-specific USS to be present in a particular subscriber's GUSS for a particular requesting NAF, and to reject the request from the NAF in case the conditions are not fulfilled. In order to satisfy this local policy, it is not required that the NAF requests the USSs over the Zn reference point, which the BSF requires to be present in the GUSS, rather it is sufficient that the BSF checks the presence of the USSs locally. It shall also be possible configure the BSF in such a way that no USS is required for the requesting NAF;\n-\tThe BSF shall be able to indicate to the NAF the bootstrapping time and the lifetime of the key material. The key lifetime sent by the BSF over Zn shall indicate the expiry time of the key, and shall be identical to the key lifetime sent by the BSF to the UE over Ub.\nNOTE 4:\tThis does not preclude a NAF to refresh the key before the expiry time according to the NAF's local policy.\nNOTE 5:\tIf one or more of the USSs that have been delivered to the NAF has been updated in subscriber's GUSS in the HSS, this change is propagated to the NAF the next time it fetches the USS from the BSF over Zn reference point (provided that the BSF has updated subscriber's GUSS from the HSS over Zh reference point).\n-\tThe BSF shall send information to the NAF that the subscriber is a 2G subscriber. If no such information is sent the NAF shall assume that the subscriber is a 3G subscriber.\nNOTE 6: This requirement enables a NAF to accept 2G subscribers according to its local policy. The second sentence ensures backward compatibility with the procedures specified in section 4 and 5 of this specification. Note also that inclusion of information on the type of subscription in the GUSS would not suffice to satisfy this requirement as a GUSS need not be present for every subscriber.\n-\tThe BSF may determine according to its local policy that the NAF shall not serve 2G subscribers. If this is the case, the BSF does not send keys to the NAF.\nNOTE 7:\tThis requirement allows an operator controlling the BSF to determine which applications shall use 3G security only. This requirement is also necessary for NAFs, which are not capable to evaluate the information about the subscription type sent by the BSF, e.g. pre-release 7 NAFs.\n-\tNAF shall be able to indicate to BSF the protocol identifier of Ua security protocol it requires the key material by sending NAF-Id to BSF (cf. Annex H).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.7\tRequirements on Bootstrapping Transaction Identifier",
                    "description": "",
                    "summary": "",
                    "text_content": "Bootstrapping transaction identifier (B-TID) shall be used to bind the subscriber identity to the keying material in reference points Ua, Ub and Zn.\nRequirements for B-TID are:\n-\tB-TID shall be globally unique;\n-\tB-TID shall be usable as a key identifier in protocols used in the reference point Ua;\n-\tNAF shall be able to detect the home network and the BSF of the UE from the B-TID.\nNOTE 1:\tNAF can remove the security association based on deletion conditions after the key has become invalid.\nNOTE 2:\tCare has to be taken that the parallel use of GBA and non-GBA authentication between UE and NAF does not lead to conflicts, e.g. in the name space. This potential conflict cannot be resolved in a generic way as it is dependent on specific protocol and authentication mechanism used between UE and application server. It is therefore out of scope of this specification.\nFor the example of HTTP Digest authentication used between UE and NAF, parallel use is possible as the following applies: <username,password>-pairs must be unique to one realm only. As the NAF controls the realm names, it has to ensure that only the GBA based realm is named with the reserved 3GPP realm name. In the special case that the NAF wants to allow non GBA based authentication in the GBA realm also, it has to ensure that no usernames in the format of a B-TID are used outside GBA based authentication.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.8\tRequirements on selection of UICC application and SIM card",
                    "description": "",
                    "summary": "",
                    "text_content": "If a UICC is present in the UE, containing a USIM or an ISIM, then a USIM or ISIM shall be used as specified in section 4.4.8. Otherwise a SIM shall be used.\nIf no UICC, but a SIM card is present in the UE, the SIM card shall be used. The IMPI is obtained from the IMSI as specified in section 4.4.8.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.9\tRequirements on reference point Ua",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from section 4.4.9 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.10\tRequirements on reference point Dz",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from section 4.4.10 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.4.11\tRequirements on reference point Zh'",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements for reference point Zh' are the same as in clause 4.4.12.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "I.5\tProcedures",
            "description": "This chapter specifies in detail the format of the 2G GBA bootstrapping procedure that is further utilized by various applications. It contains the authentication procedure with BSF, and the key material generation procedure.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "I.5.1\tInitiation of bootstrapping",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from clause 4.5.1 of the present document applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.5.2\tBootstrapping procedures",
                    "description": "",
                    "summary": "",
                    "text_content": "When a UE wants to interact with a NAF, and it knows that the bootstrapping procedure is needed, it shall first perform a bootstrapping authentication (see figure I.3). Otherwise, the UE shall perform a bootstrapping authentication only when it has received bootstrapping initiation required message or a bootstrapping negotiation indication from the NAF, or when the lifetime of the key in UE has expired (cf. subclause I.5.3).\nThe figure depicts the bootstrapping procedure, which is a crucial step in the process of creating a new network. It illustrates the steps taken to initialize the network by connecting the base station (gNB) to the network, enabling the transmission of data. The figure shows the network's structure, including the gNB, user equipment (UE), and scatterers, which are essential components for the network's operation. The figure also highlights the use of redundancy paths to ensure the network's reliability and failover capabilities.\nFigure I.3: The bootstrapping procedure\n1.\tThe UE sets up a confidentiality-protected TLS tunnel with the BSF. In the set up of the TLS tunnel, the UE shall authenticate the BSF by means of a certificate provided by the BSF. All further communication between ME and BSF is sent through this TLS tunnel. The UE now sends an initial HTTPS request.\n2.\tThe BSF requests authentication vectors and GUSS from the HSS over Zh. The HSS returns the complete set of GBA user security settings (GUSS) and one 2G authentication vectors (AV = , SRES, Kc) over the Zh reference point. The BSF discovers that the UE is equipped with 2G SIM by looking at the type of authentication vectors.\nIf the BSF implements the timestamp option and has a local copy of the GUSS for the subscriber that has been fetched from the HSS during a previous bootstrapping procedure, and this GUSS includes a timestamp, the BSF may include the GUSS timestamp in the request message. Upon receiving that timestamp, if the HSS implements the timestamp option, the HSS may compare it with the timestamp of the GUSS stored in the HSS. In this case, if and only if the HSS has done the comparison and the timestamps are equal, then the HSS shall send \"GUSS TIMESTAMP EQUAL\" indication to the BSF. In any other case, the HSS shall send the GUSS (if available) to the BSF. If the BSF receives \"GUSS TIMESTAMP EQUAL\" indication, it shall keep the local copy of the GUSS. In any other case, the BSF shall delete the local copy of the GUSS, and store the received GUSS (if sent).\nIn the case that no HSS with Zh reference point support is deployed, the BSF requests the authentication vector from either an HSS with Zh' reference point support or an HLR over the Zh' reference point. The HLR or HSS with Zh' reference point support returns one 2G authentication vectors (AV = , SRES, Kc) over the Zh' reference point. The BSF discovers that the UE is equipped with 2G SIM by looking at the type of authentication vectors.\nThe BSF converts one 2G authentication vector (, Kc, SRES) to the parameter RES.\nRES = KDF (key, \"3gpp-gba-res\", SRES), truncated to 128 bits\nwhere key = Kc || Kc || RAND and KDF is the key derivation function specified in Annex B of TS 33.220.\nThe BSF shall also select a 128-bit random number \"Ks-input\" and set\nserver specific data = Ks-input \nin the aka-nonce of HTTP Digest AKA, cf. [4].\nNOTE 1:\t\"Truncated to 128 bits\" means that from the 256 bits output of KDF, the 128 bits numbered as [0] to [127] are used.\nNOTE 2:\tIn a multiple HSS environment, the BSF may have to obtain the address of the HSS where the subscription of the user is stored by querying the SLF, prior to step 2.\n3.\tThe BSF shall forward  and server specific data in the 401 message to the UE (without RES). This is to demand the UE to authenticate itself.\n4.\tThe UE extracts  from the message and calculates the corresponding Kc and SRES values. It then calculates the parameter RES from these values as specified in step 2.\n5.\tThe UE sends another HTTP request, containing the Digest AKA response (calculated using RES as the password) and a cnonce (cf. RFC 9110 [61] and RFC 7616 [62]), to the BSF.\n6.\tThe BSF authenticates the UE by verifying the Digest AKA response. If the authentication fails the BSF shall not re-use the authentication vector in any further communication.\nNOTE 3:\tThe password in \"AKAv1\" HTTP Digest AKA is in binary format.\n7.\tThe BSF shall generate key material Ks by computing Ks = KDF (key, Ks-input, \"3gpp-gba-ks\", SRES).\nThe B-TID value shall be also generated in format of NAI by taking the base64 encoded [60] RAND value from step 3, and the BSF server name, i.e. base64encoded()@BSF_servers_domain_name.\nNOTE 3a:\tIf the HSS/AuC uses a good random number generator, then the chance of a B-TID collision is practically zero. If such a collision occurs, then the key retrieved by the NAF can have a mismatch with the UE generated NAF key. This will result in a Ua authentication failure which will cause the NAF to once again request the UE to bootstrap which will create a new Ks and a new B-TID.\n8.\tThe BSF shall send a 200 OK message, including a B-TID and an authentication-info header (cf. RFC 9110 [61] and RFC 7616 [62]), to the UE to indicate the success of the authentication. In addition, in the 200 OK message, the BSF shall supply the lifetime of the key Ks.\n9.\tThe UE shall abort the procedure if the server authentication according to RFC 9110 [61] and RFC 7616 [62]  fails. If it is successful the UE shall generate the key material Ks in the same way as the BSF.\n10.\tBoth the UE and the BSF shall use the Ks to derive the key material Ks_NAF for use with the procedures specified in clause I.5.3. Ks_NAF shall be used for securing the reference point Ua.\nKs_NAF is computed as Ks_NAF = KDF (Ks, \"gba-me\", RAND, IMPI, NAF_Id), where KDF is the key derivation function as specified in Annex B, and the key derivation parameters consist of the user's IMPI, the NAF_Id and RAND. The NAF_Id is constructed as follows: NAF_Id = FQDN of the NAF || Ua security protocol identifier. The Ua security protocol identifier is specified in Annex H. KDF shall be implemented in the ME.\nNOTE 4:\tIf a NAF hosts two or more applications which use the same FQDN and Ua security protocol identifier, they will share the same NAF specific keys. This causes a risk of so called two-time pad which may lead to the situation that the security of these applications is compromised. This can be avoided by running bootstrapping separately to each application or by application specific means, which are however out of the scope of the current specification.\nTo allow consistent key derivation based on NAF name in UE and BSF, at least one of the three following prerequisites shall be fulfilled:\n(1)\tThe NAF is known in DNS under one domain name (FQDN) only, i.e. no two different domain names point to the IP address of the NAF. This has to be achieved by administrative means.\n(2)\tEach DNS entry of the NAF points to a different IP address. The NAF responds to all these IP addresses. Each IP address is tied to the corresponding FQDN by NAF configuration. The NAF can see from the IP address, which FQDN to use for key derivation.\n(3)\tUa uses a protocol which transfers the host name (FQDN of NAF as used by UE) to NAF (e.g. HTTP/1.1 with mandatory Host request header field). This requires the NAF to check the validity of the host name, to use this name in all communication with UE where appropriate, and to transfer this name to BSF to allow for correct derivation of Ks_NAF.\nThe UE and the BSF shall store the key Ks with the associated B-TID for further use, until the lifetime of Ks has expired, or until the key Ks is updated or until the deletion conditions are satisfied (see 4.4.11).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.5.3\tProcedures using bootstrapped Security Association",
                    "description": "",
                    "summary": "",
                    "text_content": "Before communication between the UE and the NAF can start, the UE and the NAF first have to agree whether to use shared keys obtained by means of the GBA. If the UE does not know whether to use GBA with this NAF, it uses the Initiation of Bootstrapping procedure described in clause I.5.1.\nOnce the UE and the NAF have established that they want to use GBA then every time the UE wants to interact with an NAF the following steps are executed as depicted in figure I.4.\n1.\tUE starts communication over reference point Ua with the NAF:\n-\tin general, UE and NAF will not yet share the key(s) required to protect the reference point Ua. If they already do (i.e. if a key Ks_NAF for the corresponding key derivation parameter NAF_Id is already available), the UE and the NAF can start to securely communicate right away. If the UE and the NAF do not yet share a key, the UE proceeds as follows:\n-\tif a key Ks for the selected UICC application is available in the UE, the UE derives the key Ks_NAF from Ks, as specified in clause I.5.2;\n-\tif no key Ks for the selected UICC application is available in the UE, the UE first agrees on a new key Ks with the BSF over the reference point Ub, and then proceeds to derive Ks_NAF;\nIf it is not desired by the UE to use the same Ks for the selected UICC application to derive more than one Ks_NAF then the UE should agree on a new key Ks with the BSF over the reference point Ub, and then proceed to derive Ks_NAF;\n-\tif the NAF shares a key with the UE, but the NAF requires an update of that key, e.g. because the key's lifetime has expired or will expire soon, or the key can not meet the NAF local validity condition, it shall send a suitable bootstrapping renegotiation request to the UE, see figure I.5. If the key's lifetime has expired the protocol used over reference point Ua shall be terminated. The form of this indication depends on the particular protocol used over reference point Ua. If the UE receives a bootstrapping renegotiation request, it starts a run of the protocol over reference point Ub, as specified in clause I.5.2, in order to obtain a new key Ks.\nTo allow for consistent key derivation in BSF and UE, both have to use the same FQDN for derivation (see clause I.5.2). For each protocol used over Ua it shall be specified if only cases (1) and (2) of clause I.5.2 are allowed for the NAF or if the protocol used over Ua shall transfer also the FQDN used for key derivation by UE to NAF.\nNOTE 1:\tIf the shared key between UE and NAF is invalid, the NAF can set deletion conditions to the corresponding security association for subsequent removal.\n-\tthe UE supplies the B-TID to the NAF, in the form as specified in clause I.3.2, to allow the NAF to retrieve the corresponding keys from the BSF;\nNOTE 2:\tThe UE may adapt the key material Ks_NAF to the specific needs of the reference point Ua. This adaptation is outside the scope of this specification.\n-\tthe key management procedures for GBA related keys in the ME (i.e. Ks and Ks_NAF keys) are described in section 4.4.11.\n-\twhen a new Ks is agreed over the reference point Ub and a key Ks_NAF, derived from one NAF_Id, is updated, the other keys Ks_NAF, derived from different values NAF_Id, stored on the UE shall not be affected;\nAccording to the procedures defined in clauses I.5.2 and I.5.3, in the UE there is at most one Ks_NAF key stored per NAF-Id.\n2.\tNAF starts communication over reference point Zn with BSF\n-\tThe NAF requests key material corresponding to the B-TID supplied by the UE to the NAF over reference point Ua.;\n-\tThe NAF may also request one or more application-specific USSs for the applications, which the request received over Ua from UE may access;\nNOTE 3: \tIf the NAF requires service continuity, then the NAF can request a USS that contains a user pseum that allows service continuity according to BSF policy.\n-\tWith the key material request, the NAF shall supply a NAF-Id (which includes the NAF's FQDN that the UE has used to access this NAF and the Ua security protocol identifier) to the BSF. (This is to allow for consistent key derivation in the BSF and UE as described above). The BSF shall verify that the NAF is authorized to use that FQDN.\n3.\tThe BSF derives the keys required to protect the protocol used over reference point Ua from the key Ks and the key derivation parameters, as specified in clause I.5.2, and supplies to NAF the requested key Ks_NAF, as well as the bootstrapping time and the lifetime of that key, and the requested application-specific and potentially NAF group specific USSs if they are available in subscriber's GUSS and if the NAF is authorized to receive the requested USSs. For any USSs containing a NAF Group attribute, this attribute shall be removed in the USSs supplied to the NAF. In addition, the BSF shall indicate to the NAF that the subscriber is a 2G subscriber. If the key identified by the B-TID supplied by the NAF is not available at the BSF, the BSF shall indicate this in the reply to the NAF. The NAF then indicates a bootstrapping renegotiation request to the UE.\nNOTE 4:\tThe NAF can further set the local validity condition of the Ks_NAF according to the local policy, for example a limitation of reuse times of a Ks_NAF.\nNOTE 5:\tThe NAF will adapt the key material Ks_NAF to the specific needs of the reference point Ua in the same way as the UE did. This adaptation is outside the scope of this specification.\n-\tThe BSF may require that one or more application-specific and potentially NAF group specific USSs shall be present in subscriber's GUSS for the NAF (see clause I.4.6). If one or more of these required settings are missing from the GUSS, the BSF shall indicate this in the reply to the NAF.\n-\tThe BSF may also send the private user identity (IMPI) and requested USSs to NAF according to the BSF's policy;\n- \tIf the BSF or the NAF determined, according to their local policies, that the NAF shall not serve 2G subscribers, the NAF shall terminate the protocol over the reference point Ua.\n-\tWhen the NAF receives the Zn response, it shall check that the GBA type in the Zn response corresponds with the GBA type negotiated over Ua protocol. If this is not the case, NAF shall terminate the protocol over the reference point Ua.\n4.\tNAF continues with the protocol used over the reference point Ua with the UE.\nOnce the run of the protocol used over reference point Ua is completed the purpose of bootstrapping is fulfilled as it enabled UE and NAF to use reference point Ua in a secure way.\nThe figure depicts the bootstrapping usage procedure, which is a crucial step in the process of creating a new network. It illustrates the steps taken to initialize the network by connecting the initial nodes and establishing a connection between them. The figure shows the network's topology, including the nodes, their connections, and the network's structure. This figure is essential for understanding the network's initial configuration and the steps required to establish a connection between the nodes.\nFigure I.4: The bootstrapping usage procedure\nThe figure depicts a bootstrapping renegotiation request, which is a crucial step in the process of network reconfiguration. The request is initiated by the network administrator to update the network configuration to improve performance or address network issues. The figure illustrates the process of the request being sent to the network control plane, where it is processed and executed. The request is then sent to the network's hardware, which then performs the necessary changes to the network's configuration. The figure provides a visual representation of the network's configuration management process, highlighting the importance of this step in maintaining network stability and performance.\nFigure I.5: Bootstrapping renegotiation request\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.5.4\tProcedure related to service discovery",
                    "description": "",
                    "summary": "",
                    "text_content": "The UE shall discover the address of the BSF from the IMSI on the SIM. The same discovery procedure as specified in Section 4.5.4 shall be used.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "I.6\tTLS Profile",
            "description": "The UE and the BSF shall support TLS according to the TLS profile given in TS 33.310 [19], Annex E. The only difference is that TLS cipher suites without encryption shall not be used.\nThe certificates shall comply with the requirements for TLS certificates in clause 6.1 of TS 33.310 [19].\nSupport of certificate revocation and of the related fields in certificates is optional. If supported, the certificate and CRL profiles in clause 6.1 and 6.1a of TS 33.310 [19] should be followed.\nNOTE 1:\tThe management of Root Certificates is out of scope of this Technical Specification.\nNOTE 2:\tIf no revocation of certificates is deployed, it should be noted, however, that choosing short lifetimes for BSF certificates may considerably reduce the risk, in case BSF certificates may ever be compromised.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "I.6.1\tvoid",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.6.2\tAuthentication of the BSF",
                    "description": "",
                    "summary": "",
                    "text_content": "The Client shall authenticate the BSF by use of a server certificate. The client shall match the server name as specified in RFC 2818 [18] section 3.1.\nThe ME shall use a preconfigured list of trusted root certificates for 2G GBA BSF server certificate validation. BSF server certificate validation shall not require manual user interaction.\nNOTE:\tThe risk of the UE using the root certificates associated with a compromised Certification Authority (CA) can be greatly reduced when the preconfigured list of trusted root certificates is restricted to a low number of CAs trusted by the operator, as opposed to the list of all root certificates in a browser’s key store.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.6.3\tAuthentication of the UE",
                    "description": "",
                    "summary": "",
                    "text_content": "The BSF shall not request a certificate in a Server Hello Message from the UE. The BSF shall authenticate the UE as specified in clause I.5.2 of this specification.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "I.6.4\tSet-up of Security parameters",
                    "description": "",
                    "summary": "",
                    "text_content": "The TLS Handshake Protocol negotiates a session, which is identified by a Session ID. The Client and the BSF shall allow for resuming a session. The lifetime of a Session ID is subject to local policies of the UE and the BSF. A recommended lifetime is five minutes.\nNOTE:\tIf the BSF adheres to the recommended lifetime the UE can be certain to be able to resume the TLS session in case of bootstrapping re-negotiation.\nThis Annex describes how the local policy enforcement in the BSF is used between the NAF and the BSF to control the key delivery to the NAF.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "J.1\tGeneral",
            "description": "A BSF may have a local policy for zero or more NAFs where the policy for a NAF may state that subscriber's GUSS shall include one or more USSs identified by a GSID. In other words, for a particular NAF the BSF may require that one more USSs shall be present in subscriber's GUSS.\nIn general, there are two network elements where access control based on some local policy is enforced, i.e. NAF and BSF. Thus two phases with access control based on USSs have to be covered:\n1)\tAccess control within NAF for Ua requests: Whether the subscriber is allowed to access the service is decided in the NAF and possibly with the help of USSs. Upon receiving the B-TID from the UE, the NAF fetches the NAF specific shared key (Ks_(ext/int)_NAF) from the BSF, and optionally fetches the USSs, which typically contain NAF specific persistent user identities, and authorization flags. Based on a local policy in the NAF, which may include evaluating the contents of the USS, the NAF decides whether the subscriber is allowed to access the service.\n2)\tAccess control within BSF for Zn requests: In certain cases, the operator may wish to implement access control in the BSF. This functionality can be used with any NAF, but the main reason for having this is to implement home operator control in the cases where the NAF is in a visited network.\nThis Annex describes the access control case within the BSF for Zn requests in more detail.\nThe following facts should be noted on use of this Annex:\n-\tThis access control is completely local to the network of the BSF operator (i.e. home operator of subscriber). This implies that no inter-operator agreement is necessary for implementation of this access control.\n-\tThe local policies of the BSF may be based on NAF names and on NAF groups. For the sake of brevity only NAFs are mentioned in the following descriptions.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "J.2\tUsage scenarios",
            "description": "Four different scenarios can be identified how the local policy enforcement in the BSF will work:\n1)\tA NAF does not use USSs (i.e. it does not request a USS from the BSF), and the BSF does not have a local policy for this NAF.\n2)\tA NAF does not use USSs (i.e. it does not request a USS from the BSF), and the BSF does have a local policy for this NAF.\n3)\tA NAF does use USSs (i.e., it requests one or more USSs from the BSF), and the BSF does not have a local policy for this NAF.\n4)\t A NAF does use USSs (i.e., it request one or more USSs from the BSF), and the BSF does have a local policy for this NAF.\nThe steps executed in each of these scenarios are described in more detail in the following subclauses.\nIn all scenarios the NAF has received B-TID from the UE over the Ua reference point before the following steps are executed. The steps describe only the procedures that are related to the local policy enforcement in the BSF with respect to USS existence. Also transfer of other information elements not related to this access control is not mentioned (e.g. key lifetime, private subscriber identity).\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "J.2.1\tScenario 1: NAF does not use USSs, BSF does not have local policy for NAF",
                    "description": "",
                    "summary": "",
                    "text_content": "In this scenario, the NAF does not use USSs and the BSF does not have a local policy for this NAF.\n1.\tThe NAF requests the NAF specific shared key(s) from the BSF. It does not include any GSIDs in the request.\n2.\tThe BSF locates the subscriber information in its local memory using the B-TID.\n3.\tThe BSF checks whether a local policy exists for the NAF - in this scenario there is no local policy, i.e. for this particular NAF, the BSF does not require any USSs (identified by GSIDs) to be present in subscriber's GUSS.\n4.\tThe BSF derives the NAF specific shared key(s), and sends them to the NAF in the response.\n5.\tThe NAF receives the response with the NAF specific shared key(s).\nAfter receiving the NAF specific shared key(s), the NAF may perform access control to the service according to its own policies and continues to communicate with the UE.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.2.2\tScenario 2: NAF does not use USSs, BSF does have local policy for NAF",
                    "description": "",
                    "summary": "",
                    "text_content": "In this scenario, the NAF does not use USSs and the BSF does have a local policy for this NAF.\n1.\tThe NAF requests the NAF specific shared key(s) from the BSF. It does not include any GSIDs in the request.\n2.\tThe BSF locates the subscriber information in its local memory using the B-TID.\n3.\tThe BSF checks whether a local policy exists for the NAF - in this scenario there is a local policy for this NAF, i.e. for this particular NAF, the BSF does not require any USSs (identified by GSIDs) to be present in subscriber's GUSS.\nThe BSF checks whether all the required USSs identified by GSIDs are present in subscriber's GUSS: If yes, the BSF continues from step 4. If not, the BSF the BSF sends an error message to the NAF.\nNOTE:\tAs specified in clause 4.4.6, it is not required that the NAF requests the USSs over the Zn reference point, which the BSF requires to be present in the GUSS for particular NAF, rather it is sufficient that the BSF checks the presence of the USSs locally.\n4.\tThe BSF derives the NAF specific shared key(s), and sends them to the NAF in the response.\n5.\tThe NAF receives the response with the NAF specific shared key(s).\nAfter receiving the NAF specific shared key(s), the NAF may perform access control to the service according to its own policies and continues to communicate with the UE.\nIf the NAF received the \"not authorized\" error message, it may indicate this to the UE over Ua reference point. In any case, the GAA based security setup will fail between the UE and the NAF since the NAF did not get the NAF specific shared key(s).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.2.3\tScenario 3: NAF does use USSs, BSF does not have local policy for NAF",
                    "description": "",
                    "summary": "",
                    "text_content": "In this scenario, the NAF does use USSs and the BSF does not have a local policy for this NAF.\n1.\tThe NAF requests the NAF specific shared key(s) from the BSF. It includes the GSIDs it needs in the request.\n2.\tThe BSF locates the subscriber information in its local memory using the B-TID.\n3.\tThe BSF checks whether a local policy exists for the NAF - in this scenario there is no local policy, i.e. BSF does not require USSs identified by GSIDs to be present in subscriber's GUSS.\n4.\tThe BSF derives the NAF specific shared key(s), and sends them and the USSs identified by the GSIDs to the NAF in the response. If a particular USS is not found in subscriber's GUSS, or the NAF is not authorized to receive a particular USS, these USSs are omitted from the response.\n5.\tThe NAF receives the response with the NAF specific shared key(s), and those requested USSs that were available (i.e., found in subscriber's GUSS and allowed by the BSF to be received by the NAF).\nAfter receiving the NAF specific shared key(s) and the available USSs, the NAF may perform access control to the service according to its own policies (e.g. USS required or not, authorization flags required) and continue to communicate with the UE.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.2.4\tScenario 4: NAF does use USSs, BSF does have local policy for NAF",
                    "description": "",
                    "summary": "",
                    "text_content": "In this scenario, the NAF does use USSs and the BSF does have a local policy for this NAF.\n1.\tThe NAF requests the NAF specific shared key(s) from the BSF. It includes the GSIDs it needs in the request.\n2.\tThe BSF locates the subscriber information in its local memory using the B-TID.\n3.\tThe BSF checks whether a local policy exists for the NAF - in this scenario there is a local policy for this NAF, i.e., one or more USSs identified by GSIDs shall be present in subscriber's GUSS.\nThe BSF checks whether all the required USSs identified by GSIDs are present in subscriber's GUSS: If yes, the BSF continues from step 4. If not, the BSF the BSF sends an error message to the NAF.\n4. \tThe BSF derives the NAF specific shared key(s), and sends them and the USSs identified by the GSIDs to the NAF in the response. If a particular USS is not found in subscriber's GUSS, or the NAF is not authorized to receive a particular USS, these USSs are omitted from the response.\n5.\tThe NAF receives the response with the NAF specific shared key(s), and those requested USSs that were available (i.e., found in subscriber's GUSS and allowed by the BSF to be received by the NAF).\nAfter receiving the NAF specific shared key(s) and the available USSs, the NAF may perform access control to the service according to its own policies (e.g. USS required or not, authorization flags required) and continue to communicate with the UE.\nIf the NAF received the \"not authorized\" error message, it may indicate this to the UE over Ua reference point. In any case, the GAA based security setup will fail between the UE and the NAF since the NAF did not get the NAF specific shared key(s).\nThis Annex gives examples how interoperator GBA is set up and operated.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "K.1\tExample on interoperator GBA setup",
            "description": "Interoperator GBA is set up the following way:\n-\tEach home network operator sets up a BSF, which will enable bootstrapping sessions for its own subscribers.\n-\tEach operator acting as a Serving Network for foreign subscribers in interoperator GBA needs to set up a Zn-Proxy which will forward the authentication requests from its own NAFs to the subscriber's home BSF outside of the VPLMN. The GBA secret is provisioned from the home operator's BSF through the Zn-Proxy to the NAF.\nNOTE 1:\tThe security requirements on the Zn' reference point between the Zn-Proxy and the BSF can be found in clause 4.2.2a.\n- \tEach home operator that wants to provide the GBA secrets to foreign NAFs has to authorize these NAFs to request bootstrapping secrets. This is done by using TLS client certificates issued to Zn-Proxies in the serving network by the home network operator.\nNOTE 2:\tThe TLS client certificate profile is specified in the normative Annex E.\n-\tAn operator that wishes to co-operate in interoperator GBA with another operator shall issue a TLS client certificate to the other operator's Zn-Proxy. Two operators may both act as home operators or as serving operators (i.e., both possess a BSF and a Zn-Proxy), but this Annex also applies to configurations where one operator is always acting as home operator (i.e., hosts the BSF) and the other operator only as serving operator (i.e., the operator hosts only the Zn-Proxy). In the second case, where the serving foreign operator has the Zn-Proxy only, the TLS client certificate is to be handed down in one direction only (see also Annex E on usage of client certificates).\nNOTE 3:\tThe handling of TLS certificates is described in TS 33.310 [19]. When two operators sign a roaming agreement, they may also enrol TLS client certificate for each others Zn-Proxies.\nNOTE 4:\tInteroperator GBA is based on bilateral agreements between the two operators. For example, if operator1 has a \"GBA agreement\" with operator2 and operator1 signs another \"GBA agreement\" with operator3, this does not mean that operator3 and operator2 have implicitly a \"GBA agreement\". Operator2 and operator3 shall separately sign a \"GBA agreement\".\nNOTE 5:\tThe home operator may use NAF groups to support local policy checks within its BSF (cf. clause 4.2.1). These may be e.g. one group for NAFs in home network and one group for NAFs in serving networks, or separate groups for each serving network the home operator has \"GBA agreements\" with. This NAF grouping is under sole responsibility of the home operator and only visible to him. The Zn-Proxies and NAFs in serving networks are not aware of any NAF grouping done in home network.\nAs described in clause 4.2.2a, a Zn-Proxy may be co-located with a BSF (see Figure K-2). This has the benefit that the NAF has only one logical channel to BSF/Zn-Proxy. Therefore the NAF does not need to make a decision based on the B-TID whether to send the authentication request to the Zn-Proxy or to the BSF. However, this decision can be based on the B-TID as it contains the address of the BSF.\nThe figure depicts a 5G network with a separate Base Station (BS) and a Wireless Base Station (WBS) for interoperator GBA (Giga-BBU) and a Wireless Base Station (WBS) for the 5G Core Network (C-RAN). The figure illustrates the interoperator GBA's role in managing the network, with separate control and signaling paths for the BS and WBS. The figure also shows the use of a Wireless Base Station (WBS) for the 5G Core Network (C-RAN) and a Wireless Base Station (WBS) for the interoperator GBA.\nFigure K-1: Interoperator GBA with separate BSF and Zn-Proxy\nNOTE 6:\tThe figure K-1 does not show the most general case, where there could be one Zn-proxy per home network in each serving network. It is expected that networks will be optimized and that the existence of one dedicated Zn-proxy for each foreign subscriber home network will be a rare occurrence. The co-location of all Zn-Proxies of one serving network in one location as shown in Figure K-1 is a special case.\nNOTE 7:\tThe TLS connections between Zn-Proxy and BSF are \"directed\", this is indicated in Figure K-1 by the arrowed lines where the arrows point to the server TLS role. The role of the client certificates in these TLS connections is explicitly outlined. Each direction requires a TLS server certificate used at BSF and a TLS client certificate used at Zn-Proxy.\nThe figure K-2 illustrates a 5G network scenario with an interoperator GBA (Giga-BBU) co-located with a co-located BSF (Base Station Filter) and a Zn-Proxy. The diagram highlights the interoperator GBA's role in managing the network's traffic and ensuring efficient resource allocation. The Zn-Proxy is used to filter and prioritize traffic, while the BSF ensures the network's stability and reliability. The figure demonstrates the importance of these components in a 5G network, highlighting their role in managing the network's traffic and ensuring efficient resource allocation.\nFigure K-2: Interoperator GBA with co-located BSF and Zn-Proxy\nNOTE 8:\tThe two distinct TLS connections between Zn-Proxy and BSF are \"directed\", this is indicated in Figure K-2 by the two lines. Thus the two TLS connection directions may not be intermixed, as the role of the client certificates in these TLS connections is explicitly outlined. Each direction requires a server TLS certificate used at BSF and a client TLS certificate used at Zn-Proxy.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "K.2\tExample on interoperator GBA operation",
            "description": "Interoperator GBA usage goes as follows:\nNOTE 1:\tThis description is based on GBA_ME bootstrapping to simplify the examples, but GBA_U bootstrapping can also be used in interoperator GBA operation.\n1.\tA UE contacts a NAF that does not belong to subscriber's home network. The foreign NAF notifies the UE that 3GPP bootstrapping is required to secure the connection between the UE and the NAF.\n2.\tThe UE bootstraps with the home network via the subscriber's BSF. The address of subscriber's home BSF is generated from user's IMSI or IMPI as specified in TS 33.220, clause 4.5.4. The key Ks, and the B-TID are established between the BSF and the UE.\n3.\tThe UE derives the NAF specific key Ks_NAF, and uses Ks_NAF and the B-TID on the Ua reference point between the UE and the foreign NAF. At some point during this setup the UE transfers the B-TID to the NAF in the serving network.\n4.\tUpon receiving the B-TID, the foreign NAF has two modes of operations depending on the actual setup of the Zn-Proxy and the BSF in the serving network:\nNOTE 2:\tAny BSF in a network different from the home network of a subscriber and any Zn-Proxy are not visible to the subscriber. To avoid any confusion with the subscribers BSF in the home network, the BSF in a visited network is called foreign BSF in this clause.\na)\tIf the Zn-Proxy and the foreign BSF are separate entities, the foreign NAF shall inspect the B-TID to discover whether the subscriber belongs to its own network, or whether it is a visiting subscriber. In the former case, the request for the Ks_NAF is sent to the BSF, in the latter case, the request is sent to the Zn-Proxy.\nb)\tIf the Zn-Proxy and the foreign BSF are a co-located entity, the NAF sends the request for the Ks_NAF to this co-located entity. The NAF does not need to inspect the B-TID.\nNOTE 3:\tSince the B-TID contains the address of subscriber's home BSF, it can be used to discover the home network of the subscriber. A NAF supporting this approach can work with both separated and co-located configurations.\n5.\tUpon receiving the request from the NAF, the Zn-Proxy shall inspect the following:\nb)\tValidate that the NAF is authorized to request the Ks_NAF (i.e., the DNS part of NAF_Id in the message is correct).\nb)\tDiscover the BSF of the subscriber by inspecting the B-TID.\n6.\tThe Zn-Proxy will establish or use the existing DIAMETER or HTTP session to subscriber's home BSF. This DIAMETER or HTTP session is secured by TLS, and the Zn-Proxy shall use a client certificate that the BSF trusts.\n7.\tThe Zn-Proxy will forward the request to subscriber's home BSF.\n8.\tSubscriber's home BSF shall validate that the DNS part of the NAF_Id in the request also exists in the client certificate of the Zn-Proxy.\n9.\tSubscriber's home BSF locates the bootstrapping information using the B-TID, processes the request (including possible requests for USSs, local policy check, etc.), derive the NAF specific key, and send the response to the Zn-Proxy.\n10.\tThe Zn-Proxy will forward the response to the NAF.\n11.\tThe NAF continues with the Ua connection establishment with the UE.\nFigure K-3 depicts the entities involved in the above procedure.\nThe figure K-3 illustrates the interoperator GBA usage in a 5G network, showing how operators collaborate to manage the network's resources and optimize performance. Key components include the core network, the network slicing, and the network slicing controller (NSC). The figure highlights the importance of network slicing in enabling operators to allocate resources efficiently and ensure seamless service delivery.\nFigure K-3: Interoperator GBA usage\nThe 2G GBA solution aims to provide mutual authentication between UE and BSF. This annex examines how the 2G GBA solution mitigates the impersonation of UE or the BSF i.e. security threats related to the known GSM vulnerabilities.\nThe threats that are originated from the weakness in the usage of the COMP128 algorithm exist independently of the usage of 2G GBA.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "L.1\tImpersonation of the UE to the BSF during the run of the Ub protocol",
            "description": "This is the main threat to the 2G GBA solution.\n1)\tAn attacker (being in the possession of 2G GBA equipment) could try to perform a Man-in-the-middle-attack, impersonating a genuine GSM user to the BSF. In this scenario the attacker would be at the client end of the TLS tunnel to the BSF and send the challenge  to the target GSM user, in order to obtain SRES and Kc. However, for the attack to be successful, he would have to find also Kc within the runtime allowed for steps 3 to 5 of the protocol over Ub, as specified in Annex I.5.2. This may be feasible when the terminal of the target GSM user still runs A5/2. A5/2 will be removed from networks by the end of 2006, and will not be present in any 2G GBA enabled terminals. A vulnerability caused by A5/2 would only exist in the case where a GSM user has subscribed to 2G GBA feature, but uses his SIM in an old terminal with A5/2 enabled while being targeted by the attacker. But the practical implications of this remaining vulnerability are expected to be limited as a user subscribed to 2G GBA will own a Release 7 terminal (2G GBA will be a Release 7 feature), and the likelihood of him inserting his SIM in an old terminal, and an attacker obtaining this information and exploiting it for a man-in-the-middle attack, may be low in practice. Furthermore, old terminals will gradually disappear. \nThe attack may also be feasible when the attacker, using a false base station, forces the use of A5/1 on the ME. The attacker may then be able to determine Kc from the (encrypted) CIPHERING MODE COMPLETE message especially when the fillbits are not random. Note that the fillbits are required to be random from Rel-8 onwards, according to TS 44.006 [46].\nThe attack may also be feasible when the attacker, using a false base station, forces the use of GEA1 on the ME and is able to determine Kc. Note that the implementation of GEA1 in MEs is forbidden from Rel-12 onwards, according to TS 43.020 [47].\n2)\tSIM cloning: an attacker being able to find the long-term key Ki of a genuine GSM user is able to fully impersonate him in all contexts, including the 2G-GBA one (if this has been subscribed by the genuine user).. The attacker could do this by exploiting weaknesses of A3/A8 as they were found for COMP128, while in possession of the SIM i.e. the attacker tries to find the long term key K. Even if 2G GBA does not increase the risk of possible A3/A8 breakages, it has to be noted that the COMP128-related issue disappears when more secure A3/A8 algorithms are used. These are available today, cf. \"GSM MILENAGE\", as specified in TS 55.205 v610. Operators are advised in general to discontinue the use of COMP128\n3)\tUnauthorized access to SIM needs to be countered by platform security methods. The impacts of a compromised SIM/ME or UICC/ME interface on GAA security are similar in 2G GBA and 3G GBA.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "L.2\tImpersonation of the BSF to the UE during the run of the Ub protocol",
            "description": "To prevent an impersonation attack of the BSF to the UE during the run of the Ub protocol the authentication of the BSF to the UE is improved by protecting the communication with TLS. An attacker succeeds only if he can break both, the certificate-based TLS authentication to the UE and mutual authentication provided by HTTP Digest using a password derived from GSM procedures. One way to break TLS is to compromise the certificate.\nWhen an attacker was able to obtain a forged server certificate with the name of the genuine BSF from a compromised Certification Authority then the attacker could break the certificate-based TLS authentication to the UE. Furthermore, the attacker would be able to perform a make a man-in-the-middle attack between the UE and the BSF by playing TLS server towards the UE and TLS client towards the BSF. Such a a man-in-the-middle attack would make it possible for the attacker to read Ks-input and hence have a greater chance to compute the key Ks.\nThe man-in-the-middle attack could be countered by the use of channel binding as described in RFC 5929 [48]. This approach was not pursued further due to the perception that the risk posed by the relative weakness of GSM security was far greater than the risk posed by a CA.\nNOTE:\tFor a way of reducing the risk of the UE using the root key associated with a compromised Certification Authority (CA) see clause I.6.2 of the present specification.\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "L.3\tFinding the GBA key Ks during or after the Ub protocol run",
            "description": "For BSF-to-UE authentication and for establishment of the key Ks, the solution relies on both, GSM security and TLS security. The attacker needs to know all the parameters of the GSM triplet, in particular Kc, and additionally break the TLS security, as the attacker also needs to know the Ks-input parameter confidentially transmitted by the BSF over TLS. Breaking GSM security after the Ub protocol run alone does not provide sufficient information to break 2G GBA.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "L.4\tBidding down attack",
            "description": "To avoid a bidding down attack (also called downplay attack), the 2G GBA solution requires that a GBA-enabled terminal that supports SIM based 2G GBA must support also USIM/ISIM based 3G GBA as specified in I.2.4. If a USIM/ISIM is available, then the terminal must use the USIM/ISIM based 3G GBA as specified in I.4.8.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "M.1\tGeneral",
            "description": "This annex specifies the use of SIP Digest credentials, as defined in TS 33.203 [16], for GBA. The procedure specified in this annex is called GBA_Digest. GBA_Digest allows access to applications in a more secure way than would be possible with the use of password-based HTTP Digest as specified in RFC 9110 [61] and RFC 7616 [62] without enhancements. It may be useful for environments where a UICC, or a SIM card, is not available to subscribers. The use of GBA_ Digest is restricted to such environments.\nClauses 4 and 5 of the present document do not apply to this Annex unless explicitly stated.\nNOTE 1:\tThe use of the term 'UE' in this Annex is in line with the use of the term 'UE' in TS 33.203 [16], Annex N (on SIP Digest), but differs from that in other 3GPP specifications in that it assumes that a UICC is not available to subscribers in the UE.\nNOTE 2:\tThe use of MD5 in HTTP Digest is not recommended and only supported for interoperability.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "M.2\tReference model",
            "description": "The reference model is the same as described in clause 4.1, with the exception that the reference point Zh' is not needed here.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "M.3\tNetwork elements",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "M.3.1\tBootstrapping server function (BSF)",
                    "description": "",
                    "summary": "",
                    "text_content": "A generic Bootstrapping Server Function (BSF) and the UE shall mutually authenticate using a combination of the HTTP Digest protocol and the TLS protocol, and agree on session keys that are afterwards applied between UE and a Network Application Function (NAF). The BSF shall restrict the applicability of the key material to a specific NAF by using the key derivation procedure as specified in Annex B. The key derivation procedure may be used with multiple NAFs during the lifetime of the key material. The lifetime of the key material is set according to the local policy of the BSF. The generation of key material is specified in clause M.6.3.\nThe BSF shall be able to acquire the GBA user security settings (GUSS) from the HSS.\nThe BSF shall discover from the request received from the UE over the Ub interface whether the UE intends to run GBA_Digest. The BSF shall then request a SIP Digest authentication vector from the HSS or abort the Ub run with a suitable failure message, according to its local policy.\nThe BSF shall be able to keep a list, which assigns NAFs to NAF Groups. This list is used to select if any and which application-specific USS within GUSS is valid for a certain NAF.\nNOTE 1:\tThe operator does the assignment of NAFs to NAF Groups. NAF Group definitions in HSS and all connected BSFs belonging to the same operator's network shall be equal (cf., clause I.2.3). As these network elements belong to the same operator's network, standardisation of the NAF Group definitions themselves is not necessary in 3GPP.\nNOTE 2:\tThe NAF grouping may be e.g. \"home\" and \"visited\". It allows the BSF to send USSs for the same application with e.g. different authorization flags to different NAFs, e.g., in home network and visited networks. The NAF e.g. in visited network indicates only the requested application, but it is unaware of the grouping in home network of the subscriber.\nThe BSF shall allow the operator to configure a BSF policy whether to accept subscribers using SIP Digest credentials or not for a certain NAF.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.3.2\tNetwork application function (NAF)",
                    "description": "",
                    "summary": "",
                    "text_content": "After the bootstrapping has been completed, the UE and a NAF can run some application specific protocol where the authentication of messages will be based on those session keys generated during the mutual authentication between UE and BSF.\nGeneral assumptions for the functionality of a NAF are:\n-\tthere need not be a previous security association between the UE and the NAF;\n-\tNAF shall locate and communicate securely with the subscriber's BSF;\n-\tNAF shall acquire a shared key material established between UE and the BSF during the run of the application-specific protocol;\n-\tNAF shall be able to acquire zero or more application-specific USSs from the HSS via the BSF;\n-\tNAF shall be able to set the local validity condition of the shared key material according to the local policy;\n-\tNAF shall be able to check lifetime and local validity condition of the shared key material;\n-\tNAF shall have a policy whether to accept subscribers using SIP Digest credentials. However, whether GBA_Digest is allowed to be used with a specific Ua application or not, is dependent on the relevant Ua application. If there is a specific TS for an application using a particular Ua protocol, and unless this TS explicitly prohibits the use of GBA_Digest, the NAF may allow usage of SIP Digest credentials for this application,\n-\tthe NAF shall be able to indicate to the UE that the SIP Digest-based GBA bootstrapping security association is acceptable.\nNOTE:\tWithout additional measures, GBA, as defined throughout the present document, does not guarantee the freshness of the key, Ks_NAF, in the sense that it does not guarantee that the key was not used in a previous run of the Ua protocol. The additional measures which may be taken by the UE and the NAF to ensure key freshness in GBA are:\n1)\tenforce a new run of the Ub protocol (thus generating a new Ks) before deriving a new Ks_NAF;\n2)\tstore previously used keys Ks_NAF, or the corresponding key identifiers B-TID, until the end of their lifetime.\nA UE and a NAF that support a Ua protocol that does not provide replay protection over unconnected runs of the protocol, will need to take corresponding action to avoid replay attacks if desired.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.3.3\tZn-Proxy",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from clause 4.2.2a applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.3.4\tHSS",
                    "description": "",
                    "summary": "",
                    "text_content": "The set of all user security settings (USSs), i.e. GUSS, is stored in the HSS.\nThe requirements on the HSS are:\n-\tHSS shall provide the only persistent storage for GUSSs;\n-\tGUSS shall be defined in such a way that interworking of different operators for standardised application profiles is possible;\n-\tGUSS shall be defined in such a way that profiles for operator specific applications and extensions to existing application profiles are supported without need for standardisation of these elements.\n-\tGUSS shall be able to contain application-specific USSs that contain parameters that are related to identification or authorization information of one or more applications hosted by one ore more NAFs. Any other types of parameters are not allowed in the application-specific USS.\nNOTE 1:\tThe necessary subscriber profile data may be fetched by the NAF from its local database.\nNOTE 2:\tOne possibility to revoke temporarily an application specific USS from the GUSS is that the HSS may temporarily remove an application-specific USS from the GUSS if the service is temporarily revoked from the subscriber. The GUSS in the BSF is not changed by this operation and only updated when the existing bootstrapping session times out, or is overwritten by a new bootstrapping session during which the new modified GUSS is fetched from HSS along with the AV.\n-\tGUSS shall be able to contain parameters intended for the BSF usage:\n-\tsubscriber specific key lifetime;\n-\toptionally the timestamp indicating the time when the GUSS has been last modified by the HSS.\nNOTE 3:\tThese parameters are optional and if they are missing from subscriber's GUSS or subscriber does not have GUSS then the BSF will use the default values in the BSF local policy defined by the particular MNO.\n-\tHSS shall be able to assign application-specific USSs to a NAF Group. This shall be defined in such a way that different USSs for the same application, but for different groups of NAFs, are possible. The restrictions on the number of USSs per GUSS are dependent on the usage of NAF Groups by the operator:\n-\tif no NAF Groups are defined for this application then at most one USS per application is stored in GUSS;\n-\tif NAF Groups are defined for this application then at most one USS per application and NAF Group is stored in GUSS.\n-\tNAF Group definitions in the HSS and all connected BSFs belonging to the same operator's network shall be equal.\n-\tInformation on UICC type and on key choice are not required for subscribers using SIP Digest credentials. GBA_Digest is regarded as ME-based.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.3.5\tUE",
                    "description": "",
                    "summary": "",
                    "text_content": "The required functionalities from the UE are:\n-\tthe support of HTTP Digest protocol according to RFC 9110 [61] and RFC 7616 [62] with the additional profiling specified in this Annex;\n-\tthe support of TLS;\n-\tthe capability to use SIP Digest credentials in bootstrapping;\n-\tthe capability for a Ua application on the terminal to indicate to the GBA Function on the terminal whether SIP Digest credentials are allowed for use in bootstrapping;\n-\tthe capability to derive new key material to be used with the protocol over the Ua interface as defined in clause M.6.3;\n-\tsupport of at least one Ua application protocol (For an example see TS 33.221 [5]);\n- \tthe capability to send an indication to the BSF over the Ub interface that the UE intends to run GBA_Digest.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.3.6\tSLF",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from clause 4.2.5 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "M.4\tBootstrapping architecture and reference points",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "M.4.1\tReference point Ub",
                    "description": "",
                    "summary": "",
                    "text_content": "The reference point Ub is between the UE and the BSF. Reference point Ub provides mutual authentication between the UE and the BSF. It allows the UE to bootstrap the session keys based on SIP Digest credentials.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.4.2\tReference point Ua",
                    "description": "",
                    "summary": "",
                    "text_content": "The reference point Ua carries the application protocol, which is secured using the keys material agreed between UE and BSF as a result of the run of the protocol over reference point Ub.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.4.3\tReference point Zh",
                    "description": "",
                    "summary": "",
                    "text_content": "The reference point Zh used between the BSF and the HSS allows the BSF to fetch the required authentication information and all GBA user security settings from the HSS. The reference point Zh is an intra-operator domain interface.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.4.4\tReference point Zn",
                    "description": "",
                    "summary": "",
                    "text_content": "The reference point Zn is used by the NAF to fetch the key material agreed during a previous protocol run over the reference point Ub from the UE to the BSF. It is also used to fetch application-specific user security settings from the BSF, if requested by the NAF.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.4.5\tReference point Dz",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from clause 4.3.5 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "M.5\tRequirements and principles for bootstrapping",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "M.5.1\tGeneral Requirements",
                    "description": "",
                    "summary": "",
                    "text_content": "The following requirements and principles are applicable to bootstrapping procedure:\n-\tthe GBA_Digest bootstrapping function shall not depend on the particular NAF;\n-\tthe server implementing the bootstrapping function needs to be trusted by the home operator to handle authentication vectors;\n-\tthe server implementing the NAF needs only to be trusted by the home operator to handle derived key material;\n-\tit shall be possible to support NAF in the operator's home network and in the visited network;\n-\tthe architecture shall not preclude the support of network application function in a third network;\n-\tto the extent possible, existing protocols and infrastructure should be reused;\n-\tin order to ensure wide applicability, all involved protocols are preferred to run over IP;\n-\tit shall be prevented that a security breach in one NAF who is using the GBA, can be used by an attacker to mount successful attacks to the other NAFs using the GBA;\n-\tan attacker shall not be able to exploit a security breach in one security protocol over Ua in order to mount a successful attack against a different security protocol over Ua;\n- \tIf USIM, ISIM, or SIM are available and the BSF supports AKA-based GBA the UE shall not use GBA_Digest. Instead, the UE shall use the procedures as specified in clauses 4 and 5, and Annex I;\n- \tGBA_Digest shall not impact the procedures for AKA-based GBA as specified in clauses 4 and 5, and Annex I;\n- \tGBA_Digest shall not reduce security for users of AKA-based GBA;\n- \tGBA_Digest shall be closely modelled after AKA-based GBA specified in clauses 4 and 5, and Annex I;\n- \tGBA_Digest shall provide measures to mitigate known vulnerabilities of the re-use of SIP Digest credentials.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.2\tAccess independence",
                    "description": "",
                    "summary": "",
                    "text_content": "The bootstrapping procedure for GBA_Digest is, in principle, access independent as it only requires IP connectivity from the UE.  However, in order to ensure that GBA_ Digest is not used over access networks defined in 3GPP specifications operators may introduce some access dependence in their network configurations, e.g. by assigning different ports on the BSF to different access networks.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.3\tAuthentication methods",
                    "description": "",
                    "summary": "",
                    "text_content": "Authentication between the UE and the BSF shall not be possible without a valid IMS subscription. Authentication shall be based on a combination of the HTTP Digest protocol using SIP Digest credentials and the TLS protocol, as defined in clause M.6.3. TLS shall be used with server certificates, but the TLS server shall not request client certificates.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.4\tRoaming",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements on roaming are:\n-\tA subscriber located outside the home network shall be able to utilize the bootstrapping function in the home network. The subscriber shall be able to utilize a network application function that is outside the home network.\n-\tThe home network shall be able to control whether its subscriber is authorized to use the service outside the home network.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.5\tRequirements on reference point Ub",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements for reference point Ub are:\n-\tthe BSF shall be able to identify the UE;\n-\tthe BSF and the UE shall authenticate each other based on the methods specified in clasue M.5.3;\n-\tthe BSF shall send a bootstrapping transaction identifier to the UE;\n-\tthe UE and the BSF shall establish shared keys;\n-\tthe BSF shall indicate to the UE the lifetime of the key material. The key lifetime sent by the BSF over Ub shall indicate the expiry time of the key.\nNOTE:\tThis does not preclude a UE to refresh the key before the expiry time according to the UE's local policy.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.6\tRequirements on reference point Zh",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements for reference point Zh are:\n-\tmutual authentication, confidentiality and integrity shall be provided;\nNOTE 1:\tThis requirement may be fulfilled by physical or proprietary security measures since BSF and HSS are located within the same operator's network.\n-\tthe BSF shall send a bootstrapping information request concerning a subscriber;\n-\toptionally the BSF may have the capability to send the timestamp of subscriber's GBA user security settings to the HSS (timestamp option);\n-\tthe HSS shall send one SIP Digest authentication vector at a time to the BSF;\n-\tthe HSS shall send the complete set of subscriber's GBA user security settings needed for security purposes to the BSF. Optionally the HSS may have the capability to indicate to the BSF whether the BSF already has the latest copy of the GUSS based on the GUSS timestamp (timestamp option);\nNOTE 2:\tIf subscriber's GUSS is updated in HSS, this is not propagated to the BSF. The GUSS in the BSF is updated when the BSF next time fetches the authentication vectors and GUSS from the HSS over Zh reference point as part of the bootstrapping procedure.\n-\tno state information concerning bootstrapping shall be required in the HSS;\n-\tall procedures over reference point Zh shall be initiated by the BSF;\n-\tthe number of different interfaces to the HSS should be minimized.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.7\tRequirements on reference point Zn",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements for reference point Zn are:\n-\tmutual authentication, confidentiality and integrity shall be provided;\n-\tIf the BSF and the NAF are located within the same operator's network, the DIAMETER based Zn reference point shall be secured according to NDS/IP in TS 33.210 [13];\n-\tIf the BSF and the NAF are located in different operators' networks, the DIAMETER based Zn' reference point between the Zn-Proxy and the BSF shall be secured using TLS as specified in Annex E;\n-\tAn HTTP based Zn/Zn' reference point shall be secured using TLS as specified in Annex E;\n-\tThe BSF shall verify that the requesting NAF is authorised to obtain the key material or the key material and the requested USS;\n-\tThe NAF shall send a key material request to the BSF, containing NAF's public hostname used by the UE's corresponding request. The BSF shall verify that a NAF is authorized to use this hostname, i.e. the FQDN used by UE when it contacts the NAF;\n-\tThe NAF shall indicate to the BSF for each Zn run whether it is willing to accept Ks_NAF based on GBA_Digest;\n-\tThe BSF shall send the requested key material to the NAF;\n-\tThe NAF shall be able to get a selected set of application-specific USSs from the BSF, depending on the policy of the BSF and the application indicated in the request from the NAF over Zn;\n-\tThe NAF shall indicate to the BSF the single application or several applications it requires USSs for;\nNOTE 1:\tIf some application needs only a subset of an application-specific USS the NAF selects this subset from the complete set of USS sent from BSF.\n-\tThe BSF shall be configured on a per NAF or per application basis if private subscriber identity and which application-specific USSs may be sent to a NAF;\nNOTE 2:\tPrivacy issues need be considered when determining which user identifier is sent to the NAF. If service continuity is desired, then the BSF can be configured to send the IMPI (but then there is no user anonymity). If the BSF does not send the IMPI or IMPU / pseudonym in the USS, then the user remains anonymous towards the NAF; or more precisely, the B-TID functions as a temporary user identifier. This can cause that the NAF cannot provide a continuous service, since a user identity is needed in the NAF to ensure that the NAF is able to update keys for a Ua session when the UE has bootstrapped and contacts the NAF with a new B-TID. If user privacy is desired, the NAF can requests a USS and the BSF is configured to send a user pseum in the USS, but not the IMPI.\n-\tIf a NAF requests USSs from the BSF and they are not present in subscriber's GUSS, it shall not cause an error, provided the conditions of the local policy of the BSF are fulfilled. The BSF shall then send only the requested and found USSs to the NAF;\n-\tIt shall be possible to configure a local policy as follows: BSF may require one or more application-specific USS to be present in a particular subscriber's GUSS for a particular requesting NAF, and to reject the request from the NAF in case the conditions are not fulfilled. In order to satisfy this local policy, it is not required that the NAF requests the USSs over the Zn reference point, which the BSF requires to be present in the GUSS, rather it is sufficient that the BSF checks the presence of the USSs locally. It shall also be possible configure the BSF in such a way that no USS is required for the requesting NAF;\n-\tThe BSF shall indicate to the NAF the bootstrapping time and the lifetime of the key material. The key lifetime sent by the BSF over Zn shall indicate the expiry time of the key, and shall be identical to the key lifetime sent by the BSF to the UE over Ub.\nNOTE 3:\tThis does not preclude a NAF to refresh the key before the expiry time according to the NAF's local policy.\nNOTE 4:\tIf one or more of the USSs that have been delivered to the NAF has been updated in subscriber's GUSS in the HSS, this change is propagated to the NAF the next time it fetches the USS from the BSF over Zn reference point (provided that the BSF has updated subscriber's GUSS from the HSS over Zh reference point).\n-\tIf the NAF indicated its willingness to accept Ks_NAF based on GBA_Digest in the Zn request and the B-TID sent by the NAF points to a Ks generated by GBA_Digest the BSF shall send information to the NAF that the subscriber is a subscriber who used SIP Digest credentials. If the B-TID points to a Ks established by another GBA method the BSF shall respond according to that method. Otherwise, the BSF shall not send key material to the NAF.\nNOTE 5: \tThis requirement enables a NAF to accept subscribers using SIP Digest credentials according to its local policy. The second sentence ensures backward compatibility with the procedures specified in clauses 4 and 5 and Annex I. Note also that inclusion of information on the GBA variant in the GUSS is not possible as one subscriber may have both AKA and SIP Digest credentials, leading to a depencence on the credentials actually used during the last Ub run. \nA NAF that can understand a 'GBA_Digest' indication received from the BSF on Zn can understand which GBA variant was used on Ub to derive the Ks_NAF key and, hence, can always make its own judgment whether to accept the Ks_NAF based on its local policy. However, there is no technical reason why the NAF would not accept a Ks_NAF that was derived using an AKA-based GBA variant because such a Ks_NAF is stronger than a key that was derived using GBA_digest and there is no difference in using it for the NAF.\n-\tThe BSF may determine according to its local policy that the NAF shall not serve subscribers using SIP Digest credentials. If this is the case, the BSF shall not send keys generated by GBA_Digest to the NAF.\nNOTE 6:\tThis requirement allows an operator controlling the BSF to determine which applications shall use AKA-based GBA only.\n-\tThe NAF shall indicate to the BSF the protocol identifier of Ua security protocol for which it requires the key material by sending NAF-Id to BSF (cf. Annex H).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.8\tRequirements on Bootstrapping Transaction Identifier",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from clause 4.4.7 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.9\tRequirements on reference point Ua",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from clause 4.4.9 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.10\tRequirements on reference point Dz",
                    "description": "",
                    "summary": "",
                    "text_content": "The text from clause 4.4.10 applies also here.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.5.11\tRequirements on GBA keys and parameters handling",
                    "description": "",
                    "summary": "",
                    "text_content": "- \tThe terminal shall delete all GBA keys related to a certain Ks (i.e., Ks itself, and NAF specific keys derived from this specific Ks) and the corresponding NAF_IDs, B-TID, , Ks lifetime, and, if applicable, Ks_NAF lifetimes and lifetimes of the keys derived from a Ks_NAF, when the key lifetime of this specific Ks expires.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "M.6\tProcedures",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "M.6.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "This chapter specifies in detail the format of the GBA_Digest bootstrapping procedure that is further utilized by various applications. It contains the authentication procedure with BSF, and the key material generation procedure.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.6.2\tInitiation of bootstrapping",
                    "description": "",
                    "summary": "",
                    "text_content": "Before communication between the UE and the NAF can start, the UE and the NAF first have to agree whether to use GBA. When a UE wants to interact with a NAF, but it does not know if the NAF requires the use of shared keys obtained by means of the GBA, the UE may contact the NAF for further instructions (see figure M.1).\nNOTE: The above text implies that a UE may contact either the BSF or the NAF without knowing whether the NAF supports GBA.\nThe figure depicts the initiation of bootstrapping in a network, illustrating the process of network initialization. The figure shows a network with multiple layers, each representing a different stage of the bootstrapping process. The layers are labeled with the corresponding stages, such as \"Initiation,\" \"Bootstrapping,\" and \"Bootstrapping Completion.\" The figure also includes a diagram of the network's topology, showing the connections between the layers and the network's core components. The figure is a visual representation of the network's initialization process, providing a clear and concise overview of the steps involved.\nFigure M.1: Initiation of bootstrapping\n1.\tThe UE may start communication over reference point Ua with the NAF with or without any GBA-related parameters.\n2.\tIf the NAF requires the use of shared keys obtained by means of the GBA, but the request from UE does not include GBA-related parameters, the NAF replies with a bootstrapping initiation message. If the use of GBA_Digest is acceptable to the NAF the NAF shall indicate it in this message. The form of this initiation message may depend on the particular reference point Ua.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.6.3\tBootstrapping procedures",
                    "description": "",
                    "summary": "",
                    "text_content": "When a UE wants to interact with a NAF, and it knows that the bootstrapping procedure is needed, it shall first perform such a procedure. Otherwise, the UE shall perform a bootstrapping procedure only when it has received a bootstrapping initiation required message or a bootstrapping negotiation indication from the NAF, or when the lifetime of the key in UE has expired (cf. clause M.6.4).\nThe bootstrapping procedure using SIP Digest credentials is run over the Ub interface (extended for the purposes of GBA_Digest) as described below:\nThe figure depicts the GBA (Giga-BANDWIDTH Architecture) digest bootstrapping procedure, which is a crucial step in the bootstrapping process of the GBA architecture. The figure illustrates the steps involved in initializing the GBA, including the initialization of the GBA, the initialization of the GBA's memory, and the initialization of the GBA's registers. The figure also includes a diagram of the GBA's memory layout and the GBA's registers, providing a clear understanding of the GBA's architecture and its components.\nFigure M.2 GBA_Digest bootstrapping procedure\nNOTE 1:\tFigure M.2 only shows an example flow for visualization and not all details are included.\nA UE shall always include the product token \"3gpp-gba-tmpi\" in the user agent request-header field when sending HTTP messages over Ub. A BSF shall always include the product token \"3gpp-gba-tmpi\" in the server response-header field when sending HTTP messages over Ub.\nNOTE 1a:\tAccording to the HTTP specification RFC 9110 [61], the product tokens may contain any text. They are ignored when unknown by a UE or a BSF.\nStep 0:\nThe UE and the BSF shall establish a TLS tunnel with server authentication using a server certificate. The use of TLS message integrity is mandatory, while the use of TLS encryption is optional. All further messages between the BSF and UE shall be sent through this tunnel.\nNOTE 2:\tTLS encryption can be useful for protecting the user identity privacy when the TMPI mechanism defined in the present document is not used.\nStep 1:\nIn this HTTP request message from the UE to the BSF, the UE shall include an Authorization header containing a user identity in the \"username\" parameter and a token indicating the use of GBA_Digest. When a TMPI associated with the IMPI in use is available on the UE, this user identity shall be this TMPI, otherwise it shall be the IMPI. The realm in the Authorization header shall be the realm as defined for SIP Digest in TS 33.203 [16].\nStep 2:\nThe BSF recognises from the structure of the \"username\" parameter (cf. Annex B.4) whether a TMPI or an IMPI was sent. If a TMPI was sent the BSF shall look up the corresponding IMPI in its local database. If the BSF does not find an IMPI corresponding to the received TMPI it shall return an appropriate error message to the UE. The UE shall then delete the TMPI and retry the request using the IMPI.The BSF shall request a SIP Digest Authentication Vector (SD-AV) from the HSS. The SD-AV is defined in TS 33.203 [16], Annex N. The username field in the Multimedia Auth Request shall contain the IMPI.\nStep 3:\nThe HSS shall retrieve the SD-AV corresponding to the IMPI and send it to the BSF in a Multimedia Auth Answer. The handling of GUSS between BSF and HSS shall be as described in clause 4.5.2, step 2.\nThe qop value shall be set to \"auth-int \".\nNOTE 3:\tThe additional protection afforded by qop set to \"auth-int\" may seem unnecessary considering the fact that the messages exchanged between UE and BSF are protected by a TLS tunnel. However, the use of \"auth-int\" is consistent with the other modes of GBA (GBA_ME, GBA_U and 2G GBA) and also provides a second layer of integrity protection in case the TLS server authentication is ever compromised (e.g. due to replacement of insecurely stored root certificates on the UE or a Certification Authority being compromised).\nStep 4:\nIn the HTTP 401 Unauthorized response from the BSF to the UE, the BSF shall include a WWW-Authenticate header with parameters as specified in RFC 9110 [61] and RFC 7616 [62].\nThe parameters realm, qop, and algorithm were provided in the SD-AV in step 3 and the nonce=base64encode (16 byte random value) is generated according to RFC 3548 [60] by the BSF.\n\nStep 5:\nWhen responding to a challenge from the BSF, the UE shall generate a cnonce randomly, and calculate the response RESP. The RESP shall be put into the Authorization header and sent back to the BSF in the GET request.\nRESP shall be computed as a Digest-response according to RFC 9110 [61] and RFC 7616 [62] (HTTP Digest) from the most recent GBA_Digest challenge and a password 'passwd' that is generated as follows:\npasswd = KDF (H(A1), \"GBA_Digest_RESP\", TLS_MK_Extr)\nwhere H(A1) is the hash of the following three parameters:  the user name and password used by the user in IMS for SIP Digest according to TS 33.203 [16], Annex N, and the realm, cf. also RFC 9110 [61] and RFC 7616 [62]. \"GBA_Digest_RESP\" is a character string. TLS_MK_Extr is extracted from the TLS master key according to RFC5705 [44] or RFC 8446 [59] with the optional context value being omitted, the label set to \"EXPORTER_GBA_Digest\", and the length set equal to the length of the TLS master secret (48 bytes). KDF is the key derivation function as specified in clause B.2.\nNOTE 4:\tA cautionary note on notation: According to RFC 9110 [61] and RFC 7616 [62], the computation of RESP from the password 'passwd' defined above entails again a parameter called H(A1). This parameter will differ from the value of H(A1) that is input to the above formula because the passwords from which these two H(A1) values are derived differ. But no new notation is deemed necessary here as the notation H(A1), when H(A1) is derived from 'passwd', is not explicitely used in the text of the present document.\nStep 6:\nUpon receiving a GET request carrying the authentication response RESP, the BSF shall check that the expected RESP (calculated by the BSF in the same way as by the UE in step 5) matches the received RESP. If the check is successful then the user has been authenticated.\nThe BSF shall then derive Ks as follows, (see clause B.5 for the formation of the input):\nKs = KDF (H(A1), \"GBA_Digest_Ks\", TLS_MK_Extr, RESP)\nwhere H(A1), RESP, and TLS_MK_Extr are defined as in step 5, and \"GBA_Digest_Ks\" is a character string.\nThe BSF shall generate the bootstrapping transaction identifier (B-TID) for the IMPI and store the tuple \n <B-TID, IMPI, Ks, nonce>. The B-TID shall be constructed in the format of a NAI by taking the nonce from step 4, and the BSF server name, i.e. nonce@BSF_server_domain_name.\nNOTE 5:\tThe B-TID construction above is almost identical to the one used in clause 4. The difference is that in clause 4 the username part is constructed from the (base64 encoded)  value.\nThe BSF shall compute a new TMPI as specified in Annex B.4 and store it together with the IMPI, overwriting a previous TMPI related to this IMPI, if any.\nNOTE 6:\tThe formulations in the preceding paragraph, and the corresponding paragraph below relating to the computation of the TMPI in the UE, differ from the ones in clause 4.5.2 as GBA_Digest-aware UEs and BSFs always include the product tokens as described at the start of this clause. So, the condition in clause 4.5.2 is not needed.\nThe BSF shall send a 200 OK response to the UE to indicate the success of the authentication.\nIn this message from the BSF to the UE, the BSF shall include the bootstrapping transaction identifier (B-TID) and the key lifetime.\nAn Authentication-Info header according to RFC 9110 [61] and RFC 7616 [62] shall be included into the 200 OK response.\nThe UE shall abort the procedure if the server authentication according to RFC 9110 [61] and RFC 7616 [62] fails. Otherwise, the UE shall derive Ks in the same way as the BSF did above.\nThe UE shall compute the TMPI as specified in Annex B.4 and store it together with the IMPI, overwriting a previous TMPI related to this IMPI, if any.\nAfter successful bootstrapping procedure the UE and the BSF shall store the key Ks, the nonce, the B-TID, and an indication of the underlying security quality, i.e. GBA_Digest, for further use, until the key Ks is updated or until the deletion conditions in clause M.5.11 are satisfied. The key Ks shall then be used in the BSF and in the UE to derive NAF specific key(s) Ks_NAF to secure Ua reference points in the following way:\nKs_NAF shall be computed as Ks_NAF = KDF (Ks, \"gba-digest\", nonce, IMPI, NAF_Id), where KDF is the key derivation function as specified in clause B.2, and the input parameters consist of the user's IMPI, the NAF_Id and 'nonce'. 'nonce' is the nonce that was used for computing the RESP that was input to the derivation of Ks. The NAF_Id shall be constructed as in clause 4.5.2. The \"gba-digest\" parameter is a static character string.\nNOTE 6: \tThe above derivation of Ks_NAF is analagous to the derivation in clause 4.5.2, step 9, and the same KDF can be utilized.\nThe KDF shall be implemented in the terminal.\n\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.6.4\tProcedures using bootstrapped Security Association",
                    "description": "",
                    "summary": "",
                    "text_content": "Before communication between the UE and the NAF can start, the UE and the NAF first have to agree whether to use shared keys obtained by means of the GBA. If the UE does not know whether to use GBA with this NAF, it uses the Initiation of Bootstrapping procedure described in clause M.6.2.\nOnce the UE and the NAF have established that they want to use GBA then every time the UE wants to interact with an NAF the following steps are executed as depicted in figure M.3.\n1.\tUE starts communication over reference point Ua with the NAF:\n-\tin general, UE and NAF will not yet share the key(s) required to protect the reference point Ua. If they already do (i.e. if a key Ks_NAF for the corresponding key derivation parameter NAF_Id is already available), the UE and the NAF can start to securely communicate right away. If the UE and the NAF do not yet share a key, and if the use of a Ks derived from an AKA-based GBA variant according to clauses 4.5.3, 5.5.3, or I.5.3, is not possible, the UE proceeds as follows:\n-\tif the UE knows (through a lack of indication in the Initiation of Bootstrapping procedure or by configuration) that the use of GBA_Digest is not acceptable to the NAF it shall abort the communication with the NAF. Otherwise, a key Ks_NAF shall be derived in the following way:\n-\tif a key Ks derived from SIP Digest credentials is available in the UE, the UE derives the key Ks_NAF from Ks, as specified in clause M.6.3;\n-\tif no key Ks derived from SIP Digest credentials is available in the UE, the UE first agrees on a new key Ks derived from SIP Digest credentials with the BSF over the reference point Ub, and then proceeds to derive Ks_NAF;\nNOTE 0:\tA key Ks derived from an AKA-based GBA variant could still be available from a previous GBA bootstrapping run where the UICC was available, and could then still be used.\nIf it is not desired by the UE to use the same Ks derived from SIP Digest credentials to derive more than one Ks_NAF then the UE should agree on a new key Ks with the BSF over the reference point Ub, and then proceed to derive Ks_NAF;\n-\tif the NAF shares a key with the UE, but the NAF requires an update of that key, e.g. because the key's lifetime has expired or will expire soon, or the key can not meet the NAF local validity condition, it shall send a suitable bootstrapping renegotiation request to the UE, see figure M.4. If the key's lifetime has expired the protocol used over reference point Ua shall be terminated. The form of this indication depends on the particular protocol used over reference point Ua. If the UE receives a bootstrapping renegotiation request, it starts a run of the protocol over reference point Ub, as specified in clause M.6.3, in order to obtain a new key Ks.\nTo allow for consistent key derivation in BSF and UE, both have to use the same FQDN for derivation (see clause M.6.3). For each protocol used over Ua it shall be specified if only cases (1) and (2) of clause 4.5.2 are allowed for the NAF or if the protocol used over Ua shall transfer also the FQDN used for key derivation by UE to NAF.\nNOTE 1:\tIf the shared key between UE and NAF is invalid, the NAF can set deletion conditions to the corresponding security association for subsequent removal.\n-\tthe UE supplies the B-TID to the NAF, in the form as specified in clause M.5.8, to allow the NAF to retrieve the corresponding keys from the BSF;\nNOTE 2:\tThe UE may adapt the key material Ks_NAF to the specific needs of the reference point Ua. This adaptation is outside the scope of the present document.\n-\tthe key management procedures for GBA related keys in the terminal are described in section M.5.11.\n-\twhen a new Ks is agreed over the reference point Ub and a key Ks_NAF, derived from one NAF_Id, is updated, the other keys Ks_NAF, derived from different values NAF_Id, stored on the UE shall not be affected;\nAccording to the procedures defined in clauses M.6.3 and M.6.4, in the UE there is at most one Ks_NAF key stored per NAF_Id.\n2.\tNAF starts communication over reference point Zn with BSF:\n-\tThe NAF shall request key material corresponding to the B-TID supplied by the UE to the NAF over reference point Ua. The NAF shall indicate to the BSF whether it is willing to accept Ks_NAF based on GBA_Digest;\n-\tThe NAF may also request one or more application-specific USSs for the applications, which the request received over Ua from UE may access;\nNOTE 3: \tIf the NAF requires service continuity, then the NAF can request a USS that contains a user pseum that allows service continuity according to BSF policy.\n-\tWith the key material request, the NAF shall supply a NAF_Id (which includes the NAF's FQDN that the UE has used to access this NAF and the Ua security protocol identifier) to the BSF. (This is to allow for consistent key derivation in the BSF and UE as described above). The BSF shall verify that the NAF is authorized to use that FQDN.\n3.\tThe BSF derives the keys required to protect the protocol used over reference point Ua from the key Ks and the key derivation parameters, as specified in clause M.6.3, and supplies to NAF the requested key Ks_NAF, as well as the bootstrapping time and the lifetime of that key, and the requested application-specific and potentially NAF group specific USSs if they are available in subscriber's GUSS and if the NAF is authorized to receive the requested USSs. For any USSs containing a NAF Group attribute, this attribute shall be removed in the USSs supplied to the NAF. In addition, the BSF shall indicate to the NAF that the subscriber is a subscriber using SIP Digest credentials. If the key identified by the B-TID supplied by the NAF is not available at the BSF, the BSF shall indicate this in the reply to the NAF. The NAF then indicates a bootstrapping renegotiation request to the UE.\nNOTE 4:\tThe NAF can further set the local validity condition of the Ks_NAF according to the local policy, for example a limitation of reuse times of a Ks_NAF.\nNOTE 5:\tThe NAF will adapt the key material Ks_NAF to the specific needs of the reference point Ua in the same way as the UE did. This adaptation is outside the scope of the present document.\n-\tIf the NAF did not indicate that it is willing to accept a Ks_NAF based on GBA_Digest, or if the BSF determines according to its local policy that the NAF shall not serve subscribers using SIP Digest credentials, then the BSF shall not send a Ks_NAF based on GBA_Digest;\n-\tIf the NAF indicated that it is willing to accept a Ks_NAF based on GBA_Digest, but the B-TID refers to a key Ks established by using an AKA-based method, then the BSF shall send a key Ks_NAF derived from this Ks unless this Ks was derived from 2G GBA and the NAF does not accept 2G GBA (cf. NOTE 0);\n-\tThe BSF may require that one or more application-specific and potentially NAF group specific USSs shall be present in subscriber's GUSS for the NAF (see clause M.5.7). If one or more of these required settings are missing from the GUSS, the BSF shall indicate this in the reply to the NAF;\n-\tThe BSF may also send the private user identity (IMPI) and requested USSs to NAF according to the BSF's policy;\n- \tIf the NAF determines, according to its local policy, that the NAF shall not serve subscribers using SIP Digest credentials, the NAF shall terminate the protocol over the reference point Ua;\n-\tThe NAF should accept the Zn response even when the GBA_Digest indication is missing (as this means that the key Ks_NAF was derived from a key Ks established by using an AKA-based method, which is stronger), (cf. NOTE 0);\n-\tWhen the NAF receives the Zn response, it shall check that the GBA type in the Zn response corresponds with the GBA type negotiated over Ua protocol. If this is not the case, NAF shall terminate the protocol over the reference point Ua.\n4.\tNAF continues with the protocol used over the reference point Ua with the UE.\nOnce the run of the protocol used over reference point Ua is completed the purpose of bootstrapping is fulfilled as it enabled UE and NAF to use reference point Ua in a secure way.\nThe figure depicts the bootstrapping usage procedure, which is a crucial step in the process of creating a new network. It illustrates the steps taken to initialize the network by connecting the initial nodes and establishing a connection between them. The figure shows the network's topology, including the nodes, their connections, and the network's structure. This figure is essential for understanding the network's initial configuration and for planning future network expansions.\nFigure M.3: The bootstrapping usage procedure\nThe figure depicts a bootstrapping renegotiation request, which is a process in the context of network management and security. The request is initiated by a user, and the network responds with a bootstrapping request, which is then sent back to the user for further negotiation. This process is crucial in ensuring network security and maintaining network integrity.\nFigure M.4: Bootstrapping renegotiation request\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.6.5\tProcedure related to service discovery",
                    "description": "",
                    "summary": "",
                    "text_content": "The UE shall discover the address of the BSF from the IMPI related to the IMS subscription. When the IMPI was derived from an IMSI as defined in clause 13 of TS 23.003 [11] then the BSF address shall be derived as as specified in clause 16 of TS 23.003 [11] for the case of an IMSI, otherwise the BSF address shall be derived as as specified in clause 16 of TS 23.003 [11] for the case of an IMPI.\nNOTE:\tThe reason for this distinction is the NOTE in clause 16 of TS 23.003 [11] warning that BSF addresses of a certain form may be unreachable.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "M.7\tTLS Profile",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "M.7.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "The UE and the BSF shall support TLS according to the TLS profile given in TS 33.310 [19], Annex E.\nThe certificates shall comply with the requirements for TLS certificates in clause 6.1 of TS 33.310 [19].\nSupport of certificate revocation and of the related fields in certificates is optional. If supported, the certificate and CRL profiles in clauses 6.1 and 6.1a of TS 33.310 [19] should be followed.\nNOTE 1:\tThe management of Root Certificates is out of scope of the present document.\nNOTE 2:\tIf no revocation of certificates is deployed, it should be noted, however, that choosing short lifetimes for BSF certificates may considerably reduce the risk, in case BSF certificates may ever be compromised.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.7.2\tAuthentication of the BSF",
                    "description": "",
                    "summary": "",
                    "text_content": "The Client shall authenticate the BSF by use of a server certificate. If the BSF also supports 2G GBA under the same BSF address (cf. TS 23.003 [11]) it is recommended that this certificate be the same as the one used for BSF authentication in 2G GBA, cf. clause I.6.2. The client shall match the server name as specified in RFC 2818 [18], section 3.1.\nNOTE:\tIf the BSF addresses derived for the 2G GBA case and the GBA_Digest case differ, but the BSF is the same, then the operator can issue a BSF certificate with two server names or with a wildcard server name to ensure the client check of the server name works correctly, or the operator can issue two different BSF certificates.\nThe terminal shall use a preconfigured list of trusted root certificates for GBA_Digest BSF server certificate validation. It is recommended that this list be the same as the one used for 2G GBA BSF server certificate validation, cf. clause I.6.2. BSF server certificate validation shall not require manual user interaction.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.7.3\tAuthentication of the UE",
                    "description": "",
                    "summary": "",
                    "text_content": "The BSF shall not request a certificate in a Server Hello Message from the UE. The BSF shall authenticate the UE as specified in clause M.6.3.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "M.7.4\tSet-up of Security parameters",
                    "description": "",
                    "summary": "",
                    "text_content": "The TLS Handshake Protocol negotiates a session, which is identified by a Session ID. The Client and the BSF shall allow for resuming a session. The lifetime of a Session ID is subject to local policies of the UE and the BSF.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "N.1\tGeneral",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "N.1.1\tOverview",
                    "description": "",
                    "summary": "",
                    "text_content": "This Annex N describes support for SBA for GBA.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "N.1.2\tArchitectural Support",
                    "description": "",
                    "summary": "",
                    "text_content": "Figure N.1.2-1 shows the non-roaming architecture to support SBA interactions in GBA. An SBI capable BSF, HSS and NAF shall implement the SBA interfaces specified in this Annex. An SBI capable NF can invoke SBA services provided by SBI capable NFs and may expose services itself. For this Annex an SBI capable BSF uses and provides SBA services, an SBI capable HSS provides SBA services, a UDM provides SBA service, while an SBI capable NAF only uses SBA services. The BSF, HSS, UDM and NAF reside in the home network.\nIf there is no HSS or if the HSS does not support the N65 and Zh reference points within the GBA architecture, then the BSF shall be configured to use the N68 reference point with the UDM. If the N65 or Zh reference point is available in the HSS, then it shall be used between the BSF and the HSS.\n\nNOTE:\tGBA User Security Settings (GUSS) information is not sent over N68 reference point with UDM. If support of GUSS is desired in combination with the use of N68 reference point with UDM, then this can be achieved, for instance by storing the GUSS information in a BSF database (external and/or external to the node itself), or in any other network database which is deemed as appropriate for a specific deployment.\n\nFigure N.1.2-1: System Architecture to support SBA in GBA\nFigure N.1.2-2 shows the architecture using the reference point representation. It should be observed that this annex addresses only the specification of the N65 (between the BSF and HSS) , N68 (between the BSF and UDM) and N66 (between the NAF and BSF) reference point interfaces as SBA interfaces. The specification of Ua and Ub is not impacted by the introduction of the SBA interfaces between the NAF, BSF, UDM and HSS. Therefore, the UE interacts with the BSF and NAF as defined in the main body of this specification.\n\nFigure N.1.2-2: System Architecture to support SBA in reference point representation\nWith respect to roaming, the roaming requirements in clause 4.4.3 and the Zn-Proxy architecture in clause 4.1 are applicable for the case of SBA GBA.\nIn addition, the following requirements shall be followed in roaming scenarios:\n-\tThe SBI capable NAF shall support the legacy Zn interface towards the Zn-Proxy.\n-\tAn SBI capable BSF shall support the legacy Zn' interface.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "N.1.3\tReference point to support SBA in GBA",
                            "text_content": "The following reference points are realized by service-based interfaces in GBA:\nN65: Reference point between an SBI capable BSF and an SBI capable HSS.\nN66: Reference point between an SBI capable BSF and an SBI capable NAF.\nN68: Reference point between an SBI capable BSF and UDM\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "N.1.4\tService based interface to support SBA in GBA",
                            "text_content": "The following service-based interfaces are defined:\nNhss: Service-based interface exhibited by an SBI capable HSS.\nNbsp: Service-based interface exhibited by an SBI capable BSF.\nNudm: Service-based interface exhibited by UDM.\n\nThese SBI services provide equivalent functionality to the Diameter Zh and Zn reference points.\nTo support co-existence of GBA nodes supporting SBA services and GBA nodes not supporting SBA services SBI capable GBA nodes may support both SBI and non-SBI interfaces.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "N.2\tGAA/GBA SBA Services",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "N.2.1\tHSS Services",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "N.2.1.1\tGeneral",
                            "text_content": "An SBI capable HSS supports providing the authentication vectors and the subscription profile, i.e. GUSS, to an SBI capable BSF via service-based interfaces.\nThe following table shows the GBA services exposed by an SBI capable HSS.\nTable N.2.1.1-1: GBA Services provided by an SBI capable HSS\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table N.2.1.1-1: GBA Services provided by an SBI capable HSS",
                                    "table number": 1,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "N.2.1.2\tNhss_GbaSubscriberDataManagement (GbaSDM) service",
                            "text_content": "GBA Subscriber data types e.g. GUSS used in the Nhss_GbaSDM Service are defined in Table N.2.1.2.1-1 below.\nTable N.2.1.2.1-1: GBA Subscriber data types\n\nAt least a mandatory data key is required for each GBA Subscriber Data Type to identify the corresponding data as defined in Table N.2.1.2.1-2 below.\nTable N.2.1.2.1-2: GBA Subscriber data types keys\n\nService operation name: Nhss_GbaSDM_Get\nDescription: This service operation enables the NF consumer to fetch the GBA User Security for the end user.\nThe HSS shall check that the requested NF consumer is authorized to fetch the requested data.\nInputs, Required: NF Type, GBA Subscriber data type(s), Key for GBA Subscriber data type(s).\nInputs, Optional: None.\nOutputs, Required: Result indication.\nOutputs, Optional: Requested Data.\nService operation name: Nhss_GbaSDM_Subscribe\nDescription: The NF consumer subscribes for updates to requested data. HSS shall check that the requested NF consumer is authorized to subscribe to requested updates.\nInputs, Required: NF Type, GBA Subscriber data type(s), Key for GBA Subscriber data type(s).\nInputs, Optional: None.\nOutputs, Required: Result indication.\nOutputs, Optional: Subscription Data.\nService operation name: Nhss_GbaSDM_Unsubscribe\nDescription: The NF consumer unsubscribes for updates to Requested data.\nInputs, Required: GBA Subscriber data type(s), Key for GBA Subscriber data type(s).\nInputs, Optional: None.\nOutputs, Required: Result indication.\nOutputs, Optional: None.\nService operation name: Nhss_GbaSDM_Notification\nDescription: This service operation enables HSS to notify a NF of any changes to what the NF subscribed to.\nInputs, Required: GBA Subscriber data type(s), Key for each GBA Subscriber data type(s).\nInputs, Optional: None.\nOutputs, Required: Result indication.\nOutputs, Optional: None.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table N.2.1.2.1-1: GBA Subscriber data types",
                                    "table number": 2,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table N.2.1.2.1-2: GBA Subscriber data types keys",
                                    "table number": 3,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "N.2.1.3\tNhss_GbaUEAuthentication service",
                            "text_content": "Service operation name: Nhss_GbaUEAuthentication_Get\nDescription: This service operation is used between the BSF and the HSS to request the authentication data of the end user.\nInputs, Required: User Identity(-ies), Authentication Data (Authentication Scheme).\nUser Identity shall be one of IMSI, MSISDN, IMPI, IMPU. At least one of User Identities shall be presented.\nInputs, Optional: None.\nOutputs, Required: Result Indication.\nOutputs, Optional: User Identity, Authentication Data (e.g. AV).\nIn case only MSISDN or IMPU is present in the request, the HSS returns IMSI or IMPI in the response.\n\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "N.2.2\tUDM Services",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "N.2.2.1\tGeneral",
                            "text_content": "A UDM supports providing the GBA-AKA authentication vectors via the Nudm_UEAuthentication_GetGbaAv service operation.\nThe following table shows the services exposed by UDM supporting GBA.\n\nTable N.2.2.1-1: GBA Services provided by UDM\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table N.2.2.1-1: GBA Services provided by UDM",
                                    "table number": 4,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "N.2.2.2\tNudm_UEAuthentication Service",
                            "text_content": "Service operation name: Nudm_UEAuthentication_GetGbaAv\nDescription: This service operation is used by the BSF to fetch the authentication data for UE.\nInputs, Required: SUPI.\nInputs, Optional:\nOutputs, Required: GBA authentication vector\nOutputs, Optional:\nBSF needs to convert IMSI based IMPI to SUPI before invoking the Nudm_UEAuthentication_GetGbaAv service.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "N.2.3\tBSF Services",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "N.2.3.1\tGeneral",
                            "text_content": "The following table shows the services exposed by an SBI capable BSF.\nTable N.2.3.1-1: GBA Services provided by an SBI capable BSF\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table N.2.3.1-1: GBA Services provided by an SBI capable BSF",
                                    "table number": 5,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "N.2.3.2\tNbsp_Gba service",
                            "text_content": "This clause describes the SBA interfaces exposed by the BSF for the purpose of providing the bootstrap information to the NAF for the derivation of the application key material (e.g. Ks_(ext/int)_NAF).\nService operation name: Nbsp_Gba_BootstrapInfo\nDescription: This service operation is used between the BSF and the NAF to request the key material key material agreed during bootstrapping from the UE to the BSF. It is also used to fetch application-specific user security settings from the BSF, if requested by the NAF.\nInputs, Required: B-TID, NAF-Id.\nInputs, Optional: Flag to indicate that the NAF is GBA_U aware, identifier of the application-specific USS.\nOutputs, Required: Key material, bootstrapping time, key lifetime. The key material consists of Ks_NAF in case of GBA_ME and Ks_ext_NAF in case of GBA_U. The key lifetime is the lifetime associated to the key material.\nOutputs, Optional: Key material, Application-specific USS, Private Identity.\nNOTE 1: Depending on the value of the GBA_U aware flag, more key material (i.e. Ks_int_NAF) may be returned as optional output.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "N.2.4\tMapping of Zh, Zn operations and terminology to SBI services",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "N.2.4.1\tGeneral",
                            "text_content": "This clause gives mappings from Zh, Zn operations to SBI services and service operations.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "N.2.4.2\tMapping of Zh messages to HSS SBI services",
                            "text_content": "The following table defines the mapping between Zh messages and HSS SBI services and service operations:\nTable N.2.4.2-1: Zh messages to HSS SBI services and service operations mapping\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table N.2.4.2-1: Zh messages to HSS SBI services and service operations mapping",
                                    "table number": 6,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "N.2.4.3\tMapping of Zn messages to BSF SBI services",
                            "text_content": "The following table defines the mapping between Zn messages and BSF SBI services and service operations:\nTable N.2.4.3-1: Zn messages to BSF SBI services and service operations mapping\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table N.2.4.3-1: Zn messages to BSF SBI services and service operations mapping",
                                    "table number": 7,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "N.2.4.4\tMapping of Zh messages to UDM SBI services",
                            "text_content": "The following table defines the mapping between Zh messages and UDM SBI services and service operations:\nTable N.2.4.4 -1: Zh messages to UDM SBI services and service operations mapping\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table N.2.4.4 -1: Zh messages to UDM SBI services and service operations mapping",
                                    "table number": 8,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "title": "N.3\tSBI Capable NF Discovery and Selection",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "N.3.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "During the GBA procedures SBI capable network functions such as the BSF and NAF need to discover and select other SBI capable network functions such as the HSS or the UDM and the BSF respectively.\nIf there is no HSS or if the HSS does not support the N65 and Zh reference points within the GBA architecture, then the BSF shall be configured to discover and use SBA services of a UDM.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "N.3.2\tSBI Capable HSS Discovery and Selection",
                    "description": "",
                    "summary": "",
                    "text_content": "An SBI capable BSF performs discovery and selection of an SBI capable HSS. The SBI capable BSF shall utilize the NRF to discover an SBI capable HSS unless the information about SBI capable HSS instance(s) is available by other means, e.g. locally configured on the SBI capable BSF. The HSS selection function in SBI capable BSF entities selects an SBI capable HSS instance based on the available SBI capable HSS instances (obtained from the NRF or locally configured).\nAn SBI capable BSF always selects an SBI capable HSS within its own PLMN. The HSS selection should consider one of the following factors when available to the SBI capable BSF:\n1.\tHSS Group ID of the UE's user identity (IMSI/IMPI or MSISDN/IMPU).\n2.\tIMSI/IMPI; e.g. the SBI capable BSF selects an SBI capable HSS instance based on the IMSI/IMPI range the UE's IMSI/IMPI belongs to, configured locally or based on the results of a discovery procedure with NRF using the UE's IMSI/IMPI as input for HSS discovery.\n3.\tMSISDN/IMPU; e.g. the SBI capable BSF selects an SBI capable HSS instance based on the MSISDN/IMPU range the UE's IMSI/IMPU belongs to, configured locally or based on the results of a discovery procedure with NRF using the UE's MSISDN/IMPU as input for HSS discovery.\nUnless the information about the interface type to be used towards HSS is locally configured on the SBI capable BSF, an SBI capable BSF can also use the NRF to decide the type of interface (SBI vs diameter) to be used towards HSS similarly as defined for SBI capable IMS entities in TS 23.228 [65]. For this purpose, an SBI capable BSF can send a Nnrf_NFDiscovery_Request to NRF as defined in TS 23.502 [64] to discover SBI capable HSS instances within a given PLMN. The SBI capable BSF may store all returned SBI capable HSS instances and their NF profiles for subsequent use, including, if applicable, supported IMSI/IMPI and/or MSISDN/IMPU ranges, and/or HSS Group IDs. If no SBI capable HSS instance is available in the PLMN, then the NRF replies to the SBI capable BSF with no information. In this case, the SBI capable BSF may then attempt to communicate with the HSS using legacy GBA protocols.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "N.3.3\tSBI Capable BSF Discovery and Selection",
                    "description": "",
                    "summary": "",
                    "text_content": "An SBI capable NAF performs discovery and selection of an SBI capable BSF. The SBI capable NAF shall utilize the NRF to discover an SBI capable BSF unless the information about SBI capable BSF instance(s) is available by other means, e.g. locally configured on the SBI capable NAF. The BSF selection function in SBI capable NAF entities selects an SBI capable BSF instance based on the available SBI capable BSF instances (obtained from the NRF or locally configured).\nThe BSF selection in an SBI capable NAF shall consider the BSF server name included in the B-TID provided by the UE.\nUnless the information about the interface type to be used towards the BSF is locally configured on the SBI capable NAF, an SBI capable NAF can also use the NRF to decide the type of interface (SBI vs diameter) to be used towards BSF. For this purpose, an SBI capable NAF can send a Nnrf_NFDiscovery_Request to NRF as defined in TS 23.502 [64] to discover SBI capable BSF instances within a given PLMN. The SBI capable NAF may store all returned SBI capable BSF instances and their NF profiles for subsequent use. If no SBI capable BSF instance is available in the PLMN, then the NRF replies to the SBI capable NAF with no information. In this case, the SBI capable NAF may then attempt to communicate with the BSF using legacy GBA protocols.\nAn SBI capable NAF in a PLMN can serve both as an HPLMN NAF for non-roaming UEs or a VPLMN NAF for roaming UEs.\nUnless the information about the network function (BSF or Zn-Proxy) to be used is locally configured on the SBI capable NAF, the SBI capable NAF shall use the BSF server name in the B-TID to determine if the requested BSF is in the same PLMN or a different one. If the requested BSF is in a different PLMN the SBI capable NAF shall use the legacy Zn interface towards the Zn-Proxy. Otherwise the SBI capable NAF uses the procedures specified earlier in this clause.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "N.3.4\tUDM Discovery and Selection",
                    "description": "",
                    "summary": "",
                    "text_content": "See 3GPP TS 23.501 [66] clause 6.3.8.\nAnnex O (normative): \nGBA Ua protocol based on DTLS\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "O.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "This Annex covers the aspects specific to the GBA Ua protocol based on DTLS. This feature is optional to be supported for the UE and NAF. If the feature is supported, the following clauses apply.\nUE hosts the DTLS client. The DTLS client may reside in the ME or in the UICC or both might host an DTLS client independently of each other.\nThe UE should be able to indicate to the NAF which key (Ks_(ext)_NAF or Ks_int_NAF) the UE intends to or can use to secure the Ua reference point based on DTLS.\nDTLS should be supported by the NAF for the UE-NAF reference point (Ua).\nThe NAF should be able to require that a certain key (i.e., Ks_(ext)_NAF or Ks_int_NAF)  used to secure the Ua reference point based on DTLS.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "O.2\tShared key-based mutual authentication between UE and NAF",
                    "description": "",
                    "summary": "",
                    "text_content": "The TLS profile specified in TS 33.210 [13] clause 6.2 apply to DTLS 1.3[68].\nThe procedures and PSK identities given in clause 5.4.0.2 of TS 33.222[25] for TLS 1.3 are also applicable for DTLS 1.3, with the following changes.\nAt step 1, If the DTLS client resides in the ME, Ks_(ext)_NAF shall be used as the GBA shared key. If the DTLS client resides in the UICC, Ks_int_NAF shall be used as the GBA shared key.\nThe UE derives the DTLS premaster secret from the NAF specific key (Ks_(ext)_NAF if the initiating DTLS client resides on the ME or Ks_int_NAF if the initiating DTLS client resides on the UICC).\nPSK identities should be delivered via DTLS message.\nThis clause explains how a GBA-based shared secret that is established between the UE and the NAF is used with Pre-Shared Key (PSK) authentication in DTLS. It does not have any dependency on the application layer protocol.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "P.1\tGeneral",
            "description": "This annex describes how to secure access to NAF using Object Security for Constrained RESTful Environments (OSCORE) [69]. OSCORE is a lightweight security protocol protecting REST-based communication, designed for use with the Constrained Application Protocol (CoAP) [70]. OSCORE protects the CoAP payload and REST parameters such as URI path, media type and method (GET, PUT, POST, DELETE, etc.) but is independent of transport, which makes it suitable for securing application data across gateways and with interchanging transport. OSCORE, like CoAP, is designed for proxy operations to support constrained devices e.g. sleeping for long times to save power. OSCORE could be used instead of or in addition to security protocols at other layers, e.g. transport layer security between the core network and AF.\nIn the context of the GBA Ua protocol specified in this clause, the UE is assumed to be CoAP Client and the NAF is assumed to be CoAP Server.Figure P.1-1 shows a network model of the OSCORE GBA Ua protocol.\nThe figure depicts a network model of OSCORE in the context of GBA, illustrating the interconnection of various components such as the base station (gNB), user equipment (UE), and scatterers. The diagram highlights the use of beamforming techniques to mitigate interference, and the presence of redundancy paths to ensure failover reliability.\nFigure P.1-1: Network model of OSCORE in the context of GBA\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "P.2\tRequirements",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "P.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "This Annex covers the aspects specific to the GBA Ua protocol based on OSCORE. This feature is optional to be supported for the UE and NAF. If the feature is supported, the following clauses apply.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "P.2.2\tRequirements on the UE",
                    "description": "",
                    "summary": "",
                    "text_content": "To utilise GBA as described in this document the UE shall be equipped with an CoAP capable client implementing the particular features of GBA as specified in this document.\nThe support of OSCORE as a GBA Ua protocol for the UE is optional.\nThe UE hosts the CoAP client which supports OSCORE. The CoAP client supporting OSCORE may reside in the ME or in the UICC or both might host a CoAP client supporting OSCORE independently of each other. When the CoAP capable client supporting OSCORE to be used is in the ME, Ks_(ext)_NAF shall be used as the shared key between the UE and the NAF. When the CoAP capable client supporting OSCORE to be used is located in the UICC, Ks_int_NAF shall be used as the shared key between the UE and the NAF.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "P.2.3\tRequirements on the NAF",
                    "description": "",
                    "summary": "",
                    "text_content": "To utilise GBA as described in this document the NAF shall support the features of GBA as specified in this document.\nThe support of OSCORE as a GBA Ua protocol for the NAF is optional.\nIt shall be possible that the NAF is configured to restrict the access to the service based on which key is used, (e.g., access is allowed only for those CoAP capable clients supporting OSCORE that reside in the UICC and use Ks_int_NAF). The key selection indication given in the USS shall overrule the local policy of the NAF.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "P.2.4\tRequirements on the OSCORE",
                    "description": "",
                    "summary": "",
                    "text_content": "The requirements for OSCORE are described in IETF RFC 6813 [69]. OSCORE derives keys using an HMAC-based key derivation function (HKDF), and protects the communication using an authenticated encryption with additional data (AEAD) algorithm. The AEAD algorithm AES-CCM-16-64-128 defined in the IETF RFC 8152 [72] with 128-bit key, 13-byte nonce, and 64-bit tag is mandatory to implement, as is HKDF with SHA-256. Other algorithms may be specified in the optional OSC-INP parameter.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "P.3\tOSCORE as a GBA Ua protocol",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "P.3.3\tOSCORE Security context",
                    "description": "",
                    "summary": "",
                    "text_content": "The OSCORE security context consists of the following parts:\n-\tOSCORE Master Secret (OMS): A shared key between the CoAP Client and CoAP Server.\n-\tMaster Salt: A shared salt shared between the CoAP Client and CoAP Server.\n-\tUE-SID: The UE Sender Identifier\n-\tNAF-SID: The NAF Sender Identifier\n-\tOSCORE Version: The version of the OSCORE protocol\n-\tHKDF: HMAC-based Key Derivation Function\n-\tAEAD Algorithm: The algorithm used for encryption and integirty protection\n-\tOSCORE ID Context: An identifier which identifies the OSCORE context\n\nThe OSCORE security context for the OSCORE Ua protocol shall have the following values:\n-\tOMS = OSCORE Master Secret = HKDF(Ks_(int/ext)_NAF, \"GBA-OSCORE\"), where Ks_(int/ext)_NAF is the shared key between the UE and NAF and it follows the semantics of this document for GBA i.e. Ks_(int/ext)_NAF refers to Ks_NAF from GBA_ME, Ks_int_NAF or Ks_ext_NAF from GBA_U.\n-\tMaster Salt =  Request Payload | Response Payload\n-\tUE Sender ID = UE-SID generated by CoAP Server and sent to the CoAP Client in the Application Response (Step 3 in clause P.3.2)\n-\tNAF Sender ID = NAF-SID generated by CoAP Client and sent to the CoAP Server in the Application Request (Step 1 in clause P.3.2)\nwhere HKDF shall be the HMAC-based Key Derivation Function specified in IETF RFC 5869 [73]\nThe other OSCORE parameters in the OSCORE security context shall have default values unless superseded by the optional parameter OSC-INP provided by the CoAP Client in Step 1 in clause P.3.2. The default values of the rest of the OSCORE parameters in the OSCORE security context are:\n-\tOSCORE Version: default version 1\n-\tHKDF: default HKDF with SHA-256\n-\tAEAD Algorithm: default AES-CCM-16-64-128\n-\tOSCORE ID Context: default nil\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "P.3.4\tRefresh of OSCORE key material",
                    "description": "",
                    "summary": "",
                    "text_content": "OSCORE allows both the communication endpoints (UE or NAF) to renegotiate the OSCORE security context after the OSCORE security context is established, according to Appendix B.2 in IETF RFC 8613 [69] , which is shown in the figure P.3.4-1, alaternative A1.\nFurthermore since the OSCORE master secret is derived from the Ks_(int/ext)_NAF and since GBA includes a separate bootstrapping protocol (Ub) the OSCORE key material can be refreshed by refreshing the Ks_(int/ext)_NAF key. As a result the NAF may respond to the UE that a new Ks_(int/ext)_NAF is needed by initiating an explict request or a respond to a UE request with an indicator \"Ub bootstrapping required\". Upon sending such explicit message or response to the UE, the NAF shall teminate any ongoing OSCORE session. Upon receiving such indicator the UE shall terminate any current ongoing OSCORE session and UE shall run the Ub bootstrapping and re-establish the OSCORE application session, figure P.3.4-1, alternative steps A2.\nThe figure depicts a key refresh process in an OSCORE system, illustrating the steps involved in updating the system's key. The process is crucial for maintaining the security and integrity of the system.\nFigure P.3.4-1: OSCORE key refresh\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "P.3.5\tOSCORE Ua protocol payload encoding",
                    "description": "",
                    "summary": "",
                    "text_content": "IETF CoAP and OSCORE shall use the IETF Concise Binary Object Representation (CBOR) specified in the IETF RFC 8949 [71] for payload encoding for efficient information transfer between constrained IoT devices.\nThe CoAP media type for CBOR encoding shall be:\n-\tMedia Type: application/cbor\n-\tCoAP Content-Format: 60\nThe Request Payload in the Application Request message shall be formatted as a CBOR Array as follows:\nRequest Payload = [\n      B-TID : tstr,\n      KISS list: bstr,\n      N1 : bstr, \n      NAF-SID : bstr, \n      ? OSC-INP: bstr\n]OSC-INP = {           //CBOR Map\n      ? 1 => int,\t   ; version \n      ? 3 => int,\t   ; hkdf \n      ? 4 => int,   ; alg \n      ? 5 => bstr, ; salt \n      ? 6 => bstr \t; contextId\n}\nNOTE 1:\tThe KISS list is an octet with value equal to logical OR of the different KISS values that the UE supports.\nThe Response Payload in the Application Answer shall be formatted as a CBOR Array as follows:\nRequest Payload = [\n      B-TID : tstr,\n      Selected KISS: bstr,\n      N1 : bstr, \n      NAF-SID : bstr, \n      ? OSC-INP: bstr\n]OSC-INP = {\n      ? 1 => int,\t   ; version \n      ? 3 => int,\t   ; hkdf \n      ? 4 => int,   ; alg \n      ? 5 => bstr, ; salt \n      ? 6 => bstr \t; contextId\n\n\n",
                    "tables": [
                        {
                            "description": "",
                            "table number": 9,
                            "summary": "",
                            "name": ""
                        },
                        {
                            "description": "",
                            "table number": 10,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        }
    ]
}