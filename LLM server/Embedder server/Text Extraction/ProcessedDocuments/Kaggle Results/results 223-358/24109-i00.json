{
    "document_name": "24109-i00.docx",
    "content": [
        {
            "title": "Foreword",
            "description": "This Technical Specification has been produced by the 3rd Generation Partnership Project (3GPP).\nThe contents of the present document are subject to continuing work within the TSG and may change following formal TSG approval. Should the TSG modify the contents of the present document, it will be re-released by the TSG with an identifying change of release date and an increase in version number as follows:\nVersion x.y.z\nwhere:\nx\tthe first digit:\n1\tpresented to TSG for information;\n2\tpresented to TSG for approval;\n3\tor greater indicates TSG approved document under change control.\ny\tthe second digit is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc.\nz\tthe third digit is incremented when editorial only changes have been incorporated in the document.\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "1\tScope",
            "description": "The present document defines stage 3 for the HTTP Digest AKA as specified in RFC 3310 [6] based implementation of Ub interface (UE-BSF), the Disposable-Ks model based implementation of Upa interface (NAF-UE) and the HTTP Digest as specified in RFC 7616 [36] and the PSK TLS based implementation of bootstrapped security association usage over Ua interface (UE-NAF) in Generic Authentication Architecture (GAA) as specified in 3GPP TS 33.220 [1]. The purpose of the Ub interface is to create a security association between UE and BSF for further usage in GAA applications. The purpose of the Upa interface is to provide a push mechanism to created a bootstrapped security association between the UE and NAF for secure communication of pushed messages. The purpose of the Ua interface is to use the so created bootstrapped security association between UE and NAF for secure communication.\nThe present document also defines stage 3 for the Authentication Proxy usage as specified in 3GPP TS 33.222 [5].\nThe present document also defines stage 3 for the subscriber certificate enrolment as specified in 3GPP TS 33.221 [4] which is one realization of the Ua interface. The subscriber certificate enrolment uses the HTTP Digest based implementation of bootstrapped security association usage to enrol a subscriber certificate and the delivery of a CA certificate.\nThe present document also defines stage 3 for TLS using AKMA (Authentication and Key Management for Applications) keys over the Ua* interface (AKMA AF-UE) as described in 3GPP TS 33.535 [38].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "2\tReferences",
            "description": "The following documents contain provisions, which, through reference in this text, constitute provisions of the present document.\n-\tReferences are either specific (identified by date of publication, edition number, version number, etc.) or non-specific.\n-\tFor a specific reference, subsequent revisions do not apply.\n-\tFor a non-specific reference, the latest version applies. In the case of a reference to a 3GPP document (including a GSM document), a non-specific reference implicitly refers to the latest version of that document in the same Release as the present document.\n[1]\t3GPP TS 33.220: \"Generic Authentication Architecture (GAA); Generic bootstrapping architecture\".\n[2]\t3GPP TR 33.919: \"Generic Authentication Architecture (GAA); System description\".\n[3]\t3GPP TS 29.109: \"Generic Authentication Architecture (GAA); Zh and Zn Interfaces based on the Diameter protocol; Protocol details\".\n[4]\t3GPP TS 33.221: \"Generic Authentication Architecture (GAA); Support for Subscriber Certificates\".\n[5]\t3GPP TS 33.222: \"Generic Authentication Architecture (GAA); Access to network application functions using Hypertext Transfer Protocol over Transport Layer Security (HTTPS)\".\n[6]\tIETF RFC 3310: \"Hypertext Transfer Protocol (HTTP) Digest Authentication Using Authentication and Key Agreement (AKA)\".\n[7]\t3GPP TS 23.003: \"Numbering, addressing and identification\".\n[8]\tIETF RFC 3023: \"XML Media Types\".\n[9]\tVoid.\n[10]\tVoid.\n[11]\tVoid.\n[12]\tVoid.\n[13]\t3GPP TS 24.228 Release 5: \"Signalling flows for the IP multimedia call control based on Session Initiation Protocol (SIP) and Session Description Protocol (SDP); Stage 3\".\n[14]\tVoid.\n[15]\tVoid.\n[16]\tPKCS#10 v1.7: \"Certification Request Syntax Standard\".\nNOTE:\n[17]\tWAP Forum: \"WPKI: Wireless Application Protocol; Public Key Infrastructure Definition\"\nNOTE:\t.\n[18]\tVoid.\n[19]\tOpen Mobile Alliance: \"ECMAScript Crypto Object\"\nNOTE:\t.\n[20]\tOpen Mobile Alliance: \"WPKI\"\nNOTE:\t.\n[21]\t3GPP TS 33.203: \"3G security; Access security for IP-based services\".\n[22]\tIETF RFC 2234: \"Augmented BNF for Syntax Specifications: ABNF\".\n[23]\tVoid.\n[24]\t3GPP TS 33.223: \"Generic Authentication Architecture (GAA); Generic Bootstrapping Architecture (GBA) Push function\".\n[25]\t3GPP TS 33.310: \"Network Domain Security (NDS); Authentication Framework (AF)\".\n[26]\tOpen Mobile Alliance Push Enabler Release v2.2: \"Push Over the Air\".\nNOTE:\t.\n[27]\tOpen Mobile Alliance Push Enabler Releasev 2.2: \"Push Message Specification\".\nNOTE:\t.\n[28]\tOpen Mobile Alliance Device Management Enabler Release v1.2: \"Enabler Release Definition for OMA Device Management\".\nNOTE:\t.\n[29]\t3GPP TS 33.303: \"Proximity-based Services (ProSe); Security aspects\".\n[30]\tIETF RFC 9112: \"HTTP/1.1\".\n[31]\tIETF RFC 9110: \"HTTP Semantics\".\n[32]\tVoid.\n[33]\tVoid.\n[34]\tIETF RFC 9111: \"HTTP Caching\".\n[35]\tVoid.\n[36]\tIETF RFC 7616: \"HTTP Digest Access Authentication\".\n[37]\tIETF RFC 4648: \"The Base16, Base32, and Base64 Data Encodings\".\n[38]\t3GPP TS 33.535: \"Authentication and Key Management for Applications (AKMA) based on 3GPP credentials in the 5G System (5GS)\".\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "3\tDefinitions and abbreviations",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "3.1\tDefinitions",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the following terms and definitions apply.\nBootstrapping information: set of parameters that have been established during bootstrapping procedure\nThe information consists of a bootstrapping transaction identifier (B-TID), key material (Ks), and a group of application specific security parameters related to the subscriber.\nBootstrapped security association: association between a UE and a BSF that is established by running bootstrapping procedure between them. The association is identified by a bootstrapping transaction identifier (B-TID) and consists of bootstrapping information.\nCA certificate: The Certificate Authority public key is itself contained within a certificate, called a CA certificate. The CA sign all certificates that it issues with the private key that corresponds to the public key in the CA certificate.\nDelivery of CA certificate: procedure during which UE requests a root certificate from PKI portal, who delivers the certificate to the UE. The procedure is secured by using GBA.\nPKI portal: certification authority (or registration authority) operated by a cellular operator\nReverse proxy: a reverse proxy is a gateway for servers, and enables one server (i.e., reverse proxy) to provide content from another server transparently, e.g., when UE's request for a particular information is received at a reverse proxy, the reverse proxy is configured to request the information from another server. The reverse proxy functionality is transparent to the UE, i.e., the UE does not know that the request is being forwarded to another server by the reverse proxy.\nRoot certificate: a certificate that an entity explicitly trusts, typically a self-signed CA certificate\nSubscriber certificate: certificate issued to a subscriber\nIt contains the subscriber's own public key and possibly other information such as the subscriber's identity in some form.\nSubscriber certificate enrolment: procedure during which UE sends certification request to PKI portal and who issues a certificate to UE. The procedure is secured by using GBA.\nWAP Identity Module (WIM): used in performing WTLS, TLS, and application level security functions, and especially, to store and process information needed for user identification and authentication\nThe WPKI may use the WIM for secure storage of certificates and keys (see 3GPP TS 33.221 [4], OMA ECMAScript [19], and OMA WPKI [20] specifications).\nFor the purposes of the present document, the following terms and definitions given in 3GPP TS 33.220 [1] apply:\nTemporary IP Multimedia Private Identity\nFor the purposes of the present document, the following terms and definitions given in 3GPP TS 33.223 [24] apply:\nDisposable-Ks model\nPush-message\nPush-NAF\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "3.2\tAbbreviations",
                    "description": "",
                    "summary": "",
                    "text_content": "For the purposes of the present document, the following abbreviations apply:\nA-KID\tAKMA Key IDentifier\nAKA\tAuthentication and Key Agreement\nAKMA\tAuthentication and Key Management for Applications\nAP\tAuthentication Proxy\nAS\tApplication Server\nAUTN\tAuthentication Token\nAUTS\tRe-synchronisation Token\nAV\tAuthentication Vector\nBSF\tBootStrapping Function\nB-TID\tBootstrapping - Transaction IDentifier\nCA\tCertification Authority\nCK\tConfidentiality Key\nDER\tDistinquished Encoding Rules\nFQDN\tFully Qualified Domain Name\nGAA\tGeneric Authentication Architecture\nGBA\tGeneric Bootstrapping Architecture\nGBA_ME\tME-based GBA\nGBA_U\tGBA with UICC-based enhancements\nGPI\tGBA Push Info\nGUSS\tGBA User Security Settings\nHSS\tHome Subscriber System\nHTTP\tHypertext Transfer Protocol\nHTTPS\tHTTP over TLS\nIK\tIntegrity Key\nIMPI\tIP Multimedia Private Identity\nIMPU\tIP Multimedia PUblic identity\nKs\tKey material\nKs_NAF\tNAF specific key material\nMAC\tMessage Authentication Code\nME\tMobile Equipment\nNAF\tNetwork Application Function\nPKCS\tPublic-Key Cryptography Standards\nPKI\tPublic Key Infrastructure\nPSK\tPre-Shared Secret\nRAND\tRANDom challenge\nRES\tauthentication Response\nSA\tSecurity Association\nSQN\tSeQuence Number\nTLS\tTransport Layer Security\nTMPI\tTemporary IP Multimedia Private Identity\nUE\tUser Equipment\nUICC\tUniversal Integrated Circuit Card\nURI\tUniform Resource Identifier\nURN\tUniform Resource Name\nUSIM\tUser Service Identity Module\nUSS\tUser Security Settings\nUTC\tCoordinated Universal Time\nWIM\tWireless Identity Module\nWPKI\tWireless PKI\nWTLS\tWireless Transport Layer Security\nXRES\tExpected authentication response\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "4\tGeneric Bootstrapping Architecture; Ub interface",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "4.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "Generic Authentication Architecture (GAA) is based on shared secrets provided by generic bootstrapping architecture (GBA). The stage 2 description of GAA framework is described in 3GPP TR 33.919 [2] and the GBA procedures in 3GPP TS 33.220 [1].\nThe GBA related to the Ub interface is between the UE and bootstrapping server function (BSF). During the bootstrapping procedure BSF also uses the Zh interface to request authentication vectors from HSS. The Zh interface is defined in 3GPP TS 29.109 [3]. The end result of the bootstrapping procedure is that both BSF and an UE have a security association in a form of a bootstrapping transaction identifier (B-TID) and key material (Ks).\nAccording to 3GPP TS 33.220 [1] the bootstrapping procedure shall be based on HTTP Digest AKA as described in RFC 3310 [6]. The protocol stack of the Ub interface in bootstrapping procedure is presented in figure 4.1-1. The details are defined in the following clauses.\nThe figure depicts the protocol stack of the Ub interface, illustrating the various components and their interactions. The diagram includes the protocol stack, which includes the Ub interface, the network layer, the transport layer, the application layer, and the user interface. The figure also shows the network layer, which includes the network protocol stack, the network interface, and the network layer protocol stack. The transport layer includes the transport protocol stack, the transport interface, and the transport layer protocol stack. The application layer includes the application protocol stack, the application interface, and the application layer protocol stack. The user interface includes the user interface protocol stack, the user interface interface, and the user interface layer protocol stack.\nFigure 4.1-1: Protocol stack of Ub interface\nThe bootstrapping procedure described in the present document can result to different key materials depending on whether ME-based or UICC-based GBA is used. However, the bootstrapping procedure itself is the same for both ME-based GBA (GBA_ME), and UICC-based GBA (GBA_U).\nThe bootstrapping procedure can also be based on SIM, i.e., 2G GBA. The 2G GBA bootstrapping procedure is specified in annex H.\nThe bootstrapping procedures can also be based on GBA_Digest. The GBA_Digest bootstrapping procedures is specified in annex I.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.2\tBootstrapping procedure",
                    "description": "",
                    "summary": "",
                    "text_content": "The UE shall initiate the bootstrapping procedure when:\na)\tthe UE wants to interact with a NAF and bootstrapping is required;\nb)\ta NAF has requested bootstrapping required indication as described in clause 5.2.4 or bootstrapping renegotiation indication as described in clause 5.2.5; or\nc)\tthe lifetime of the key has expired in the UE if one or more applications are using that key.\nA UE and the BSF shall establish bootstrapped security association between them by running bootstrapping procedure. Bootstrapping security association consists of a bootstrapping transaction identifier (B-TID) and key material Ks. Bootstrapping session on the BSF also includes security related information about subscriber (e.g. user's private identity). Bootstrapping session is valid for a certain time period, and shall be deleted in the BSF when the session becomes invalid.\nBootstrapping procedure shall be based on HTTP Digest AKA as described in 3GPP TS 33.220 [1] and in RFC 3310 [6] with the modifications described below.\nThe BSF address is derived from the IMPI or IMSI according to 3GPP TS 23.003 [7].\nA UE shall indicate to the BSF that it supports the use of TMPI as defined in 3GPP 33.220 [1] by including a \"product\" token in the \"User-Agent\" header field (cf. RFC 9110 [31]) that is set to a static string \"3gpp-gba-tmpi\" in HTTP requests sent to the BSF.\nA BSF shall indicate to the UE that it supports the use of  TMPI as defined in 3GPP 33.220 [1] by including a \"product\" token in the \"Server\" header field (cf. RFC 9110 [31]) that is set to a static string \"3gpp-gba-tmpi\" in HTTP responses sent to the UE.\nIn the bootstrapping procedure, Authorization, WWW-Authenticate, and Authentication-Info HTTP headers shall be used as described in RFC 3310 [6] with following exceptions:\na)\tthe \"realm\" parameter shall contain the network name where the username is authenticated;\nb)\tthe quality of protection (\"qop\") parameter shall be \"auth-int\"; and\nc)\tthe \"username\" parameter shall contain user's private identity (IMPI).\nNOTE:\tIf the UE does not have an ISIM application with an IMPI, the IMPI will be constructed from IMSI, according to 3GPP TS 23.003 [7].\nIn addition to RFC 3310 [6], the following apply:\na)\tIn the initial request from the UE to the BSF, the UE shall include Authorization header with following parameters:\n-\tthe username directive, set to\n1)\tthe value of the TMPI if one has been associated with the private user identity as described in 3GPP 33.220 [1]; or\n2)\tthe value of the private user identity;\n-\tthe realm directive, set to the BSF address derived from the IMPI or IMSI according to 3GPP TS 23.003 [7];\n-\tthe uri directive, set to either absoluteURL \"http://<BSF address>/\" or abs_path \"/\", and which one is used is specified in RFC 7616 [36];\n-\tthe nonce directive, set to an empty value; and\n-\tthe response directive, set to an empty value;\nb)\tIn the challenge response from the BSF to the UE, the BSF shall include parameters to WWW-Authenticate header as specified in RFC 3310 [6] with following clarifications:\n-\tthe realm directive, set to the BSF address derived from the IMPI or IMSI according to 3GPP TS 23.003 [7];\nc)\tIn the message from the BSF to the UE, the BSF shall include bootstrapping transaction identifier (B-TID) and the key lifetime to an XML document in the HTTP response payload. The BSF may also include additional server specific data to the XML document. The XML schema definition of this XML document is given in annex C.\nd)\tWhen responding to a challenge from the BSF, the UE shall include an Authorization header containing a realm directive set to the value as received in the realm directive in the WWW-Authenticate header.\ne)\tAuthentication-Info header shall be included into the subsequent HTTP response after the BSF concluded that the UE has been authenticated. Authentication-Info header shall include the \"rspauth\" parameter.\nAfter successful bootstrapping procedure the UE and the BSF shall contain the key material (Ks) and the B-TID. The key material shall be derived from AKA parameters as specified in 3GPP TS 33.220 [1]. In addition, BSF shall also contain a set of security specific attributes related to the UE.\nAn example flow of successful bootstrapping procedure can be found in clause A.3.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.3\tUser authentication failure",
                    "description": "",
                    "summary": "",
                    "text_content": "If the response returned by the UE is different than expected, the BSF may challenge the UE again with a new AKA challenge. After N consecutive incorrect responses from the UE, the BSF shall indicate a failure to the UE. The exact value of N is defined by local policy.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.4\tNetwork authentication failure",
                    "description": "",
                    "summary": "",
                    "text_content": "In case the UE fails at authenticating the network, the UE shall abort the bootstrapping procedure.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4.5\tSynchronization failure",
                    "description": "",
                    "summary": "",
                    "text_content": "If the UE considers the sequence number in the challenge not to be in the correct, the UE shall send a synchronization failure indication back to the BSF as specified RFC 3310 [6].\nAn example flow can be found in clause A.4.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "4A\tGeneric Bootstrapping Achitecture Push; Upa",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "4A.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "Generic Authentication Architecture (GAA) is based on shared secrets provided by generic bootstrapping architecture (GBA). The stage 2 description of GAA framework is described in 3GPP TR 33.919 [2] and the GBA-Push procedures in 3GPP TS 33.223 [24].\nThe GBA-Push related to the Upa interface is between a NAF and UE. GBA-Push is a mechanism to bootstrap the security between a NAF and a UE, without forcing the UE to contact the BSF to initiate the bootstrapping. GBA-Push is closely related to and builds upon GBA as specified in 3GPP TS 33.220 [1]. GBA-Push is intended for both GBA_U and GBA_ME environments. The end result of the bootstrapping procedure is that the NAF and the UE have security associations, called NAF SAs, in the form of unique identifiers for uplink and downlink references and NAF-key material as defined in 3GPP TS 33.223 [24]. The unique identifiers take the following forms:\nRAND@'naf':\tIdentifies NAF SA in the UE (used by NAF).\nValue of P-TID:\tIdentifies NAF SA in the NAF (used by UE).\nThe GBA-Push procedure shall be based on a disposable-Ks model as described in 3GPP TS 33.223 [24]. The protocol stack of the Upa interface in GBA-Push procedure is presented in figure 4A.1-1. The details are defined in the following clauses.\nThe figure depicts the protocol stack of the Upa interface, illustrating the various components and their interactions.\nFigure 4A.1-1: Protocol stack of Upa interface\nThe bootstrapping procedure described in the present document can result in different key materials depending on whether ME-based or UICC-based GBA is used. However, the bootstrapping procedure over Upa interface itself is the same for both ME-based GBA (GBA_ME), and UICC-based GBA (GBA_U).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4A.2\tBootstrapping procedure",
                    "description": "",
                    "summary": "",
                    "text_content": "The Push-NAF may initiate the bootstrapping procedure when:\na)\tthe UE is registered for the intended service; and\nb)\tthe UE does not or can not perform a bootstrapping procedure directly with the BSF.\nAccording to local policy, the Push-NAF may refresh the NAF SA before the expiry time of the NAF SA.\nA Push-NAF and UE shall establish the NAF SA between them by running the bootstrapping procedure. The NAF SA consists of a NAF SA identifier, NAF-key material and. additional information as defined in 3GPP TS 33.223 [24]. The NAF SA is only valid for a certain time period, as determined by the NAF-key lifetime, and shall be deleted in the Push-NAF when the session expires.\nThe bootstrapping procedure shall be based on disposable Ks model and GBA-Push-Info (GPI) as defined in 3GPP TS 33.223 [24]. The Push-NAF pushes the GPI to the UE. The processing of GPI is defined in 3GPP TS 33.223 [24].\nNo specific transport method is mandated for transport of the GPI from the Push-NAF to the UE. However, when using specific transport methods, the transport address shall be determined as described in table 4A.2.1.\nTable 4A.2.1: Transport addresses for Push message from Push-NAF to UE\n\nAnnex J specifies the protocol details when using WAP Push via SMS for the transport of the GPI from the Push-NAF to the UE.\nAfter a successful bootstrapping procedure and processing of the GPI, the UE and the Push-NAF have established NAF SAs as described in 3GPP TS 33.223 [24].\nAn example flow of a successful bootstrapping procedure can be found in clause A1.3.\n",
                    "tables": [
                        {
                            "description": "Table 4A.2.1: Transport addresses for Push message from Push-NAF to UE",
                            "table number": 1,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4A.3\tUser authentication failure",
                    "description": "",
                    "summary": "",
                    "text_content": "User authentication is not applicable to GBA Push since all messages over the Upa interface are network initiated.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4A.4\tNetwork authentication failure",
                    "description": "",
                    "summary": "",
                    "text_content": "In case the UE fails to authenticate the network, the UE shall abort the bootstrapping procedure.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "4A.5\tSynchronization failure",
                    "description": "",
                    "summary": "",
                    "text_content": "A disposable Ks model is used for GBA Push in order to avoid many synchronization problems. One situation when an out-of-synch problem will appear even with the adoption of the disposable Ks model is when the BSF may erase a valid Ks while the UE keeps it due to that the GBA Push message can not be validated at the UE. This will lead to an error situation if the UE tries to use a NAF specific key (Ks_(ext/int)_NAF) which is derived from such a Ks.\nWhen this situation occurs, the Push-NAF will receive an error message from the BSF indicating that the Ks_(ext/int)_NAF (indicated by B-TID) is not available. The Push-NAF shall send this error message to the terminal. Upon receipt of the error message, indicating that the NAF specific key material is not available at the BSF, the UE shall perform a new bootstrap.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "5\tNetwork application function; Ua interface",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "5.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "The usage of bootstrapped security association i.e. B-TID and Ks_NAF (or Ks_ext_NAF or Ks_int_NAF) over Ua interface depends on the application protocol used between UE and NAF.\nThe Ua interface is used to supply the B-TID, generated during the bootstrapping procedure, to the network application function (NAF), and Zn interface is used by the NAF to retrieve the Ks_NAF or Ks_ext_NAF or Ks_int_NAF from BSF. The default is the use of Ks_(ext)_NAF, but the usage of Ks_int_NAF in Ua interface is possible. The Ua interface depends on type of NAF. The Zn interface is defined in 3GPP TS 29.109 [3]. This clause describes how B-TID and Ks_NAF or Ks_ext_NAF or Ks_int_NAF can be utilized, as specified in 3GPP TS 33.220 [1], and in the context of more specific Ua usage, as specified for deployment of HTTPS in 3GPP TS 33.222 [5], or for a PKI portal in 3GPP TS 33.221 [4]).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "5.2\tHTTP Digest authentication",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.2.1\tGeneral",
                            "text_content": "The HTTP Digest authentication model as described in RFC 7616 [36] can be used with bootstrapped security association as the authentication and integrity protection method, if the application protocol used over Ua interface between UE and NAF is based on HTTP (see RFC 9112 [30], RFC 9110 [31] and RFC 9111 [34]). The HTTP Digest authentication may be used for all protocols that have adopted the HTTP authentication framework to mutually authenticate the UE and the NAF, and also optionally integrity protect any payload being transferred between them.\nThe UE shall indicate to an application server (i.e. a NAF) that it supports 3GPP-bootstrapping based HTTP Digest authentication by including a \"product\" token to the \"User-Agent\" header (cf. RFC 9110 [31]) in outgoing HTTP requests. If the UE supports\na)\tAKA-based authentication, then the \"product\" token is a static string \"3gpp-gba\" if the HTTP client application resides in the ME, or \"3gpp-gba-uicc\" if the HTTP client application resides in the UICC; or\nb)\tGBA_Digest, then the \"product\" token is \"3gpp-gba-digest\".\nThe UE may indicate multiple GBA modes by inserting multiple \"product\" tokens in the User-Agent header field. The User-Agent header field with GBA related \"product\" tokens shall be added to each outgoing HTTP request if the UE supports GBA-based authentication using HTTP Digest.\nUpon receiving  GBA related \"product\" tokens, the application server if it supports NAF functionality may decide to authenticate the UE using GBA-based shared secret by executing the authentication procedure. If multiple GBA modes have been indicated in the User-Agent header field, then the NAF selects one GBA mode and indicates the selected mode in responses to the UE in the \"realm\" parameter of the WWW-Authenticate header field. In the selection of the GBA mode by the UE, AKA-based modes shall take priority over GBA_Digest.\nThe protocol stack of the Ua interface when HTTP Digest authentication is used is presented in figure 5.2-1. The details are defined in the following clauses.\nHTTP is a widely-used protocol for transmitting data over the internet, but it is not the only protocol that can be used. Other protocols, such as SMTP, FTP, and POP3, can also be used as long as they have adopted the HTTP authentication framework. This framework ensures secure communication and prevents unauthorized access to the data being transmitted.\nNOTE:\tHTTP is not the only protocol that can be used. Other protocols can also be used as long as the protocol has adopted the HTTP authentication framework.\nFigure 5.2-1: Protocol stack of Ua interface with HTTP Digest authentication\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.2\tAuthentication procedure",
                            "text_content": "HTTP Digest authentication as specified in RFC 7616 [36] shall be used with previously bootstrapped security association as follows:\n1)\tthe \"username\" parameter shall be the bootstrapping transaction identifier (B-TID);\n2)\tthe password used in the digest calculations shall be\na)\tin case of GBA_ME the NAF specific key material (Ks_NAF);\nb)\tin case of GBA_U the NAF specific ME based key material (Ks_ext_NAF) or the NAF specific UICC-based key material (Ks_int_NAF);and\nc)\tin case of GBA_Digest the NAF specific key material (Ks_NAF);\nNOTE:\tThe NAF specific key material (Ks_NAF or Ks_ext_NAF or Ks_int_NAF) is derived from the key material (Ks) using key derivation function as specified in 3GPP TS 33.220 [1].\nThe NAF specific key material (Ks_NAF or Ks_ext_NAF or Ks_int_NAF) is Base64 encoded as specified in RFC 4648 [37].\n3\tthe \"realm\" parameter shall contain two parts delimited by \"@\" sign. The first part is the constant string \"3GPP-bootstrapping\" (in case of a ME-based application) , \"3GPP-bootstrapping-uicc\" (in case of a UICC-based application) or \"3GPP-bootstrapping-digest \" (in case of GBA_Digest), and the latter part shall be the FQDN of the NAF (e.g. \"3GPP-bootstrapping@naf1.operator.com\" or \"3GPP-bootstrapping-uicc@naf1.operator.com\" or \"3GPP-bootstrapping-digest@naf1.operator.com\").\nIn the case of GBA_U, the NAF shall indicate to the UE which NAF specific key was selected to be used by setting the first part of the realm to  \"3GPP-bootstrapping\" (for the ME-based key i.e. Ks_ext_NAF), or to \"3GPP-bootstrapping-uicc\" (for the UICC-based key i.e. Ks_int_NAF).\nBoth the UE and the NAF shall verify upon receiving each of the HTTP responses and HTTP requests that the second part of the realm attribute is equal to the FQDN of the NAF.\nIn the case of GBA_U, if the HTTPS client application resides in the ME, then the application shall use only the ME-based key i.e. Ks_ext_NAF (the UICC-based key Ks_int_NAF is not available in the ME). If the NAF indicates to the ME-based HTTPS client application that only UICC-based key shall be used, the application must terminate the communication with the NAF. If the HTTP client application resides in the UICC, then the application shall use only the UICC-based key. If the NAF indicates to the UICC-based application that only ME-based key shall be used, the application must terminate the communication with the NAF.\nIn the case of GBA_U, the operator may indicate the type of the key to be used in the Ua reference point in the NAF specific USS as specified in 3GPP TS 29.109 [3]. If the NAF has requested an application specific USS, and the indication is present in the USS, the NAF shall use the indicated key type. If the type of the negotiated key is different from the type indicated in the USS, the NAF shall terminate the communication with the UE.\nAn example flow of a successful HTTP Digest authentication procedure can be found in clause B.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.3\tAuthentication failures",
                            "text_content": "Authentication failures are handled as they are described in RFC 7616 [36] and RFC 9110 [31].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.4\tBootstrapping required indication",
                            "text_content": "NAF shall indicate to the UE that bootstrapped security association is required by sending an HTTP response with code 401 \"Unauthorized\" and include the WWW-Authenticate header into the response. In particular, the \"realm\" attribute shall contain a prefix \"3GPP-bootstrapping@\" or \"3GPP-bootstrapping-uicc@\" or \"3GPP-bootstrapping-digest\", and this shall trigger UE to run bootstrapping procedure over Ub interface.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.5\tBootstrapping renegotiation indication",
                            "text_content": "The NAF shall indicate to the UE that the existing bootstrapped security association used in the last HTTP request sent by the UE has expired and that a new bootstrapped security association is required by sending an HTTP response described in clause 5.2.3. When the UE receives the 401 \"Unauthorized\" HTTP response to the HTTP request that was protected using the existing bootstrapped security association, this shall trigger the UE to run bootstrapping procedure over Ub interface.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.2.6\tIntegrity protection",
                            "text_content": "Integrity protection may be provided by using HTTP Digest integrity protection, i.e. quality of protection (qop) parameter is set to \"auth-int\".\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                },
                {
                    "title": "5.3\tUE and NAF authentication using HTTPS",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "5.3.1\tGeneral",
                            "text_content": "Prior to establishing HTTP, the UE and the NAF may perform authentication. Three different authentication mechanisms may be used for UE and NAF authentication:\na)\tShared key-based UE authentication (HTTP Digest) with certificate-based NAF authentication (TLS);\nb)\tShared key-based mutual authentication between UE and NAF (PSK TLS), and;\nc)\tCertificate based mutual authentication between UE and AS;\nThe protocol stack of the Ua interface when TLS is used is presented in figure 5.3.1-1. and described in clause 5.3.2. The HTTP Digest authentication is described in clause 5.2.\nThe figure depicts a protocol stack of the User Interface (UA) interface with Transport Layer Security (TLS) encryption, illustrating the encryption process and the use of encryption keys.\nFigure 5.3.1-1: Protocol stack of Ua interface with TLS\nThe protocol stack of the Ua interface when PSK TLS is used is presented in figure 5.3.1-2 and described in clause 5.3.3. The HTTP Digest authentication is described in clause 5.2.\nThe figure depicts a protocol stack of the User Interface (UA) interface with PSK (Phase Shift Keying) and TLS (Transport Layer Security) encryption. The diagram illustrates the various components and their interactions, including the User Agent (UA), the Protocol Stack, and the Transport Layer (TL). The figure highlights the importance of security measures in the communication process, such as encryption and authentication, to ensure the confidentiality and integrity of the data transmitted.\nFigure 5.3.1-2: Protocol stack of Ua interface with PSK TLS\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.2\tShared key-based UE authentication with certificate-based NAF authentication",
                            "text_content": "The authentication mechanism described in this section for ME-based application is mandatory to implement in the ME and optional to implement in the NAF.\nThe authentication mechanism described in this section for UICC-based application is optional to implement in the UICC and the NAF.\nThe UE and the NAF shall support the TLS version as specified in annex E of 3GPP TS 33.310 [25]. See clause 5.3.1 in 3GPP TS 33.222 [5] for the detailed profiling of TLS.\na)\tWhen the UE starts communication via Ua reference point with the NAF, it shall establish a TLS tunnel with the NAF. The NAF is authenticated to the UE by means of a public key certificate. The UE shall verify that the server certificate corresponds to the FQDN of the NAF it established the tunnel with. No client authentication is performed as part of TLS (no client certificate necessary).\nb)\tThe UE sends an HTTP request to the NAF inside the TLS tunnel (HTTPS, i.e. HTTP over TLS) as described in clause 5.2.\nc)\tThe NAF shall authenticate the HTTP request using HTTP Digest as specified in clause 5.2.\nServer authentication failures are handled in TLS as they are described in the RFC for TLS which is defined in annex E of 3GPP TS 33.310 [25]. Client authentication failures are handled in HTTP Digest as they are described in RFC 7616 [36] and RFC 9110 [31].\nBootstrapping required indication is done on HTTP Digest and therefore described in clause 5.2.4.\nBootstrapping renegotiation indication is done on HTTP Digest and therefore described in clause 5.2.5.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.3\tShared key-based mutual authentication between UE and NAF",
                            "text_content": "The authentication mechanism described in this section for ME-based application is optional to implement in the ME and the NAF.\nThe authentication mechanism described in this section for UICC-based application is optional to implement in the UICC and the NAF.\nThe PSK-based authentication for TLS (PSK TLS) may be used with bootstrapped security association as the authentication, confidentiality, and integrity protection method. The profile for TLS and TLS Extensions to be used together with PSK TLS is defined in annex E of 3GPP TS 33.310 [25].\nThe PSK TLS handshake shall be used with bootstrapped security association as follows:\n-\tthe ClientHello message shall contain one or more PSK-based ciphersuites;\n-\tthe ClientHello message shall contain the server_name TLS extension and it shall contain the hostname of the NAF;\n-\tthe ServerHello message shall contain a PSK-based ciphersuite selected by the NAF;\n-\tthe ServerKeyExchange shall be sent by the server and it shall contain the psk_identity_hint field and it shall contain the static string \"3GPP-bootstrapping\" or \"3GPP-bootstrapping-uicc\" or \"3GPP-bootstrapping-digest\". If several authentication methods are supported then the ServerKeyExchange message shall include the PSK-identity hints for all allowed authentication methods, separated by semi-colon \";\" (e.g., \"3GPP-bootstrapping;3GPP-bootstrapping-uicc\").\nIn the case of GBA_U, the NAF shall indicate to the UE which NAF specific key can be used by setting the psk_identity_hint to \"3GPP-bootstrapping\" (for the ME-based key i.e. Ks_ext_NAF), or to \"3GPP-bootstrapping-uicc\" (for the UICC-based key i.e. Ks_int_NAF). If the NAF allows both types of keys to be used then the psk_identity_hint field shall contain both hints separated by semi-colon \";\".\nIn addition, the NAF may include an indication to use a BSF address different from the one specified in 3GPP TS 23.003 [7] in the psk_identity_hint field of the ServerKeyExchange message. The indication to use the different BSF address shall contain a prefix \"3GPP bootstrapping-BSF-address\", a separator character \":\" and the FQDN of the BSF. The NAF may only include this indication for an application specified to support this functionality (e.g. Proximity-based Services, see 3GPP TS 33.303 [29]) and if it is included then the static strings \"3GPP bootstrapping\" shall be included.\nThe psk_identity_hint field may contain a list of psk_identity_hints and are separated by a semi-colon character (\";\") (see NOTE 1);\nNOTE 1:\tOther psk identity name spaces than \"3GPP-bootstrapping\" or \"3GPP-bootstrapping-uicc\" can be supported, however, they are out of the scope of this specification.\n-\tthe ClientKeyExchange shall contain the psk_identity field and it shall contain a prefix \"3GPP-bootstrapping\" or \"3GPP-bootstrapping-uicc\" or \"3GPP-bootstrapping-digest\" indicating the selected psk identity name space, a separator character \";\" and the B-TID. In the selection of the GBA mode by the UE, AKA-based modes shall take priority over GBA_Digest.;\n-\tif the PSK TLS client resides in the ME, the UE shall derive the TLS premaster secret from the NAF specific key material i.e. Ks_NAF in the case of GBA_ME. For GBA_U the UE shall derive the TLS premaster secret from the ME-based key material i.e. Ks_ext_NAF;\n-\tif the PSK TLS client resides in the UICC, the UE shall derive the TLS premaster secret from the NAF specific UICC-based key material i.e. Ks_int_NAF;\n-\tif the indication to use a different BSF address was included in the psk_identity_hint field of the ServerKeyExchange message, the ME shall derive the TLS premaster secret from a Ks_NAF resulting from a GBA_ME bootstrapping with the indicated BSF and shall use the prefix \"3GPP bootstrapping\" in the psk_identity field of the ClientKeyExchange message.\nNOTE 2:\tA GBA_U capable NAF indicates to the UE the type of the authorized NAF specific key (i.e. (Ks_ext_NAF or Ks_int_NAF or both). The details of the key decision mechanism in the NAF are specified in 3GPP TS 29.109 [3].\nIn the case of GBA_U, if the HTTPS client application resides in the ME then the application shall use only the ME-based key i.e. Ks_ext_NAF (the UICC-based key Ks_int_NAF is not available in the ME). If a NAF indicates to a ME-based HTTPS client application that the UICC-based key shall be used then the application must terminate the communication with this NAF. If a HTTPS client application resides in the UICC, then the application shall only use the UICC-based key. If the NAF indicates to the UICC-based application that only the ME-based key can be used then the application must terminate the communication with the NAF.\nIn the case of GBA_U, the operator may indicate the type of the key to be used in the Ua reference point in the NAF specific USS as specified in 3GPP TS 29.109 [3]. If the NAF has requested an application specific USS, and the indication is present in the USS, the NAF shall use the indicated key type. If the type of the negotiated key is different from the type indicated in the USS, the NAF shall terminate the communication with the UE.\nAn example flow of the PSK TLS procedure can be found in clause F.3.\nThe PSK TLS handshake shall be used with bootstrapped security association as follows:\n1)\tThe UE shall include in the ClientHello message:\na)\tan indication that it supports the TLS with PSK authentication using the \"psk_key_exchange_modes\" extension;\nb)\tthe hostname of the NAF using the \"server_name\" TLS extension;\nc)\tauthentication methods other than PSK the UE supports;\nd)\tPSK identities within the psk_identities field. Each included psk_identity parameter within the psk_identities field shall contain a prefix indicating the PSK identity name space, a separator character \";\" and the B-TID. The psk_identity parameters within the psk_identities field are separated by a comma character (\",\"); and\ne)\tan additional psk_identity parameter in the psk_identities field for each of psk_identity parameter included in step 1)d) to allow the NAF to signal that a bootstrapping is required for that bootstrapping method. The format of this additional psk_identity parameter is the original one without the semi-colon character and B-TID but with \"_bootstrappingrequired\" appended, e.g. \"3GPP-bootstrapping-uicc-bootstrappingrequired\" parameter is included if the psk_identity parameter with the \"3GPP-bootstrapping-uicc\" PSK identity name space is included in the psk_identities field and similarly for the other methods.\nThe prefix \"3GPP-bootstrapping\" is used in the psk_identity parameter to indicate that the UE accepts that AKA-based Ks(_ext)_NAF is used establish the TLS session keys.\nThe prefix \"3GPP-bootstrapping-uicc\" is used in the psk_identity parameter to indicate that the UE accepts that Ks_int_NAF is used to establish the TLS sessions keys.\nThe prefix \"3GPP-bootstrapping-digest\" is used in the psk_identity parameter to indicate that the UE accepts that GBA_Digest-based Ks_NAF is used to establish the TLS sessions keys.\nNOTE:\tOther PSK identity name spaces can be supported, however, they are out of the scope of the present document.\nIf the UE has a choice in the selection of the GBA mode, AKA-based modes shall take priority over GBA_Digest.\nThe UE shall derive the TLS external PSK from the NAF specific key Ks(_ext)_NAF if the initiating HTTPS client resides on the ME or Ks_int_NAF if the initiating HTTP client resides on the UICC).\n2)\tIf the NAF wants the UE to perform a new bootstrapping for a particular method:\na)\tthe NAF shall indicate the index of the bootstrapping required of the selected psk_identity parameter in the ServerHello message;\nb)\tthe UE shall treat the ServerHello message the NAF sent in step 2)a) as a HelloRetryRequest message and shall perform a new bootstrapping run for the indicated bootstrapping method; and\nc)\tonce the bootstrapping is completed, the UE shall send a new ClientHello message with the psk_identities field including only the psk_identity parameter containing the psk_identity_namespace of the chosen bootstrapping method and the new B-TID.\n3)\tIf the NAF is willing to establish a TLS tunnel using PSK authentication the NAF shall select one of the psk_identity parameters from the psk_identities field received within the ClientHello message.\n4)\tThe NAF shall reply with the ServerHello message and indicate the index of the psk_identity parameter. The NAF concludes the TLS handshake by sending Finished message to the UE.\nIf the NAF received within the ClientHello messages the psk_identities field with the psk_identity parameter containing:\na)\t\"3GPP-bootstrapping\" prefix and the B-TID the NAF shall fetch the NAF specific shared secret (Ks(_ext)_NAF) from the BSF using the B-TID;\nb)\t\"3GPP-bootstrapping-uicc\" prefix and the B-TID the NAF shall fetch the NAF specific shared secret (Ks_int_NAF) from the BSF using the B-TID; or\nc)\t\"3GPP-bootstrapping-digest\" prefix and the B-TID the NAF shall indicate to the BSF that GBA_Digest is acceptable.\nIf the NAF has requested an application specific USS, and the indication is present in the USS, the NAF shall use the indicated key type. If the type of the negotiated key is different from the type indicated in the USS, the NAF shall terminate the communication with the UE.\nThe NAF shall derive the TLS external PSK from the NAF specific key (Ks(_ext)_NAF or Ks_int_NAF).\n5)\tThe UE concludes the TLS handshake by sending Finished message to the NAF.\nThe UE and the NAF have established a TLS tunnel using GBA-based shared secret, and they may start to use the application level communication through this tunnel.\nAuthentication failures are handled as they are described in the profile for TLS specified in annex E of 3GPP TS 33.310 [25].\nIn TLS 1.2, during TLS handshake, the NAF shall indicate to the UE that bootstrapped security association is required by sending a ServerHello message containing a PSK-based ciphersuite, and a ServerKeyExchange message containing the psk_identity_hint field, which contains a static string \"3GPP-bootstrapping\" or \"3GPP-bootstrapping-uicc\" or \"3GPP-bootstrapping-digest\". This shall trigger the UE to run the bootstrapping procedure over Ub interface.\nNOTE:\tThe NAF shall select a PSK-based ciphersuite only if the UE has offered one or more PSK-based ciphersuites in the corresponding ClientHello message.\nIn TLS 1.3, during TLS handshake, the UE shall include the psk_identities field in the ClientHello message to enable the request of a fresh bootstrapping. If the NAF wants the UE to perform a new bootstrapping for a particular method, the NAF shall indicate the index of the bootstrapping required of the selected psk_identity parameter in the ServerHello message. This shall trigger the UE to run the new bootstrapping procedure over Ub interface.\nDuring usage of TLS session, the NAF shall indicate to the UE that bootstrapped security association has expired by sending close_notify alert message to the UE.\nIn TLS 1.2, the UE may attempt resume the old TLS session by sending a ClientHello message containing the old session ID. The NAF shall refuse to use the old session ID by sending a ServerHello message with a new session ID. This will indicate to the UE that the bootstrapped security association it used has expired.\nDuring TLS handshake, the NAF shall indicate to the UE that the bootstrapped security association has expired by sending handshake_failure message as a response to the Finished message sent by the UE. This will indicate to the UE that the bootstrapped security association it used has expired.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.4\tCertificate based mutual authentication between UE and application server",
                            "text_content": "The authentication mechanism described in this clause is optional to implement in the UE and in the application server.\nThe certificate based mutual authentication between an UE and an application server shall be based on TLS and TLS Extensions. The profile for TLS and TLS Extensions is defined in annex E of 3GPP TS 33.310 [25].\nAnnex B in 3GPP TS 33.222 [5] provides guidance on certificate mutual authentication between UE and application server.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "5.3.5\tIntegrity protection",
                            "text_content": "Integrity protection is provided by using authenticated TLS tunnel as described in RFC 9110 [31].\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "6\tPKI portal, Ua interface",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "6.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "3GPP TS 33.221 [4] specifies the enrolment of subscriber certificates and the delivery of CA certificates to the UE. The TS specifies that the authentication of these procedures be based on bootstrapping procedure and more generally on the HTTP Digest authentication as described in clause 5.2 of the present document.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "6.2\tSubscriber certificate enrolment",
                    "description": "",
                    "summary": "",
                    "text_content": "The subscriber certificate enrolment procedure contains the following requests:\n-\tan enrolment request in the form of PKCS#10 [16];\n-\tan optional request for WIM specific authentication code for key generation [19]; and\n-\tan optional request for WIM specific authentication code for proof of key origin [19].\nRespectively, the subscriber certificate enrolment procedure contains the following responses:\n-\ta subscriber certificate; and\n-\ta WIM specific authentication code [19].\nNOTE:\tThe on board key generation and the generation of the proof of key origin requires a WIM specific authentication code. Whether it is, is decided by the issuer of the WIM card.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.2.1\tEnrolment procedure",
                            "text_content": "The UE shall generate a PKCS#10 certification request [16] according to 3GPP TS 33.221 [4]. The UE shall send the PKCS#10 certification request to the PKI portal in the HTTP payload in a HTTP POST request. The Request-URI shall indicate the desired response type. Upon successful enrolment, PKI portal shall return the enrolled subscriber certificate in the desired format.\nThe UE populates the HTTP POST request as follows:\n-\tthe HTTP version shall be 1.1 which is specified in RFC 9112 [30];\n-\tthe base of the Request-URI is extracted from the full PKI portal URI (e.g. if the full PKI portal URI is \"\" then the Request-URI shall be \"/enrol\".\nNOTE 1:\tIn case a proxy is used between the UE and the PKI portal, then the full Request-URI will be used in the HTTP Post request.\n-\tthe Request-URI shall contain an URI parameter \"response\" that shall be set to \"single\", \"pointer\", or \"chain\" depending on the UE's desired response type (e.g. Request-URI may take the form of \"/enrol?response=single\" for certificate delivery);\nNOTE 2:\tThe PKI portal might ignore the UE's desired response type, and the UE should be capable of receiving the issued subscriber certificate in any of the response types.\n-\tthe UE may add additional URI parameters to the Request-URI;\nNOTE 3:\tThe PKI portal might ignore the additional URI parameters.\n-\tthe HTTP header Content-Type shall be \"application/x-pkcs10\";\n-\tthe HTTP header Content-Length shall be the length of the Base64 encoded PKCS#10 certification request in Octets; and\n-\tthe HTTP payload shall contain the Base64 encoded PKCS#10 certification request and optionally surrounded by \"----- BEGIN CERTIFICATE REQUEST -----\" and \"----- END CERTIFICATE REQUEST -----\" tags;\n-\tthe UE may add additional HTTP headers to the HTTP POST request.\nThe UE sends the HTTP POST request to the PKI portal. The PKI portal checks that the HTTP request is valid, and extracts the Base64 encoded PKCS#10 certification request for further processing. The PKI portal shall verify that the subscriber is authorized to receive the particular type of certificate by checking subscriber's user security settings received from the BSF as specified 3GPP TS 33.220 [1].\nUpon successful subscriber certificate creation procedure, the PKI portal shall return the subscriber certificate to the UE in the UE's desired format or in the PKI portal's desired format.\nThe response format type shall be one of the following:\n-\tthe subscriber certificate itself (i.e. desired response type was \"single\");\n-\ta pointer to the subscriber certificate (i.e. desired response type was \"pointer\"); or\n-\ta certificate chain that contains full certification chain from subscriber certificate to the root certificate (i.e. desired response type was \"chain\").\nIf response format type is \"single\", the PKI portal shall populate HTTP response as follows:\n-\tthe HTTP status code shall be 200;\n-\tthe HTTP header Content-Type shall be \"application/x-x509-user-cert\";\n-\tthe HTTP header Content-Length shall be the length of the HTTP payload in octets;\n-\tthe HTTP payload shall contain the Base64 encoded subscriber certificate and optionally surrounded by\n\"----- BEGIN CERTIFICATE -----\" and \"----- END CERTIFICATE -----\" tags;\n-\tthe PKI portal may add additional HTTP headers to the HTTP response.\nIf response format type is \"pointer\", the PKI portal shall populate HTTP response as follows:\n-\tthe HTTP status code shall be 200;\n-\tthe HTTP header Content-Type shall be \"application/vnd.wap.cert-response\";\n-\tthe HTTP header Content-Length shall be the length of the HTTP payload in octets;\n-\tthe HTTP payload shall contain the Base64 encoded CertResponse structure and optionally surrounded by\n\"----- BEGIN CERTIFICATE RESPONSE -----\" and \"----- END CERTIFICATE RESPONSE -----\" tags;\n-\tthe PKI portal may add additional HTTP headers to the HTTP response.\nIf response format type is \"chain\", the PKI portal shall populate HTTP response as follows:\n-\tthe HTTP status code shall be 200;\n-\tthe HTTP header Content-Type shall be \"application/pkix-pkipath\";\n-\tthe HTTP header Content-Length shall be the length of the HTTP payload in octets;\n-\tthe HTTP payload shall contain the Base64 encoded PkiPath structure;\n-\tthe PKI portal may add additional HTTP headers to the HTTP response.\nThe PKI portal shall send the HTTP response to the UE. The UE shall check that the HTTP response is valid, and extract the Base64 encoded subscriber certificate, pointer to the subscriber certificate, or certificate chain for further processing.\nAn example flow of a successful subscriber certificate enrolment procedure can be found in clause E.3.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.2\tWIM specific authentication code for key generation",
                            "text_content": "The UE may be equipped with a WIM which may require an authentication code from WIM provider in order to generate a key onboard WIM as specified in OMA ECMAScript [19] and OMA WPKI [20] specifications. In this case, the UE shall request the authentication code from PKI portal using a HTTP GET request. If the PKI portal can acquire authentication code, it is returned to the UE in the corresponding HTTP response.\nThe UE populates the HTTP GET request as follows:\n-\tthe HTTP version shall be 1.1 which is specified in RFC 9112 [30];\n-\tthe base of the Request-URI is extracted from the full PKI portal URI and appended with \"/wim-auth-code\" (e.g. if the full PKI portal URI is \"http://pki-portal.operator.com/enrol\" then the Request-URI shall be \"/enrol/wim-auth-code\");\n-\tthe Request-URI shall contain an URI parameter \"request\" that shall be set to the return value received from the WIM;\nNOTE 1:\tIf an authentication code is required, the WIM will return \"error:AuthReq:cardSerialNumber:Challenge\". The cardSerialNumber and the Challenge are in a hexadecimal format as specified in OMA ECMAScript specification [19].\n-\tthe UE may add additional URI parameters to the Request-URI;\n-\tthe UE may add additional HTTP headers to the HTTP GET request.\nThe UE sends the HTTP GET request to the PKI portal. The PKI portal acknowledges that this is an authentication code because the Request-URI contains the \"/wim-auth-code\" and the URI parameter \"request\". The PKI portal extracts the authentication code derivation parameters from the URI parameter \"request\", and derives the authentication code.\nNOTE 2:\tThe actual derivation of the authentication code is outside the scope.\nUpon successful authentication code derivation, the PKI portal shall return the authentication code to the UE in a HTTP response:\n-\tthe HTTP status code shall be 200;\n-\tthe HTTP header Content-Type shall be \"text/plain\";\n-\tthe HTTP header Content-Length shall be the length of the HTTP payload in octets;\n-\tthe HTTP payload shall contain the authentication code in a hexadecimal format;\n-\tthe PKI portal may add additional HTTP headers to the HTTP response.\nUpon receiving the authentication code from the PKI portal, the UE shall use it to authenticate the procedure of generating the key onboard the WIM.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.3\tWIM specific authentication code for proof of key origin",
                            "text_content": "The UE may be equipped with a WIM which may require an authentication code from WIM provider in order to generate a proof of key origin onboard WIM as specified in OMA ECMAScript [19] and OMA WPKI [20] specifications. In this case, the UE shall request the authentication code from PKI portal using a HTTP GET request. If the PKI portal can acquire authentication code, it is returned to the UE in the corresponding HTTP response.\nThe procedure to obtain the authentication code for the generation of proof of key origin onboard WIM is the same as for the key generation, and is described in clause D.2.1.\nUpon receiving the authentication code from the PKI portal, the UE shall use it to authenticate the procedure generating the proof of key origin onboard the WIM.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.2.4\tError situations",
                            "text_content": "Subscriber certificate enrolment may not be successful for multiple reasons. The error cases are indicated by using 4xx and 5xx HTTP Status Codes as defined in RFC 9110 [31]. The 4xx status code indicates that the UE seems to have erred, and the 5xx status code indicates that the PKI portal is aware that it has erred. Possible error situations during subscriber certificate enrolment and their mappings to HTTP Status Codes are described in table 6.2.4-1.\nNOTE:\tOn the table 6.2.4-1, the \"Description\" column describes the error situation in PKI portal. The \"PKI portal error\" column describes the typical reason for the error.\nAn example flow of a failure in subscriber certificate enrolment procedure can be found in clause E.4.\nTable 6.2.4-1: HTTP Status Codes used for enrolment error\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.2.4-1: HTTP Status Codes used for enrolment error",
                                    "table number": 2,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "6.3\tCA certificate delivery",
                    "description": "",
                    "summary": "",
                    "text_content": "The root certificate delivery procedure contains the following request:\n-\ta CA certificate delivery request;\nand the corresponding response:\n-\tthe CA certificate.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "6.3.1\tCA certificate delivery procedure",
                            "text_content": "The UE shall populate the HTTP GET request as follows:\n-\tthe HTTP version shall be 1.1 which is specified in RFC 9112 [30];\n-\tthe base of the Request-URI is extracted from the full PKI portal URI (e.g. if the full PKI portal URI is \"getcertificate\" then the Request-URI shall be \"/getcertificate\".\nNOTE 1:\tIn case a proxy is used between the UE and the PKI portal, then the full Request-URI will be used in the HTTP Post request.\n-\tthe Request-URI shall contain an URI parameter \"in\" that shall be the Base64 encoding of the DER encoded Issuer field of the X.509 certificate;\n-\tthe Request-URI may contain an URI parameter \"ki\" that shall be the Base64 encoding of the DER encoded the Key Identifier of the X.509 certificate;\nNOTE 2:\tKey Identifier of the CA certificate can be obtained from the Authority Key Identifier extension of the subscriber certificate.\n-\tthe UE may add additional URI parameters to the Request-URI;\n-\tthe UE may add additional HTTP headers to the HTTP GET request.\nThe UE sends the HTTP GET request to the PKI portal. The PKI portal checks that the HTTP request is valid, and extracts the \"in\" parameter and optionally \"ki\" parameter from the Request-URI. If the PKI portal can verify that the Issuer field parameter is valid, and that the UE may set the CA certificate as a root certificate (i.e. trusted CA certificate), it will then send the CA certificate back to the UE in the corresponding HTTP response.\nThe PKI portal shall populate the HTTP response as follows:\n-\tthe HTTP status code shall be 200;\n-\tthe HTTP header Content-Type shall be \"application/x-x509-ca-cert\";\n-\tthe HTTP header Content-Length shall be the length of the HTTP payload in octets;\n-\tthe HTTP payload shall contain the Base64 encoded CA certificate structure and optionally surrounded by \"----- BEGIN CERTIFICATE -----\" and \"----- END CERTIFICATE -----\" tags;\n-\tthe PKI portal may add additional HTTP headers to the HTTP response.\nThe PKI portal shall send the HTTP response to the UE. The UE shall check that the HTTP response is valid, and extract the Base64 encoded CA certificate for further processing. UE shall validate and match the received CA certificate against the parameters supplied in the corresponding request.\nAn example flow of CA certificate procedure can be found in clause E.5.\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "6.3.2\tError situations",
                            "text_content": "CA certificate delivery may not be successful for multiple reasons. The error cases are indicates by using 4xx and 5xx HTTP Status Codes as defined in 9110 [31]. The 4xx status code indicates that the UE seems to have erred, and the 5xx status codes indicate that the PKI portal is aware that it has erred. Possible error situations during CA certificate delivery and their mappings to HTTP Status Codes are described in table 6.3.2-1.\nNOTE:\tOn the table 6.3.2-1, the \"Description\" column describes the error situation in PKI portal. The \"PKI portal error\" column describes the typical reason for the error.\nAn example flow of a failure in CA certificate delivery procedure can be found in clause E.6.\nTable 6.3.2-1: HTTP Status Codes for CA certificate delivery error\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table 6.3.2-1: HTTP Status Codes for CA certificate delivery error",
                                    "table number": 3,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "title": "7\tAuthentication Proxy",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "7.1\tIntroduction",
                    "description": "",
                    "summary": "",
                    "text_content": "The use of authentication proxy (AP) is specified in 3GPP TS 33.222 [5]. The AP in GAA is used to separate the GAA specific authentication procedure and the Application Server (AS) specific application logic to different logical entities. The AP is configured as a HTTP reverse proxy, i.e. the FQDN of the AS is configured to the AP such a way that the IP traffic intended to the AS is directed to the AP by the network. The AP performs the GAA authentication of the UE. After the GAA authentication procedure has been successfully completed, the AP assumes the typical role of a reverse proxy, i.e. the AP forwards HTTP requests originating from the UE to the correct AS, and returns the corresponding HTTP responses from the AS to the originating UE.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "7.2\tAuthentication",
                    "description": "",
                    "summary": "",
                    "text_content": "The authentication of the UE shall be based on GAA as specified in clause 5.\nThe AP shall remove the \"Authorization\" header from the HTTP requests that are forwarded from the UE to the AS. The AP shall add the \"Authentication-Info\" header to the HTTP responses that are forwarded to the UE from the AS.\nThe UE may indicate the user identity intended to be used with the AS by adding a HTTP header to the outgoing HTTP requests. The HTTP header name shall be \"X-3GPP-Intended-Identity\" and it shall contain the user identity surrounded by quotation marks (\"). If the HTTP header has been added, the AP may verify that the user identity belongs to the subscriber. In case the AP supports this check of the user identity then it shall be performed dependant on the subscriber’s application specific or AP specific user security settings.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "7.3\tAuthorization",
                    "description": "",
                    "summary": "",
                    "text_content": "The AP shall be able to decide whether particular subscriber, i.e. the UE, is authorized to access a particular AS. The granularity of the authorization procedures is specified in 3GPP TS 33.222 [5].\nThe AP may indicate an asserted identity or a list of identities to the AS by adding a HTTP header to the HTTP requests coming from the UE and forwarded to the AS. The HTTP header name shall be \"X-3GPP-Asserted-Identity\" and it shall contain a list of identities separated by comma (,) and each identity is surrounded by quotation marks (\"). Whether the AP supports this handling of an asserted identity or a list of identities then it shall depend on local policy in the AP. In addition the subscriber’s application specific or AP specific user security settings may be considered.\nThe AP may indicate an authorization flag or a list of authorization flags from the application specific user security settings (USS) to the AS by adding a HTTP header to the HTTP requests coming from the UE and forwarded to the AS. The HTTP header name shall be \"X-3GPP-Authorization-Flags\" and it shall contain a list of authorization flags separated by comma (,) and each authorization flag is surrounded by quotation marks (\"). In case the AP supports this handling of authorization flags from USS then it shall depend on local policy in the AP.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "A.1\tScope of signalling flows",
            "description": "This annex gives examples of signalling flows for bootstrapping procedure.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "A.2\tIntroduction",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "A.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "Bootstrapping procedure is executed in order to establish bootstrapped security association, i.e. bootstrapping session between an UE and the BSF.\nThe bootstrapping session is used between a UE and a NAF. An example usage of it is described in annex B.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A.2.2\tKey required to interpret signalling flows",
                    "description": "",
                    "summary": "",
                    "text_content": "3GPP TS 24.228 [13], clause 4.1.1, specifies the key required to interpret the contents of the SIP methods. This key is used with HTTP based messages (cf. RFC 9110 [31]) as well since SIP and HTTP messages resemble each other in structure. The following key rules are used in addition to those specified in 3GPP TS 24.228 [13]:\na)\tThe HTTP based messaging is always initiated by the client:\n-\tHTTP request is generated by the client (i.e. UE);\n-\tHTTP response is generated by the server as a response to the HTTP request;\n-\tHTTP proxies may be between the client and the server.\nb)\tThere is only one single HTTP response to the HTTP request.\nc)\tIn order to differentiate between HTTP messages and other protocol messages, the HTTP messages are marked with simple arrow line, and all non-HTTP messages with block arrows.\nd)\tThe flows show the signalling exchanges between the following functional entities in addition to those specified in 3GPP TS 24.228 [13]:\n-\tBootstrapping Server Function (BSF);\n-\tNetwork Application Function (NAF);\n-\tPKI portal (PKI portal).\ne)\tThe \"(B-TID)\" sequence of characters is used to indicate that the bootstrapping transaction identifier (B-TID) needs to be filled in.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "A.3\tSignalling flows demonstrating a successful bootstrapping procedure",
            "description": "The overall bootstrapping procedure in successful case is presented in figure A.3-1. The bootstrapping Zh interface performs the retrieval of an authentication vector by BSF from the HSS. The procedure corresponds to the step 2 in figure A.3-1.\nThis clause specifies in detail the format of the bootstrapping procedure that is further utilized by various applications. It contains the AKA authentication procedure with BSF, and later the bootstrapping key material generation procedure.\nThe figure depicts a bootstrapping signalling scenario in a 5G network, illustrating the process of signal propagation and the role of the base station (gNB) in the network. The diagram highlights the importance of beamforming techniques to mitigate interference and ensure reliable communication.\nFigure A.3-1: Bootstrapping signalling\n1.\tInitial GET request  (UE to BSF) - see example in table A.3-1\nThe purpose of this message is to initiate bootstrapping procedure between the UE and BSF. The UE sends an HTTP request containing the private user identity towards its home BSF.\nTable A.3-1: Initial GET request (UE to BSF)\nGET / HTTP/1.1\nHost: bsf.home1.net:80\nUser-Agent: Bootstrapping Client Agent; Release-6; 3gpp-gba-tmpi\nDate: Thu, 08 Jan 2004 10:13:17 GMT\nAccept: */*\nAuthorization: Digest\nusername=\"user1_private@home1.net\",\nrealm=\"bsf.home1.net\",\nnonce=\"\",\nuri=\"/\",\nresponse=\"\"\n\nRequest-URI:\tThe Request-URI (the URI that follows the method name, \"GET\", in the first line) indicates the resource indication of this GET request. For bootstrapping server, this is by default \"/\".\nHost:\tSpecifies the Internet host and port number of the BSF server, derived from the private user identity or IMSI according to 3GPP TS 23.003 [7], or obtained from the original URI given by referring resource. The port number to be used with Ub reference point is the default port of HTTP, i.e. 80.\nUser-Agent:\tContains information about the user agent originating the request.\nDate:\tRepresents the date and time at which the message was originated.\nAccept:\tMedia types which are acceptable for the response.\nAuthorization:\tIt carries authentication information. The private user identity (user1_private@home1.net) is carried in the username field of the Digest AKA protocol. The \"uri\" parameter (directive) contains the same value as the Request-URI. The ”realm” parameter (directive) contains the network name where the username is authenticated. The Host and the \"realm\" parameter (directive) value are obtained from the same field in the USIM and therefore, are identical. In this example, it is assumed that a new UICC card was just inserted into the terminal, and there is no other cached information to send. Therefore, \"nonce\" and \"response\" parameters (directives) are empty.\n2.\tZh: Authentication procedure\nBSF retrieves the corresponding AVs from the HSS.\nFor detailed signalling flows see 3GPP TS 29.109 [3].\nTable A.3-2: BSF authentication information procedure (BSF to HSS)\n\n3.\tAuthentication vector selection\nThe BSF selects an authentication vector for use in the authentication challenge. For detailed description of the authentication vector, see 3GPP TS 33.220 [1].\nNOTE 1:\tThe authentication vector can be of the form as in 3GPP TS 33.203 [21] (if IMS AKA is the selected authentication scheme):\n-\tAV = RANDn||AUTNn||XRESn||CKn||IKn  where:\n•\tRAND: random number used to generate the XRES, CK, IK, and part of the AUTN. It is also used to generate the RES at the UE.\n•\tAUTN: Authentication token (including MAC and SQN); 128 bit value generated by the HSS.\n•\tXRES: Expected (correct) result from the UE.\n•\tCK: Cipher key (optional).\n•\tIK: Integrity key.\n4.\t401 Unauthorized response (BSF to UE) - see example in table A.3-3\nBSF forwards the challenge to the UE in HTTP 401 Unauthorized response (without the CK, IK and XRES). This is to demand the UE to authenticate itself. The challenge contains RAND and AUTN that are populated in nonce field according to RFC 3310 [6].\nTable A.3-3: 401 Unauthorized response (BSF to UE)\nHTTP/1.1 401 Unauthorized\nServer: Bootstrapping Server; Release-6\nDate: Thu, 08 Jan 2004 10:13:17 GMT\nWWW-Authenticate: Digest\nrealm=\"bsf.home1.net\",\nnonce= base64(RAND + AUTN + server specific data),\nalgorithm=AKAv1-MD5,\nqop=\"auth-int\",\nopaque=\"5ccc069c403ebaf9f0171e9517f30e41\"\n\nServer:\tContains information about the software used by the origin server (BSF).\nDate:\tRepresents the date and time at which the message was originated.\nWWW-Authenticate:\tThe BSF challenges the user. The nonce includes the quoted string, base64 encoded value of the concatenation of the AKA RAND, AKA AUTN and server specific data.\nNOTE 2:\tThe actual nonce value in the WWW-Authenticate header field is encoded in base64, and it can look like: nonce=\"A34Cm+Fva37UYWpGNB34JP\".\n5.\tGeneration of response and session keys at UE\nUpon receiving the Unauthorized response, the UE extracts the MAC and the SQN from the AUTN. The UE calculates the XMAC and checks that XMAC matches the received MAC and that the SQN is in the correct range. If both these checks are successful the UE calculates the authentication challenge response (using RES and other parameters as defined in RFC 3310 [6]), and also computes the session keys IK and CK. The authentication challenge response is put into the Authorization header and sent back to the BSF in the GET request.\n6.\tGET request (UE to BSF) - see example in table A.3-4\nThe UE sends an HTTP GET request again, with the RES, which is used for response calculation, to the BSF.\nTable A.3-4: GET request (UE to BSF)\nGET / HTTP/1.1\nHost: bsf.home1.net:80\nUser-Agent: Bootstrapping Client Agent; Release-6; 3gpp-gba-tmpi\nDate: Thu, 08 Jan 2004 10:13:18 GMT\nAccept: */*\nAuthorization: Digest\nusername=\"user1_private@home1.net\",\nrealm=\"bsf.home1.net\",\nnonce=\"base64(RAND + AUTN + server specific data)\",\nuri=\"/\", qop=auth-int,\nnc=00000001,\ncnonce=\"6629fae49393a05397450978507c4ef1\",\nresponse=\"6629fae49393a05397450978507c4ef1\",\nopaque=\"5ccc069c403ebaf9f0171e9517f30e41\",\nalgorithm=AKAv1-MD5\n\nAuthorization:\tThis carries the response to the authentication challenge received in step 4 and contains the private user identity, the realm, the nonce, the URI, the qop, the nc, the cnonce, the response, the opaque, and the algorithm.\n7.\tAuthentication and generation of key material at BSF\nUpon receiving an integrity protected GET request carrying the authentication challenge response, the BSF checks that the expected response (calculated by the BSF using XRES and other parameter as defined in RFC 3310 [6]) matches the received challenge response. If the check is successful then the user has been authenticated and the private user identity is registered in the BSF.\nThe BSF generates the bootstrapping transaction identifier (B-TID) for the IMPI and stores the tuple <B-TID,IMPI,CK,IK>.\nFor detailed bootstrapping key material generation procedure see 3GPP TS 33.220 [1].\n8.\t200 OK response (BSF to UE) - see example in table A.3-5\nThe BSF sends 200 OK response to the UE to indicate the success of the authentication.\nTable A.3-5: 200 OK response (BSF to UE)\nHTTP/1.1 200 OK\nServer: Bootstrapping Server; Release-6; 3gpp-gba-tmpi\nAuthentication-Info: qop=auth-int,\nrspauth=\"6629fae49394a05397450978507c4ef1\",\ncnonce=\"6629fae49393a05397450978507c4ef1\",\nnc=00000001,\nnextnonce=\"base64(RAND + AUTN + server specific data)\"\nDate:\nExpires: Thu, 08 Jan 2004 10:23:17 GMT\nContent-Type: application/vnd.3gpp.bsf+xml\nContent-Length: (...)\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<BootstrappingInfo xmlns=\"uri:3gpp-gba\">\n<btid>user@bsf.operator.com</btid>\n<lifetime>2004-05-28T13:20:00Z</lifetime>\n<Extension>\n<currenttime>2004-05-27T13:20:00Z</currenttime>\n</Extension>\n</BootstrappingInfo>\n\nContent-Type:\tContains the media type of the entity body.\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nAuthentication-Info:\tThis carries the server authentication information. The header includes the \"rspauth\" parameter, which is calculated as specified in RFC 7616 [36] using RES for response calculation as specified in RFC 3310 [6].\nExpires:\tGives the date/time after which the response is considered stale.\n9.\tGeneration of key material at UE\nThe key material Ks is generated in UE by concatenating CK and IK. In the case of GBA_ME, the ME stores the tuple <B-TID,Ks>, and in the case of GBA_U, the UICC stores the tuple <B-TID,Ks>.\nNOTE 3:\tThe NAF specific key material (Ks_NAF in the case of GBA_ME, or Ks_ext_NAF and Ks_int_NAF in the case of GBA_U) is derived from Ks during the Ua interface procedures, and is used for securing the Ua interface. In the case of GBA_ME, the ME stores the tuple <B-TID,Ks_NAF> and in the case of GBA_U, the ME stores the tuple <B-TID,Ks_ext_NAF>, and the UICC stores the tuple <B-TID,Ks_int_NAF>.\nFor detailed bootstrapping key material generation procedure for NAF specific key (Ks_NAF, Ks_ext_NAF or Ks_int_NAF) see 3GPP TS 33.220 [1].\n",
            "summary": "",
            "tables": [
                {
                    "description": "Table A.3-2: BSF authentication information procedure (BSF to HSS)",
                    "table number": 4,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "A.4\tSignalling flows demonstrating a synchronization failure in the bootstrapping procedure",
            "description": "If the UE considers the sequence number in the challenge to be not in the correct range, it sends a synchronization failure indication back to BSF. The parameter AUTS contains the concealed value of the counter value SQNMS in the UE.\nThe figure depicts the bootstrapping procedure in sequence number synchronization failure case, illustrating the steps taken to recover from a failed sequence number synchronization in a network. The figure shows the steps from the beginning to the end, with arrows indicating the sequence of events. The steps include initializing the sequence number, checking the sequence number, and re-synchronizing the sequence number. The figure provides a clear and concise visual representation of the process, making it easy to understand and follow.\nFigure A.4-1: The bootstrapping procedure in sequence number synchronization failure case.\n1-4.\tInitial bootstrapping steps\nSteps 1 through 4 are described in the corresponding steps in clause A.3.\n5.\tSQN invalid, generate AUTS at UE\nThe UE identifies the sequence number is out of synchronization. The UE generates the AUTS parameter (112 bit value). The AUTS parameter is populated in Authorization header, as specified in RFC 3310 [6].\n6.\tGET request (UE to BSF) - see example in table A.4-1\nThe UE sends HTTP GET request, with the AUTS parameter to the BSF.\nTable A.4-1: GET request (UE to BSF)\nGET / HTTP/1.1\nHost: bsf.home1.net:80\nUser-Agent: Bootstrapping Client Agent; Release-6\nDate: Thu, 08 Jan 2004 10:13:17 GMT\nAccept: */*\nAuthorization: Digest\nusername=\"user1_private@home1.net\",\nrealm=\"bsf.home1.net\",\nnonce=\"base64(RAND + AUTN + server specific data)\",\nuri=\"/\",\nqop=auth-int,\nnc=00000001,\ncnonce=\"6629fae49393a05397450978507c4ef1\",\nresponse=\"6629fae49393a05397450978507c4ef1\",\nopaque=\"5ccc069c403ebaf9f0171e9517f30e41\",\nalgorithm=AKAv1-MD5,\nauts=\"base64(AUTS)\"\n\nAuthorization:\tThis carries the response to the authentication challenge received in step 4 and contains the AUTS parameter.\n7.\tZh: Authentication procedure\nIf BSF does not have the corresponding AV indicated by the AUTS, the BSF shall retrieve it from the HSS.\nFor detailed signalling flows see 3GPP TS 29.109 [3].\nTable A.4-2: BSF authentication information procedure (BSF to HSS)\n\n8.\tAuthentication vector selection\nThe BSF selects the AV indicated by the AUTS for use in the authentication challenge. For detailed description of the authentication vector, see 3GPP TS 33.203 [21].\n9.\t401 Unauthorized response (BSF to UE) - see example in table A.4-3\nThe BSF sends another challenge based on new range of sequence number.\nTable A.4-3: 401 Unauthorized response (BSF to UE)\nHTTP/1.1 401 Unauthorized\nServer: Bootstrapping Server; Release-6\nDate: Thu, 08 Jan 2004 10:13:17 GMT\nWWW-Authenticate: Digest\nrealm=\"bsf.home1.net\",\nnonce=\"base64(RAND + AUTN + server specific data)\",\nalgorithm=AKAv1-MD5,\nqop=\"auth-int\",\nopaque=\"5ccc069c403ebaf9f0171e9517f30e41\"\n\nWWW-Authenticate:\tThe BSF challenges the user with new range of sequence number. The nonce includes the quoted string, base64 encoded value of the concatenation of the AKA RAND, AKA AUTN and server specific data.\n10.\tContinue with bootstrapping\nThe bootstrapping procedure continues from step 5 of clause A.3.\n",
            "summary": "",
            "tables": [
                {
                    "description": "Table A.4-2: BSF authentication information procedure (BSF to HSS)",
                    "table number": 5,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "A1.1\tScope of signalling flows",
            "description": "This annex gives examples of signalling flows for the GBA Push procedure.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "A1.2\tIntroduction",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "A1.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "The GBA Push procedure is executed in order to establish a bootstrapped security association, i.e. bootstrapping session between a Push-NAF and a UE.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "A1.2.2\tKey required to interpret signalling flows",
                    "description": "",
                    "summary": "",
                    "text_content": "The detailed message contents are not shown in the flows for this clause as they are not necessarily transported using a text based mechanism. The details for the message contents can be found in 3GPP TS 33.223 [24].\nThe flows show the signalling exchanges between the following functional entities:\n-\tUser Equipment (UE);\n-\tPush-Network Application Function (P-NAF);\n-\tBootstrapping Server Function (BSF);\n-\tHome Subscriber Server (HSS).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "A1.3\tSignalling flows demonstrating a successful GBA Push procedure",
            "description": "The overall GBA Push procedure in the successful case is presented in figure A1.3-1. The bootstrapping interface Zh performs the retrieval of an authentication vector by BSF from the HSS, this corresponds to steps 4 and 5 in figure A1.3-1. The bootstrapping interface Zpn performs the retrieval of the GPI by the Push-NAF from the BSF, this corresponds to steps 2 and 7 in figure A1.3-1. The bootstrapping interface Upa is used to transfer the GPI from the Push-NAF to the UE, this corresponds to step 9 in figure A1.3-1. The Zpn interface is defined in 3GPP TS 29.109 [3].\nThe figure depicts a GBA (Giga-BANDWIDTH Architecture) push signalling scenario, illustrating the process of data transmission between a GBA and a GBA-based switch. The figure shows the GBA push signaling process, with the GBA initiating the push and the switch processing the data. The figure is a visual representation of the GBA push signaling process, providing a clear understanding of how data is transmitted between the GBA and the switch.\nFigure A1.3-1: GBA Push signalling\n1.\tGenerate GPI Request (Push-NAF)\nA Push-NAF needs to establish a shared NAF SA with a UE which is registered for Push services. It knows the identity of the subscriber. The Push-NAF performs the processing described in 3GPP TS 33.223 [24] and generates the GPI Request.\n2.\tSend GPI Request (Push-NAF to BSF)\nThe Push-NAF sends the GPI Request to the BSF.\n3.\tInitial processing of GPI Requestion (BSF)\nUpon receiving the request from the NAF, the BSF performs the processing steps described in 3GPP TS 33.223 [24].\n4-5.\tZh: Authentication procedure (BSF and HSS)\nThese steps correspond to Step 2 in figure A.3-1.\n6.\tNAF SA generation (BSF)\nThe BSF generates the NAF SA as defined in 3GPP TS 33.223 [24].\n7.\tSend GPI Response (BSF to Push-NAF)\nThe GPI Response generated in the previous step is sent from the BSF to the Push-NAF.\n8.\tNAF SA storage (Push-NAF)\nThe Push-NAF stores the information needed to maintain the NAF SA as described in 3GPP TS 33.223 [24].\n9.\tGPI Push (Push-NAF to UE)\nThe Push-NAF sends a GPI Push to the UE. This can be send over whatever transport method that the Push-NAF wishes to use (e.g. SMS, MMS, SIP Message, etc) The GPI Push message is described in 3GPP TS 33.223 [24].\n10.\tNAF SA Storage (UE)\nThe UE processes the GPI as described in 3GPP TS 33.223 [24] and stores the NAF SA. The UE does not need to contact the network to correctly generate the NAF SA.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.1\tScope of signalling flows",
            "description": "This annex gives examples of signalling flows for using HTTP Digest Authentication with bootstrapped security association.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "B.2\tIntroduction",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "B.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "A bootstrapping session established using a bootstrapping procedure (cf. clause 4 and annex A) is used between a UE and a NAF. The BSF provides to the NAF a NAF specific key material (Ks_NAF or Ks_ext_NAF and optionally Ks_int_NAF) which is derived from the key material (Ks). The NAF uses this key to authenticate and optionally secure (i.e. integrity protect and encrypt) the communications between it and the UE. The BSF will also provide the NAF the expiration time of the bootstrapping session. When the bootstrapping session becomes invalid the NAF will stop using the session, and indicate to the UE that bootstrapping session has expired and that new session needs to be established.\nAn example of the signalling flows of the authentication procedure using HTTP Digest authentication as specified in RFC 7616 [36] is given in clause B.3.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "B.2.2\tKey required to interpret signalling flows",
                    "description": "",
                    "summary": "",
                    "text_content": "The key to interpret signalling flows is specified in clause A.2.2.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "B.3\tSignalling flows demonstrating a successful authentication procedure",
            "description": "The signalling flow in figure B.3-1 describes the generic message exchange between UE and NAF using HTTP Digest Authentication. In this example, the HTTPS client application resides in the ME, i.e., either Ks_NAF or Ks_ext_NAF is used as the key. The conversation can take place inside a server-authenticated TLS (as described in the RFC for TLS defined in annex E of 3GPP TS 33.310 [25]) tunnel in which case TLS session has been established before step 1.\nHTTP Digest Authentication with bootstrapped security association\nFigure B.3-1: HTTP Digest Authentication with bootstrapped security association\n1.\tGET request  (UE to NAF) - see example in table B.3-1\nThe UE sends an HTTP request to a NAF to gain access to a service.\nTable B.3-1: Initial GET request (UE to NAF)\nGET / HTTP/1.1\nHost: naf1.home1.net:1234\nUser-Agent: NAF1 Application Agent; Release-6 3gpp-gba\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer:\nX-3GPP-Intended-Identity: \"user@as1.home1.net\"\n\nRequest-URI:\tThe Request-URI (the URI that follows the method name, \"GET\", in the first line) indicates the resource indication of this GET request.\nHost:\tSpecifies the Internet host and port number of the NAF server, obtained from the original URI given by referring resource.\nUser-Agent:\tContains information about the user agent originating the request and it includes the static string \"3gpp-gba\" to indicate to the application server (i.e. NAF) that the UE supports 3GPP-bootstrapping based authentication.\nDate:\tRepresents the date and time at which the message was originated.\nAccept:\tMedia types which are acceptable for the response.\nReferer:\tAllows the user agent to specify the address (URI) of the resource from which the URI for the NAF was obtained.\nNOTE 1:\tThis step can also be a POST request in which case the request would contain a client payload in the HTTP request and the corresponding Content-Type and Content-Length header values.\n2.\t401 Unauthorized response (NAF to UE) - see example in table B.3-2\nUpon receiving an HTTP request that contains static string \"3gpp-gba\" in the User-Agent header, NAF can choose to authenticate the UE using bootstrapped security association. If NAF chooses to authenticate the UE using bootstrapped security association, it responds with HTTP response code 401 \"Unauthorized\" which contains a WWW-Authenticate header. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nTable B.3-2: 401 Unauthorized response (NAF to UE)\nHTTP/1.1 401 Unauthorized\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nWWW-Authenticate: Digest realm=\"3GPP-bootstrapping@naf.home1.net\", nonce=\"6629fae49393a05397450978507c4ef1\", algorithm=SHA2-256, qop=\"auth,auth-int\", opaque=\"5ccc069c403ebaf9f0171e9517f30e41\"\n\nServer:\tContains information about the software used by the origin server (NAF).\nDate:\tRepresents the date and time at which the message was originated.\nWWW-Authenticate:\tThe NAF challenges the user. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nThe options for the quality of protection (qop) attribute is by default \"auth-int\" meaning that the payload of the following HTTP requests and responses should integrity protected. If the conversation is taking place inside a server-authenticated TLS tunnel, the options for the qop attribute can also contain \"auth\" meaning that the payload of the following HTTP requests and responses are not protected by HTTP Digest. The integrity protection is handled on the TLS layer instead.\nThe realm attribute contains two parts delimited by \"@\" sign. The first part is a constant string \"3GPP-bootstrapping\" instructing the UE to use a bootstrapped security association. The second part is the FQDN of the NAF.\nThe value of the \"algorithm\" attribute is \"SHA2-256\", \"SHA2-512/256\" or \"MD5\".\nNOTE 2:\tThe MD5 algorithm is only supported for backward compatibility.\n3.\tGeneration of NAF specific keys at UE\nUE verifies that the second part of the realm attribute does correspond to the server it is talking to. In particular, if the conversation is taking place inside a server-authenticated TLS tunnel, the UE shall verify that the server name in the server's TLS certificate matches the server name in the realm attribute of the WWW-Authenticate header.\nUE derives the NAF specific key material Ks_(ext)_NAF as specified in 3GPP TS 33.220 [1].\nNOTE 3:\tIf UE does not have a bootstrapped security association available, it obtains one by running bootstrapping procedure over Ub interface\n4.\tGET request (UE to NAF) - see example in table B.3-3\nUE generates the HTTP request by calculating the Authorization header values using the bootstrapping transaction identifier B-TID it received from the BSF as the username and the NAF specific key material Ks_(ext)_NAF (base64 encoded) as the password, and sends the request to NAF.\nTable B.3-3: GET request (UE to NAF)\nGET / HTTP/1.1\nHost: naf1.home1.net:1234\nUser-Agent: NAF1 Application Agent; Release-6 3gpp-gba\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer: http://naf1.home1.net:1234/service\nX-3GPP-Intended-Identity: \"user@as1.home1.net\"\nAuthorization: Digest username=\"(B-TID)\", realm=\"3GPP-bootstrapping@naf.home1.net\", nonce=\"a6332ffd2d234==\", uri=\"/\", qop=auth-int, nc=00000001, cnonce=\"6629fae49393a05397450978507c4ef1\", response=\"6629fae49393a05397450978507c4ef1\", opaque=\"5ccc069c403ebaf9f0171e9517f30e41\", algorithm=SHA2-256\n\nAuthorization:\tThis carries the response to the authentication challenge received in step 2 along with the username, the realm, the nonce, the URI, the qop, the nc, the cnonce, the response, the opaque, and the algorithm.\nThe qop attribute is set to \"auth-int\" by default. If the conversation is taking place inside a server-authenticated TLS tunnel, the qop attribute can be set to \"auth\" as well.\nThe value of the \"algorithm\" attribute is set to \"SHA2-256\", \"SHA2-512/256\" or \"MD5\".\nNOTE 4:\tThe MD5 algorithm is only supported for backward compatibility.\nNOTE 5:\tIf step 1 was a POST request then this request would also be POST request and contain the same client payload in the HTTP request as was carried in step 1.\n5.\tZn: NAF specific key procedure\nNAF retrieves the NAF specific key material (Ks_NAF or Ks_ext_NAF) from the BSF.\nIn the case that the HTTPS client resides in the UICC, then the NAF needs to retrieve Ks_int_NAF.\nIf the NAF retrieved an application-specific USS and it contained a keyChoice indication, the NAF must enforce this indication. Hence, if the UICC-based key was indicated the NAF must terminate the communication with the UE in this phase.\nNOTE 6:\tIf the local configuration in the NAF restricts the access to the service to UICC-based applications using only Ks_int_NAF, then the NAF will terminate the communication with the UE in this phase.\nFor detailed signalling flows see 3GPP TS 29.109 [3].\nTable B.3-4: Bootstrapping authentication information procedure (NAF to BSF)\n\n6.\tAuthentication at NAF\nNAF verifies the Authorization header by using the bootstrapping transaction identifier B-TID and the key material Ks_(ext)_NAF obtained from BSF. NAF calculates the corresponding digest values using Ks_(ext)_NAF, and compares the calculated values with the received values in the Authorization header.\nThe NAF also verifies that the DNS name in the realm attribute matches its own. If the conversation is taking place inside a server-authenticated TLS tunnel, the NAF shall also verify that this DNS name is the same as that of the TLS server certificate.\nIf the verification succeeds, the incoming client-payload request is taken in for further processing.\n7.\t200 OK response (NAF to UE) - see example in table B.3-5\nThe NAF sends 200 OK response to the UE to indicate the success of the authentication. NAF generates a HTTP response containing the server-payload it wants to send back to the UE.  The NAF can use key material Ks_(ext)_NAF to integrity protect and authenticate the response.\nTable B.3-5: 200 OK response (NAF to UE)\nHTTP/1.1 200 OK\nServer: Apache/1.3.22 (Unix) mod_perl/1.27Content-Type: text/html\nContent-Length: 1234\nAuthentication-Info: qop=auth-int, rspauth=\"6629fae49394a05397450978507c4ef1\", cnonce=\"6629fae49393a05397450978507c4ef1\", nc=00000001\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nExpires: Fri, 09 Jan 2004 10:50:36 GMT\n\n<SERVER PAYLOAD>\n\nContent-Type:\tContains the media type of the entity body.\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nAuthentication-Info:\tThis carries the protection\nExpires:\tGives the date/time after which the response is considered stale.\n8.\tAuthentication at UE\nUE receives the response and verifies the Authentication-Info header. If the verification succeeds, the UE can accept the server-payload for further processing.\nNOTE 7:\tAdditional messages can be exchanged using steps 4 through 8 as many times as is necessary. The following HTTP requests and responses are constructed according to RFC 7616 [36].\n",
            "summary": "",
            "tables": [
                {
                    "description": "Table B.3-4: Bootstrapping authentication information procedure (NAF to BSF)",
                    "table number": 6,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "C.1\tIntroduction",
            "description": "This annex contains the XML schema definition for an XML document carrying the bootstrapping transaction identifier (B-TID), the key lifetime, and possibly other server specific data.\nThe \"lifetime\" attribute shall indicate the expiry time of the key. The lifetime value shall be expressed in UTC form, indicated by a time zone designator \"Z\" immediately following the time portion of the value.\nIf the XML document includes <currenttime> element, the <currenttime> element is included in the <Extension> element of the <BootstrappingInfo> root element.\nNOTE 1:\tWhen included, the <currenttime> element is validated by the <xs:any processContents=\"lax\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> particle of the <Extension> element.\nThe current time shall be expressed in UTC form, indicated by a time zone designator \"Z\" immediately following the time portion of the value. The UE may use information in the <currenttime> element to determine the duration for which the bootstrapping transaction identifier (B-TID) is valid.\nThe receiving entity ignores any unknown XML element and any unknown XML attribute.\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xs:schema targetNamespace=\"uri:3gpp-gba\"\nxmlns:gba=\"uri:3gpp-gba\"\nxmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\nelementFormDefault=\"qualified\"\nattributeFormDefault=\"unqualified\">\n\n<xs:complexType name=\"tExtension\">\n<xs:sequence>\n<xs:any processContents=\"lax\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n</xs:sequence>\n</xs:complexType>\n\n<!-- definition of the root element containing B-TID and key lifetime -->\n<xs:complexType name=\"bootstrappingInfoType\">\n<xs:sequence>\n<xs:element name=\"btid\" type=\"xs:string\"/>\n<xs:element name=\"lifetime\" type=\"xs:dateTime\"/>\n<xs:element name=\"Extension\" type=\"gba:tExtension\" minOccurs=\"0\"/>\n</xs:sequence>\n</xs:complexType>\n\n<!-- the root element -->\n<xs:element name=\"BootstrappingInfo\" type=\"gba:bootstrappingInfoType\"/>\n\n<!-- extension elements included in the Extension element of the root BootstrappingInfo element -->\n<xs:element name=\"currenttime\" type=\"xs:dateTime\"/>\n\n\n</xs:schema>\n\nNOTE 2:\tThe <xs:any> element within the complex type tExtension allows for compatible standard extensions in future releases.\n\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "D.1\tScope of signalling flows",
            "description": "This annex gives examples of signalling flows for using AP in GAA.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "D.2\tIntroduction",
            "description": "A bootstrapping session (established using a bootstrapping procedure, cf. clause 4 and annex A) is used between a UE and an authentication proxy (AP) that is functioning as a NAF. The BSF provides to the AP an AP specific key material (Ks_NAF or Ks_ext_NAF and optionally Ks_int_NAF), which is derived from the key material (Ks). The AP uses this key to authenticate and optionally secure (i.e. integrity protect with HTTP Digest using \"auth-int\" qop option, or integrity protect and encrypt with PSK TLS) the communications between it and the UE. The BSF will also provide the AP the expiration time of the bootstrapping session. When the bootstrapping session becomes invalid the AP will stop using the session, and indicate to the UE that bootstrapping session has expired and that new session needs to be established.\nThe AP functions as a reverse proxy. After the AP has authenticated and optionally secured the communcation between it and the UE, the AP will forward the incoming HTTP requests from the UE to the correct appliation server (AS) behind the AP. There can be multiple application servers behind the AP.\nNOTE:\tAs consequence of the fact that the UE assumes it is communicating with the AS, not the AP, the AP might need to use different NAF specific keys per UE because (i) the UE will use the hostname of the AS (i.e., NAF_ID) when deriving the NAF specific key, (ii) the AP is doing virtual name based hosting, i.e., has reverse proxy functionality, and (iii) the UE can communicate through the AP with several ASes at the same time.\nAn example of the signalling flows of the authentication procedure between a UE, an AP, and an AS is given in clause D.3.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "D.2.1\tKey required to interpret signalling flows",
                    "description": "",
                    "summary": "",
                    "text_content": "The key to interpret signalling flows specified in clause A.2.2.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "D.3\tSignalling flow demonstrating a successful authentication procedure",
            "description": "The signalling flow in figure D.3-1 describes the generic message exchange between a UE, a AP, and an AS using HTTP. In this example, the HTTP client application resides in the ME, i.e., either Ks_NAF or Ks_ext_NAF is used as the key. The conversation between the UE and the AP can take place inside a server-authenticated TLS (as described in the RFC for TLS defined in annex E of 3GPP TS 33.310 [25]) tunnel in which case TLS session has been established before step 1.\nThe figure depicts a successful authentication process with an AP and an AS, illustrating the use of authentication protocols such as RADIUS and RADIUSv2. The diagram shows the network infrastructure, including the AP and AS, and the authentication process, highlighting the use of RADIUS and RADIUSv2 for secure communication.\nFigure D.3-1: Successful authentiation with AP and AS\n1.\tGET request  (UE to AP) - see example in table D.3-1\nThe UE sends an HTTP request to a AP to gain access to a service.\nTable D.3-1: Initial GET request (UE toAP)\nGET / HTTP/1.1\nHost: as1.home1.net:1234\nUser-Agent: NAF1 Application Agent; Release-6 3gpp-gba\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer: http://as1.home1.net:1234/service\n\n\nRequest-URI:\tThe Request-URI (the URI that follows the method name, \"GET\", in the first line) indicates the resource indication of this GET request.\nHost:\tSpecifies the Internet host and port number of the AS, obtained from the original URI given by referring resource.\nUser-Agent:\tContains information about the user agent originating the request and it includes the static string \"3gpp-gba\" to indicate to the application server (i.e. NAF) that the UE supports 3GPP-bootstrapping based authentication.\nDate:\tRepresents the date and time at which the message was originated.\nAccept:\tMedia types which are acceptable for the response.\nReferer:\tAllows the user agent to specify the address (URI) of the resource from which the URI for the AS was obtained.\nNOTE 1:\tThe UE assumes it is communicating directly with the AS, but is in fact communicating with the AP which functioning as a reverse proxy.\n2.\t401 Unauthorized response (AP to UE) - see example in table D.3-2\nUpon receiving an HTTP request that contains static string \"3gpp-gba\" in the User-Agent header, the AP might choose to authenticate the UE using bootstrapped security association. If AP chooses to authenticate the UE using bootstrapped security association, it responds with HTTP response code 401 \"Unauthorized\" which contains a WWW-Authenticate header. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nTable D.3-2: 401 Unauthorized response (AP to UE)\nHTTP/1.1 401 Unauthorized\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nWWW-Authenticate: Digest realm=\"3GPP-bootstrapping@as1.home1.net\", nonce=\"6629fae49393a05397450978507c4ef1\", algorithm=SHA2-256, qop=\"auth,auth-int\", opaque=\"5ccc069c403ebaf9f0171e9517f30e41\"\n\n\nServer:\tContains information about the software used by the origin server (AP).\nDate:\tRepresents the date and time at which the message was originated.\nWWW-Authenticate:\tThe AP challenges the user. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nThe options for the quality of protection (qop) attribute for HTTP Digest integrity protection is by default \"auth-int\" meaning that the payload of the following HTTP requests and responses should integrity protected. If the conversation is taking place inside a server-authenticated TLS tunnel, the options for the qop attribute might also contain \"auth\" meaning that the payload of the following HTTP requests and responses are not protected by HTTP Digest. The integrity protection is handled on the TLS layer instead.\nThe realm attribute contains two parts delimited by \"@\" sign. The first part is a constant string \"3GPP-bootstrapping\" instructing the UE to use a bootstrapped security association. The second part is the FQDN of the NAF. In this case, the FQDN of the NAF must be the server hostname that the UE used in the corresponding HTTP request, i.e., the hostname of the AS.\nThe value of the \"algorithm\" attribute is \"SHA2-256\", \"SHA2-512/256\" or \"MD5\".\nNOTE 2:\tThe MD5 algorithm is only supported for backward compatibility.\n3.\tGeneration of NAF specific keys at UE\nThe UE verifies that the second part of the realm attribute does correspond to the server it is talking to. In particular, if the conversation is taking place inside a server-authenticated TLS tunnel, the UE verifies that the server name in the server's TLS certificate matches the server name in the realm attribute of the WWW-Authenticate header.\nThe UE derives the NAF specific key material Ks_(ext)_NAF as specified in 3GPP TS 33.220 [1].\nNOTE 3:\tIf the UE does not have a bootstrapped security association available, it will obtain one by running bootstrapping procedure over Ub interface\n4.\tGET request (UE to AP) - see example in table D.3-3\nThe UE generates the HTTP request by calculating the Authorization header values using the bootstrapping transaction identifier B-TID it received from the BSF as the username and the NAF specific key material Ks_(ext)_NAF (base64 encoded) as the password, and sends the request to the AP.\nTable D.3-3: GET request (UE to AP)\nGET / HTTP/1.1\nHost: as1.home1.net:1234\nUser-Agent: NAF1 Application Agent; Release-6 3gpp-gba\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer: http://as1.home1.net:1234/service\nAuthorization: Digest username=\"(B-TID)\", realm=\"3GPP-bootstrapping@as1.home1.net\", nonce=\"a6332ffd2d234==\", uri=\"/\", qop=auth-int, nc=00000001, cnonce=\"6629fae49393a05397450978507c4ef1\", response=\"6629fae49393a05397450978507c4ef1\", opaque=\"5ccc069c403ebaf9f0171e9517f30e41\", algorithm=SHA2-256\n\n\nAuthorization:\tThis carries the response to the authentication challenge received in step 2 along with the username, the realm, the nonce, the URI, the qop, the nc, the cnonce, the response, the opaque, and the algorithm.\nThe qop attribute is set to \"auth-int\" when HTTP Digest integrity protection is used. If the conversation is taking place inside a server-authenticated TLS tunnel, the qop attribute can be set to \"auth\" as well.\nThe value of the \"algorithm\" attribute is set to \"SHA2-256\", \"SHA2-512/256\" or \"MD5\".\nNOTE 4:\tThe MD5 algorithm is only supported for backward compatibility.\n5.\tValidate authentication and authorize request\nIf the AP does not have the NAF specific key material (Ks_NAF or Ks_ext_NAF), then the AP retrieves that and one or more user security setting (USS) from the BSF. For detailed signalling flows see 3GPP TS 29.109 [3].\nIf the AP retrieved an application-specific USS and it contained a keyChoice indication, the AP must enforce this indication. Hence, if the UICC-based key was indicated the AP must terminate the communication with the UE in this phase.\nNOTE 5:\tIf the local configuration in the AP restricts the access to this NAF service to UICC-based applications, then the AP will terminate the communication with the UE in this phase.\nThe AP verifies the Authorization header by using the bootstrapping transaction identifier B-TID and the key material Ks_(ext)_NAF obtained from BSF. The AP calculates the corresponding digest values using Ks_(ext)_NAF, and compares the calculated values with the received values in the Authorization header.\tThe AP will also verify that the DNS name in the realm attribute matches the AS hostname. If the conversation is taking place inside a server-authenticated TLS tunnel, the AP will also verify that this DNS name is the same as that of the TLS server.\nIf the verification succeeds, the incoming client-payload request is taken in for further processing.\nDepending on the AP configuration, the AP will inspect the incoming HTTP request accordingly, see 3GPP TS 33.222 [5]. In this example it is assumed that the AP has been configured to add subscriber's identifiers (UIDs) to the forwarded HTTP request (see step 6).\nNOTE 6:\tIf UE has included \"X-3GPP-Intended-Identity\" with subscriber's identity to the HTTP response, then the AP will validate the given identity before forwarding the request to the AS.\n6.\tGET request  (AP to AS) - see example in table D.3-4\nThe AP forwards the HTTP request to the correct AS. The correct AS is determined by checking the \"Host\" header of the request and AP's internal configuration.\nThe AP removes the \"Authorization\" header from the forwarded HTTP request. Depending on the AP configuration, the AP might add subscriber's UIDs to the HTTP request by using \"X-3GPP-Asserted-Identity\" header.\nIn this example, subscriber's UIDs are added to the request.\nTable D.3-4: GET request (AP to AS)\nGET / HTTP/1.1\nHost: as1.home1.net:1234\nUser-Agent: NAF1 Application Agent; Release-6 3gpp-gba\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer: http://as1.home1.net:1234/service\nX-3GPP-Asserted-Identity: \"user@as1.home1.net\", \"user2@as1.home.net\"\n\n\nContent-Type:\tContains the media type of the entity body.\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nAuthentication-Info:\tThis carries the protection\nExpires:\tGives the date/time after which the response is considered stale.\nX-3GPP-Asserted-Identity:\tThis header is added by the AP and carries the list of subscriber's identities to the AS.\n7.\tAS specific logic at AS\nThe AS processes the incoming HTTP request and extracts the UIDs from the \"X-3GPP-Asserted-Identity\" header.\n8.\t200 OK response (AS to AP) - see example in table D.3-5\nThe AS returns a HTTP response to the AP with service specific payload.\nTable D.3-5: 200 OK response (AS to AP)\nHTTP/1.1 200 OK\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nContent-Type: text/html\nContent-Length: (...)\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nExpires: Fri, 09 Jan 2004 10:50:36 GMT\n\n<SERVER PAYLOAD>\n\nContent-Type:\tContains the media type of the entity body.\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nExpires:\tGives the date/time after which the response is considered stale.\n9.\tAdd Authentication-Info header at AP\nThe AP calculates and adds the \"Authentication-Info\" header to the HTTP response that forwarded to the UE.\n10.\t200 OK response (AP to UE) - see example in table D.3-6\nThe AP forwards the HTTP response to the UE.\nTable D.3-6: 200 OK response (AP to UE)\nHTTP/1.1 200 OK\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nContent-Type: text/html\nContent-Length: 1234\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nExpires: Fri, 09 Jan 2004 10:50:36 GMT\nAuthentication-Info: qop=auth-int, rspauth=\"6629fae49394a05397450978507c4ef1\", cnonce=\"6629fae49393a05397450978507c4ef1\", nc=00000001\n\n<SERVER PAYLOAD>\n\nAuthentication-Info:\tThis header is inserted by the AP to the request. The values in the header are calculated by the AP.\n11.\tProcess response at UE\nThe UE receives the response and verifies the Authentication-Info header. If the verification succeeds, the UE can accept the server-payload for further processing.\nNOTE 7:\tAdditional messages can be exchanged using steps 4 through 11 as many times as is necessary. The HTTP Digest releated headers in the following HTTP requests and responses must be constructed according to RFC 7616 [36].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "E.1\tScope of signalling flows",
            "description": "This annex gives examples of signalling flows for the subscriber certificate enrolment and the CA certificate delivery.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "E.2\tIntroduction",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "E.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "A bootstrapping session established using a bootstrapping procedure (cf., clause 4 and annex A) is used between a UE and a PKI portal. The BSF provides to the PKI portal a NAF specific key material (Ks_NAF or Ks_ext_NAF) which is derived from the key material (Ks). The PKI portal uses this key to authenticate and optionally secure (i.e. integrity protect and encrypt) the communications between it and the UE. The BSF will also provide the PKI portal the expiration time of the bootstrapping session.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.2.2\tKey required to interpret signalling flows",
                    "description": "",
                    "summary": "",
                    "text_content": "The key to interpret signalling flows is specified in clause A.2.2.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "E.3\tSignalling flows demonstrating a successful subscriber certificate enrolment",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "E.3.1\tSimple subscriber certificate enrolment",
                    "description": "",
                    "summary": "",
                    "text_content": "The signalling flow in figure E.3.1-1 describes the message exchange between UE and PKI portal when UE wants to enrol a subscriber certificate. The messaging can take place inside a server-authenticated TLS (as described in the RFC for TLS defined in annex E of 3GPP TS 33.310 [25]) tunnel in which case TLS session has been established before step 1.\nThe figure depicts a successful subscriber certificate enrolment process, illustrating the steps taken by the subscriber to obtain a certificate. The process includes obtaining a digital certificate from a trusted authority, signing the certificate with the subscriber's private key, and then using the certificate to authenticate the subscriber's identity. The figure also shows the certificate's validity period and the steps required to renew the certificate.\nFigure E.3.1-1: Successful subscriber certificate enrolment.\n1.\tInitial enrolment request  (UE to PKI portal) - see example in table E.3.1-1\nThe UE sends an HTTP request to the PKI portal containing a PKCS#10 certification request.\nTable E.3.1-1: Initial enrolment request (UE to PKI portal)\nPOST /enrol?response=single HTTP/1.1\nHost: pkiportal.home1.net:1234\nContent-Type: application/x-pkcs10\nContent-Length: (...)\nUser-Agent: SCEnrolmentAgent; Release-6 3gpp-gba\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer:\n\n----- BEGIN CERTIFICATE REQUEST -----\n<PKCS#10 BLOB>\n----- END CERTIFICATE REQUEST -----\n\nRequest-URI:\tThe Request-URI (the URI that follows the method name, \"POST\", in the first line) indicates the resource of this POST request. The Request-URI contains the parameter \"response\" which is set to \"single\" to indicate to the PKI portal the desired response type, i.e. just the subscriber certificate is requested to be delivered.\nHost:\tSpecifies the Internet host and port number of the PKI portal server, obtained from the original URI given by referring resource.\nContent-Type:\tContains the media type \"application/x-pkcs10\", i.e. the PKCS#10.\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nUser-Agent:\tContains information about the user agent originating the request and it will include the static string \"3gpp-gba\" to indicate to the application server (i.e., NAF) that the UE supports 3GPP-bootstrapping based authentication.\nDate:\tRepresents the date and time at which the message was originated.\nAccept:\tMedia types which are acceptable for the response.\nReferer:\tAllows the user agent to specify the address (URI) of the resource from which the URI for the PKI portal was obtained.\nNOTE 1:\tThis step is used to trigger the GBA-based authentication between the UE and the PKI portal.\n2.\t401 Unauthorized response (PKI portal to UE) - see example in table E.3.1-2\nUpon receiving an HTTP request that contains static string \"3gpp-gba\" in the User-Agent header the PKI portal responds with HTTP response code 401 \"Unauthorized\" which contains a WWW-Authenticate header. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nTable E.3.1-2: 401 Unauthorized response (PKI portal to UE)\nHTTP/1.1 401 Unauthorized\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nWWW-Authenticate: Digest realm=\"3GPP-bootstrapping@pkiportal.home1.net\", nonce=\"6629fae49393a05397450978507c4ef1\", algorithm=MD5, qop=\"auth,auth-int\", opaque=\"5ccc069c403ebaf9f0171e9517f30e41\"\n\nServer:\tContains information about the software used by the origin server (PKI portal).\nDate:\tRepresents the date and time at which the message was originated.\nWWW-Authenticate:\tThe PKI portal challenges the user. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nThe options for the quality of protection (qop) attribute is by default \"auth-int\" meaning that the payload of the following HTTP requests and responses should integrity protected. If the messaging is taking place inside a server-authenticated TLS tunnel, the options for the qop attribute can also contain \"auth\" meaning that the payload of the following HTTP requests and responses are not protected by HTTP Digest. The integrity protection is handled on the TLS layer instead.\nThe realm attribute contains two parts delimited by \"@\" sign. The first part is a constant string \"3GPP-bootstrapping\" instructing the UE to use a bootstrapped security association. The second part is the hostname of the server (i.e. FQDN of the PKI portal).\n3.\tGeneration of NAF specific keys at UE\nThe UE verifies that the second part of the realm attribute does correspond to the server it is talking to. In particular, if the messaging is taking place inside a server-authenticated TLS tunnel, the UE verifies that the server name (i.e. FQDN of the PKI portal) in the server's TLS certificate matches the hostname of the server in the realm attribute of the WWW-Authenticate header.\nUE derives the NAF specific key material Ks_NAF as specified in 3GPP TS 33.220 [1].\nNOTE 2:\tIf UE does not have a bootstrapped security association available, it will obtain one by running bootstrapping procedure over Ub interface.\n4.\tAuthenticated enrolment request (UE to PKI portal) - see example in table E.3.1-3\nUE generates the HTTP request by calculating the Authorization header values using the bootstrapping transaction identifier B-TID it received from the BSF as the username and the NAF specific key material Ks_NAF (base64 encoded) as the password, and sends the request to PKI portal.\nTable E.3.1-3: Authenticated enrolment request (UE to PKI portal)\nPOST /enrol?response=single HTTP/1.1\nHost: pkiportal.home1.net:1234\nContent-Type: application/pkcs10\nContent-Length: (...)\nUser-Agent: SCEnrolmentAgent; Release-6 3gpp-gba\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer: http://pkiportal.home1.net:1234/service\nAuthorization: Digest username=\"(B-TID)\", realm=\"3GPP-bootstrapping@pkiportal.home1.net\", nonce=\"a6332ffd2d234==\", uri=\"/enrol?response=single\", qop=auth-int, nc=00000001, cnonce=\"6629fae49393a05397450978507c4ef1\", response=\"6629fae49393a05397450978507c4ef1\", opaque=\"5ccc069c403ebaf9f0171e9517f30e41\", algorithm=MD5\n\n----- BEGIN CERTIFICATE REQUEST -----\n<PKCS#10 BLOB>\n----- END CERTIFICATE REQUEST -----\n\nAuthorization:\tThis carries the response to the authentication challenge received in step 2 along with the username, the realm, the nonce, the URI, the qop, the NC, the cnonce, the response, the opaque, and the algorithm.\nThe qop attribute is set to \"auth-int\" by default. If the messaging is taking place inside a server-authenticated TLS tunnel, the qop attribute can be set to \"auth\" as well.\nNOTE 3:\tIf step 1 was a POST request then this request would also be POST request and contain the same client payload in the HTTP request as was carried in step 1.\n5.\tZn: NAF specific key procedure\nPKI portal retrieves the NAF specific key material (Ks_NAF) and subscriber's user security setting from the BSF.\nNOTE 4:\tSubscriber's user security setting for PKI portal consists of flags that indicate whether certain type certificate is authorized to be issued to the subscriber. There are two certificate types: authentication certificate and non-repudiation certificate.\nFor detailed signalling flows see 3GPP TS 29.109 [3].\nTable E.3.1-4: Bootstrapping authentication information procedure (PKI portal to BSF)\n\n6.\tAuthentication and certificate generation at PKI portal\nPKI portal verifies the Authorization header by using the bootstrapping transaction identifier B-TID and the key material Ks_NAF obtained from BSF. PKI portal calculates the corresponding digest values using Ks_NAF, and compares the calculated values with the received values in the Authorization header.\nThe PKI portal also verifies that the hostname (i.e. its FQDN) in the realm attribute matches its own. If the messaging is taking place inside a server-authenticated TLS tunnel, the PKI portal also verifies that this hostname is the same as that of the TLS server.\nIf the verification succeeds, the incoming client-payload request is taken in for further processing. The PKI portal continues processing of the PKCS#10 request according to its internal policies. The PKI portal verifies that the subscriber is allowed to receive the particular type of certificate indicate in the PKCS#10 request by checking subscriber's user security setting received from the BSF in step 5.\nNOTE 5:\tThe procedures for generating the subscriber certificate are outside the scope.\n7.\tDelivery of subscriber certificate (PKI portal to UE) - see example in table E.3.1-5\nThe PKI portal sends 200 OK response to the UE to indicate the success of the authentication and the subscriber certificate enrolment. The PKI portal generates a HTTP response containing the enrolled subscriber certificate.  The PKI portal can use key material Ks_NAF to integrity protect and authenticate the response.\nTable E.3.1-5: Delivery of subscriber certificate (PKI portal to UE)\nHTTP/1.1 200 OK\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nContent-Type: text/html\nContent-Type: application/x-x509-user-cert\nContent-Length: (...)\nAuthentication-Info: qop=auth-int, rspauth=\"6629fae49394a05397450978507c4ef1\", cnonce=\"6629fae49393a05397450978507c4ef1\", nc=00000001\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nExpires: Fri, 09 Jan 2004 10:50:36 GMT\n\n----- BEGIN CERTIFICATE -----\n<Subscriber certificate BLOB>\n----- END CERTIFICATE -----\n\nContent-Type:\tContains the media type \"application/x-x509-user-cert\", i.e. X.509 certificate.\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nAuthentication-Info:\tThis carries the protection\nExpires:\tGives the date/time after which the response is considered stale.\n8.\tAuthentication at UE\nThe UE receives the response and verifies the Authentication-Info header. If the verification succeeds, the UE can accept the subscriber certificate for further processing.\n",
                    "tables": [
                        {
                            "description": "Table E.3.1-4: Bootstrapping authentication information procedure (PKI portal to BSF)",
                            "table number": 7,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "E.3.2\tSubscriber certificate enrolment with WIM authentication codes",
                    "description": "",
                    "summary": "",
                    "text_content": "The signalling flow in figure E.3.2-1 describes the message exchange between UE and PKI portal when UE wants to enrol a subscriber certificate, and the UE uses a WIM that requires authentication codes both for onboard key pair generation and proof-of-origin generation. The messaging can take place inside a server-authenticated TLS (as described in the RFC for TLS defined in annex E of 3GPP TS 33.310 [25]) tunnel in which case TLS session has been established before step 1.\nThe figure depicts a successful subscriber certificate enrolment process, illustrating the steps taken by the subscriber to obtain a certificate. The process includes obtaining a digital certificate from a trusted authority, signing the certificate with the subscriber's private key, and then using the certificate to authenticate the subscriber's identity. The figure also shows the certificate's validity period, which is typically 10 years, and the expiration date. The certificate is presented in a graphical format, with the certificate number, expiration date, and validity period clearly displayed.\nFigure E.3.2-1: Successful subscriber certificate enrolment\n1.\tWIM authentication code for onboard key pair generation required at UE\nThe UE has initiated enrolment procedure and the WIM in the UE requires an WIM authentication code for the onboard key pair generation.\nNOTE 1:\tIt is not mandatory to generate a key pair for each enrolment procedure, and the WIM can not require WIM authentication code for generating the key pair. In these cases, the WIM authentication code is not needed.\n2.\tInitial WIM authentication code request  (UE to PKI portal) - see example in table E.3.2-1\nThe UE sends an HTTP request to the PKI portal containing a WIM authentication code request.\nTable E.3.2-1: Initial WIM authentication code request (UE to PKI portal)\nGET /enrol/wim-auth-code?request=error:AuthReq:123456789ABCDEF:AABBCCDDEE HTTP/1.1\nHost: pkiportal.home1.net:1234\nUser-Agent: SCEnrolmentAgent; Release-6\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer:\n\n\nRequest-URI:\tThe Request-URI (the URI that follows the method name, \"GET\", in the first line) indicates the resource of this GET request.  The Request-URI contains the parameter \"request\" which contains the WIM authentication request parameter received from the WIM, i.e. a static string \"error:AuthReq:\" appended by the WIM serial number in hexadecimal format, colon \":\", and the challenge data in hexadecimal format.\nHost:\tSpecifies the Internet host and port number of the PKI portal server, obtained from the original URI given by referring resource.\nUser-Agent:\tContains information about the user agent originating the request.\nDate:\tRepresents the date and time at which the message was originated.\nAccept:\tMedia types which are acceptable for the response.\nReferer:\tAllows the user agent to specify the address (URI) of the resource from which the URI for the PKI portal was obtained.\nNOTE 2:\tThis step is used to trigger the GBA-based authentication between the UE and the PKI portal.\n3.\t401 Unauthorized response (PKI portal to UE) - see example in table E.3.2-2\nThe PKI portal responds with HTTP response code 401 \"Unauthorized\" which contains a WWW-Authenticate header. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nTable E.3.2-2: 401 Unauthorized response (PKI portal to UE)\nHTTP/1.1 401 Unauthorized\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nWWW-Authenticate: Digest realm=\"3GPP-bootstrapping@pkiportal.home1.net\", nonce=\"6629fae49393a05397450978507c4ef1\", algorithm=MD5, qop=\"auth,auth-int\", opaque=\"5ccc069c403ebaf9f0171e9517f30e41\"\n\nServer:\tContains information about the software used by the origin server (PKI portal).\nDate:\tRepresents the date and time at which the message was originated.\nWWW-Authenticate:\tThe PKI portal challenges the user. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nThe options for the quality of protection (qop) attribute is by default \"auth-int\" meaning that the payload of the following HTTP requests and responses should integrity protected. If the messaging is taking place inside a server-authenticated TLS tunnel, the options for the qop attribute can also contain \"auth\" meaning that the payload of the following HTTP requests and responses are not protected by HTTP Digest. The integrity protection is handled on the TLS layer instead.\nThe realm attribute contains two parts delimited by \"@\" sign. The first part is a constant string \"3GPP-bootstrapping\" instructing the UE to use a bootstrapped security association. The second part is the hostname of the server (i.e. FQDN of the PKI portal).\n4.\tGeneration of NAF specific keys at UE\nThe UE verifies that the second part of the realm attribute does correspond to the server it is talking to. In particular, if the messaging is taking place inside a server-authenticated TLS tunnel, the UE verifies that the server name (i.e. FQDN of the PKI portal) in the server's TLS certificate matches the hostname of the server in the realm attribute of the WWW-Authenticate header.\nUE derives the NAF specific key material Ks_NAF as specified in 3GPP TS 33.220 [1].\nNOTE 3:\tIf UE does not have a bootstrapped security association available, it will obtain one by running bootstrapping procedure over Ub interface.\n5.\tAuthenticated WIM authentication code request (UE to PKI portal) - see example in table E.3.2-3\nUE generates the HTTP request by calculating the Authorization header values using the bootstrapping transaction identifier B-TID it received from the BSF as the username and the NAF specific key material Ks_NAF as the password, and sends the request to PKI portal.\nTable E.3.2-3: Authenticated WIM authentication code request (UE to PKI portal)\nGET /enrol/wim-auth-code?request=error:AuthReq:123456789ABCDEF:AABBCCDDEE HTTP/1.1\nHost: pkiportal.home1.net:1234\nUser-Agent: SCEnrolmentAgent; Release-6\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer: http://pkiportal.home1.net:1234/service\nAuthorization: Digest username=\"(B-TID)\", realm=\"3GPP-bootstrapping@pkiportal.home1.net\", nonce=\"a6332ffd2d234==\", uri=\"/enrol/wim-auth-code?request=error:AuthReq:123456789ABCDEF:AABBCCDDEE \", qop=auth-int, nc=00000001, cnonce=\"6629fae49393a05397450978507c4ef1\", response=\"6629fae49393a05397450978507c4ef1, opaque=\"5ccc069c403ebaf9f0171e9517f30e41\", algorithm=MD5\n\n\nAuthorization:\tThis carries the response to the authentication challenge received in step 2 along with the username, the realm, the nonce, the URI, the qop, the NC, the cnonce, the response, the opaque, and the algorithm.\nThe qop attribute is set to \"auth-int\" by default. If the messaging is taking place inside a server-authenticated TLS tunnel, the qop attribute can be set to \"auth\" as well.\n6.\tZn: NAF specific key procedure\nPKI portal retrieves the NAF specific key material (Ks_NAF) from the BSF.\nFor detailed signalling flows see 3GPP TS 29.109 [3].\nTable E.3.2-4: Bootstrapping authentication information procedure (PKI portal to BSF)\n\n7.\tAuthentication and WIM authentication code generation at NAF\nPKI portal verifies the Authorization header by using the bootstrapping transaction identifier B-TID and the key material Ks_NAF obtained from BSF. The PKI portal calculates the corresponding digest values using Ks_NAF, and compares the calculated values with the received values in the Authorization header.\nThe PKI portal also verifies that the hostname (i.e. its FQDN) in the realm attribute matches its own. If the messaging is taking place inside a server-authenticated TLS tunnel, the PKI portal also verifies that this hostname is the same as that of the TLS server.\nIf the verification succeeds, the WIM authentication code is taken in for further processing. The PKI portal continues processing of the WIM authentication code request according to its internal policies.\nNOTE 4:\tThe procedures for generating the WIM authentication code are outside the scope.\n8.\tDelivery of WIM authentication code (PKI portal to UE) - see example in table E.3.2-5\nThe PKI portal sends 200 OK response to the UE to indicate the success of the authentication and the WIM authentication code generation. The PKI portal generates a HTTP response containing the WIM authentication code.  The PKI portal can use key material Ks_NAF to integrity protect and authenticate the response.\nTable E.3.2-5: Delivery of WIM authentication code (PKI portal to UE)\nHTTP/1.1 200 OK\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nContent-Type: text/plain\nContent-Length: (...)\nAuthentication-Info: qop=auth-int, rspauth=\"6629fae49394a05397450978507c4ef1\", cnonce=\"6629fae49393a05397450978507c4ef1\", nc=00000001\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nExpires: Fri, 09 Jan 2004 10:50:36 GMT\n\n13579BDF2468ACE\n\nContent-Type:\tContains the media type \"text/plain\".\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nAuthentication-Info:\tThis carries the protection\nExpires:\tGives the date/time after which the response is considered stale.\n9.\tAuthentication, key pair generation, and WIM authentication code request for proof-of-origin generation at UE\nThe UE receives the response and verifies the Authentication-Info header.  If the verification succeeds, the UE can use the WIM authentication code in the onboard key pair generation with the WIM.\nThe WIM in the UE also requires a WIM authentication code for the proof-of-origin generation.\nNOTE 5:\tIt is not mandatory to include the proof-of-origin to certificate request of the enrolment procedure, and the WIM can not require WIM authentication code for generating the proof-of-origin. In these cases, the WIM authentication code is not needed.\n10.\tAuthenticated WIM authentication code request (UE to PKI portal) - see example in table E.3.2-6\nThe UE generates the HTTP request by calculating the Authorization header values using the bootstrapping transaction identifier B-TID it received from the BSF as the username and the NAF specific key material Ks_NAF as the password, and sends the request to PKI portal.\nTable E.3.2-6: Authenticated WIM authentication code request (UE to PKI portal)\nGET /enrol/wim-auth-code?request=error:AuthReq:1122334455667788:1122334455 HTTP/1.1\nHost: pkiportal.home1.net:1234\nUser-Agent: SCEnrolmentAgent; Release-6\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer: http://pkiportal.home1.net:1234/service\nAuthorization: Digest username=\"(B-TID)\", realm=\"3GPP-bootstrapping@pkiportal.home1.net\", nonce=\"a6332ffd2d234==\", uri=\"/enrol/wim-auth-code?request=error:AuthReq:123456789ABCDEF:AABBCCDDEE \", qop=auth-int, nc=00000001, cnonce=\"6629fae49393a05397450978507c4ef1\", response=\"6629fae49393a05397450978507c4ef1, opaque=\"5ccc069c403ebaf9f0171e9517f30e41\", algorithm=MD5\n\n\n11.\tAuthentication and WIM authentication code generation at NAF\nPKI portal verifies the Authorization header by using the bootstrapping transaction identifier B-TID and the key material Ks_NAF obtained from BSF. PKI portal calculates the corresponding digest values using Ks_NAF, and compares the calculated values with the received values in the Authorization header.\nThe PKI portal also verifies that the hostname (i.e. its FQDN) in the realm attribute matches its own. If the messaging is taking place inside a server-authenticated TLS tunnel, the PKI portal also verifies that this hostname is the same as that of the TLS server.\nIf the verification succeeds, the WIM authentication code is taken in for further processing. The PKI portal continues processing of the WIM authentication code request according to its internal policies.\nNOTE 6:\tThe procedures for generating the WIM authentication code are outside the scope.\n12.\tDelivery of WIM authentication code (PKI portal to UE) - see example in table E.3.2-7\nThe PKI portal sends 200 OK response to the UE to indicate the success of the authentication and the WIM authentication code generation. The PKI portal generates a HTTP response containing the WIM authentication code.  The PKI portal can use key material Ks_NAF to integrity protect and authenticate the response.\nTable E.3.2-7: Delivery of WIM authentication code (PKI portal to UE)\nHTTP/1.1 200 OK\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nContent-Type: text/plain\nContent-Length: (...)\nAuthentication-Info: qop=auth-int, rspauth=\"6629fae49394a05397450978507c4ef1\", cnonce=\"6629fae49393a05397450978507c4ef1\", nc=00000001\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nExpires: Fri, 09 Jan 2004 10:50:36 GMT\n\nFFEEDDCCBBAA998877665544\n\nContent-Type:\tContains the media type \"text/plain\".\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nAuthentication-Info:\tThis carries the protection\nExpires:\tGives the date/time after which the response is considered stale.\n13.\tAuthentication, proof-key-origin key pair generation, and PKCS#10 generation at UE\nThe UE receives the response and verifies the Authentication-Info header.  If the verification succeeds, the UE can use the WIM authentication code in the proof-of-origin generation with the WIM.\nThe WIM in the UE also requires a WIM authentication code for the proof-of-origin generation.\nNOTE 7:\tIt is not mandatory to include the proof-of-origin to certificate request of the enrolment procedure, and the WIM can not require WIM authentication code for generating the proof-of-origin. In these cases, the WIM authentication code is not needed.\n14.\tAuthenticated enrolment request (UE to PKI portal) - see example in table E.3.2-8\nUE generates the HTTP request by calculating the Authorization header values using the bootstrapping transaction identifier B-TID it received from the BSF as the username and the NAF specific key material Ks_NAF as the password, and sends the request to PKI portal.\nTable E.3.2-8: Authenticated enrolment request (UE to PKI portal)\nPOST /enrol?response=single HTTP/1.1\nHost: pkiportal.home1.net:1234\nContent-Type: application/pkcs10\nContent-Length: (...)\nUser-Agent: SCEnrolmentAgent; Release-6\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer: http://pkiportal.home1.net:1234/service\nAuthorization: Digest username=\"(B-TID)\", realm=\"3GPP-bootstrapping@pkiportal.home1.net\", nonce=\"a6332ffd2d234==\", uri=\"/enrol?response=single\", qop=auth-int, nc=00000002, cnonce=\"6629fae49393a05397450978507c4ef1\", response=\"6629fae49393a05397450978507c4ef1, opaque=\"5ccc069c403ebaf9f0171e9517f30e41\", algorithm=MD5\n\n----- BEGIN CERTIFICATE REQUEST -----\n<PKCS#10 BLOB>\n----- END CERTIFICATE REQUEST -----\n\nAuthorization:\tThis carries the response to the authentication challenge received in step 2 along with the username, the realm, the nonce, the URI, the qop, the NC, the cnonce, the response, the opaque, and the algorithm.\nThe qop attribute is set to \"auth-int\" by default. If the messaging is taking place inside a server-authenticated TLS tunnel, the qop attribute can be set to \"auth\" as well.\n15.\tAuthentication and certificate generation at PKI portal\nPKI portal verifies the Authorization header by using the bootstrapping transaction identifier B-TID and the key material Ks_NAF obtained from BSF. PKI portal calculates the corresponding digest values using Ks_NAF, and compares the calculated values with the received values in the Authorization header.\nThe PKI portal also verifies that the hostname (i.e. its FQDN) in the realm attribute matches its own. If the messaging is taking place inside a server-authenticated TLS tunnel, the PKI portal also verifies that this hostname is the same as that of the TLS server.\nIf the verification succeeds, the incoming client-payload request is taken in for further processing. The PKI portal continues processing of the PKCS#10 request according to its internal policies.\nNOTE 8:\tThe procedures for generating the subscriber certificate are outside the scope.\n16.\tDelivery of subscriber certificate (PKI portal to UE) - see example in table E.3.2-9\nThe PKI portal sends 200 OK response to the UE to indicate the success of the authentication and the subscriber certificate enrolment. The PKI portal generates a HTTP response containing the enrolled subscriber certificate. The PKI portal can use key material Ks_NAF to integrity protect and authenticate the response.\nTable E.3.2-9: Delivery of subscriber certificate (PKI portal to UE)\nHTTP/1.1 200 OK\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nContent-Type: text/html\nContent-Type: application/x-x509-user-cert\nContent-Length: (...)\nAuthentication-Info: qop=auth-int, rspauth=\"6629fae49394a05397450978507c4ef1\", cnonce=\"6629fae49393a05397450978507c4ef1\", nc=00000001\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nExpires: Fri, 09 Jan 2004 10:50:36 GMT\n\n----- BEGIN CERTIFICATE -----\n<Subscriber certificate BLOB>\n----- END CERTIFICATE -----\n\nContent-Type:\tContains the media type \"application/x-x509-user-cert\", i.e. X.509 certificate.\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nAuthentication-Info:\tThis carries the protection\nExpires:\tGives the date/time after which the response is considered stale.\n17.\tAuthentication at UE\nThe UE receives the response and verifies the Authentication-Info header.  If the verification succeeds, the UE can accept the subscriber certificate for further processing.\n",
                    "tables": [
                        {
                            "description": "Table E.3.2-4: Bootstrapping authentication information procedure (PKI portal to BSF)",
                            "table number": 8,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "E.4\tSignalling flows demonstrating a failure in subscriber certificate enrolment",
            "description": "The signalling flow in figure E.3.1-1 describes the message exchange between UE and PKI portal using HTTP Digest Authentication. This clause describes a failure in the subscriber certificate enrolment, related to PKI procedures. Thus, it assumed that subscriber certificate enrolment procedure has proceeded to step 6 as described in clause E.3.1.\n6.\tAuthentication and certificate generation at PKI portal\nThe verification procedures described in clause E.3.1 step 6 are successfully completed.\nThe PKI portal encounters an error during the internal enrolment procedure. For example, the PKI portal is not allowed to issue a certificate to the subscriber due operator's internal policies, i.e. the subscriber's profile in the HSS indicates that the enrolment is not allowed.\n7.\tError notification (PKI portal to UE) - see example in table E.4-1\nThe PKI portal sends 403 Forbidden response to the UE to indicate that the subscriber certificate enrolment is allowed. The PKI portal generates a HTTP response containing the error notification.  The PKI portal can use key material Ks_NAF to authenticate the response.\nTable E.4-1: Error notification (PKI portal to UE)\nHTTP/1.1 403 Forbidden\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nContent-Type: text/html\nAuthentication-Info: qop=auth-int, rspauth=\"6629fae49394a05397450978507c4ef1\", cnonce=\"6629fae49393a05397450978507c4ef1\", nc=00000001\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nExpires: Fri, 09 Jan 2004 10:50:36 GMT\n\nAuthentication-Info:\tThis carries the protection\nExpires:\tGives the date/time after which the response is considered stale.\n8.\tAuthentication at UE\nThe UE receives the response and verifies the Authentication-Info header.  If the verification succeeds, the UE is notified of the failure of the subscriber certificate enrolment.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "E.5\tSignalling flows demonstrating a successful CA certificate delivery",
            "description": "The signalling flow in figure E.5-1 describes the message exchange between UE and PKI portal when UE requests a CA certificate delivery. The messaging can take place inside a server-authenticated TLS (as described in the RFC for TLS defined in annex E of 3GPP TS 33.310 [25]) tunnel in which case TLS session has been established before step 1.\nThe figure depicts a successful CA certificate delivery, illustrating the process of a certificate authority (CA) validating a digital certificate and issuing a new one. The CA is shown as a green square with a white \"C\" on top, indicating its role in the digital certificate process. The figure also includes a red square with a white \"X\" on top, representing the certificate that has been revoked. The CA's green square is surrounded by a white border, and the red square is surrounded by a black border, emphasizing the contrast between the two. The figure is set against a white background, and the overall layout is simple and clear, making it easy to understand the process.\nFigure E.5-1: Successful CA certificate delivery.\n1.\tInitial get request  (UE to PKI portal) - see example in table E.5-1\nThe UE sends an HTTP request to the PKI portal requesting the delivery of CA certificate.\nTable E.5-1: Initial get request (UE to PKI portal)\nGET /getcertificate?in=aabbccdd== HTTP/1.1\nHost: pkiportal.home1.net:1234\nUser-Agent: SCEnrolmentAgent; Release-6\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer:\n\nRequest-URI:\tThe Request-URI (the URI that follows the method name, \"GET\", in the first line) indicates the resource indication of this GET request. The Request-URI contains the parameter \"in\" (i.e. issuer name) which is set to the Base64 encoding of the DER encoded Issuer field of the X.509 certificate.\nHost:\tSpecifies the Internet host and port number of the PKI portal server, obtained from the original URI given by referring resource.\nUser-Agent:\tContains information about the user agent originating the request.\nDate:\tRepresents the date and time at which the message was originated.\nAccept:\tMedia types which are acceptable for the response.\nReferer:\tAllows the user agent to specify the address (URI) of the resource from which the URI for the PKI portal was obtained.\nNOTE 1:\tThis step is used to trigger the GBA-based authentication between the UE and the PKI portal.\n2.\t401 Unauthorized response (PKI portal to UE) - see example in table E.5-2\nThe PKI portal responds with HTTP response code 401 \"Unauthorized\" which contains a WWW-Authenticate header. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nTable E.5-2: 401 Unauthorized response (PKI portal to UE)\nHTTP/1.1 401 Unauthorized\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nWWW-Authenticate: Digest realm=\"3GPP-bootstrapping@pkiportal.home1.net\", nonce=\"6629fae49393a05397450978507c4ef1\", algorithm=MD5, qop=\"auth,auth-int\", opaque=\"5ccc069c403ebaf9f0171e9517f30e41\"\n\n\nServer:\tContains information about the software used by the origin server (PKI portal).\nDate:\tRepresents the date and time at which the message was originated.\nWWW-Authenticate:\tThe PKI portal challenges the user. The header instructs the UE to use HTTP Digest Authentication with a bootstrapped security association.\nThe options for the quality of protection (qop) attribute is by default \"auth-int\" meaning that the payload of the following HTTP requests and responses should integrity protected. If the messaging is taking place inside a server-authenticated TLS tunnel, the options for the qop attribute can also contain \"auth\" meaning that the payload of the following HTTP requests and responses are not protected by HTTP Digest. The integrity protection is handled on the TLS layer instead.\nThe realm attribute contains two parts delimited by \"@\" sign. The first part is a constant string \"3GPP-bootstrapping\" instructing the UE to use a bootstrapped security association. The second part is the host of the server (i.e. the FQDN of the PKI portal).\n3.\tGeneration of NAF specific keys at UE\nThe UE verifies that the second part of the realm attribute does correspond to the server it is talking to. In particular, if the messaging is taking place inside a server-authenticated TLS tunnel, the UE verifies that the server name (i.e. FQDN of the PKI portal) in the server's TLS certificate matches the hostname of the server in the realm attribute of the WWW-Authenticate header.\nUE derives the NAF specific key material Ks_NAF as specified in 3GPP TS 33.220 [1].\nNOTE 2:\tIf UE does not have a bootstrapped security association available, it will obtain one by running bootstrapping procedure over Ub interface.\n4.\tAuthenticated get request (UE to PKI portal) - see example in table E.5-3\nUE generates the HTTP request by calculating the Authorization header values using the bootstrapping transaction identifier B-TID it received from the BSF as the username and the NAF specific key material Ks_NAF (base64 encoded) as the password, and sends the request to PKI portal.\nTable E.5-3: Authenticated get request (UE to PKI portal)\nGET /getcertificate?in=aabbccdd== HTTP/1.1\nHost: pkiportal.home1.net:1234\nUser-Agent: SCEnrolmentAgent; Release-6\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nAccept: */*\nReferer: http://pkiportal.home1.net:1234/service\nAuthorization: Digest username=\"(B-TID)\", realm=\"3GPP-bootstrapping@pkiportal.home1.net\", nonce=\"a6332ffd2d234==\", uri=\"/getcertificate?in=aabbccdd==\", qop=auth-int, nc=00000001, cnonce=\"6629fae49393a05397450978507c4ef1\", response=\"6629fae49393a05397450978507c4ef1\", opaque=\"5ccc069c403ebaf9f0171e9517f30e41\", algorithm=MD5\n\n\nAuthorization:\tThis carries the response to the authentication challenge received in step 2 along with the username, the realm, the nonce, the URI, the qop, the NC, the cnonce, the response, the opaque, and the algorithm.\nThe qop attribute is set to \"auth-int\" by default. If the messaging is taking place inside a server-authenticated TLS tunnel, the qop attribute can be set to \"auth\" as well.\nNOTE 3:\tIf step 1 was a GET request then this request would also be GET request and contain the same Request-URI in the HTTP request as was carried in step 1.\n5.\tZn: NAF specific key procedure\nPKI portal retrieves the NAF specific key material (Ks_NAF) from the BSF.\nFor detailed signalling flows see 3GPP TS 29.109 [3].\nTable E.5-4: Bootstrapping authentication information procedure (PKI portal to BSF)\n\n6.\tAuthentication at PKI portal\nPKI portal verifies the Authorization header by using the bootstrapping transaction identifier B-TID and the key material Ks_NAF obtained from BSF. PKI portal calculates the corresponding digest values using Ks_NAF, and compares the calculated values with the received values in the Authorization header.\nThe PKI portal also verifies that the hostname (i.e. its FQDN) in the realm attribute matches its own. If the HTTP messaging is taking place inside a server-authenticated TLS tunnel, the PKI portal also verifies that this hostname is the same as that of the TLS server.\nIf the verification succeeds, the incoming client-payload request is taken in for further processing, i.e. the PKI portal sends the requested CA certificate to the UE.\n7.\tDelivery of CA certificate (PKI portal to UE) – see example in table E.5-5\nThe PKI portal sends 200 OK response to the UE to indicate the success of the authentication. The PKI portal generates a HTTP response containing the requested CA certificate. The PKI portal use the key material Ks_NAF to integrity protect and authenticate the response.\nTable E.5-5: Delivery of CA certificate (PKI portal to UE)\nHTTP/1.1 200 OK\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nContent-Type: text/html\nContent-Type: application/x-x509-ca-cert\nContent-Length: (...)\nAuthentication-Info: qop=auth-int, rspauth=\"6629fae49394a05397450978507c4ef1\", cnonce=\"6629fae49393a05397450978507c4ef1\", nc=00000001\nDate: Thu, 08 Jan 2004 10:50:35 GMT\nExpires: Fri, 09 Jan 2004 10:50:36 GMT\n\n----- BEGIN CERTIFICATE -----\n<CA certificate BLOB>\n----- END CERTIFICATE -----\n\nContent-Type:\tContains the media type \"application/x-x509-ca-cert\", i.e. X.509 CA certificate.\nContent-Length:\tIndicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient.\nAuthentication-Info:\tThis carries the protection.\nExpires:\tGives the date/time after which the response is considered stale.\n8.\tAuthentication and response verification at UE\nThe UE receives the response and verifies the Authentication-Info header.  If the verification succeeds, the UE can accept the CA certificate for further processing.\n",
            "summary": "",
            "tables": [
                {
                    "description": "Table E.5-4: Bootstrapping authentication information procedure (PKI portal to BSF)",
                    "table number": 9,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "E.6\tSignalling flows demonstrating a failure in CA certificate delivery",
            "description": "The signalling flow in figure E.5-1 describes the message exchange between UE and PKI portal when UE requests a CA certificate delivery. This clause describes a failure in the CA certificate delivery. It assumed that CA certificate delivery procedure has proceeded to step 6 as described in clause E.5.\n6.\tAuthentication at PKI portal\nThe verification procedures described in clause E.5 step 6 are successfully completed.\nThe PKI portal discovers that it does not have the requested CA certificate.\n7.\tError notification (PKI portal to UE) - see example in table E.6-1\nThe PKI portal sends 404 Not Found response to the UE to indicate that the requested CA certificate is not found in the PKI portal. The PKI portal can use key material Ks_NAF to authenticate the response.\nTable E.6-1: Error notification (PKI portal to UE)\nHTTP/1.1 404 Not Found\nServer: Apache/1.3.22 (Unix) mod_perl/1.27\nContent-Type: text/html\nAuthentication-Info: qop=auth-int, rspauth=\"6629fae49394a05397450978507c4ef1\", cnonce=\"6629fae49393a05397450978507c4ef1\", nc=00000001\nDate: Thu, 08 Jan 2004 10:50:35 GMT\n\nAuthentication-Info:\tThis carries the protection\n8.\tAuthentication and response verification at UE\nThe UE receives the response and verifies the Authentication-Info header. If the verification succeeds, the UE is notified of the failure of the CA certificate delivery.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "F.1\tScope of signalling flows",
            "description": "This annex gives examples of signalling flows for using PSK TLS with bootstrapped security association.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "F.2\tIntroduction",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "F.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "A bootstrapping session established using a bootstrapping procedure (cf., clause 4 and annex A) is used between a UE and a NAF. The BSF provides to the NAF a NAF specific key material (Ks_NAF or Ks_ext_NAF and optionally Ks_int_NAF) which is derived from the key material (Ks). The NAF uses this key to authenticate and optionally secure (i.e. integrity protect and encrypt) the communications between it and the UE. The BSF will also provide the NAF the expiration time of the bootstrapping session. When the bootstrapping session becomes invalid the NAF will stop using the session, and indicate to the UE that bootstrapping session has expired and that new session needs to be established.\nAn example of the signalling flows of the authentication procedure using PSK TLS is given in clause F.3.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "F.2.2\tKey required to interpret signalling flows",
                    "description": "",
                    "summary": "",
                    "text_content": "The following key (rules) have been applied to TLS handshake signalling flows to improve readability, reduce errors and increase maintainability:\na)\tThe description of TLS messages and their fields are identified by three fields: \"TLS.MESSAGE.FIELD\":\n-\t\"TLS\" identifies that the message is a TLS message;\n-\t\"MESSAGE\" identifies the name of the TLS message (e.g. ClientHello);\n-\t\"FIELD\" identifies the name of the TLS message field (e.g. client_version).\nAn example being \"TLS.ClientHello.client_version\", which identifies TLS message \"ClientHello\" and its data field \"client_version\". The possible TLS message and TLS message field names as well as their encoding to the TLS protocol are specified in IETF TLS related specifications as defined in annex E of 3GPP TS 33.310 [25].\nb)\tIf multiple TLS messages are sent in sequence from one entity to another this is described as one step.\n-\tthe figures describe the sending of multiple TLS messages in one step by listing the TLS message names in separate lines;\n-\tthe description of the step contains the explanation of the messages and their parameters as described in bullet a).\nc)\tIn order to differentiate between TLS messages and other protocol messages, the TLS messages are marked with simple arrow line, and all non-TLS messages with block arrows.\nd)\tThe flows show the signalling exchanges between the following functional entities:\n-\tUser Equipment (UE);\n-\tBootstrapping Server Function (BSF);\n-\tNetwork Application Function (NAF).\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        },
        {
            "title": "F.3\tSignalling flow demonstrating a successful PSK TLS authentication procedure",
            "description": "The signalling flow in figure F.3-1 describes the generic message exchange between UE and NAF using PSK TLS. In this example, the PSK TLS client application resides in the ME, i.e., either Ks_NAF or Ks_ext_NAF is used as the key.\nThe figure depicts a PSK (Phase Shift Keying) TLS (Transport Layer Security) handshake, which is a key component of secure communication protocols. The handshake involves two parties, the sender and the receiver, exchanging cryptographic keys to establish a secure connection. The figure illustrates the handshake process, including the use of bootstrapped security association, which is a method of establishing a secure connection without the need for a shared secret key. This handshake is crucial for ensuring the confidentiality and integrity of data transmitted over the network.\nFigure F.3-1: PSK TLS handshake with bootstrapped security association.\n1.\tTLS handshake message: ClientHello (UE to NAF)\nThe UE sends ClientHello message to the NAF. In order to indicate that the UE is capable of PSK-based authentication it includes the PSK-based ciphersuites to the list of acceptable ciphersuites list. The UE also includes to the ClientHello message the server_name TLS extension containing the hostname of the NAF.\nTLS.ClientHello.client_version: the version of the TLS protocol in the UE is 3.1.\nTLS.ClientHello.random: a UE generated random structure.\nTLS.ClientHello.session_id: the ID of the TLS session is empty, i.e. no previous TLS session is used.\nTLS.ClientHello.cipher_suites: the list of ciphersuites includes one or more PSK-based ciphersuites.\nTLS.ClientHello.compression_methods: a list of the compression methods is null.\nTLS.ClientHello.client_hello_extension_list: list of extensions includes server_name extension that contains the hostname of the NAF.\n2.\tTLS handshake messages: ServerHello, ServerKeyExchange, ServerHelloDone (NAF to UE)\nIf the NAF wants to use PSK-based authentication, it selects one of the acceptable PSK-based ciphersuites, places the selected ciphersuite in the ServerHello message, and includes an appropriate ServerKeyExchange message. The NAF can help the UE in selecting the correct PSK identity by providing a list of hints in ServerKeyExchange message. That list includes a static string \"3GPP-bootstrapping \".\nTLS.ServerHello.server_version: the version of the TLS protocol in the NAF is 3.1.\nTLS.ServerHello.random: a NAF generated random (must be different from ClientHello.random).\nTLS.ServerHello.session_id: the identity of the TLS session generated by the NAF.\nTLS.ServerHello.cipher_suite: the ciphersuite selected by the NAF is one of the PSK-based ciphersuites listed in ClientHello.cipher_suites.\nTLS.ServerHello.compression_method: the compression method selected by the NAF is null.\nTLS.ServerHello.server_hello_extension_list: list of extensions is empty.\nTLS.ServerKeyExchange.psk_identity_hint: the PSK identity hint contains the constant string \"3GPP-bootstrapping\".\nTLS.ServerHelloDone: this message does not have data fields.\n3.\tBootstrapping and generation of NAF specific key material at UE\nThe UE performs the bootstrapping procedure to produce B-TID and Ks_(ext)_NAF as described in clause A.3. If bootstrapping procedure has been done recently, the UE can use the B-TID and Ks_(ext)_NAF produced from that procedure.\n4.\tTLS handshake messages: ClientKeyExchange, ChangeCipherSpec, Finished (UE to NAF)\nThe UE sets concatenated \"3GPP-bootstrapping\" string, separator character \";\" and the B-TID as the PSK identity, and Ks_(ext)_NAF as the pre-shared key. The UE then sends ClientKeyExchange containing the B-TID, ChangeCipherSpec, and Finished messages to the NAF. The TLS premaster secret is derived from Ks_(ext)_NAF.\nTLS.ClientKeyExchange.psk_identity: the PSK identity contains concatenated \"3GPP-bootstrapping\" string, separator character \";\" and the B-TID.\nTLS.ChangeCipherSpec.type: contains value 1 (change_cipher_spec).\nTLS.Finished.verify_data: the verify data contains the hash of the handshake messages. For details, see the RFC for TLS defined in annex E of 3GPP TS 33.310 [25].\n5.\tZn: NAF specific key procedure\nThe NAF extracts the B-TID from the ClientKeyExchange message and requests the NAF specific key (Ks_NAF or Ks_ext_NAF) from BSF. The BSF returns the NAF specific key that corresponds to the B-TID.\nIf the NAF retrieved an application-specific USS and it contained a keyChoice indication, the NAF must enforce this indication. Hence, if the UICC-based key was indicated the NAF must terminate the communication with the UE in this phase.\nNOTE:\tIf the local configuration in the NAF restricts the access to this NAF service to UICC-based applications, then the NAF will terminate the communication with the UE in this phase.\nFor detailed signalling flows see 3GPP TS 29.109 [3].\nTable F.3-1: Bootstrapping authentication information procedure (NAF to BSF)\n\n6.\tAuthentication at NAF\nThe NAF validates the Finished message sent by the UE.\n7.\tTLS handshake messages: ChangeCipherSpec, Finished (NAF to UE)\nThe NAF sends ChangeCipherSpec, and Finished messages to the UE.\nTLS.ChangeCipherSpec.type: contains value 1 (change_cipher_spec).\nTLS.Finished.verify_data: the verify data contains the hash of the handshake messages. For details, see the RFC for TLS defined in annex E of 3GPP TS 33.310 [25].\n8.\tAuthentication at UE\nThe UE validates the Finished message sent by the NAF.\n9.\tApplication data transfer\nThe UE and the NAF initiate application data transfer in the TLS session.\n",
            "summary": "",
            "tables": [
                {
                    "description": "Table F.3-1: Bootstrapping authentication information procedure (NAF to BSF)",
                    "table number": 10,
                    "summary": "",
                    "name": ""
                }
            ],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "G.1\tGeneral",
            "description": "This annex defines the syntax of 3GPP specific extension-headers introduced in this document in augmented Backus-Naur form as defined in RFC 2234 [22].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "G.2\tX-3GPP-Intended-Identity extension-header",
            "description": "The \"X-3GPP-Intended-Identity\" header is used optionally by the UE to indicate the user identity intended to be used with the AS. It contains the user identity surrounded by quotation marks (\").\nTable G.2: Syntax of X-3GPP-Intended-Identity extension-header\n\nX-3GPP-Intended-Identity = \"X-3GPP-Intended-Identity\" \":\" DQUOTE identity DQUOTE\nidentity = *(%x20-21 / %x23-7E)\n\n\nIn the syntax definition the rule 'identity' refers to the user identity and it is defined as a string of printable characters and spaces but excluding quotation marks. The exact type definition for 'identity' is done in 3GPP TS 29.109 [3] as part of the User Security Setting definition (as the uid tag in the XML scheme definition).\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "G.3\tX-3GPP-Asserted-Identity extension-header",
            "description": "Depending on the subscriber's GBA user security settings the \"X-3GPP-Asserted-Identity\" header is used by the AP to indicate an asserted identity or a list of identities to the AS. It contains a list of identities separated by comma (,) and each identity is surrounded by quotation marks (\").\nTable G.3: Syntax of X-3GPP-Asserted-Identity extension-header\n\nX-3GPP-Asserted-Identity = \"X-3GPP-Asserted-Identity\" \":\" identity-list\nidentity-list = DQUOTE identity DQUOTE *(\",\" DQUOTE identity DQUOTE)\nidentity = *(%x20-21 / %x23-7E)\n\n\nIn the syntax definition the rule 'identity' refers to the user identity and it is defined as a string of printable characters and spaces but excluding quotation marks. The exact type definition for 'identity' is done in 3GPP TS 29.109 [3] as part of the User Security Setting definition (as the uid tag in the XML scheme definition).\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "G.4\tX-3GPP-Authorization-Flags extension-header",
            "description": "The \"X-3GPP-Authorization-Flags\" header is used optionally by the AP to indicate an authorization flag or a list of authorization flags from the application specific user security setting (USS) to the AS. It contains a list of authorization flags separated by comma (,) and each authorization flag is surrounded by quotation marks (\").\nTable G.4: Syntax of X-3GPP-Authorization-Flags extension-header\n\nX-3GPP-Authorization-Flags = \"X-3GPP-Authorization-Flags\" \":\" auth-flag-list\nauth-flag-list = DQUOTE auth-flag DQUOTE *(\",\" DQUOTE auth-flag DQUOTE)\nauth-flag = *(%x20-21 / %x23-7E)\n\n\nIn the syntax definition the rule 'auth-flag' refers to the authorization flag and it is defined as a string of printable characters and spaces but excluding quotation marks. The exact type definition for authorization flag is done in 3GPP TS 29.109 [3] as part of the User Security Setting definition.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "H.1\tIntroduction",
            "description": "This annex specifies the implementation option to allow the use of SIM cards or SIMs on UICC for GBA. The procedure specified in this annex is called 2G GBA. 2G GBA allows access to applications in a more secure way that would be possible with the use of password or with GSM without enhancements. Stage 2 level details for 2G GBA has been specified in 3GPP TS 33.220 [1], annex I.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "H.2\t2G GBA bootstrapping procedure",
            "description": "A UE and the BSF shall establish a bootstrapped security association between them by running the 2G GBA bootstrapping procedure. The bootstrapping security association consists of a bootstrapping transaction identifier (B-TID) and key material Ks. Bootstrapping session on the BSF also includes security related information about subscriber (e.g. user's private identity). Bootstrapping session is valid for a certain time period, and shall be deleted in the BSF when the session becomes invalid.\nIt shall be possible that the BSF is configured to either allow or disallow the use of 2G GBA bootstrapping. If 2G GBA is disallowed, the BSF shall not start the TLS handshake with the UE as described below.\nThe 2G GBA Bootstrapping procedure as specified in 3GPP TS 33.220 [1] is further detailed as described below.\n-\tAuthorization, WWW-Authenticate, and Authentication-Info HTTP headers shall be used as described in RFC 3310 [6] with following exceptions:\na)\tthe \"realm\" parameter shall contain the FQDN of the BSF. The UE shall check that the \"realm\" attribute contains the same FQDN of the BSF that was present in the BSF certificate.\nb)\tthe quality of protection (\"qop\") parameter shall be \"auth-int\".\nc)\tthe \"username\" parameter shall contain user's private identity (IMPI) which has been derived from the IMSI of the SIM application as specified in 3GPP TS 23.003 [7].\nd)\tthe \"nonce\" field shall be populated as specified in 3GPP TS 33.220 [1], annex H with\n-\tthe \"RAND\" which is the RAND of the 2G authentication vector, and\n-\tthe \"AUTN\" which is a 128-bit zero number, and\n-\tthe \"server specific\" data is a 128-bit random number \"Ks-input\" generated by the BSF.\n-\tthe \"RES\" which is used as the password is derived as specified in 3GPP TS 33.220 [1], annex H.\nIn addition to RFC 3310 [6], the following apply:\na)\tIn the initial request from the UE to the BSF, the UE shall include Authorization header with following parameters:\n-\tthe username directive, set to the value of the private user identity IMPI derived from the IMSI of the SIM according to 3GPP TS 23.003 [7];\n-\tthe realm directive, set to the BSF address derived from the IMSI of the SIM according to 3GPP TS 23.003 [7];\n-\tthe uri directive, set to either absoluteURL \"https://<BSF address>/\" or abs_path \"/\", and which one is used is specified in RFC 7616 [36];\n-\tthe nonce directive, set to an empty value; and\n-\tthe response directive, set to an empty value;\nb)\tIn the challenge response from the BSF to the UE, the BSF shall include parameters to WWW-Authenticate header as specified in RFC 3310 [6] with following clarifications:\n-\tthe realm directive, set to the BSF address derived from the IMSI of the SIM according to 3GPP TS 23.003 [7];\nc)\tIn the message from the BSF to the UE, the BSF shall include bootstrapping transaction identifier (B-TID) and the key lifetime to an XML document in the HTTP response payload. The BSF may also include additional server specific data to the XML document. The XML schema definition of this XML document is given in annex C.\nd)\tAuthentication-Info header shall be included into the subsequent HTTP response after the BSF concluded that the UE has been authenticated. Authentication-Info header shall include the \"rspauth\" parameter.\nAfter successful bootstrapping procedure the UE and the BSF shall contain the key material (Ks) and the B-TID. The key material shall be derived from AKA parameters as specified for 2G GBA in 3GPP TS 33.220 [1]. In addition, BSF shall also contain a set of security specific attributes (GUSS) related to the UE.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "H.3\tUser authentication failure",
            "description": "If the response returned by the UE is different than expected, the BSF may challenge the UE again with a new AKA challenge using a new 2G authentication vector. After N consecutive incorrect responses from the UE, the BSF shall indicate a failure to the UE. The exact value of N is defined by local policy.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "H.4\tNetwork authentication failure",
            "description": "In case the UE fails at authenticating the network, the UE shall abort the bootstrapping procedure.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "I.1\tIntroduction",
            "description": "This annex specifies the implementation option to use SIP Digest credentials for GBA. The procedure specified in this annex is called GBA_Digest. GBA_Digest allows access to applications in a more secure way that would be possible with the use of password based HTTP Digest. Stage 2 level description for GBA_Digest has been specified in 3GPP TS 33.220 [1], annex M.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "I.2\tGBA_Digest bootstrapping procedure",
            "description": "A UE and the BSF shall establish a bootstrapped security association between them by running the GBA_Digest bootstrapping procedure. The bootstrapping security association consists of a bootstrapping transaction identifier (B-TID) and key material Ks. A Bootstrapping session on the BSF also includes security related information about the subscriber (in particular the user's private identity). A Bootstrapping session is valid for a certain time period, and shall be deleted in the BSF when the session becomes invalid.\nThe UE shall establish a TLS connection with the BSF prior to sending any HTTP request to the BSF.\nA UE shall indicate to the BSF that it intends to run GBA_Digest as defined in 3GPP TS 33.220 [1] by including a \"product\" token in the \"User-Agent\" header field (cf. RFC 9110 [31]) that is set to a static string \"GBA_Digest\" in HTTP requests sent to the BSF. The BSF is configured to either allow or disallow the use of GBA_Digest bootstrapping. If GBA_Digest is disallowed, the BSF shall reject the HTTP request by the UE.\nThe GBA_Digest Bootstrapping procedure as specified in 3GPP TS 33.220 [1] is further detailed as described below.\n-\tAuthorization, WWW-Authenticate, and Authentication-Info HTTP header fields shall be used as described in RFC 7616 [36] with following exceptions:\na)\tthe \"realm\" parameter shall be set to the domain name of the home network;\nb)\tthe quality of protection (\"qop\") parameter shall be \"auth-int\";\nc)\tthe \"username\" parameter shall contain user's private identity;\nd)\tthe \"nonce\" field shall be populated as specified in 3GPP TS 33.220 [1], annex M with a random number generated by the BSF according to RFC 7616 [36]; and\n-\ta password, which is called \"passwd\" and is derived as specified in 3GPP TS 33.220 [1], annex M.\nIn addition to RFC 7616 [36], the following apply:\na)\tin the initial request from the UE to the BSF, the UE shall include an Authorization header field with following parameters:\nthe uri directive, set to either absoluteURL \"https://<BSF address>/\" or abs_path \"/\", and which one is used is specified in RFC 7616 [36];\n-\tthe nonce directive, set to an empty value;\n-\tthe response directive, set to an empty value;\nb)\tin the HTTP response containing the Digest challenge from the BSF to the UE, the BSF shall include parameters to WWW-Authenticate header field as specified in RFC 7616 [36];\nc)\tin the HTTP request sent as an answer to the HTTP response in bullet b) the UE shall include an Authorization header field that contains a digest-response, \"algorithm\", \"qop\", \"cnonce\", and \"nc\" header field parameters as specified in RFC 7616 [36], and\n-\tthe uri directive, set to either absoluteURL \"https://<BSF address>/\" or abs_path \"/\", and which one is used is specified in RFC 7616 [36];\n-\tthe nonce directive, set to an empty value; and\nd)\tn the message from the BSF to the UE, which the BSF shall only send after the BSF concluded that the UE has been authenticated, the BSF shall include an Authentication-Info header with the \"rspauth\" parameter. Furthermore, the BSF shall include the bootstrapping transaction identifier (B-TID) and the key lifetime to an XML document in the HTTP response payload. The BSF may also include additional server specific data to the XML document. The XML schema definition of this XML document is given in annex C.\nAfter a successful bootstrapping procedure the UE and the BSF shall contain the key material (Ks) and the B-TID. The key material shall be derived from SIP Digest  parameters as specified for GBA_Digest in 3GPP TS 33.220 [1]. In addition, the BSF may also contain a set of security specific attributes (GUSS) related to the UE, depending on the conditions in clause 4.5.2 of 3GPP TS 33.220 [1].\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "I.3\tUser authentication failure",
            "description": "If the response returned by the UE is different than expected, the BSF may challenge the UE again with a new Digest challenge using the same SIP Digest authentication vector. After N consecutive incorrect responses from the UE, the BSF shall indicate a failure to the UE. The exact value of N is defined by local policy.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "I.4\tNetwork authentication failure",
            "description": "In case the UE fails at authenticating the network, the UE shall abort the bootstrapping procedure.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "J.1\tIntroduction",
            "description": "The GBA Push procedure is executed in order to establish a bootstrapped security association, i.e. bootstrapping session between a Push-NAF and a UE. The GBA Push service is initiated by delivering GBA Push Information (GPI) to the UE as described in 3GPP TS 33.223 [24]. However, 3GPP TS 33.223 [24] only specifies the GBA Push architecture; this annex specifies how GPI is delivered to the UE using WAP Push without the OMA DM Notification structure.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "J.2\tGPI delivery using WAP Push",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "J.2.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "When the GPI data object is delivered using SMS, the Push-NAF and the UE shall use the Push OTA protocol over WSP as defined in OMA's \"Push Over the Air\" specification [26] for connectionless non-secure push.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.2.2\tPush-NAF procedures",
                    "description": "",
                    "summary": "",
                    "text_content": "In order to send the GPI via WSP, the Push-NAF shall construct a push message according to OMA's \"Push Message Specification\" [27] and shall populate the push message as follows:\n-\tthe Content-Type header shall include the MIME media type ‘application/vnd.3gpp.gba.gpi’ or the corresponding short code as defined in clause J.3.1.3.\n-\tthe X-WAP-Application-ID header shall include the application-id associated with the specific GBA User Agent or the corresponding short code, if available for the application in question. The short code for the identifier of a specific application is defined in the corresponding specification for the application.\n-\tthe Session Identifier shall be different between different GBA Push initiated sessions for the same recipient. All messages in the associated OMA DM session shall include the Session identifier as Session ID.\n-\tthe  message body shall contain the GPI envelope as described in clause J.3.1.2 with the version field set to 1, the session identifier set by the server, as specified in sublause J.3.1.2, and GPI field set to the GPI.\nNOTE 1:\tOne SMS can carry 140 bytes of information and the GPI message fits into a single SMS when short codes are used for the Content-Type and X-WAP-Application-ID attributes, as described in clause J.3. When short codes are not defined, or not used, the WAP Push message does not fit into a single SMS message and then concatenated SMS messages are used.\nThe general format of the GPI push message within one SMS message is shown as an example in table J.2-1.\nTable J.2-1: Example of a GPI Push message with header and content in one SMS\n\nNOTE 2:\tIf the GPI Push message needs to be sent in more than one SMS, the segmentation information is added in 5 bytes to the WDP headers in each SMS (in total 7+5=12 bytes). The 5 added bytes are Type 0x00, len 0x03, Message Reference Number (byte) for concatenation, Current Segment Number (byte) and Total Segment Count (byte).\n",
                    "tables": [
                        {
                            "description": "Table J.2-1: Example of a GPI Push message with header and content in one SMS",
                            "table number": 11,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "J.2.3\tUE procedures",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "J.2.3.1\tReception of GPI in push message",
                            "text_content": "Upon receiving a push message on the IANA registered WDP port 2948 according to OMA's \"Push Message Specification\" [27] where:\n-\tthe Content-Type header indicates the application/vnd.3gpp.gba.gpi MIME type as defined in clause J.3.1.4 or the the corresponding short code as defined in clause J.3.1.3; and\n-\tthe X-WAP-Application-ID header indicates an application supported by the UE;\nthe UE shall extract GPI from the GPI envelope according to clause J.3.1, check the integrity of the GPI and use the Application-ID to locate the corresponding application in the UE. The UE uses the content of the push message to establish a connection with the indicated server. All messages in the associated OMA DM session shall include the Session identifier (Session ID) as received from Push-NAF.\nNOTE:\tAs indicated in OMA DM Enabler Release v1.2 [28] it is also possible to send WAP Push messages using some other transport than SMS, if the UE for example does not support SMS. OMA's \"Push Message Specification\" [27] also specifies OTA-HTTP and OTA-SIP, which can be supported by the UE.\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "J.3\tPDUs and parameters specific to the present document",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "J.3.1\tGPI envelope",
                    "description": "",
                    "summary": "",
                    "text_content": "",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": [
                        {
                            "title": "J.3.1.1\tGeneral",
                            "text_content": "This clause defines the GPI envelope carrying GPI as specified for the GAA bootstrap framework in 3GPP TS 33.223 [24].\n",
                            "figures_meta_data": [],
                            "tables": []
                        },
                        {
                            "title": "J.3.1.2\tStructure",
                            "text_content": "The GPI envelope is coded according to figure J.3.1.2-1 and table J.3.1.2-1.\nFigure J.3.1.2-1: GPI envelope\nTable J.3.1.2-1: GPI envelope\n\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "The GPI envelope is coded according to figure J.3.1.2-1 and table J.3.1.2-1.",
                                    "table number": 12,
                                    "summary": "",
                                    "name": ""
                                },
                                {
                                    "description": "Table J.3.1.2-1: GPI envelope",
                                    "table number": 13,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "J.3.1.3\tGPI envelope short code values",
                            "text_content": "The GPI envelope defined in table J.3.2-1 indicates the Content-Type in the WSP header.\nTable J.3.2-1: GPI Envelope short code values\n\nEditor's note: The WSP short code for ‘application/vnd.3gpp.gba.gpi’ should be requested from Open Mobile Alliance.\n",
                            "figures_meta_data": [],
                            "tables": [
                                {
                                    "description": "Table J.3.2-1: GPI Envelope short code values",
                                    "table number": 14,
                                    "summary": "",
                                    "name": ""
                                }
                            ]
                        },
                        {
                            "title": "J.3.1.4\tIANA registration template",
                            "text_content": "Editor’s note: The MIME type \"application/vnd.3gpp.gba.gpi\" needs to be registered in the IANA registry.\nMIME media type name:\napplication\nMIME subtype name:\nVendor Tree – vnd.3gpp.gba.gpi\nRequired parameters:\nNone\nOptional parameters:\nNone\nEncoding considerations:\nbinary\nSecurity considerations:\nNone\nInteroperability considerations:\nThis content type provides a format for exchanging information in WAP push message.\nPublished specification:\n3GPP TS 24.109\n()\nApplications which use this media:\nGBA Push\nIntended usage:\nDelivery of GBA Push information\n",
                            "figures_meta_data": [],
                            "tables": []
                        }
                    ]
                }
            ]
        },
        {
            "title": "K.1\tGeneral",
            "description": "This annex provides the details of how to apply TLS with AKMA keys (see 3GPP TS 33.535 [38]) based on the procedures in clauses 5.3.2 and 5.3.3.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "K.2\tShared key-based UE authentication with certificate-based AF authentication",
            "description": "The TLS profile for GBA in clause 5.3.2.1 is modified with the AKMA AF taking the role of the NAF from GBA (see 3GPP TS 33.220 [1]) to support AKMA keys as follows:\n-\tthe UE and the AF shall support the TLS version as specified in annex E of 3GPP TS 33.310 [25]. See clause 5.3.1 in 3GPP TS 33.222 [5] for the detailed profiling of TLS.\na)\twhen the UE starts communication via Ua* reference point with the AF, it shall establish a TLS tunnel with the AF. The AF is authenticated to the UE by means of a public key certificate. The UE shall verify that the server certificate corresponds to the FQDN of the AF with which it established the tunnel. No client authentication is performed as part of TLS (no client certificate necessary).\nb)\tthe UE sends an HTTP request to the AF inside the TLS tunnel (HTTPS, i.e. HTTP over TLS) as described in clause 5.2 with the following changes:\n1)\tthe UE shall indicate to an AF that it supports AKMA based HTTP Digest authentication by including a \"product\" token, that is a constant string \"3gpp-akma\", in the \"User-Agent\" header (see RFC 9110 [31]) in outgoing HTTP requests; and\n2)\tthe AF may decide to authenticate the UE using AKMA-based shared secret by executing the authentication procedure. This is indicated in the \"realm\" parameter of the WWW-Authenticate header field. The realm attribute shall contain the constant string \"3GPP-bootstrapping-akma\". If the AF has a choice between GBA_Digest (see 3GPP TS 33.220 [1]) and AKMA keying, then the AF shall select AKMA over GBA_Digest.\nNOTE 1:\tThe choice between AKMA and AKA-based GBA at the UE and the AF, if both are supported, is application dependent.\nc)\tthe UE shall generate the HTTP request and the AF shall authenticate the HTTP request using HTTP Digest. HTTP Digest authentication (see RFC 3310 [6]) shall be used with previously bootstrapped security association as follows:\n1)\tthe \"username\" parameter shall be the A-KID;\n2)\tthe password used in the digest calculations shall be KAF (AKMA Application Key) with the KAF Base64 encoded as specified in RFC 4648 [37]; and\n3)\tthe \"realm\" parameter shall contain two parts delimited by \"@\" sign where the first part is the constant string \"3gpp-akma\" and the latter part shall be the FQDN of the AF (e.g. \"3gpp-akma@af1.operator.com\"); and\nd)\tboth the UE and the AF shall verify upon receiving each of the HTTP responses and HTTP requests that the second part of the realm attribute is equal to the FQDN of the AF.\nThe authentication failures are supported as described in clause 5.3.2.2.\nClauses 5.3.2.3 and 5.3.2.4 are not supported as AKMA does not support deriving a fresh key in the same way as GBA.\nNOTE 2:\tHow a fresh key is derived for AKMA is up to Ua* protocol implementation.\n",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": []
        },
        {
            "title": "K.3\tShared key-based mutual authentication between UE and AF",
            "description": "",
            "summary": "",
            "tables": [],
            "figures_meta_data": [],
            "subsections": [
                {
                    "title": "K.3.1\tGeneral",
                    "description": "",
                    "summary": "",
                    "text_content": "The TLS profile for GBA in clause 5.3.3.1 is modified with the AKMA AF taking the role of the NAF from GBA (see 3GPP TS 33.220 [1]) to support AKMA keys as follows:\n-\tThe profile for TLS and TLS Extensions to be used together with PSK TLS is defined in annex E of 3GPP TS 33.310 [25].\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "K.3.2\tTLS 1.2",
                    "description": "",
                    "summary": "",
                    "text_content": "The PSK TLS handshake shall be used with bootstrapped security association as follows:\na)\tthe ClientHello message shall contain one or more PSK-based ciphersuites;\nb)\tthe ClientHello message shall contain the server_name TLS extension and it shall contain the hostname of the AF;\nc)\tthe ServerHello message shall contain a PSK-based ciphersuite selected by the AF;\nd)\tthe ServerKeyExchange shall be sent by the server and it shall contain the psk_identity_hint field and it shall contain the static string \"3GPP-AKMA\";\ne)\tthe ClientKeyExchange shall contain the psk_identity field and it shall contain a prefix \"3GPP-AKMA\" and the A-KID. If the UE has a choice between GBA_Digest (see 3GPP TS 33.220 [1]) and AKMA keying, then the AF shall select AKMA over GBA_Digest; and\nNOTE 1:\tThe choice between AKMA and AKA-based GBA at the UE and the AF, if both are supported, is application dependent.\nf)\tthe UE and AF shall derive the TLS premaster secret from KAF (AKMA Application Key).\nThe authentication failures are supported as described in clause 5.3.3.2.\nClauses 5.3.3.3 and 5.3.3.4 are not supported as AKMA does not support deriving a fresh key in the same way as GBA.\nNOTE 2:\tHow a fresh key is derived for AKMA is up to Ua* protocol implementation.\n",
                    "tables": [],
                    "figures_meta_data": [],
                    "subsubsections": []
                },
                {
                    "title": "K.3.3\tTLS 1.3",
                    "description": "",
                    "summary": "",
                    "text_content": "The PSK TLS handshake shall be used with bootstrapped security association as follows:\n1)\tThe UE shall include in the ClientHello message:\na)\tan indication that it supports the TLS with PSK authentication using the \"psk_key_exchange_modes\" extension;\nb)\tthe hostname of the AF using the \"server_name\" TLS extension;\nc)\tauthentication methods other than PSK which the UE supports; and\nd)\tPSK identities within the psk_identities field. The psk_identity parameters within the psk_identities field shall contain a prefix indicating the PSK identity name space, i.e. \"3GPP-AKMA\", a separator character \";\" and the A-KID. The psk_identity parameters within the psk_identities field are separated by a comma character (\",\");\nThe UE shall derive the TLS external PSK from the AF specific key KAF.\n2)\tIf the AF is willing to establish a TLS tunnel using PSK authentication with AKMA keys, the AF shall reply with the ServerHello message and indicate the index of the AKMA psk_identity parameter. The AF concludes the TLS handshake by sending Finished message to the UE.\nNOTE 1:\tThe choice between AKMA and AKA-based GBA at the UE and the AF, if both are supported, is application dependent.\nThe AF shall derive the TLS external PSK from the AF specific key KAF.\n3)\tThe UE concludes the TLS handshake by sending Finished message to the AF.\nOnce the UE and the AF have established a TLS tunnel using AKMA-based shared secret, they may start to use the application level communication through this tunnel.\nThe authentication failures are supported as described in clause 5.3.3.2.\nClauses 5.3.3.3 and 5.3.3.4 are not supported as AKMA does not support deriving a fresh key in the same way as GBA.\nNOTE 2:\tHow a fresh key is derived for AKMA is up to Ua* protocol implementation.\n\n\n\n",
                    "tables": [
                        {
                            "description": "",
                            "table number": 15,
                            "summary": "",
                            "name": ""
                        },
                        {
                            "description": "",
                            "table number": 16,
                            "summary": "",
                            "name": ""
                        }
                    ],
                    "figures_meta_data": [],
                    "subsubsections": []
                }
            ]
        }
    ]
}